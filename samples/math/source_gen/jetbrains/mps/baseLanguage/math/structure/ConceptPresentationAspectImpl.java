package jetbrains.mps.baseLanguage.math.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;

public class ConceptPresentationAspectImpl extends ConceptPresentationAspectBase {
  private ConceptPresentation props_AbsExpression;
  private ConceptPresentation props_AbstractIndex;
  private ConceptPresentation props_ArithmSymbol;
  private ConceptPresentation props_BigComplexType;
  private ConceptPresentation props_BigDecimalType;
  private ConceptPresentation props_BigIntegerType;
  private ConceptPresentation props_BigMaxExpression;
  private ConceptPresentation props_BigMinExpression;
  private ConceptPresentation props_BigProdExpression;
  private ConceptPresentation props_BigSumExpression;
  private ConceptPresentation props_ComplexLiteral;
  private ConceptPresentation props_ComplexType;
  private ConceptPresentation props_ConjugateOperation;
  private ConceptPresentation props_CosineExpression;
  private ConceptPresentation props_DecimalBinaryOperation;
  private ConceptPresentation props_DecimalDivExpression;
  private ConceptPresentation props_DecimalMinusExpression;
  private ConceptPresentation props_DecimalMulExpression;
  private ConceptPresentation props_DecimalPlusExpression;
  private ConceptPresentation props_Determinant;
  private ConceptPresentation props_DivExpressionFraction;
  private ConceptPresentation props_ExponentExpression;
  private ConceptPresentation props_ExponentialOperation;
  private ConceptPresentation props_ExtrSymbol;
  private ConceptPresentation props_InIntervalExpression;
  private ConceptPresentation props_IntervalContainsExpression;
  private ConceptPresentation props_IntervalLiteral;
  private ConceptPresentation props_IntervalType;
  private ConceptPresentation props_LinearSolveOperation;
  private ConceptPresentation props_LiteralI;
  private ConceptPresentation props_LogExpression;
  private ConceptPresentation props_MathContext;
  private ConceptPresentation props_MathFuncExpression;
  private ConceptPresentation props_MathPrimitiveType;
  private ConceptPresentation props_MathSymbol;
  private ConceptPresentation props_MathSymbolFromToIndex;
  private ConceptPresentation props_MathSymbolIndex;
  private ConceptPresentation props_MathSymbolIndexReference;
  private ConceptPresentation props_MathTypeCast;
  private ConceptPresentation props_MatrixConstructor;
  private ConceptPresentation props_MatrixElementAccessExpression;
  private ConceptPresentation props_MatrixExponentialOperation;
  private ConceptPresentation props_MatrixIndexWildcard;
  private ConceptPresentation props_MatrixInitializer;
  private ConceptPresentation props_MatrixInitializerIndex;
  private ConceptPresentation props_MatrixInitializerIndexReference;
  private ConceptPresentation props_MatrixInverseOperation;
  private ConceptPresentation props_MatrixNorm;
  private ConceptPresentation props_MatrixOrVectorInitializer;
  private ConceptPresentation props_MatrixOrVectorType;
  private ConceptPresentation props_MatrixType;
  private ConceptPresentation props_MatrixUnit;
  private ConceptPresentation props_MatrixZero;
  private ConceptPresentation props_PowExpression;
  private ConceptPresentation props_SineExpression;
  private ConceptPresentation props_TangentExpression;
  private ConceptPresentation props_TransposeOperation;
  private ConceptPresentation props_VectorInitializer;
  private ConceptPresentation props_VectorType;

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) myLanguageRuntime.getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);
    switch (structureDescriptor.internalIndex(c)) {
      case LanguageConceptSwitch.AbsExpression:
        if (props_AbsExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Absolute value of a number");
          props_AbsExpression = cpb.create();
        }
        return props_AbsExpression;
      case LanguageConceptSwitch.AbstractIndex:
        if (props_AbstractIndex == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_AbstractIndex = cpb.create();
        }
        return props_AbstractIndex;
      case LanguageConceptSwitch.ArithmSymbol:
        if (props_ArithmSymbol == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ArithmSymbol = cpb.create();
        }
        return props_ArithmSymbol;
      case LanguageConceptSwitch.BigComplexType:
        if (props_BigComplexType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Arbitrary precision complex number");
          props_BigComplexType = cpb.create();
        }
        return props_BigComplexType;
      case LanguageConceptSwitch.BigDecimalType:
        if (props_BigDecimalType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Arbitrary precision signed decimal number");
          props_BigDecimalType = cpb.create();
        }
        return props_BigDecimalType;
      case LanguageConceptSwitch.BigIntegerType:
        if (props_BigIntegerType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Arbitrary precision integer");
          props_BigIntegerType = cpb.create();
        }
        return props_BigIntegerType;
      case LanguageConceptSwitch.BigMaxExpression:
        if (props_BigMaxExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Maximum of expressions");
          props_BigMaxExpression = cpb.create();
        }
        return props_BigMaxExpression;
      case LanguageConceptSwitch.BigMinExpression:
        if (props_BigMinExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Minimum of expressions");
          props_BigMinExpression = cpb.create();
        }
        return props_BigMinExpression;
      case LanguageConceptSwitch.BigProdExpression:
        if (props_BigProdExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Product of expressions");
          props_BigProdExpression = cpb.create();
        }
        return props_BigProdExpression;
      case LanguageConceptSwitch.BigSumExpression:
        if (props_BigSumExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Sum of expressions");
          props_BigSumExpression = cpb.create();
        }
        return props_BigSumExpression;
      case LanguageConceptSwitch.ComplexLiteral:
        if (props_ComplexLiteral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ComplexLiteral = cpb.create();
        }
        return props_ComplexLiteral;
      case LanguageConceptSwitch.ComplexType:
        if (props_ComplexType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Double precision complex number");
          props_ComplexType = cpb.create();
        }
        return props_ComplexType;
      case LanguageConceptSwitch.ConjugateOperation:
        if (props_ConjugateOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Matrix conjugate");
          props_ConjugateOperation = cpb.create();
        }
        return props_ConjugateOperation;
      case LanguageConceptSwitch.CosineExpression:
        if (props_CosineExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Trigonometric cosine of a value");
          props_CosineExpression = cpb.create();
        }
        return props_CosineExpression;
      case LanguageConceptSwitch.DecimalBinaryOperation:
        if (props_DecimalBinaryOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_DecimalBinaryOperation = cpb.create();
        }
        return props_DecimalBinaryOperation;
      case LanguageConceptSwitch.DecimalDivExpression:
        if (props_DecimalDivExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("divide operation for big decimal types");
          props_DecimalDivExpression = cpb.create();
        }
        return props_DecimalDivExpression;
      case LanguageConceptSwitch.DecimalMinusExpression:
        if (props_DecimalMinusExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("minus operation for big decimal types");
          props_DecimalMinusExpression = cpb.create();
        }
        return props_DecimalMinusExpression;
      case LanguageConceptSwitch.DecimalMulExpression:
        if (props_DecimalMulExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("multiplication operation for big decimal types");
          props_DecimalMulExpression = cpb.create();
        }
        return props_DecimalMulExpression;
      case LanguageConceptSwitch.DecimalPlusExpression:
        if (props_DecimalPlusExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("plus operation for bigdecimal types");
          props_DecimalPlusExpression = cpb.create();
        }
        return props_DecimalPlusExpression;
      case LanguageConceptSwitch.Determinant:
        if (props_Determinant == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Matrix determinant");
          props_Determinant = cpb.create();
        }
        return props_Determinant;
      case LanguageConceptSwitch.DivExpressionFraction:
        if (props_DivExpressionFraction == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_DivExpressionFraction = cpb.create();
        }
        return props_DivExpressionFraction;
      case LanguageConceptSwitch.ExponentExpression:
        if (props_ExponentExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Exponent of a value");
          props_ExponentExpression = cpb.create();
        }
        return props_ExponentExpression;
      case LanguageConceptSwitch.ExponentialOperation:
        if (props_ExponentialOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ExponentialOperation = cpb.create();
        }
        return props_ExponentialOperation;
      case LanguageConceptSwitch.ExtrSymbol:
        if (props_ExtrSymbol == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ExtrSymbol = cpb.create();
        }
        return props_ExtrSymbol;
      case LanguageConceptSwitch.InIntervalExpression:
        if (props_InIntervalExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("is in interval");
          props_InIntervalExpression = cpb.create();
        }
        return props_InIntervalExpression;
      case LanguageConceptSwitch.IntervalContainsExpression:
        if (props_IntervalContainsExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("(?) interval contains");
          props_IntervalContainsExpression = cpb.create();
        }
        return props_IntervalContainsExpression;
      case LanguageConceptSwitch.IntervalLiteral:
        if (props_IntervalLiteral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Interval literal");
          props_IntervalLiteral = cpb.create();
        }
        return props_IntervalLiteral;
      case LanguageConceptSwitch.IntervalType:
        if (props_IntervalType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Interval type");
          props_IntervalType = cpb.create();
        }
        return props_IntervalType;
      case LanguageConceptSwitch.LinearSolveOperation:
        if (props_LinearSolveOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_LinearSolveOperation = cpb.create();
        }
        return props_LinearSolveOperation;
      case LanguageConceptSwitch.LiteralI:
        if (props_LiteralI == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Imaginary unit");
          props_LiteralI = cpb.create();
        }
        return props_LiteralI;
      case LanguageConceptSwitch.LogExpression:
        if (props_LogExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Natural logarithm of a value");
          props_LogExpression = cpb.create();
        }
        return props_LogExpression;
      case LanguageConceptSwitch.MathContext:
        if (props_MathContext == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MathContext = cpb.create();
        }
        return props_MathContext;
      case LanguageConceptSwitch.MathFuncExpression:
        if (props_MathFuncExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MathFuncExpression = cpb.create();
        }
        return props_MathFuncExpression;
      case LanguageConceptSwitch.MathPrimitiveType:
        if (props_MathPrimitiveType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MathPrimitiveType = cpb.create();
        }
        return props_MathPrimitiveType;
      case LanguageConceptSwitch.MathSymbol:
        if (props_MathSymbol == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MathSymbol = cpb.create();
        }
        return props_MathSymbol;
      case LanguageConceptSwitch.MathSymbolFromToIndex:
        if (props_MathSymbolFromToIndex == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("iterate over interval of integers");
          props_MathSymbolFromToIndex = cpb.create();
        }
        return props_MathSymbolFromToIndex;
      case LanguageConceptSwitch.MathSymbolIndex:
        if (props_MathSymbolIndex == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("iterate over arbitrary iterable class");
          props_MathSymbolIndex = cpb.create();
        }
        return props_MathSymbolIndex;
      case LanguageConceptSwitch.MathSymbolIndexReference:
        if (props_MathSymbolIndexReference == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MathSymbolIndexReference = cpb.create();
        }
        return props_MathSymbolIndexReference;
      case LanguageConceptSwitch.MathTypeCast:
        if (props_MathTypeCast == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MathTypeCast = cpb.create();
        }
        return props_MathTypeCast;
      case LanguageConceptSwitch.MatrixConstructor:
        if (props_MatrixConstructor == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Matrix row constructor");
          props_MatrixConstructor = cpb.create();
        }
        return props_MatrixConstructor;
      case LanguageConceptSwitch.MatrixElementAccessExpression:
        if (props_MatrixElementAccessExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatrixElementAccessExpression = cpb.create();
        }
        return props_MatrixElementAccessExpression;
      case LanguageConceptSwitch.MatrixExponentialOperation:
        if (props_MatrixExponentialOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatrixExponentialOperation = cpb.create();
        }
        return props_MatrixExponentialOperation;
      case LanguageConceptSwitch.MatrixIndexWildcard:
        if (props_MatrixIndexWildcard == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Wildcard index");
          props_MatrixIndexWildcard = cpb.create();
        }
        return props_MatrixIndexWildcard;
      case LanguageConceptSwitch.MatrixInitializer:
        if (props_MatrixInitializer == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Matrix initializer");
          props_MatrixInitializer = cpb.create();
        }
        return props_MatrixInitializer;
      case LanguageConceptSwitch.MatrixInitializerIndex:
        if (props_MatrixInitializerIndex == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatrixInitializerIndex = cpb.create();
        }
        return props_MatrixInitializerIndex;
      case LanguageConceptSwitch.MatrixInitializerIndexReference:
        if (props_MatrixInitializerIndexReference == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatrixInitializerIndexReference = cpb.create();
        }
        return props_MatrixInitializerIndexReference;
      case LanguageConceptSwitch.MatrixInverseOperation:
        if (props_MatrixInverseOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Matrix inverse operation");
          props_MatrixInverseOperation = cpb.create();
        }
        return props_MatrixInverseOperation;
      case LanguageConceptSwitch.MatrixNorm:
        if (props_MatrixNorm == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatrixNorm = cpb.create();
        }
        return props_MatrixNorm;
      case LanguageConceptSwitch.MatrixOrVectorInitializer:
        if (props_MatrixOrVectorInitializer == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatrixOrVectorInitializer = cpb.create();
        }
        return props_MatrixOrVectorInitializer;
      case LanguageConceptSwitch.MatrixOrVectorType:
        if (props_MatrixOrVectorType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatrixOrVectorType = cpb.create();
        }
        return props_MatrixOrVectorType;
      case LanguageConceptSwitch.MatrixType:
        if (props_MatrixType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatrixType = cpb.create();
        }
        return props_MatrixType;
      case LanguageConceptSwitch.MatrixUnit:
        if (props_MatrixUnit == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Identity matrix");
          props_MatrixUnit = cpb.create();
        }
        return props_MatrixUnit;
      case LanguageConceptSwitch.MatrixZero:
        if (props_MatrixZero == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Zero matrix");
          props_MatrixZero = cpb.create();
        }
        return props_MatrixZero;
      case LanguageConceptSwitch.PowExpression:
        if (props_PowExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Power expression");
          props_PowExpression = cpb.create();
        }
        return props_PowExpression;
      case LanguageConceptSwitch.SineExpression:
        if (props_SineExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Trigonometric sine of a value");
          props_SineExpression = cpb.create();
        }
        return props_SineExpression;
      case LanguageConceptSwitch.TangentExpression:
        if (props_TangentExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Trigonometric tangent of a value");
          props_TangentExpression = cpb.create();
        }
        return props_TangentExpression;
      case LanguageConceptSwitch.TransposeOperation:
        if (props_TransposeOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Transpose operation");
          props_TransposeOperation = cpb.create();
        }
        return props_TransposeOperation;
      case LanguageConceptSwitch.VectorInitializer:
        if (props_VectorInitializer == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Vector initializer");
          props_VectorInitializer = cpb.create();
        }
        return props_VectorInitializer;
      case LanguageConceptSwitch.VectorType:
        if (props_VectorType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_VectorType = cpb.create();
        }
        return props_VectorType;
    }
    return null;
  }
}
