package jetbrains.mps.baseLanguage.math.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class AdditionalStructurePropertiesImpl extends ConceptPresentationAspectBase {
  private final ConceptPresentation props_AbsExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_AbstractIndex = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ArithmSymbol = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_BigComplexType = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_BigDecimalType = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_BigIntegerType = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_BigMaxExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_BigMinExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_BigProdExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_BigSumExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ComplexLiteral = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ComplexType = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ConjugateOperation = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_CosineExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_DecimalBinaryOperation = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_DecimalDivExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_DecimalMinusExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_DecimalMulExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_DecimalPlusExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_Determinant = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_DivExpressionFraction = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ExponentExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ExponentialOperation = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ExtrSymbol = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_InIntervalExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_IntervalContainsExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_IntervalLiteral = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_IntervalType = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_LinearSolveOperation = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_LiteralI = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_LogExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MathContext = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MathFuncExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MathPrimitiveType = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MathSymbol = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MathSymbolFromToIndex = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MathSymbolIndex = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MathSymbolIndexReference = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MathTypeCast = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixConstructor = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixElementAccessExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixExponentialOperation = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixIndexWildcard = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixInitializer = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixInitializerIndex = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixInitializerIndexReference = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixInverseOperation = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixNorm = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixOrVectorInitializer = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixOrVectorType = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixType = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixUnit = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatrixZero = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_PowExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_SineExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_TangentExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_TransposeOperation = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_VectorInitializer = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_VectorType = new ConceptPresentationBuilder().create();

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    {
      SAbstractConcept cncpt = c;
      Integer preIndex = indices_4qogsf_a0ic.get(cncpt);
      int switchIndex = (preIndex == null ? -1 : preIndex);
      switch (switchIndex) {
        case 0:
          if (true) {
            return props_AbsExpression;
          }
          break;
        case 1:
          if (true) {
            return props_AbstractIndex;
          }
          break;
        case 2:
          if (true) {
            return props_ArithmSymbol;
          }
          break;
        case 3:
          if (true) {
            return props_BigComplexType;
          }
          break;
        case 4:
          if (true) {
            return props_BigDecimalType;
          }
          break;
        case 5:
          if (true) {
            return props_BigIntegerType;
          }
          break;
        case 6:
          if (true) {
            return props_BigMaxExpression;
          }
          break;
        case 7:
          if (true) {
            return props_BigMinExpression;
          }
          break;
        case 8:
          if (true) {
            return props_BigProdExpression;
          }
          break;
        case 9:
          if (true) {
            return props_BigSumExpression;
          }
          break;
        case 10:
          if (true) {
            return props_ComplexLiteral;
          }
          break;
        case 11:
          if (true) {
            return props_ComplexType;
          }
          break;
        case 12:
          if (true) {
            return props_ConjugateOperation;
          }
          break;
        case 13:
          if (true) {
            return props_CosineExpression;
          }
          break;
        case 14:
          if (true) {
            return props_DecimalBinaryOperation;
          }
          break;
        case 15:
          if (true) {
            return props_DecimalDivExpression;
          }
          break;
        case 16:
          if (true) {
            return props_DecimalMinusExpression;
          }
          break;
        case 17:
          if (true) {
            return props_DecimalMulExpression;
          }
          break;
        case 18:
          if (true) {
            return props_DecimalPlusExpression;
          }
          break;
        case 19:
          if (true) {
            return props_Determinant;
          }
          break;
        case 20:
          if (true) {
            return props_DivExpressionFraction;
          }
          break;
        case 21:
          if (true) {
            return props_ExponentExpression;
          }
          break;
        case 22:
          if (true) {
            return props_ExponentialOperation;
          }
          break;
        case 23:
          if (true) {
            return props_ExtrSymbol;
          }
          break;
        case 24:
          if (true) {
            return props_InIntervalExpression;
          }
          break;
        case 25:
          if (true) {
            return props_IntervalContainsExpression;
          }
          break;
        case 26:
          if (true) {
            return props_IntervalLiteral;
          }
          break;
        case 27:
          if (true) {
            return props_IntervalType;
          }
          break;
        case 28:
          if (true) {
            return props_LinearSolveOperation;
          }
          break;
        case 29:
          if (true) {
            return props_LiteralI;
          }
          break;
        case 30:
          if (true) {
            return props_LogExpression;
          }
          break;
        case 31:
          if (true) {
            return props_MathContext;
          }
          break;
        case 32:
          if (true) {
            return props_MathFuncExpression;
          }
          break;
        case 33:
          if (true) {
            return props_MathPrimitiveType;
          }
          break;
        case 34:
          if (true) {
            return props_MathSymbol;
          }
          break;
        case 35:
          if (true) {
            return props_MathSymbolFromToIndex;
          }
          break;
        case 36:
          if (true) {
            return props_MathSymbolIndex;
          }
          break;
        case 37:
          if (true) {
            return props_MathSymbolIndexReference;
          }
          break;
        case 38:
          if (true) {
            return props_MathTypeCast;
          }
          break;
        case 39:
          if (true) {
            return props_MatrixConstructor;
          }
          break;
        case 40:
          if (true) {
            return props_MatrixElementAccessExpression;
          }
          break;
        case 41:
          if (true) {
            return props_MatrixExponentialOperation;
          }
          break;
        case 42:
          if (true) {
            return props_MatrixIndexWildcard;
          }
          break;
        case 43:
          if (true) {
            return props_MatrixInitializer;
          }
          break;
        case 44:
          if (true) {
            return props_MatrixInitializerIndex;
          }
          break;
        case 45:
          if (true) {
            return props_MatrixInitializerIndexReference;
          }
          break;
        case 46:
          if (true) {
            return props_MatrixInverseOperation;
          }
          break;
        case 47:
          if (true) {
            return props_MatrixNorm;
          }
          break;
        case 48:
          if (true) {
            return props_MatrixOrVectorInitializer;
          }
          break;
        case 49:
          if (true) {
            return props_MatrixOrVectorType;
          }
          break;
        case 50:
          if (true) {
            return props_MatrixType;
          }
          break;
        case 51:
          if (true) {
            return props_MatrixUnit;
          }
          break;
        case 52:
          if (true) {
            return props_MatrixZero;
          }
          break;
        case 53:
          if (true) {
            return props_PowExpression;
          }
          break;
        case 54:
          if (true) {
            return props_SineExpression;
          }
          break;
        case 55:
          if (true) {
            return props_TangentExpression;
          }
          break;
        case 56:
          if (true) {
            return props_TransposeOperation;
          }
          break;
        case 57:
          if (true) {
            return props_VectorInitializer;
          }
          break;
        case 58:
          if (true) {
            return props_VectorType;
          }
          break;
        default:
      }
    }
    throw new IllegalStateException();
  }
  private static Map<SAbstractConcept, Integer> buildConceptIndices(SAbstractConcept... concepts) {
    HashMap<SAbstractConcept, Integer> res = new HashMap<SAbstractConcept, Integer>();
    int counter = 0;
    for (SAbstractConcept c : concepts) {
      res.put(c, counter++);
    }
    return res;
  }
  private static final Map<SAbstractConcept, Integer> indices_4qogsf_a0ic = buildConceptIndices(MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x12051ecbe19L, "AbsExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fea76c7e0L, "AbstractIndex"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0e7ac42L, "ArithmSymbol"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x120096f8e4cL, "BigComplexType"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x12009449465L, "BigDecimalType"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1200944b8b7L, "BigIntegerType"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0e16047L, "BigMaxExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0e1674dL, "BigMinExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0e12aa0L, "BigProdExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe188eafbL, "BigSumExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x12052224b0bL, "ComplexLiteral"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x120095d7138L, "ComplexType"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x64b1e972e64afe53L, "ConjugateOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x12053114b76L, "CosineExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x120568d9c5bL, "DecimalBinaryOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1207697107bL, "DecimalDivExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x12076988136L, "DecimalMinusExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x120769754c8L, "DecimalMulExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1207697a328L, "DecimalPlusExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x3a6682eeb060fd5L, "Determinant"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x12008f4e805L, "DivExpressionFraction"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x120531e6b2fL, "ExponentExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x64b1e972e6443a20L, "ExponentialOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0e1ca4eL, "ExtrSymbol"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fb8483964L, "InIntervalExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fb8483968L, "IntervalContainsExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fb848396cL, "IntervalLiteral"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fb8483972L, "IntervalType"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x13afebc2af505abdL, "LinearSolveOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1205202c5edL, "LiteralI"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1205311f8ffL, "LogExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1a6fbb5a434b008bL, "MathContext"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1205307b067L, "MathFuncExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1200ff11214L, "MathPrimitiveType"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0ca1899L, "MathSymbol"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fea765cf0L, "MathSymbolFromToIndex"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0ca6da8L, "MathSymbolIndex"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0d91491L, "MathSymbolIndexReference"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1200fb8bcedL, "MathTypeCast"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x42d5783a626b0a85L, "MatrixConstructor"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x58aab8999c8f432aL, "MatrixElementAccessExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x64b1e972e647ad7dL, "MatrixExponentialOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x58aab8999c8f4339L, "MatrixIndexWildcard"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x5650ac0d4240a048L, "MatrixInitializer"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x5650ac0d4240f255L, "MatrixInitializerIndex"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x5650ac0d4240f252L, "MatrixInitializerIndexReference"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x13afebc2af505abcL, "MatrixInverseOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0xcc7e1ce69847db2L, "MatrixNorm"), MetaAdapterFactory.getInterfaceConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x5650ac0d424d5141L, "MatrixOrVectorInitializer"), MetaAdapterFactory.getInterfaceConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x513c04200c187a63L, "MatrixOrVectorType"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x42d5783a6267f776L, "MatrixType"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x13afebc2af3c3bdfL, "MatrixUnit"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x36700251396ecb7bL, "MatrixZero"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x12052b2cdd3L, "PowExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1205311204eL, "SineExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1205311cb56L, "TangentExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x7418107bdc9576d4L, "TransposeOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x5650ac0d424d0fb5L, "VectorInitializer"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x42d5783a6267f775L, "VectorType"));
}
