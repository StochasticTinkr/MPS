package jetbrains.mps.baseLanguage.math.behavior;

/*Generated by MPS */

import jetbrains.mps.core.aspects.behaviour.BaseBehaviorAspectDescriptor;
import jetbrains.mps.core.aspects.behaviour.api.BHDescriptor;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public final class BehaviorAspectDescriptor extends BaseBehaviorAspectDescriptor {
  private final BHDescriptor myInIntervalExpression__BehaviorDescriptor = new InIntervalExpression__BehaviorDescriptor();
  private final BHDescriptor myIntervalContainsExpression__BehaviorDescriptor = new IntervalContainsExpression__BehaviorDescriptor();
  private final BHDescriptor myMathSymbol__BehaviorDescriptor = new MathSymbol__BehaviorDescriptor();
  private final BHDescriptor myBigProdExpression__BehaviorDescriptor = new BigProdExpression__BehaviorDescriptor();
  private final BHDescriptor myBigMaxExpression__BehaviorDescriptor = new BigMaxExpression__BehaviorDescriptor();
  private final BHDescriptor myBigMinExpression__BehaviorDescriptor = new BigMinExpression__BehaviorDescriptor();
  private final BHDescriptor myBigSumExpression__BehaviorDescriptor = new BigSumExpression__BehaviorDescriptor();
  private final BHDescriptor myDecimalBinaryOperation__BehaviorDescriptor = new DecimalBinaryOperation__BehaviorDescriptor();
  private final BHDescriptor myDecimalDivExpression__BehaviorDescriptor = new DecimalDivExpression__BehaviorDescriptor();
  private final BHDescriptor myDecimalMulExpression__BehaviorDescriptor = new DecimalMulExpression__BehaviorDescriptor();
  private final BHDescriptor myDecimalPlusExpression__BehaviorDescriptor = new DecimalPlusExpression__BehaviorDescriptor();
  private final BHDescriptor myDecimalMinusExpression__BehaviorDescriptor = new DecimalMinusExpression__BehaviorDescriptor();
  private final BHDescriptor myMatrixInverseOperation__BehaviorDescriptor = new MatrixInverseOperation__BehaviorDescriptor();
  private final BHDescriptor myMathContext__BehaviorDescriptor = new MathContext__BehaviorDescriptor();
  private final BHDescriptor myMatrixType__BehaviorDescriptor = new MatrixType__BehaviorDescriptor();
  private final BHDescriptor myMatrixConstructor__BehaviorDescriptor = new MatrixConstructor__BehaviorDescriptor();
  private final BHDescriptor myMatrixElementAccessExpression__BehaviorDescriptor = new MatrixElementAccessExpression__BehaviorDescriptor();
  private final BHDescriptor myExponentialOperation__BehaviorDescriptor = new ExponentialOperation__BehaviorDescriptor();
  private final BHDescriptor myMatrixExponentialOperation__BehaviorDescriptor = new MatrixExponentialOperation__BehaviorDescriptor();
  private final BHDescriptor myConjugateOperation__BehaviorDescriptor = new ConjugateOperation__BehaviorDescriptor();
  private final BHDescriptor myTransposeOperation__BehaviorDescriptor = new TransposeOperation__BehaviorDescriptor();

  public BehaviorAspectDescriptor() {
  }

  @Nullable
  public BHDescriptor getDescriptor(@NotNull SAbstractConcept concept) {
    {
      SAbstractConcept cncpt = concept;
      Integer preIndex = indices_846f5o_a0y.get(cncpt);
      int switchIndex = (preIndex == null ? -1 : preIndex);
      switch (switchIndex) {
        case 0:
          if (true) {
            return myBigMaxExpression__BehaviorDescriptor;
          }
          break;
        case 1:
          if (true) {
            return myBigMinExpression__BehaviorDescriptor;
          }
          break;
        case 2:
          if (true) {
            return myBigProdExpression__BehaviorDescriptor;
          }
          break;
        case 3:
          if (true) {
            return myBigSumExpression__BehaviorDescriptor;
          }
          break;
        case 4:
          if (true) {
            return myConjugateOperation__BehaviorDescriptor;
          }
          break;
        case 5:
          if (true) {
            return myDecimalBinaryOperation__BehaviorDescriptor;
          }
          break;
        case 6:
          if (true) {
            return myDecimalDivExpression__BehaviorDescriptor;
          }
          break;
        case 7:
          if (true) {
            return myDecimalMinusExpression__BehaviorDescriptor;
          }
          break;
        case 8:
          if (true) {
            return myDecimalMulExpression__BehaviorDescriptor;
          }
          break;
        case 9:
          if (true) {
            return myDecimalPlusExpression__BehaviorDescriptor;
          }
          break;
        case 10:
          if (true) {
            return myExponentialOperation__BehaviorDescriptor;
          }
          break;
        case 11:
          if (true) {
            return myInIntervalExpression__BehaviorDescriptor;
          }
          break;
        case 12:
          if (true) {
            return myIntervalContainsExpression__BehaviorDescriptor;
          }
          break;
        case 13:
          if (true) {
            return myMathContext__BehaviorDescriptor;
          }
          break;
        case 14:
          if (true) {
            return myMathSymbol__BehaviorDescriptor;
          }
          break;
        case 15:
          if (true) {
            return myMatrixConstructor__BehaviorDescriptor;
          }
          break;
        case 16:
          if (true) {
            return myMatrixElementAccessExpression__BehaviorDescriptor;
          }
          break;
        case 17:
          if (true) {
            return myMatrixExponentialOperation__BehaviorDescriptor;
          }
          break;
        case 18:
          if (true) {
            return myMatrixInverseOperation__BehaviorDescriptor;
          }
          break;
        case 19:
          if (true) {
            return myMatrixType__BehaviorDescriptor;
          }
          break;
        case 20:
          if (true) {
            return myTransposeOperation__BehaviorDescriptor;
          }
          break;
        default:
          // default 
      }
    }
    return null;
  }
  private static Map<SAbstractConcept, Integer> buildConceptIndices(SAbstractConcept... concepts) {
    HashMap<SAbstractConcept, Integer> res = new HashMap<SAbstractConcept, Integer>();
    int counter = 0;
    for (SAbstractConcept c : concepts) {
      res.put(c, counter++);
    }
    return res;
  }
  private static final Map<SAbstractConcept, Integer> indices_846f5o_a0y = buildConceptIndices(MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0e16047L, "jetbrains.mps.baseLanguage.math.structure.BigMaxExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0e1674dL, "jetbrains.mps.baseLanguage.math.structure.BigMinExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0e12aa0L, "jetbrains.mps.baseLanguage.math.structure.BigProdExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe188eafbL, "jetbrains.mps.baseLanguage.math.structure.BigSumExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x64b1e972e64afe53L, "jetbrains.mps.baseLanguage.math.structure.ConjugateOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x120568d9c5bL, "jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1207697107bL, "jetbrains.mps.baseLanguage.math.structure.DecimalDivExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x12076988136L, "jetbrains.mps.baseLanguage.math.structure.DecimalMinusExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x120769754c8L, "jetbrains.mps.baseLanguage.math.structure.DecimalMulExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1207697a328L, "jetbrains.mps.baseLanguage.math.structure.DecimalPlusExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x64b1e972e6443a20L, "jetbrains.mps.baseLanguage.math.structure.ExponentialOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fb8483964L, "jetbrains.mps.baseLanguage.math.structure.InIntervalExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fb8483968L, "jetbrains.mps.baseLanguage.math.structure.IntervalContainsExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x1a6fbb5a434b008bL, "jetbrains.mps.baseLanguage.math.structure.MathContext"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x11fe0ca1899L, "jetbrains.mps.baseLanguage.math.structure.MathSymbol"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x42d5783a626b0a85L, "jetbrains.mps.baseLanguage.math.structure.MatrixConstructor"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x58aab8999c8f432aL, "jetbrains.mps.baseLanguage.math.structure.MatrixElementAccessExpression"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x64b1e972e647ad7dL, "jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x13afebc2af505abcL, "jetbrains.mps.baseLanguage.math.structure.MatrixInverseOperation"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x42d5783a6267f776L, "jetbrains.mps.baseLanguage.math.structure.MatrixType"), MetaAdapterFactory.getConcept(0x3304fc6e7c6b401eL, 0xa016b944934bb21fL, 0x7418107bdc9576d4L, "jetbrains.mps.baseLanguage.math.structure.TransposeOperation"));
}
