package jetbrains.mps.debugger.api.ui.tree;

/*Generated by MPS */

import jetbrains.mps.debug.api.programState.IWatchable;
import jetbrains.mps.debug.api.AbstractUiState;
import jetbrains.mps.ide.ui.tree.TextTreeNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.debug.api.programState.Watchable2;
import jetbrains.mps.debug.api.programState.IValue;
import javax.swing.tree.TreeNode;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.application.ApplicationManager;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.ide.ui.tree.MPSTree;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;

public class WatchableNode extends AbstractWatchableNode {
  private boolean myInitialized;
  private final IWatchable myWatchable;
  private final AbstractUiState myState;
  private final TextTreeNode myEvaluateInProgress;

  public WatchableNode(@NotNull IWatchable w, AbstractUiState state) {
    super((w instanceof Watchable2 ? ((Watchable2) w).getSourceNode() : ((w.getNode() == null ? null : w.getNode().getReference()))));
    myWatchable = w;
    myState = state;
    setNodeIdentifier(calculateNodeId(w));
    setIcon(w.getPresentationIcon());
    myEvaluateInProgress = new TextTreeNode("Evaluation in progress...");
  }
  @Override
  protected void doUpdate() {
    this.removeAllChildren();
    myInitialized = false;
  }
  @Override
  public boolean isInitialized() {
    return myInitialized;
  }
  private static String calculateNodeId(IWatchable watchable) {
    IValue value = watchable.getValue();
    if (value == null) {
      return watchable.getName() + " = null";
    }
    return watchable.getName() + " = " + value.getValuePresentation();
  }
  @Override
  public boolean isLeaf() {
    IValue value = getValue();
    return value == null || !(value.isStructure());
  }
  public IValue getValue() {
    return myWatchable.getValue();
  }
  /*package*/ void nodeChanged() {
    getTree().getModel().nodeStructureChanged(this);
  }

  @Override
  protected void doInit() {
    if (isLeaf()) {
      //  no subvalues - drop placeholders created to restore expanded/selected path, if any. 
      boolean affected = false;
      for (int i = getChildCount() - 1; i >= 0; i--) {
        TreeNode childAt = getChildAt(i);
        if (childAt instanceof PlaceholderTreeNode) {
          affected = true;
          remove(i);
        }
      }
      if (affected) {
        // Fire tree structure change event, for now go with total change, although could do 
        // getTree().getModel().nodesWereRemoved() instead. Just lazy to find out whether total change does any harm. 
        nodeChanged();
      }
      return;
    }
    // ok, we might get subvalues, schedule their calculation and update children later 
    add(myEvaluateInProgress);
    myState.invokeEvaluation(new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        myWatchable.getValue().initSubvalues();
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          @Override
          public void run() {
            Map<String, PlaceholderTreeNode> placeholders = new HashMap<String, PlaceholderTreeNode>();
            for (int i = getChildCount() - 1; i >= 0; i--) {
              TreeNode childAt = getChildAt(i);
              if (childAt == myEvaluateInProgress) {
                remove(i);
                continue;
              }
              if (childAt instanceof PlaceholderTreeNode) {
                PlaceholderTreeNode ptn = (PlaceholderTreeNode) childAt;
                placeholders.put(ptn.getNodeIdentifier(), ptn);
                remove(i);
              }
            }
            for (IWatchable watchable : ListSequence.fromList(getValue().getSubvalues())) {
              WatchableNode newNode = new WatchableNode(watchable, myState);
              // see PlaceholderTreeNode comment for details why we escape identifier prior to match 
              PlaceholderTreeNode placeholder = placeholders.remove(newNode.getNodeIdentifier().replaceAll(MPSTree.TREE_PATH_SEPARATOR, "-"));
              if (placeholder != null) {
                boolean placeholderWithChildren = placeholder.getChildCount() > 0;
                // placeholder's chilren shall become children of a node that replaces it 
                for (MPSTreeNode ch : placeholder) {
                  newNode.add(ch);
                }
                add(newNode);
                if (placeholderWithChildren) {
                  // likely, there are nested expanded/selected placeholders, need to update tree presentation to get them replaced with actual values 
                  newNode.init();
                }
              } else {
                add(newNode);
              }
            }
            updatePresentation();
            nodeChanged();
          }
        });
      }
    });
    myInitialized = true;
  }
}
