package jetbrains.mps.debugger.api.ui.tool;

/*Generated by MPS */

import com.intellij.openapi.Disposable;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.annotations.NonNls;
import com.intellij.execution.runners.ProgramRunner;
import com.intellij.openapi.project.Project;
import java.util.ArrayList;
import com.intellij.execution.ExecutionResult;
import com.intellij.execution.Executor;
import com.intellij.execution.runners.ExecutionEnvironment;
import com.intellij.execution.ui.RunContentDescriptor;
import com.intellij.execution.configurations.RunProfile;
import com.intellij.execution.ui.ExecutionConsole;
import com.intellij.execution.ui.ExecutionConsoleEx;
import com.intellij.execution.ui.RunnerLayoutUi;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import jetbrains.mps.workbench.action.BaseGroup;
import com.intellij.openapi.actionSystem.ActionManager;
import jetbrains.mps.debug.api.AbstractDebugSession;
import jetbrains.mps.debug.api.DebugSessionManagerComponent;
import org.apache.log4j.Level;
import com.intellij.ui.content.Content;
import com.intellij.openapi.util.IconLoader;
import com.intellij.execution.ui.layout.PlaceInGrid;
import com.intellij.openapi.actionSystem.ActionGroup;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import com.intellij.openapi.actionSystem.IdeActions;
import com.intellij.execution.ui.actions.CloseAction;
import javax.swing.JComponent;
import org.jetbrains.annotations.NotNull;
import com.intellij.ide.DataManager;
import com.intellij.openapi.actionSystem.DataProvider;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.actionSystem.LangDataKeys;
import com.intellij.openapi.util.Disposer;

public class DebuggerToolContentBuilder implements Disposable {
  private static final Logger LOG = LogManager.getLogger(DebuggerToolContentBuilder.class);
  @NonNls
  private static final String JAVA_RUNNER = "JavaRunner";
  private final ProgramRunner myRunner;
  private final Project myProject;
  private final ArrayList<Disposable> myDisposeables = new ArrayList<Disposable>();
  private final boolean myReuseProhibited = false;
  private final ExecutionResult myExecutionResult;
  private final Executor myExecutor;
  private final ExecutionEnvironment myEnvironment;
  public DebuggerToolContentBuilder(Project project, ProgramRunner runner, Executor executor, ExecutionResult executionResult, ExecutionEnvironment env) {
    myProject = project;
    myRunner = runner;
    myExecutor = executor;
    myExecutionResult = executionResult;
    myEnvironment = env;
  }
  @Override
  public void dispose() {
    for (Disposable disposable : myDisposeables) {
      disposable.dispose();
    }
  }
  private RunContentDescriptor createDescriptor() {
    RunProfile profile = myEnvironment.getRunProfile();
    ExecutionConsole console = myExecutionResult.getExecutionConsole();
    String runnerType = (console instanceof ExecutionConsoleEx ? JAVA_RUNNER + "." + ((ExecutionConsoleEx) console).getExecutionConsoleId() : JAVA_RUNNER);
    RunnerLayoutUi ui = RunnerLayoutUi.Factory.getInstance(myProject).create(runnerType, myExecutor.getId(), profile.getName(), this);
    if (ApplicationManager.getApplication().isUnitTestMode()) {
      return createDescriptorInternal(ui, profile);
    }
    buildUi(ui, console);
    DebuggerToolContentBuilder.MyRunContentDescriptor contentDescriptor = createDescriptorInternal(ui, profile);
    ui.getOptions().setLeftToolbar(createActionToolbar(ui, contentDescriptor), ActionPlaces.DEBUGGER_TOOLBAR);
    ui.getOptions().setTopToolbar(((BaseGroup) ActionManager.getInstance().getAction("jetbrains.mps.debugger.api.ui.actions.DebugStepsMenu_ActionGroup")), ActionPlaces.DEBUGGER_TOOLBAR);
    return contentDescriptor;
  }
  private DebuggerToolContentBuilder.MyRunContentDescriptor createDescriptorInternal(RunnerLayoutUi ui, RunProfile profile) {
    return new DebuggerToolContentBuilder.MyRunContentDescriptor(profile, myExecutionResult, myReuseProhibited, ui.getComponent(), this);
  }
  private void buildUi(RunnerLayoutUi ui, ExecutionConsole console) {
    ui.getOptions().setMoveToGridActionEnabled(true).setMinimizeActionEnabled(true);
    AbstractDebugSession debugSession = DebugSessionManagerComponent.getInstance(myProject).getDebugSession(myExecutionResult.getProcessHandler());
    if (debugSession == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("No debug session found for process handler " + myExecutionResult.getProcessHandler());
      }
    } else {
      new DebuggerToolPanel(myProject, debugSession, ui);
    }
    Content consoleContent = ui.createContent("Console2.0", console.getComponent(), "Console", IconLoader.getIcon("/debugger/console.png"), console.getPreferredFocusableComponent());
    consoleContent.setSearchComponent(console.getComponent());
    consoleContent.setCloseable(false);
    ui.addContent(consoleContent, 1, PlaceInGrid.center, false);
  }
  private ActionGroup createActionToolbar(RunnerLayoutUi ui, RunContentDescriptor contentDescriptor) {
    DefaultActionGroup actionGroup = new DefaultActionGroup();
    //  TODO use context to get data to the action 
    actionGroup.add(ActionManager.getInstance().getAction(IdeActions.ACTION_RERUN));
    actionGroup.add(((BaseGroup) ActionManager.getInstance().getAction("jetbrains.mps.debugger.api.ui.actions.DebugTool_ActionGroup")));
    actionGroup.addAll(myExecutionResult.getActions());
    actionGroup.addSeparator();
    actionGroup.add(ui.getOptions().getLayoutActions());
    actionGroup.addSeparator();
    actionGroup.add(ActionManager.getInstance().getAction(IdeActions.ACTION_PIN_ACTIVE_TAB));
    actionGroup.add(new CloseAction(myExecutor, contentDescriptor, myProject));
    return actionGroup;
  }
  /**
   * * @param reuseContent see {@link RunContentDescriptor#myContent}
   */
  public RunContentDescriptor showRunContent(final RunContentDescriptor reuseContent) {
    final RunContentDescriptor descriptor = createDescriptor();
    if (reuseContent != null) {
      descriptor.setAttachedContent(reuseContent.getAttachedContent());
    }
    return descriptor;
  }
  private static class MyRunContentDescriptor extends RunContentDescriptor {
    private final boolean myReuseProhibited;
    private final Disposable myAdditionalDisposable;
    public MyRunContentDescriptor(final RunProfile profile, final ExecutionResult executionResult, final boolean reuseProhibited, final JComponent component, @NotNull Disposable additionalDisposable) {
      super(executionResult.getExecutionConsole(), executionResult.getProcessHandler(), component, profile.getName(), profile.getIcon());
      myReuseProhibited = reuseProhibited;
      myAdditionalDisposable = additionalDisposable;
      DataManager.registerDataProvider(component, new DataProvider() {
        @Nullable
        public Object getData(@NonNls String dataId) {
          if (LangDataKeys.RUN_CONTENT_DESCRIPTOR.is(dataId)) {
            return MyRunContentDescriptor.this;
          }
          return null;
        }
      });
    }
    @Override
    public boolean isContentReuseProhibited() {
      return myReuseProhibited;
    }
    @Override
    public void dispose() {
      Disposer.dispose(myAdditionalDisposable);
      DataManager.removeDataProvider(getComponent());
      super.dispose();
    }
  }
}
