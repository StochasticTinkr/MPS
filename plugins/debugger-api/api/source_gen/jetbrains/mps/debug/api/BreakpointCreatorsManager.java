package jetbrains.mps.debug.api;

/*Generated by MPS */

import com.intellij.openapi.components.ApplicationComponent;
import java.util.Set;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.debug.api.breakpoints.ILocationBreakpoint;
import com.intellij.openapi.project.Project;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.HashMap;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.util.annotation.ToRemove;
import jetbrains.mps.util.Mapper2;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactoryByName;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.apache.log4j.Level;
import jetbrains.mps.textgen.trace.TraceablePositionInfo;
import jetbrains.mps.textgen.trace.TraceInfo;
import jetbrains.mps.kernel.model.SModelUtil;
import com.intellij.openapi.application.ApplicationManager;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class BreakpointCreatorsManager implements ApplicationComponent {
  private Set<Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>> myCreators = SetSequence.fromSet(new LinkedHashSet<Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>>());
  private Map<String, Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>> myAddedByConceptCreators = MapSequence.fromMap(new LinkedHashMap<String, Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>>(16, (float) 0.75, false));
  /**
   * Map to keep binary compatibility inside 3.1.x, should be removed together with addBreakpointCreator()/removeBreakpointCreator()
   */
  private Map<Tuples._2<_FunctionTypes._return_P1_E0<? extends Boolean, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>, Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>> myOldToNewCreatorMap = MapSequence.fromMap(new HashMap<Tuples._2<_FunctionTypes._return_P1_E0<? extends Boolean, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>, Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>>());
  public BreakpointCreatorsManager() {
  }
  @NotNull
  @Override
  public String getComponentName() {
    return "Debug Info Manager";
  }
  @Deprecated
  @ToRemove(version = 3.4)
  public void addConceptBreakpointCreator(String baseConcept, final Mapper2<SNode, Project, ILocationBreakpoint> breakpointCreator) {
    SAbstractConcept concept = MetaAdapterFactoryByName.getConcept(baseConcept);
    if (concept == null) {
      concept = MetaAdapterFactoryByName.getInterfaceConcept(baseConcept);
    }
    Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>> pair = MultiTuple.<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>,_FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>from(new _FunctionTypes._return_P2_E0<Boolean, SNode, SNode>() {
      public Boolean invoke(SNode concept, SNode n) {
        return SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.asSConcept(concept)), SNodeOperations.asSConcept(SNodeOperations.asSConcept(concept)));
      }
    }, new _FunctionTypes._return_P2_E0<ILocationBreakpoint, SNode, Project>() {
      public ILocationBreakpoint invoke(SNode node, Project project) {
        return breakpointCreator.value(node, project);
      }
    });
    MapSequence.fromMap(myAddedByConceptCreators).put(baseConcept, pair);
    SetSequence.fromSet(myCreators).addElement(pair);

    // this is needed to support compilation compatibility in 3.4 
  }
  public void addConceptBreakpointCreator(final SAbstractConcept baseConcept, final Mapper2<SNode, Project, ILocationBreakpoint> breakpointCreator) {
    Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>> pair = MultiTuple.<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>,_FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>from(new _FunctionTypes._return_P2_E0<Boolean, SNode, SNode>() {
      public Boolean invoke(SNode concept, SNode n) {
        return SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.asSConcept(concept)), SNodeOperations.asSConcept(baseConcept));
      }
    }, new _FunctionTypes._return_P2_E0<ILocationBreakpoint, SNode, Project>() {
      public ILocationBreakpoint invoke(SNode node, Project project) {
        return breakpointCreator.value(node, project);
      }
    });
    MapSequence.fromMap(myAddedByConceptCreators).put(baseConcept.getQualifiedName(), pair);
    SetSequence.fromSet(myCreators).addElement(pair);
  }
  public void removeConceptBreakpointCreator(String fqName) {
    SetSequence.fromSet(myCreators).removeElement(MapSequence.fromMap(myAddedByConceptCreators).get(fqName));
    MapSequence.fromMap(myAddedByConceptCreators).removeKey(fqName);
  }
  public void addCreator(Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>> creator) {
    SetSequence.fromSet(myCreators).addElement(creator);
  }
  public void removeCreator(Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>> creator) {
    SetSequence.fromSet(myCreators).removeElement(creator);
  }
  public boolean isDebuggableNode(@Nullable final SNode node) {
    if (node == null) {
      return false;
    }
    return SetSequence.fromSet(myCreators).findFirst(new IWhereFilter<Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>>>() {
      public boolean accept(Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>> it) {
        return it._0().invoke(SNodeOperations.getConceptDeclaration(node), node);
      }
    }) != null;
  }
  private ILocationBreakpoint createBreakpoint(SNode concept, SNode node, Project project) {
    for (Tuples._2<_FunctionTypes._return_P2_E0<? extends Boolean, ? super SNode, ? super SNode>, _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project>> creator : SetSequence.fromSet(myCreators)) {
      if (creator._0().invoke(concept, node)) {
        _FunctionTypes._return_P2_E0<? extends ILocationBreakpoint, ? super SNode, ? super Project> function = creator._1();
        if (function == null) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Could not create breakpoint for node " + node);
          }
          return null;
        }
        return function.invoke(node, project);
      }
    }
    return null;
  }
  @Nullable
  public ILocationBreakpoint createBreakpoint(SNode node, Project project) {
    ILocationBreakpoint breakpoint = createBreakpoint(SNodeOperations.getConceptDeclaration(node), node, project);
    if (breakpoint != null) {
      return breakpoint;
    }

    TraceablePositionInfo position = TraceInfo.getPositionForNode(node);
    if (position != null) {
      String conceptFqName = position.getConceptFqName();
      if (conceptFqName == null) {
        return null;
      }
      SNode concept = (SNode) SModelUtil.findConceptDeclaration(conceptFqName);
      return createBreakpoint(concept, node, project);
    }
    return null;
  }
  @Override
  public void initComponent() {
  }
  @Override
  public void disposeComponent() {
  }
  public static BreakpointCreatorsManager getInstance() {
    return ApplicationManager.getApplication().getComponent(BreakpointCreatorsManager.class);
  }
  protected static Logger LOG = LogManager.getLogger(BreakpointCreatorsManager.class);
}
