package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class RequiredPlugins {
  private final Set<SNode> myDependencies = SetSequence.fromSet(new HashSet<SNode>());
  private final List<SNode> myPlugins = ListSequence.fromList(new ArrayList<SNode>());

  public RequiredPlugins(SNode project, TemplateQueryContext genContext) {
    ListSequence.fromList(myPlugins).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(project, MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x5b7be37b4de9bb74L, "jetbrains.mps.build.mps.structure.BuildMps_IdeaPlugin"), false, new SAbstractConcept[]{})));
  }

  public RequiredPlugins(TemplateQueryContext genContext, SNode initialPlugin) {
    ListSequence.fromList(myPlugins).addElement(initialPlugin);
  }

  public RequiredPlugins(TemplateQueryContext genContext, SNode root, Iterable<SNode> initialPlugins) {
    ListSequence.fromList(myPlugins).addSequence(Sequence.fromIterable(initialPlugins));
  }

  public void collectDependencies() {
    Set<SNode> visited = SetSequence.fromSet(new LinkedHashSet<SNode>());
    for (SNode plugin : ListSequence.fromList(myPlugins)) {
      collectDependencies(plugin, visited);
    }
    SetSequence.fromSet(myDependencies).addSequence(SetSequence.fromSet(visited).subtract(ListSequence.fromList(myPlugins)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (it != null);
      }
    }).toListSequence());
  }

  public Iterable<SNode> returnDependencies() {
    Set<SNode> visited = SetSequence.fromSet(new LinkedHashSet<SNode>());
    for (SNode plugin : ListSequence.fromList(myPlugins)) {
      collectDependencies(plugin, visited);
    }
    return SetSequence.fromSet(visited).subtract(ListSequence.fromList(myPlugins)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (it != null);
      }
    }).toListSequence();
  }

  public Iterable<SNode> returnDepsWithInitial() {
    return Sequence.fromIterable(returnDependencies()).union(ListSequence.fromList(myPlugins)).distinct();
  }

  private void collectDependencies(SNode plugin, Set<SNode> visited) {
    SetSequence.fromSet(visited).addElement(plugin);
    for (SNode dependency : ListSequence.fromList(SLinkOperations.getChildren(plugin, MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x5b7be37b4de9bb74L, 0x5b7be37b4de9bbd4L, "dependencies")))) {
      SNode dependencyPlugin = SLinkOperations.getTarget(dependency, MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x5b7be37b4de9bbd3L, 0x5b7be37b4de9bbfaL, "target"));
      if (dependencyPlugin != null && !(SetSequence.fromSet(visited).contains(dependencyPlugin))) {
        collectDependencies(dependencyPlugin, visited);
      }
    }
  }

  public Iterable<SNode> getDependency() {
    // Usages suggest myDependencies are to come from original (non-transient) model - they used to get passed to DependenciesHelper.artifacts().get() directly 
    return myDependencies;
  }

  public Iterable<SNode> getDependencyInsideCurrent() {
    return myPlugins;
  }
}
