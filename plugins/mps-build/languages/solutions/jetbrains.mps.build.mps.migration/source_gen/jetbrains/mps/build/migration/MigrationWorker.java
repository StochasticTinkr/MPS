package jetbrains.mps.build.migration;

/*Generated by MPS */

import jetbrains.mps.tool.builder.MpsWorker;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import jetbrains.mps.tool.environment.IdeaEnvironment;
import java.util.Map;
import java.io.File;
import java.util.List;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.make.MPSCompilationResult;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.make.ModuleMaker;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.classloading.ClassLoaderManager;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.ide.plugins.PluginManager;
import com.intellij.openapi.extensions.PluginId;
import java.lang.reflect.Method;
import com.intellij.openapi.project.ProjectManager;
import com.intellij.ide.impl.ProjectUtil;
import com.intellij.openapi.application.ModalityState;
import jetbrains.mps.util.PathManager;
import jetbrains.mps.tool.common.ScriptProperties;

public class MigrationWorker extends MpsWorker {
  private static final String MIGRATION_PLUGIN = "jetbrains.mps.ide.migration.workbench";
  private static final String TASK_EXEC_CLASS = "jetbrains.mps.ide.migration.AntTaskExecutionUtil";

  public MigrationWorker(Script whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
  }

  @Override
  protected Environment createEnvironment() {
    addPluginsToClassPath();

    EnvironmentConfig cfg = createEnvironmentConfig(myWhatToDo);
    cfg.addPlugin("migration", MigrationWorker.MIGRATION_PLUGIN);

    Environment environment = new IdeaEnvironment(cfg);
    environment.init();

    return environment;
  }

  @Override
  public void work() {
    Map<File, List<String>> mpsProjects = myWhatToDo.getMPSProjectFiles();
    for (File file : mpsProjects.keySet()) {
      final Project p = myEnvironment.openProject(file);
      info("Loaded project " + p);
      myEnvironment.flushAllEvents();

      final Wrappers._T<MPSCompilationResult> mpsCompilationResult = new Wrappers._T<MPSCompilationResult>();
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          mpsCompilationResult.value = new ModuleMaker().make(IterableUtil.asCollection(p.getProjectModulesWithGenerators()), new EmptyProgressMonitor(), myJavaCompilerOptions);
        }
      });
      if (mpsCompilationResult.value.isReloadingNeeded()) {
        ModelAccess.instance().runWriteAction(new Runnable() {
          public void run() {
            ClassLoaderManager.getInstance().reloadModules(mpsCompilationResult.value.getChangedModules());
          }
        });
      }
      myEnvironment.flushAllEvents();

      ApplicationManager.getApplication().invokeAndWait(new Runnable() {
        public void run() {
          try {
            Class<?> euClass = PluginManager.getPlugin(PluginId.getId(MIGRATION_PLUGIN)).getPluginClassLoader().loadClass(TASK_EXEC_CLASS);
            Method method = euClass.getMethod("migrate", Project.class);
            method.invoke(null, p);
            com.intellij.openapi.project.Project[] projects = ProjectManager.getInstance().getOpenProjects();
            assert projects.length == 1 : "more than one project opened: " + projects.length;
            ProjectUtil.closeAndDispose(projects[0]);
          } catch (Exception e) {
            throw new RuntimeException("Exception during migration", e);
          }
        }
      }, ModalityState.defaultModalityState());

      p.dispose();
      myEnvironment.flushAllEvents();
    }

    dispose();
  }

  private void addPluginsToClassPath() {
    StringBuilder cp = new StringBuilder();
    File pluginDir = new File(PathManager.getPreInstalledPluginsPath());
    for (File plugin : pluginDir.listFiles()) {
      if (plugin.isFile()) {
        if (cp.length() > 0) {
          cp.append(File.pathSeparator);
        }
        cp.append(plugin.getAbsolutePath());
      } else {
        File lib = new File(plugin + File.separator + "lib");
        if (lib.exists() && lib.isDirectory()) {
          for (File libJar : lib.listFiles(PathManager.JAR_FILE_FILTER)) {
            if (cp.length() > 0) {
              cp.append(File.pathSeparator);
            }
            cp.append(plugin.getAbsolutePath());
          }
        }
      }
    }

    myWhatToDo.putProperty(ScriptProperties.PLUGIN_PATHS, cp.toString());
  }

  public static void main(String[] args) {
    MigrationWorker mpsWorker = new MigrationWorker(Script.fromDumpInFile(new File(args[0])), new MpsWorker.SystemOutLogger());
    mpsWorker.workFromMain();
  }

  protected void executeTask(Project project, MpsWorker.ObjectsToProcess go) {
  }

  protected void showStatistic() {
  }
}
