package jetbrains.mps.build.util;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import jetbrains.mps.generator.template.TemplateQueryContext;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.generator.TransientModelsModule;

public class DependenciesHelper {
  private final Map<SNode, String> locationMap;
  private final Map<SNode, String> contentLocationMap;
  private final Map<Object, SNode> idToArtifactMap;
  private final Set<SNode> requiresFetch;
  protected final MacroHelper macros;
  private final TemplateQueryContext myGenContext;
  public DependenciesHelper(@NotNull TemplateQueryContext genContext, SNode project) {
    this.locationMap = GenerationUtil.<SNode,String>getSessionMap(project, genContext, "location");
    this.contentLocationMap = GenerationUtil.<SNode,String>getSessionMap(project, genContext, "contentLocation");
    this.idToArtifactMap = GenerationUtil.<Object,SNode>getSessionMap(project, genContext, "IDToArtifact");
    this.macros = new MacroHelper.MacroContext(project, genContext).getMacros(project);
    this.requiresFetch = GenerationUtil.getSessionSet(project, genContext, "requiresFetch");
    myGenContext = genContext;
  }
  public Map<SNode, String> locations() {
    return locationMap;
  }
  public Map<SNode, String> contentLocations() {
    return contentLocationMap;
  }

  /*package*/ Map<Object, SNode> artifacts() {
    return idToArtifactMap;
  }

  public SNode getArtifact(String id) {
    return SNodeOperations.as(idToArtifactMap.get(id), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafac4c85L, "jetbrains.mps.build.structure.BuildLayout_Node"));
  }

  public SNode getArtifact(SNode id) {
    return SNodeOperations.as(idToArtifactMap.get(getOriginalNode(id)), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafac4c85L, "jetbrains.mps.build.structure.BuildLayout_Node"));
  }

  public SNode getArtifact(LocalSourcePathArtifact id) {
    return SNodeOperations.as(idToArtifactMap.get(id), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafac4c85L, "jetbrains.mps.build.structure.BuildLayout_Node"));
  }

  public void putArtifact(String id, SNode artifact) {
    idToArtifactMap.put(id, artifact);
  }

  public void putArtifact(SNode id, SNode artifact) {
    idToArtifactMap.put(getOriginalNode(id), artifact);
  }

  public void putArtifact(LocalSourcePathArtifact id, SNode artifact) {
    idToArtifactMap.put(id, artifact);
  }

  public boolean requiresFetch(SNode node) {
    return requiresFetch.contains(node);
  }

  public void doFetch(SNode node) {
    requiresFetch.add(node);
  }
  public MacroHelper getMacroHelper() {
    return macros;
  }

  public SNode getOriginalNode(SNode node) {
    return getOriginalNode(node, myGenContext);
  }

  public static SNode getOriginalNode(SNode node, TemplateQueryContext genContext) {
    if (SNodeOperations.getModel(node) == null) {
      return node;
    }

    SModule module = SNodeOperations.getModel(node).getModule();
    if (module != null && !((module instanceof TransientModelsModule))) {
      return node;
    }

    if (genContext == null) {
      throw new IllegalStateException("transient model is not expected");
    }

    SNode originalNode = genContext.getOriginalCopiedInputNode(node);
    if ((originalNode == null)) {
      genContext.showErrorMessage(node, "cannot resolve dependency on transient model, no original node is available");
      return null;
    }

    if (SNodeOperations.getModel(originalNode).getModule() instanceof TransientModelsModule) {
      genContext.showErrorMessage(node, "internal error: cannot get original node");
      return null;
    }

    return originalNode;
  }
}
