package jetbrains.mps.build.workflow.constraints;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.generator.template.TemplateQueryContext;
import java.util.Set;
import java.util.LinkedHashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import java.util.LinkedList;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class TaskLibrariesHelper {
  private SNode project;
  private TemplateQueryContext genContext;
  public TaskLibrariesHelper(SNode project, TemplateQueryContext genContext) {
    this.project = project;
    this.genContext = genContext;
  }
  public void importLibs() {
    Set<SNode> libsSet = new LinkedHashSet<SNode>();
    for (SNode tldep : SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x2670d5989d5a6271L, 0x6565da114725c6b7L, "imports"))) {
      libsSet.add(SLinkOperations.getTarget(tldep, MetaAdapterFactory.getReferenceLink(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x6565da1147260537L, 0x6565da1147260538L, "target")));
    }
    closure(libsSet);
    List<SNode> libs = new ArrayList<SNode>(libsSet);
    for (SNode lib : libs) {
      for (SNode n : SNodeUtil.getDescendants(lib)) {
        for (SReference ref : SNodeOperations.getReferences(n)) {
          SNode targetNode = SNodeOperations.getTargetNodeSilently(ref);
          if (targetNode == null) {
            genContext.showErrorMessage(n, "cannot import library `" + SPropertyOperations.getString(lib, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")) + "': unresolved reference");
          } else if (!(libsSet.contains(targetNode.getContainingRoot()))) {
            genContext.showErrorMessage(n, "cannot import library `" + SPropertyOperations.getString(lib, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")) + "': broken reference, target is not imported");
          }
        }
      }
    }
    List<SNode> parts = Sequence.fromIterable(SLinkOperations.collectMany(libs, MetaAdapterFactory.getContainmentLink(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x6565da114724ce92L, 0x6565da114724ce94L, "parts"))).toListSequence();
    Map<SNode, SNode> map = new HashMap<SNode, SNode>();
    parts = (List<SNode>) CopyUtil.copy((List<SNode>) parts, map);
    ListSequence.fromList(SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x2670d5989d5a6271L, 0x6565da114725c6b7L, "imports"))).clear();
    for (SNode n : SNodeUtil.getDescendants(project)) {
      for (SReference ref : n.getReferences()) {
        SNode targetNode = SNodeOperations.getTargetNodeSilently(ref);
        if (map.containsKey(targetNode)) {
          SNodeAccessUtil.setReferenceTarget(n, ref.getRole(), map.get(targetNode));
        } else {
          SNode containingRoot = targetNode.getContainingRoot();
          if (jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.isInstanceOf(containingRoot, MetaAdapterFactory.getConcept(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x6565da114724ce92L, "jetbrains.mps.build.workflow.structure.BwfTaskLibrary"))) {
            genContext.showErrorMessage(n, "task library is not imported");
          }
        }
      }
    }
    // we add everything in the beginning 
    for (int i = parts.size() - 1; i >= 0; i--) {
      ListSequence.fromList(SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x2670d5989d5a6271L, 0x2670d5989d5ace60L, "parts"))).insertElement(0, parts.get(i));
    }
  }
  public static void closure(Set<SNode> libs) {
    Queue<SNode> queue = QueueSequence.fromQueue(new LinkedList<SNode>());
    QueueSequence.fromQueue(queue).addSequence(SetSequence.fromSet(libs));
    while (!(QueueSequence.fromQueue(queue).isEmpty())) {
      SNode lib = QueueSequence.fromQueue(queue).removeFirstElement();
      for (SNode dep : SLinkOperations.getChildren(lib, MetaAdapterFactory.getContainmentLink(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x6565da114724ce92L, 0x6565da114725c6b6L, "imports"))) {
        if (!(libs.contains(SLinkOperations.getTarget(dep, MetaAdapterFactory.getReferenceLink(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x6565da1147260537L, 0x6565da1147260538L, "target"))))) {
          libs.add(SLinkOperations.getTarget(dep, MetaAdapterFactory.getReferenceLink(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x6565da1147260537L, 0x6565da1147260538L, "target")));
          QueueSequence.fromQueue(queue).addLastElement(SLinkOperations.getTarget(dep, MetaAdapterFactory.getReferenceLink(0x698a8d22a10447a0L, 0xba8d10e3ec237f13L, 0x6565da1147260537L, 0x6565da1147260538L, "target")));
        }
      }
    }
  }
}
