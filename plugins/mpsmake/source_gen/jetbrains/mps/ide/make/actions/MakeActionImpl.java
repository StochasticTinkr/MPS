package jetbrains.mps.ide.make.actions;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.Project;
import jetbrains.mps.ide.save.SaveRepositoryCommand;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.ide.make.DefaultMakeMessageHandler;
import jetbrains.mps.make.IMakeService;
import java.util.List;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.resources.MResource;
import jetbrains.mps.ide.generator.GenerationCheckHelper;

public class MakeActionImpl {
  private MakeActionParameters myParams;

  public MakeActionImpl(@NotNull MakeActionParameters params) {
    this.myParams = params;
  }

  /**
   * should be called outside of command
   */
  public void executeAction() {
    final Project project = myParams.getProject();
    if (project.getModelAccess().isCommandAction()) {
      throw new IllegalStateException("should be called outside of command");
    }
    // save all before launching make 
    new SaveRepositoryCommand(project.getRepository()).execute();


    MakeSession session = new MakeSession(project, new DefaultMakeMessageHandler(project), myParams.isCleanMake());
    if (IMakeService.INSTANCE.get().openNewSession(session)) {
      // empty collection is fine, it's up to make service to report there's nothing to do (odd, but fine for now. Action could have do that instead) 
      // We grab write access although read would suffice rather as a 'exclusive read'. Besides, until ModelValidatorAdapter is refactored 
      // not to mix model checking code with UI, which might request write access e.g. on focus lost and eventually lead to 'write from read' issue like 
      // FIXME https://youtrack.jetbrains.com/issue/MPS-24020. Proper fix is to split model check into read, and results reporting into EDT. 
      final List<IResource> inputRes = new ModelAccessHelper(project.getModelAccess()).runWriteAction(new Computable<List<IResource>>() {
        public List<IResource> compute() {
          List<IResource> rv = Sequence.fromIterable(myParams.collectInput()).toListSequence();
          List<SModel> models = ListSequence.fromList(rv).translate(new ITranslator2<IResource, SModel>() {
            public Iterable<SModel> translate(IResource it) {
              return ((MResource) it).models();
            }
          }).toListSequence();
          if (new GenerationCheckHelper().checkModelsBeforeGenerationIfNeeded(project, models)) {
            return rv;
          }
          return null;
        }
      });

      if (inputRes != null) {
        IMakeService.INSTANCE.get().make(session, inputRes);
      }
    }
  }
}
