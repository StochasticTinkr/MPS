package jetbrains.mps.debugger.java.runtime.evaluation.container;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.debugger.java.runtime.state.DebugSession;
import jetbrains.mps.debugger.java.api.state.JavaUiState;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.module.ModelAccess;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.debugger.java.api.evaluation.EvaluationException;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.module.ReloadableModule;
import jetbrains.mps.debugger.java.api.evaluation.Evaluator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import jetbrains.mps.smodel.ModelDependencyUpdate;
import jetbrains.mps.smodel.ModelImports;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.SModelUtil_new;

public class EvaluationContainer implements IEvaluationContainer {
  protected final Project myProject;
  protected final SModuleReference myContainerModule;
  protected volatile SModelReference myContainerModel;
  protected volatile SNodeReference myNode;
  protected final SRepository myDebuggerRepository;

  protected final DebugSession myDebugSession;
  protected volatile JavaUiState myUiState;

  public EvaluationContainer(Project mpsProject, DebugSession session, @NotNull SModuleReference containerModule, final List<SNodeReference> nodesToImport, final _FunctionTypes._void_P1_E0<? super IEvaluationContainer> onNodeSetUp) {
    myProject = mpsProject;
    myDebugSession = session;
    myContainerModule = containerModule;
    myUiState = myDebugSession.getUiState();
    myDebuggerRepository = mpsProject.getRepository();
    final ModelAccess modelAccess = mpsProject.getModelAccess();
    modelAccess.runWriteAction(new Runnable() {
      public void run() {
        SModule containerModule = myContainerModule.resolve(myDebuggerRepository);
        SModel descriptor = TemporaryModels.getInstance().create(false, TempModuleOptions.forExistingModule(containerModule));
        myContainerModel = descriptor.getReference();
      }
    });

    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        modelAccess.executeCommand(new Runnable() {
          public void run() {
            setUpNode(nodesToImport);
          }
        });
        onNodeSetUp.invoke(EvaluationContainer.this);
      }
    });
  }

  @Override
  public Class generateClass() throws EvaluationException {
    // XXX this method is invoked from EvaluationUi, from a thread without any model access. 
    SModel containerModel = myContainerModel.resolve(myDebuggerRepository);
    // FIXME in fact, I'm pretty sure we can accomplish the same with regular dependency to j.m.d.java.api from EvaluationModule 
    //       Then, classpath built for EvaluationModule would include everything we try to push here with an extra CL. However, 
    //       don't want to dive too deep into this mess now, shall refactor make facet to get rid of CResource use anyway, and  
    //       refresh the whole idea of EvaluationModule and its temp models, and how are they handled/processed. Then, this code is likely to fade away. 
    ClassLoader extraCL = new ModelAccessHelper(myDebuggerRepository).runReadAction(new Computable<ClassLoader>() {
      public ClassLoader compute() {
        SModule extraClasspath = PersistenceFacade.getInstance().createModuleReference("cf8c9de5-1b4a-4dc8-8e6d-847159af31dd(jetbrains.mps.debugger.java.api)").resolve(myDebuggerRepository);
        assert extraClasspath instanceof ReloadableModule;

        return ((ReloadableModule) extraClasspath).getClassLoader();
      }
    });
    return GeneratorUtil.generateAndLoadEvaluatorClass(myProject, containerModel, Properties.EVALUATOR_NAME, Properties.IS_DEVELOPER_MODE, extraCL);
  }

  @Override
  public Evaluator createEvaluatorInstance(Class clazz) throws EvaluationException {
    return GeneratorUtil.createInstance(clazz, new Class[]{JavaUiState.class}, new Object[]{myUiState});
  }

  @Override
  public IEvaluationContainer copy(boolean isWatch, _FunctionTypes._void_P1_E0<? super IEvaluationContainer> onNodeSetUp) {
    final SNodeReference reference = myNode;
    return new EvaluationContainer(myProject, myDebugSession, myContainerModule, ListSequence.fromList(new ArrayList<SNodeReference>()), onNodeSetUp) {
      @Override
      protected SNode createEvaluatorNode() {
        return (SNode) CopyUtil.copyAndPreserveId(reference.resolve(myDebuggerRepository), true);
      }
    };
  }

  @Override
  public String getPresentation() {
    return new ModelAccessHelper(myDebuggerRepository).runReadAction(new Computable<String>() {
      @Override
      public String compute() {
        return PresentationUtil.getPresentation(((SNode) BHReflection.invoke0(SNodeOperations.cast(getNode(), MetaAdapterFactory.getInterfaceConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x7f4a99699cea367bL, "jetbrains.mps.debugger.java.evaluation.structure.IEvaluatorConcept")), MetaAdapterFactory.getInterfaceConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x7f4a99699cea367bL, "jetbrains.mps.debugger.java.evaluation.structure.IEvaluatorConcept"), SMethodTrimmedId.create("getCode", null, "hASWOEj0jB"))));
      }
    });
  }

  @Override
  public SNode getNode() {
    if (myNode == null) {
      return null;
    }
    return myNode.resolve(myDebuggerRepository);
  }

  @Override
  public void updateState() {
    myUiState = myDebugSession.getUiState();
  }

  protected void setUpNode(List<SNodeReference> nodesToImport) {
    SModel containerModel = myContainerModel.resolve(myDebuggerRepository);

    SNode evaluatorNode = createEvaluatorNode();
    containerModel.addRootNode(evaluatorNode);
    myNode = SNodeOperations.getPointer(evaluatorNode);

    // todo: variables 
    new EvaluationContainer.MyBaseLanguagesImportHelper().tryToImport(((SNode) BHReflection.invoke0(evaluatorNode, MetaAdapterFactory.getInterfaceConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x7f4a99699cea367bL, "jetbrains.mps.debugger.java.evaluation.structure.IEvaluatorConcept"), SMethodTrimmedId.create("getCode", null, "hASWOEj0jB"))), nodesToImport);

    // XXX likely, don't need a repo in updateImportedModels() here, as it's not vital to import accessories implicitly 
    new ModelDependencyUpdate(containerModel).updateUsedLanguages().updateImportedModels(myDebuggerRepository).updateModuleDependencies(myDebuggerRepository);
    ModelImports modelImports = new ModelImports(containerModel);
    modelImports.addUsedLanguage(MetaAdapterFactory.getLanguage(0x7da4580f9d754603L, 0x816251a896d78375L, "jetbrains.mps.debugger.java.evaluation"));
    modelImports.addUsedLanguage(MetaAdapterFactory.getLanguage(0x802088974572437dL, 0xb50e8f050cba9566L, "jetbrains.mps.debugger.java.privateMembers"));
  }
  protected SNode createEvaluatorNode() {
    return SNodeFactoryOperations.createNewNode(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0xbbe5b47d7cc5fa1L, "jetbrains.mps.debugger.java.evaluation.structure.Evaluator"), null);
  }
  private class MyBaseLanguagesImportHelper extends BaseLanguagesImportHelper {
    @Override
    public SNode findVariable(SReference variableReference) {
      return null;
    }
    @Override
    public SNode createVariableReference(SNode variable) {
      return createInternalVariableReference_jbng3m_a0a1z(variable.getName());
    }
  }
  private static SNode createInternalVariableReference_jbng3m_a0a1z(Object p0) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode n1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xdf345b11b8c74213L, 0xac6648d2a9b75d88L, 0x111fb5bb1f2L, "jetbrains.mps.baseLanguageInternal.structure.InternalVariableReference"), null, null, false);
    {
      n1.setProperty(MetaAdapterFactory.getProperty(0xdf345b11b8c74213L, 0xac6648d2a9b75d88L, 0x111fb5bb1f2L, 0x111fb5dbc49L, "name"), p0 + "");
      SNode n2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType"), null, null, false);
      n2.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"), jetbrains.mps.smodel.SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"), n2, facade.createModelReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065/java:java.lang(JDK/)"), facade.createNodeId("~Object")));
      n1.addChild(MetaAdapterFactory.getContainmentLink(0xdf345b11b8c74213L, 0xac6648d2a9b75d88L, 0x111fb5bb1f2L, 0x111fb5c4f4cL, "type"), n2);
    }
    return n1;
  }
}
