package jetbrains.mps.vcs.diff;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNodeId;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.jetbrains.annotations.Nullable;

public class StructChangeSetImpl implements StructChangeSet {
  private final SModel myOldModel;
  private final SNodeId myOldNodeId;
  private final SModel myNewModel;
  private final SNodeId myNewNodeId;
  private final List<ModelChange> myModelChanges = new CopyOnWriteArrayList<ModelChange>();
  private final Map<SNodeId, SNodeId> myOldToNewMap = MapSequence.fromMap(new HashMap<SNodeId, SNodeId>());
  private final Map<SNodeId, SNodeId> myNewToOldMap = MapSequence.fromMap(new HashMap<SNodeId, SNodeId>());
  private StructChangeSetImpl myOppositeChangeSet = null;
  public StructChangeSetImpl(@NotNull SNode oldNode, @NotNull SNode newNode) {
    this(SNodeOperations.getModel(oldNode), oldNode.getNodeId(), SNodeOperations.getModel(newNode), newNode.getNodeId());
  }
  public StructChangeSetImpl(@NotNull SModel oldModel, @NotNull SNodeId oldNodeId, @NotNull SModel newModel, @NotNull SNodeId newNodeId) {
    myOldModel = oldModel;
    myOldNodeId = oldNodeId;
    myNewModel = newModel;
    myNewNodeId = newNodeId;
  }
  @NotNull
  @Override
  public List<ModelChange> getModelChanges() {
    return Collections.unmodifiableList(myModelChanges);
  }
  public void clear() {
    ListSequence.fromList(myModelChanges).clear();
  }
  @NotNull
  @Override
  public <C extends ModelChange> Iterable<C> getModelChanges(final Class<C> changeClass) {
    return ListSequence.fromList(myModelChanges).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return changeClass.isInstance(ch);
      }
    }).select(new ISelector<ModelChange, C>() {
      public C select(ModelChange ch) {
        return (C) ch;
      }
    });
  }
  @NotNull
  @Override
  public SModel getOldModel() {
    return myOldModel;
  }
  @NotNull
  @Override
  public SModel getNewModel() {
    return myNewModel;
  }
  @NotNull
  public SNodeId getOldNodeId() {
    return myOldNodeId;
  }
  @NotNull
  public SNodeId getNewNodeId() {
    return myNewNodeId;
  }
  @NotNull
  @Override
  public ChangeSet getOppositeChangeSet() {
    if (myOppositeChangeSet == null) {
      throw new IllegalStateException("opposite chage set is not built");
    }

    return myOppositeChangeSet;
  }
  public void clearOppositeChangeSet() {
    myOppositeChangeSet = null;
  }
  public void buildOppositeChangeSet() {
    if (myOppositeChangeSet == null) {
      myOppositeChangeSet = new StructChangeSetImpl(myNewModel, myNewNodeId, myOldModel, myOldNodeId);
      myOppositeChangeSet.myOppositeChangeSet = this;

      MapSequence.fromMap(myOppositeChangeSet.myOldToNewMap).putAll(myNewToOldMap);
      MapSequence.fromMap(myOppositeChangeSet.myNewToOldMap).putAll(myOldToNewMap);
      ListSequence.fromList(myOppositeChangeSet.myModelChanges).addSequence(ListSequence.fromList(myModelChanges).select(new ISelector<ModelChange, ModelChange>() {
        public ModelChange select(ModelChange c) {
          return c.getOppositeChange();
        }
      }));
    }
  }
  public void add(@NotNull ModelChange change) {
    ListSequence.fromList(myModelChanges).addElement(change);
    if (myOppositeChangeSet != null) {
      ListSequence.fromList(myOppositeChangeSet.myModelChanges).addElement(change.getOppositeChange());
    }
  }
  public void remove(@NotNull ModelChange change) {
    ListSequence.fromList(myModelChanges).removeElement(change);
    if (myOppositeChangeSet != null) {
      ListSequence.fromList(myOppositeChangeSet.myModelChanges).removeElement(change.getOppositeChange());
    }
  }
  public void addAll(Iterable<? extends ModelChange> changes) {
    ListSequence.fromList(myModelChanges).addSequence(Sequence.fromIterable(changes));
    if (myOppositeChangeSet != null) {
      ListSequence.fromList(myOppositeChangeSet.myModelChanges).addSequence(Sequence.fromIterable(changes).select(new ISelector<ModelChange, ModelChange>() {
        public ModelChange select(ModelChange c) {
          return c.getOppositeChange();
        }
      }));
    }
  }
  public void buildNodeMaps(Map<SNodeId, SNodeId> oldToNewMap) {
    for (IMapping<SNodeId, SNodeId> mapping : MapSequence.fromMap(oldToNewMap)) {
      MapSequence.fromMap(myOldToNewMap).put(mapping.key(), mapping.value());
      MapSequence.fromMap(myNewToOldMap).put(mapping.value(), mapping.key());
    }
  }
  @Nullable
  public SNodeId mapToNewId(SNodeId idOld) {
    return MapSequence.fromMap(myOldToNewMap).get(idOld);
  }
  @Nullable
  public SNodeId mapToOldId(SNodeId idNew) {
    return MapSequence.fromMap(myNewToOldMap).get(idNew);
  }
}
