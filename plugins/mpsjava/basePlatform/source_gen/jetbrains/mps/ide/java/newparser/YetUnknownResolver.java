package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import org.jetbrains.mps.openapi.util.SubProgressKind;
import jetbrains.mps.progress.EmptyProgressMonitor;
import java.util.concurrent.atomic.AtomicBoolean;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.List;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.smodel.ModelImports;
import java.util.function.Consumer;

/**
 * To deal with ambiguous notations in Java source code (like a.b.c.d.E.f), we need to perform few rounds of reference resolution.
 */
public class YetUnknownResolver {
  private final Iterable<SNode> myInitialNodes;
  private Map<SNode, SNode> myResolutionMap;
  private Set<SModelReference> myRefTargetOfResolved;
  private int myIterationCount = 0;
  private SModel myModel;


  public YetUnknownResolver(SModel model) {
    this(model, SModelOperations.roots(model, null));
  }

  public YetUnknownResolver(SModel model, Iterable<SNode> nodes) {
    myModel = model;
    myInitialNodes = nodes;
  }

  /**
   * Handy method that combines other public methods of this class into proper sequence, and wraps calls with proper IncrementalModelAccess
   * Use this method unless you need to handle resolution in some special way (and you are 119% sure you know what you do)
   */
  public void tryResolveUnknowns(ProgressMonitor progress, IncrementalModelAccess modelAccess) {
    // make room for this many passes, and just don't advance the progress afterwards 
    final int PASSES_TO_SHOW_UNDER_PROGRESS = 5;
    progress.start("", PASSES_TO_SHOW_UNDER_PROGRESS + 1);
    int k = 0;
    int watchdog = 100;
    do {
      final ProgressMonitor progressForThisPass;
      if (k++ < PASSES_TO_SHOW_UNDER_PROGRESS) {
        progressForThisPass = progress.subTask(1, SubProgressKind.REPLACING);
      } else {
        progressForThisPass = new EmptyProgressMonitor();
      }
      progressForThisPass.start("", 3);
      final AtomicBoolean anyUnresolvedYet = new AtomicBoolean(false);
      modelAccess.accessModel(new Runnable() {
        public void run() {
          anyUnresolvedYet.set(collectYetUnresolved(progressForThisPass.subTask(2, SubProgressKind.REPLACING)));

        }
      });
      if (anyUnresolvedYet.get()) {
        modelAccess.replaceNodes(new Runnable() {
          public void run() {
            replaceYetUnresolved(progressForThisPass.subTask(1, SubProgressKind.REPLACING));
            updateWithImportsOfResolved();
          }
        });
      } else {
        break;
      }
      progressForThisPass.done();
    } while (--watchdog > 0);
    progress.done();
  }

  /**
   * Collect IYetUnresolved, record their substitutions, and report whether there were any.
   * 
   * @param progress monitor progress
   * @return {@code true} when there are IYetUnresolved with substitutions
   */
  public boolean collectYetUnresolved(ProgressMonitor progress) {
    assert myIterationCount == 0 || myResolutionMap != null;
    collectYetUnresolved((myResolutionMap == null ? myInitialNodes : MapSequence.fromMap(myResolutionMap).values()), progress);
    myIterationCount++;
    return !(MapSequence.fromMap(myResolutionMap).isEmpty());
  }

  private void collectYetUnresolved(Iterable<SNode> roots, ProgressMonitor progress) {
    progress.start("Ambiguous concepts...", Sequence.fromIterable(roots).count());
    myResolutionMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    for (SNode node : Sequence.fromIterable(roots)) {
      progress.step((SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")) ? ("node: " + SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))) : ""));
      List<SNode> unknowns = SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x70ea1dc4c5721865L, "jetbrains.mps.baseLanguage.structure.IYetUnresolved"), false, new SAbstractConcept[]{MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x70ea1dc4c5721865L, "jetbrains.mps.baseLanguage.structure.IYetUnresolved")});
      for (SNode unk : ListSequence.fromList(unknowns)) {
        final SNode unkNode = unk;
        final _FunctionTypes._return_P0_E0<? extends SNode> subst = ((_FunctionTypes._return_P0_E0<? extends SNode>) BHReflection.invoke0(unk, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x70ea1dc4c5721865L, "jetbrains.mps.baseLanguage.structure.IYetUnresolved"), SMethodTrimmedId.create("evaluateSubst", null, "73E7sj5sxxG")));
        if (subst == null) {
          continue;
        }

        SNode theRightNode = subst.invoke();
        MapSequence.fromMap(myResolutionMap).put(unkNode, theRightNode);
      }
      progress.advance(1);
    }
    progress.done();
  }

  public void replaceYetUnresolved(final ProgressMonitor progress) {
    progress.start("replacing nodes", MapSequence.fromMap(myResolutionMap).count());
    myRefTargetOfResolved = SetSequence.fromSet(new HashSet<SModelReference>());
    for (IMapping<SNode, SNode> it : MapSequence.fromMap(myResolutionMap)) {
      SNode unresolved = it.key();
      SNode resolved = it.value();
      SNodeOperations.replaceWithAnother(unresolved, resolved);
      for (StaticReference sr : Sequence.fromIterable(JavaToMpsConverter.deepReferences(resolved)).ofType(StaticReference.class)) {
        SModelReference targetModelRef = sr.getTargetSModelReference();
        if (targetModelRef != null) {
          SetSequence.fromSet(myRefTargetOfResolved).addElement(targetModelRef);
        }
      }
      progress.advance(1);
    }
    progress.done();
  }

  /**
   * Update imports of a source model with references to newly resolved targets (discovered from replacement nodes of most recent {@link jetbrains.mps.ide.java.newparser.YetUnknownResolver#replaceYetUnresolved(ProgressMonitor) } run).
   * Although it's not necessary to update imports after *each* replacement step, it might be vital for replacement of futher IYetUnresolved as model imports affect scope.
   */
  public void updateWithImportsOfResolved() {
    assert myRefTargetOfResolved != null;
    SModelReference srcModelRef = SModelOperations.getPointer(myModel);
    SetSequence.fromSet(myRefTargetOfResolved).removeElement(srcModelRef);
    ModelImports mi = new ModelImports(myModel);
    for (SModelReference mr : myRefTargetOfResolved) {
      mi.addModelImport(mr);
    }
  }

  /**
   * Special case (persistence, partial model load) when we can not update model imports through SModelInternal and need to go right through model data
   * 
   * @param callback receives each external model reference of the most recent {@link #replaceYetUnresolved(ProgressMonitor) node replacement} run
   */
  public void withImportsOfResolved(Consumer<SModelReference> callback) {
    SModelReference srcModelRef = SModelOperations.getPointer(myModel);
    SetSequence.fromSet(myRefTargetOfResolved).removeElement(srcModelRef);
    myRefTargetOfResolved.stream().forEach(callback);
  }
}
