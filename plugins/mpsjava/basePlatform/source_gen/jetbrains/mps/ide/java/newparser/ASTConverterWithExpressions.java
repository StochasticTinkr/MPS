package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNode;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.smodel.StaticReference;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
import org.eclipse.jdt.internal.compiler.ast.ArrayReference;
import org.eclipse.jdt.internal.compiler.ast.Assignment;
import org.eclipse.jdt.internal.compiler.ast.BinaryExpression;
import org.eclipse.jdt.internal.compiler.ast.CastExpression;
import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
import org.eclipse.jdt.internal.compiler.ast.FieldReference;
import org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;
import org.eclipse.jdt.internal.compiler.ast.Literal;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.ast.ThisReference;
import org.eclipse.jdt.internal.compiler.ast.UnaryExpression;
import org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;
import org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;
import org.eclipse.jdt.internal.compiler.ast.EqualExpression;
import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
import org.eclipse.jdt.internal.compiler.ast.PostfixExpression;
import org.eclipse.jdt.internal.compiler.ast.PrefixExpression;
import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
import org.eclipse.jdt.internal.compiler.ast.SuperReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.eclipse.jdt.internal.compiler.ast.NameReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
import org.eclipse.jdt.internal.compiler.impl.Constant;
import jetbrains.mps.util.NameUtil;
import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.SModelUtil_new;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;

public class ASTConverterWithExpressions extends ASTConverter {
  private Logger LOG = LogManager.getLogger(ASTConverterWithExpressions.class);

  public ASTConverterWithExpressions(boolean onlyStubs) {
    super(onlyStubs);
  }
  protected ASTConverterWithExpressions(ASTConverterWithExpressions base) {
    super(base);
  }

  /*package*/ SNode convertBinaryOperation(Expression left, Expression right, SNode binaryOperation) throws JavaParseException {
    SLinkOperations.setTarget(binaryOperation, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbdeb6fecfL, 0xfbdeb7a11cL, "leftExpression"), convertExpressionWrap(left));
    SLinkOperations.setTarget(binaryOperation, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbdeb6fecfL, 0xfbdeb7a11bL, "rightExpression"), convertExpressionWrap(right));
    return binaryOperation;
  }
  public void addCallArgs(SNode call, Expression[] args) throws JavaParseException {
    if (args == null) {
      return;
    }
    for (Expression arg : args) {
      ListSequence.fromList(SLinkOperations.getChildren(call, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, "actualArgument"))).addElement(convertExpressionWrap(arg));
    }
  }
  public TypeReference[] typeArguments(TypeReference typeRef) {
    if (typeRef instanceof ParameterizedSingleTypeReference) {
      return ((ParameterizedSingleTypeReference) typeRef).typeArguments;
    } else if (typeRef instanceof ParameterizedQualifiedTypeReference) {
      // ignoring type arguments in not last components, e.g. Class1<T>.Class2 
      TypeReference[][] allArgs = ((ParameterizedQualifiedTypeReference) typeRef).typeArguments;
      // return only type arguments of the last component 
      return allArgs[allArgs.length - 1];
    } else {
      return new TypeReference[0];
    }
  }
  private String typeName(TypeReference typeRef) {
    char[][] tokens = typeRef.getTypeName();
    if (tokens == null || tokens.length == 0) {
      return null;
    }

    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < tokens.length; i++) {
      if (i > 0) {
        sb.append('.');
      }
      sb.append(tokens[i]);
    }
    return sb.toString();
  }
  private SReference adjustClassReference(SNode clsType, SNode source, String role) {
    org.jetbrains.mps.openapi.model.SReference sref = clsType.getReference("classifier");
    if (sref instanceof DynamicReference) {
      return new DynamicReference(role, source, null, ((DynamicReference) sref).getResolveInfo());
    } else if (sref instanceof StaticReference) {
      return new StaticReference(role, source, ((StaticReference) sref).getTargetNode());
    } else {
      throw new RuntimeException("Unknown type of reference: " + sref.getClass().getName());
    }
  }

  public SNode convertExpressionWrap(Expression expression) throws JavaParseException {
    SNode result = convertExpression(expression);
    if (expression != null) {
      int parenthesisCount = (expression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;
      for (int parenthsCreated = 0; parenthsCreated < parenthesisCount; parenthsCreated++) {
        SNode parenthesizedExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfb4ed32b7fL, "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression"));
        SLinkOperations.setTarget(parenthesizedExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfb4ed32b7fL, 0xfb4ed32b80L, "expression"), result);
        result = parenthesizedExpression;
      }
    }
    return result;
  }
  @Override
  public SNode convertExpression(Expression x) throws JavaParseException {
    if (x instanceof AllocationExpression) {
      return convertExpression((AllocationExpression) x);
    } else if (x instanceof ArrayAllocationExpression) {
      return convertExpression((ArrayAllocationExpression) x);
    } else if (x instanceof ArrayInitializer) {
      return convertExpression((ArrayInitializer) x);
    } else if (x instanceof ArrayReference) {
      return convertExpression((ArrayReference) x);
    } else if (x instanceof Assignment) {
      return convertExpression((Assignment) x);
    } else if (x instanceof BinaryExpression) {
      return convertExpression((BinaryExpression) x);
    } else if (x instanceof CastExpression) {
      return convertExpression((CastExpression) x);
    } else if (x instanceof ClassLiteralAccess) {
      return convertExpression((ClassLiteralAccess) x);
    } else if (x instanceof ConditionalExpression) {
      return convertExpression((ConditionalExpression) x);
    } else if (x instanceof FieldReference) {
      return convertExpression((FieldReference) x);
    } else if (x instanceof InstanceOfExpression) {
      return convertExpression((InstanceOfExpression) x);
    } else if (x instanceof Literal) {
      return convertExpression((Literal) x);
    } else if (x instanceof MessageSend) {
      return convertExpression((MessageSend) x);
    } else if (x instanceof QualifiedNameReference) {
      return convertExpression((QualifiedNameReference) x);
    } else if (x instanceof SingleNameReference) {
      return convertExpression((SingleNameReference) x);
    } else if (x instanceof ThisReference) {
      return convertExpression((ThisReference) x);
    } else if (x instanceof UnaryExpression) {
      return convertExpression((UnaryExpression) x);
    } else {
      if (x != null) {
        LOG.error("Unknown expression type: " + x.getClass().getName());
      }
      return null;
    }

  }

  /*package*/ SNode convertExpression(AND_AND_Expression x) throws JavaParseException {
    SNode andExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfb7c3070eeL, "jetbrains.mps.baseLanguage.structure.AndExpression"));
    return convertBinaryOperation(x.left, x.right, andExpression);
  }
  /*package*/ SNode convertExpression(OR_OR_Expression x) throws JavaParseException {
    SNode orExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfb8255689fL, "jetbrains.mps.baseLanguage.structure.OrExpression"));
    return convertBinaryOperation(x.left, x.right, orExpression);
  }
  /*package*/ SNode convertExpression(ArrayAllocationExpression x) throws JavaParseException {
    SNode compType = convertTypeReference(x.type);
    if (x.initializer != null) {

      if (x.dimensions.length > 1) {
        compType = buildArrayType(compType, x.dimensions.length - 1, false);
      }

      List<SNode> initializers = new ArrayList<SNode>();
      if (x.initializer.expressions != null) {
        for (Expression expression : x.initializer.expressions) {
          ListSequence.fromList(initializers).addElement(convertExpressionWrap(expression));
        }
      }
      SNode arrayCreator = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10cd01b77ddL, "jetbrains.mps.baseLanguage.structure.ArrayCreatorWithInitializer"));
      for (SNode initializer : initializers) {
        ListSequence.fromList(SLinkOperations.getChildren(arrayCreator, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10cd01b77ddL, 0x10cd01d19acL, "initValue"))).addElement(initializer);
      }
      SLinkOperations.setTarget(arrayCreator, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10cd01b77ddL, 0x10cd01cf3c4L, "componentType"), compType);
      SNode genericNewExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ab8473cc5L, "jetbrains.mps.baseLanguage.structure.GenericNewExpression"));
      SLinkOperations.setTarget(genericNewExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ab8473cc5L, 0x10ab847b486L, "creator"), arrayCreator);
      return genericNewExpression;
    } else {
      List<SNode> dims = new ArrayList<SNode>();
      for (Expression dimension : x.dimensions) {
        if (dimension == null) {
          ListSequence.fromList(dims).addElement(null);
        } else {
          ListSequence.fromList(dims).addElement(convertExpressionWrap(dimension));
        }
      }
      SNode arrayCreator = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x113e4952f12L, "jetbrains.mps.baseLanguage.structure.ArrayCreator"));
      for (SNode dim : dims) {
        SNode dimensionExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x113e4b2dfdaL, "jetbrains.mps.baseLanguage.structure.DimensionExpression"));
        ListSequence.fromList(SLinkOperations.getChildren(arrayCreator, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x113e4952f12L, 0x113e4b36742L, "dimensionExpression"))).addElement(dimensionExpression);
        if (dim != null) {
          SLinkOperations.setTarget(dimensionExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x113e4b2dfdaL, 0x113e4b846d4L, "expression"), dim);
        }
      }
      SNode deepestComponentType = compType;
      while (SNodeOperations.isInstanceOf(deepestComponentType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
        deepestComponentType = SLinkOperations.getTarget(SNodeOperations.cast(deepestComponentType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, "jetbrains.mps.baseLanguage.structure.ArrayType")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, 0xf940d819f8L, "componentType"));
      }
      SLinkOperations.setTarget(arrayCreator, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x113e4952f12L, 0x113e49578edL, "componentType"), deepestComponentType);
      SNode genericNewExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ab8473cc5L, "jetbrains.mps.baseLanguage.structure.GenericNewExpression"));
      SLinkOperations.setTarget(genericNewExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ab8473cc5L, 0x10ab847b486L, "creator"), arrayCreator);
      return genericNewExpression;
    }
  }
  /*package*/ SNode convertExpression(ArrayInitializer x) throws JavaParseException {
    List<SNode> initializers = new ArrayList<SNode>();
    if (x.expressions != null) {
      for (Expression expression : x.expressions) {
        ListSequence.fromList(initializers).addElement(convertExpressionWrap(expression));
      }
    }
    SNode arrayLiteral = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a770dc0dL, "jetbrains.mps.baseLanguage.structure.ArrayLiteral"));
    for (SNode initializer : initializers) {
      ListSequence.fromList(SLinkOperations.getChildren(arrayLiteral, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a770dc0dL, 0x114a770fdbfL, "item"))).addElement(initializer);
    }
    return arrayLiteral;
  }
  /*package*/ SNode convertExpression(ArrayReference x) throws JavaParseException {
    SNode accessExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11126b40c25L, "jetbrains.mps.baseLanguage.structure.ArrayAccessExpression"));
    SLinkOperations.setTarget(accessExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11126b40c25L, 0x11126b6de5aL, "array"), convertExpressionWrap(x.receiver));
    SLinkOperations.setTarget(accessExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11126b40c25L, 0x11126b6ac89L, "index"), convertExpressionWrap(x.position));
    return accessExpression;
  }
  /*package*/ SNode convertExpression(Assignment x) throws JavaParseException {
    if (x instanceof CompoundAssignment) {
      return convertExpression((CompoundAssignment) x);
    } else {
      SNode assignmentExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e96L, "jetbrains.mps.baseLanguage.structure.AssignmentExpression"));
      SLinkOperations.setTarget(assignmentExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11b0d00332cL, 0xf8c77f1e97L, "lValue"), convertExpressionWrap(x.lhs));
      SLinkOperations.setTarget(assignmentExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11b0d00332cL, 0xf8c77f1e99L, "rValue"), convertExpressionWrap(x.expression));
      return assignmentExpression;
    }

  }
  /*package*/ SNode convertExpression(BinaryExpression x) throws JavaParseException {
    if (x instanceof AND_AND_Expression) {
      return convertExpression((AND_AND_Expression) x);
    } else if (x instanceof EqualExpression) {
      return convertExpression((EqualExpression) x);
    } else if (x instanceof OR_OR_Expression) {
      return convertExpression((OR_OR_Expression) x);
    } else {
      SNode op;
      int binOp = (x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;
      switch (binOp) {
        case OperatorIds.LEFT_SHIFT:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11d6cde9fb9L, "jetbrains.mps.baseLanguage.structure.ShiftLeftExpression"));
          break;
        case OperatorIds.RIGHT_SHIFT:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11d6ce051dfL, "jetbrains.mps.baseLanguage.structure.ShiftRightExpression"));
          break;
        case OperatorIds.UNSIGNED_RIGHT_SHIFT:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x470fa5a7b03ac59L, "jetbrains.mps.baseLanguage.structure.ShiftRightUnsignedExpression"));
          break;
        case OperatorIds.PLUS:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7fbL, "jetbrains.mps.baseLanguage.structure.PlusExpression"));
          break;
        case OperatorIds.MINUS:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f5L, "jetbrains.mps.baseLanguage.structure.MinusExpression"));
          break;
        case OperatorIds.REMAINDER:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10c8d509af4L, "jetbrains.mps.baseLanguage.structure.RemExpression"));
          break;
        case OperatorIds.XOR:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11d19ef69abL, "jetbrains.mps.baseLanguage.structure.BitwiseXorExpression"));
          break;
        case OperatorIds.AND:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11d19eede01L, "jetbrains.mps.baseLanguage.structure.BitwiseAndExpression"));
          break;
        case OperatorIds.MULTIPLY:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfe476b758fL, "jetbrains.mps.baseLanguage.structure.MulExpression"));
          break;
        case OperatorIds.OR:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11d19ef4652L, "jetbrains.mps.baseLanguage.structure.BitwiseOrExpression"));
          break;
        case OperatorIds.DIVIDE:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xff2bbc13daL, "jetbrains.mps.baseLanguage.structure.DivExpression"));
          break;
        case OperatorIds.LESS_EQUAL:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10c8d53a915L, "jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression"));
          break;
        case OperatorIds.GREATER_EQUAL:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10c8d0fac2cL, "jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression"));
          break;
        case OperatorIds.GREATER:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbced38fcfL, "jetbrains.mps.baseLanguage.structure.GreaterThanExpression"));
          break;
        case OperatorIds.LESS:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbced3b82aL, "jetbrains.mps.baseLanguage.structure.LessThanExpression"));
          break;
        default:
          throw new JavaParseException("Unsupported operator for BinaryExpression");
      }
      return convertBinaryOperation(x.left, x.right, op);
    }

  }
  /*package*/ SNode convertExpression(CompoundAssignment x) throws JavaParseException {
    if (x instanceof PostfixExpression) {
      return convertExpression((PostfixExpression) x);
    } else if (x instanceof PrefixExpression) {
      return convertExpression((PrefixExpression) x);
    } else {
      SNode op;
      switch (x.operator) {
        case OperatorIds.PLUS:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11b0d1476d2L, "jetbrains.mps.baseLanguage.structure.PlusAssignmentExpression"));
          break;
        case OperatorIds.MINUS:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11b0d14a4eaL, "jetbrains.mps.baseLanguage.structure.MinusAssignmentExpression"));
          break;
        case OperatorIds.MULTIPLY:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x617aa860be8616ecL, "jetbrains.mps.baseLanguage.structure.MulAssignmentExpression"));
          break;
        case OperatorIds.DIVIDE:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x617aa860be862ea4L, "jetbrains.mps.baseLanguage.structure.DivAssignmentExpression"));
          break;
        case OperatorIds.AND:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x617aa860be862eaaL, "jetbrains.mps.baseLanguage.structure.AndAssignmentExpression"));
          break;
        case OperatorIds.OR:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x617aa860be862ea8L, "jetbrains.mps.baseLanguage.structure.OrAssignmentExpression"));
          break;
        case OperatorIds.XOR:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x617aa860be862eacL, "jetbrains.mps.baseLanguage.structure.XorAssignmentExpression"));
          break;
        case OperatorIds.REMAINDER:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x617aa860be862ea6L, "jetbrains.mps.baseLanguage.structure.RemAssignmentExpression"));
          break;
        case OperatorIds.LEFT_SHIFT:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x617aa860be862eaeL, "jetbrains.mps.baseLanguage.structure.LeftShiftAssignmentExpression"));
          break;
        case OperatorIds.RIGHT_SHIFT:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x617aa860be862eb0L, "jetbrains.mps.baseLanguage.structure.RightShiftAssignmentExpression"));
          break;
        case OperatorIds.UNSIGNED_RIGHT_SHIFT:
          op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x470fa5a7b0ad087L, "jetbrains.mps.baseLanguage.structure.UnsignedRightShiftAssignmentExpression"));
          break;
        default:
          throw new JavaParseException("Unsupported operator for CompoundAssignment");
      }
      SLinkOperations.setTarget(op, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11b0d00332cL, 0xf8c77f1e97L, "lValue"), convertExpressionWrap(x.lhs));
      SLinkOperations.setTarget(op, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11b0d00332cL, 0xf8c77f1e99L, "rValue"), convertExpressionWrap(x.expression));
      return op;
    }

  }
  /*package*/ SNode convertExpression(PrefixExpression x) throws JavaParseException {
    SNode op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x120a472f0e8L, "jetbrains.mps.baseLanguage.structure.PrefixDecrementExpression"));
        break;
      case OperatorIds.PLUS:
        op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x120a46df580L, "jetbrains.mps.baseLanguage.structure.PrefixIncrementExpression"));
        break;
      default:
        throw new JavaParseException("Unexpected prefix operator");
    }
    SLinkOperations.setTarget(op, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x120a4c1f269L, 0x120a4c433a6L, "expression"), convertExpressionWrap(x.lhs));
    return op;
  }
  /*package*/ SNode convertExpression(CastExpression x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940dabe4aL, "jetbrains.mps.baseLanguage.structure.CastExpression"));
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940dabe4aL, 0xf940dabe4cL, "expression"), convertExpressionWrap(x.expression));

    // x.type is expression, not type reference 
    // we're making TypeReference out of NameReference 

    // in idea 12's eclipse parser seems to give us type reference right away 
    if (!(x.type instanceof TypeReference)) {
      LOG.error("Class in class cast expession is not a type reference. Class name: " + x.type.toString());
      return null;
    }

    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940dabe4aL, 0xf940dabe4bL, "type"), convertTypeReference(x.type));
    return result;
  }
  /*package*/ SNode convertExpression(NullLiteral x) {
    return SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940cd6167L, "jetbrains.mps.baseLanguage.structure.NullLiteral"));
  }
  /*package*/ SNode convertExpression(SuperReference x) throws JavaParseException {
    return SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL, "jetbrains.mps.baseLanguage.structure.Expression"));
  }
  /*package*/ SNode convertExpression(ThisReference x) throws JavaParseException {
    if (x instanceof QualifiedThisReference) {
      return convertExpression((QualifiedThisReference) x);
    } else if (x instanceof SuperReference) {
      return convertExpression((SuperReference) x);
    } else {
      return SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93d4da00cL, "jetbrains.mps.baseLanguage.structure.ThisExpression"));
    }

  }
  /*package*/ SNode convertExpression(QualifiedThisReference x) throws JavaParseException {
    SNode thisRef = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93d4da00cL, "jetbrains.mps.baseLanguage.structure.ThisExpression"));
    SNode type = convertTypeReference(x.qualification);
    if (!(SNodeOperations.isInstanceOf(type, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")))) {
      throw new JavaParseException("Type should be class in qualified this reference");
    }
    SReference sref = adjustClassReference(SNodeOperations.cast(type, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")), thisRef, "classConcept");
    thisRef.setReference(sref.getRole(), sref);
    return thisRef;
  }
  /*package*/ SNode convertExpression(SingleNameReference x) {
    SNode varRef = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference"));
    SReference sref = new DynamicReference("variableDeclaration", varRef, null, new String(x.token));
    varRef.setReference(sref.getRole(), sref);
    return varRef;
  }
  /*package*/ SNode convertExpression(QualifiedNameReference x) {
    String[] tokens = new String[x.tokens.length];
    if (tokens.length == 0) {
      return null;
    }

    SNode unkName = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x759937a5973279b7L, "jetbrains.mps.baseLanguage.structure.UnknownNameRef"));
    StringBuilder sb = new StringBuilder();

    for (int i = 0; i < tokens.length; i++) {
      sb.append(x.tokens[i]);
      sb.append('.');
    }
    sb.deleteCharAt(sb.length() - 1);

    SPropertyOperations.set(unkName, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x5a98df4004080866L, 0x1996ec29712bdd92L, "tokens"), sb.toString());
    return unkName;
  }

  /*package*/ SNode convertExpression(MessageSend x) throws JavaParseException {
    // it's a method call 
    //  results in either LocalStaticMethodCall, LocalInstanceMethodCall, StaticMethodCall 
    //  or DotExpression with MethodCallOperation 

    String methodName = new String(x.selector);
    SNode result = null;
    SNode call = null;

    if (x.receiver instanceof ThisReference && ((ThisReference) x.receiver).isImplicitThis()) {
      // it's a local call, f() 


      SNode lmc = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x6c6b6a1e379f9404L, "jetbrains.mps.baseLanguage.structure.LocalMethodCall"));
      org.jetbrains.mps.openapi.model.SReference ref = new DynamicReference("baseMethodDeclaration", lmc, null, methodName);
      lmc.setReference("baseMethodDeclaration", ref);

      result = lmc;
      call = lmc;

    } else {
      // it's something.method(...) 
      // let's see if 'something' is SingleNameRef or QualifiedNameRef; if yes let's see if it's a class 
      // if either it's not a name ref or not a class then handle it just as some random expression 

      Expression receiver = x.receiver;

      if (receiver instanceof NameReference) {
        // handle this special case 

        SNode unkDotCall = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x245faa02186fc7b5L, "jetbrains.mps.baseLanguage.structure.UnknownDotCall"));
        SPropertyOperations.set(unkDotCall, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x245faa02186fc7b5L, 0x439f6403036ad2f4L, "callee"), methodName);

        String[] tokens;

        if (x.receiver instanceof SingleNameReference) {
          tokens = new String[1];
          tokens[0] = new String(((SingleNameReference) x.receiver).token);

        } else if (x.receiver instanceof QualifiedNameReference) {
          QualifiedNameReference nameRef = ((QualifiedNameReference) x.receiver);
          tokens = new String[nameRef.tokens.length];
          for (int i = 0; i < tokens.length; i++) {
            tokens[i] = new String(nameRef.tokens[i]);
          }

        } else {
          // TODO report error 
          return null;
        }

        StringBuilder sb = new StringBuilder();
        for (String tok : tokens) {
          sb.append(tok);
          sb.append('.');
        }
        sb.deleteCharAt(sb.length() - 1);

        SPropertyOperations.set(unkDotCall, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x5a98df4004080866L, 0x1996ec29712bdd92L, "tokens"), sb.toString());

        result = unkDotCall;
        call = unkDotCall;

      } else if (x.receiver instanceof SuperReference) {
        SNode smc = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf9d78b55aaL, "jetbrains.mps.baseLanguage.structure.SuperMethodCall"));
        org.jetbrains.mps.openapi.model.SReference ref = new DynamicReference("baseMethodDeclaration", smc, null, methodName);
        smc.setReference(ref.getRole(), ref);

        result = smc;
        call = smc;

      } else {
        // we can already know that it should be an InstanceMethodCall 

        SNode dotExpr = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"));
        SLinkOperations.setTarget(dotExpr, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand"), convertExpressionWrap(x.receiver));

        SNode instCall = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation"));
        SLinkOperations.setTarget(dotExpr, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation"), instCall);

        org.jetbrains.mps.openapi.model.SReference sref = new DynamicReference("baseMethodDeclaration", instCall, null, methodName);
        instCall.setReference(sref.getRole(), sref);

        result = dotExpr;
        call = instCall;
      }
    }

    if ((call != null)) {
      addCallArgs(call, x.arguments);
      addTypeArgs(x.typeArguments, SLinkOperations.getChildren(call, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0x4500f31eb02a7788L, "typeArgument")));
    }
    return result;
  }
  /*package*/ SNode convertExpression(AllocationExpression x) throws JavaParseException {
    if (x instanceof QualifiedAllocationExpression) {
      return convertExpression((QualifiedAllocationExpression) x);
    } else {

      SNode unkNew = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x2dda7700ec3ae154L, "jetbrains.mps.baseLanguage.structure.UnknownNew"));
      addCallArgs(unkNew, x.arguments);
      addTypeArgs(typeArguments(x.type), SLinkOperations.getChildren(unkNew, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0x4500f31eb02a7788L, "typeArgument")));
      SPropertyOperations.set(unkNew, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x2dda7700ec3ae154L, 0x2dda7700ec3bb537L, "className"), typeName(x.type));

      return unkNew;
    }

  }
  /*package*/ SNode convertExpression(ClassLiteralAccess x) throws JavaParseException {
    SNode argType = convertTypeReference(x.type);

    if (SNodeOperations.isInstanceOf(argType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType"))) {
      SNode result = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x103fb730c14L, "jetbrains.mps.baseLanguage.structure.ClassifierClassExpression"));
      SReference sref = adjustClassReference(SNodeOperations.cast(argType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")), result, "classifier");
      result.setReference(sref.getRole(), sref);
      return result;

    } else if (SNodeOperations.isInstanceOf(argType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
      SNode result = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x115f7830a32a65e7L, "jetbrains.mps.baseLanguage.structure.ArrayClassExpression"));
      SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x115f7830a32a65e7L, 0x115f7830a32a65e8L, "arrayType"), argType);
      return result;
    } else if (SNodeOperations.isInstanceOf(argType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10f0ad8bde4L, "jetbrains.mps.baseLanguage.structure.PrimitiveType"))) {
      SNode result = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x3f57ea36bd70a4e1L, "jetbrains.mps.baseLanguage.structure.PrimitiveClassExpression"));
      SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x3f57ea36bd70a4e1L, 0x3f57ea36bd70a4e2L, "primitiveType"), argType);
      return result;
    } else {
      throw new JavaParseException("Type in class literal access is expected to be classifier or array type");
    }
  }
  /*package*/ SNode convertExpression(UnaryExpression x) throws JavaParseException {
    int operator = ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT);
    switch (operator) {
      case OperatorIds.MINUS:
        SNode unaryMinus = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x6fea7de6103549b1L, "jetbrains.mps.baseLanguage.structure.UnaryMinus"));
        SLinkOperations.setTarget(unaryMinus, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x120a4c1f269L, 0x120a4c433a6L, "expression"), convertExpressionWrap(x.expression));
        return unaryMinus;
      case OperatorIds.NOT:
        SNode notExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbcf6bd10dL, "jetbrains.mps.baseLanguage.structure.NotExpression"));
        SLinkOperations.setTarget(notExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbcf6bd10dL, 0xfbcf6c30a4L, "expression"), convertExpressionWrap(x.expression));
        return notExpression;
      case OperatorIds.PLUS:
        return convertExpressionWrap(x.expression);
      case OperatorIds.TWIDDLE:
        SNode twiddle = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11d6d026f5fL, "jetbrains.mps.baseLanguage.structure.BitwiseNotExpression"));
        SLinkOperations.setTarget(twiddle, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11d6d026f5fL, 0x11d6d026f62L, "expression"), convertExpressionWrap(x.expression));
        return twiddle;
      default:
        throw new JavaParseException("Unexpected operator for unary expression");
    }
  }
  /*package*/ SNode convertExpression(ConditionalExpression x) throws JavaParseException {
    SNode ifTest = convertExpressionWrap(x.condition);
    SNode thenExpr = convertExpressionWrap(x.valueIfTrue);
    SNode elseExpr = convertExpressionWrap(x.valueIfFalse);
    SNode tOp = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef01239c9L, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression"));
    SLinkOperations.setTarget(tOp, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef01239c9L, 0x10ef012826fL, "condition"), ifTest);
    SLinkOperations.setTarget(tOp, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef01239c9L, 0x10ef012a1c0L, "ifTrue"), thenExpr);
    SLinkOperations.setTarget(tOp, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef01239c9L, 0x10ef012cedcL, "ifFalse"), elseExpr);
    return tOp;
  }
  /*package*/ SNode convertExpression(EqualExpression x) throws JavaParseException {
    SNode op;
    switch ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) {
      case OperatorIds.EQUAL_EQUAL:
        op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b210L, "jetbrains.mps.baseLanguage.structure.EqualsExpression"));
        break;
      case OperatorIds.NOT_EQUAL:
        op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf9e20e303fL, "jetbrains.mps.baseLanguage.structure.NotEqualsExpression"));
        break;
      default:
        throw new JavaParseException("Unexpected operator for EqualExpression");
    }
    return convertBinaryOperation(x.left, x.right, op);
  }
  /*package*/ SNode convertExpression(InstanceOfExpression x) throws JavaParseException {
    SNode expr = convertExpressionWrap(x.expression);
    SNode testType = convertTypeReference(x.type);
    SNode instanceOfExpression = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbff03700L, "jetbrains.mps.baseLanguage.structure.InstanceOfExpression"));
    SLinkOperations.setTarget(instanceOfExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbff03700L, 0xfbbff06218L, "leftExpression"), expr);
    SLinkOperations.setTarget(instanceOfExpression, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbff03700L, 0xfbbff06219L, "classType"), testType);
    return instanceOfExpression;
  }
  /*package*/ SNode convertExpression(PostfixExpression x) throws JavaParseException {
    SNode op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11aded05fe6L, "jetbrains.mps.baseLanguage.structure.PostfixDecrementExpression"));
        break;
      case OperatorIds.PLUS:
        op = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11adecdb4f0L, "jetbrains.mps.baseLanguage.structure.PostfixIncrementExpression"));
        break;
      default:
        throw new JavaParseException("Unexpected postfix operator");
    }
    SLinkOperations.setTarget(op, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x120a4c1f269L, 0x120a4c433a6L, "expression"), convertExpressionWrap(x.lhs));
    return op;
  }
  /*package*/ SNode convertExpression(FieldReference x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"));
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand"), convertExpressionWrap(x.receiver));
    SNode fieldRef = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation"));
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation"), fieldRef);
    SReference sref = new DynamicReference("fieldDeclaration", fieldRef, null, new String(x.token));
    fieldRef.setReference(sref.getRole(), sref);
    return result;
  }
  /*package*/ SNode convertExpression(QualifiedAllocationExpression x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ab8473cc5L, "jetbrains.mps.baseLanguage.structure.GenericNewExpression"));
    SNode create = null;
    if (x.anonymousType != null) {
      SNode anonCreate = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1133e3b449aL, "jetbrains.mps.baseLanguage.structure.AnonymousClassCreator"));
      create = anonCreate;
      SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ab8473cc5L, 0x10ab847b486L, "creator"), anonCreate);
      SNode cls = SNodeOperations.cast(convertTypeDecl(x.anonymousType), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass"));
      SLinkOperations.setTarget(anonCreate, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1133e3b449aL, 0x1133e3b8b49L, "cls"), cls);
      addReference(x.type, cls, "classifier");
      addCallArgs(cls, x.arguments);
      addTypeArgs(typeArguments(x.type), SLinkOperations.getChildren(cls, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, 0x117ac45a693L, "typeParameter")));
    } else {
      // TODO what is enclosing instance? handle it 
      if (x.enclosingInstance() == null) {
        return convertExpression((AllocationExpression) x);
      }
    }

    return result;
  }
  /*package*/ SNode convertExpression(Literal x) {
    if (x instanceof NullLiteral) {
      return convertExpression((NullLiteral) x);
    } else {
      x.computeConstant();
      if (x.constant == null) {
        return null;
      }
      if (x.constant != Constant.NotAConstant) {
        return convertConstant(x.constant, new String(x.source()));
      } else if (x instanceof NullLiteral) {
        return SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940cd6167L, "jetbrains.mps.baseLanguage.structure.NullLiteral"));
      } else {
        // import token as string constant even if it was an error in literal 
        return _quotation_createNode_do26wr_a1a0c0pb(NameUtil.escapeString(new String(((Literal) x).source())));
      }
    }

  }


  public int addReference(TypeReference typeRef, SNode source, String role) {
    if (typeRef instanceof QualifiedTypeReference) {
      return addReference((QualifiedTypeReference) typeRef, source, role);
    } else if (typeRef instanceof SingleTypeReference) {
      return addReference((SingleTypeReference) typeRef, source, role);
    } else {
      LOG.error("Unexpected kind of type reference: " + typeRef.getClass().getName());
      return 0;
    }

  }
  public int addReference(SingleTypeReference typeRef, SNode source, String role) {
    org.jetbrains.mps.openapi.model.SReference ref = new DynamicReference(role, source, null, new String(typeRef.token));
    source.setReference(role, ref);
    return 1;
  }
  public int addReference(QualifiedTypeReference typeRef, SNode source, String role) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < typeRef.tokens.length; i++) {
      if (i > 0) {
        sb.append(".");
      }
      sb.append(new String(typeRef.tokens[i]));
    }
    String qname = sb.toString();

    org.jetbrains.mps.openapi.model.SReference ref = new DynamicReference(role, source, null, qname);
    source.setReference(role, ref);
    return 2;
  }

  @Override
  protected ASTConverterWithExpressions withNewState(ASTConverter.State state) {
    return new ASTConverterWithExpressions.ASTConverterExprWithState(this, state);
  }
  private class ASTConverterExprWithState extends ASTConverterWithExpressions {
    private ASTConverter.State myState;
    private ASTConverterExprWithState(ASTConverterWithExpressions base, ASTConverter.State state) {
      super(base);
      myState = state;
    }
    @Override
    public ASTConverter.State getState() {
      return myState;
    }
  }

  private static SNode _quotation_createNode_do26wr_a1a0c0pb(Object parameter_1) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode quotedNode_2 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93d565d10L, "jetbrains.mps.baseLanguage.structure.StringLiteral"), null, null, false);
    SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93d565d10L, 0xf93d565d11L, "value"), (String) parameter_1);
    return quotedNode_2;
  }
}
