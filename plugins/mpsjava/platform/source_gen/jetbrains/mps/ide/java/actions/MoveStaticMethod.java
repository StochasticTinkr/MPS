package jetbrains.mps.ide.java.actions;

/*Generated by MPS */

import jetbrains.mps.ide.platform.actions.core.MoveNodesAction;
import jetbrains.mps.smodel.structure.Extension;
import jetbrains.mps.project.MPSProject;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.ide.platform.refactoring.MoveNodeDialog;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.ide.platform.actions.core.MoveNodesUtil;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.ide.platform.actions.core.RefactoringParticipant;
import jetbrains.mps.lang.migration.runtime.base.RefactoringSession;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.MoveStaticMethodRefactoring;

public class MoveStaticMethod implements MoveNodesAction {

  public static class MoveStaticMethod_extension extends Extension.Default<MoveNodesAction> {
    public MoveStaticMethod_extension() {
      super("jetbrains.mps.ide.platform.MoveNodesActionEP");
    }
    public MoveNodesAction get() {
      return new MoveStaticMethod();
    }
  }

  public String getName() {
    return "Move Static Method";
  }
  public boolean isApplicable(MPSProject project, final List<SNode> nodes) {
    final Wrappers._boolean result = new Wrappers._boolean();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result.value = ListSequence.fromList(nodes).count() == 1 && SNodeOperations.isInstanceOf(ListSequence.fromList(nodes).first(), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"));
      }
    });
    return result.value;
  }
  public void execute(final MPSProject project, List<SNode> nodes) {
    final SNode target = SNodeOperations.cast(ListSequence.fromList(nodes).first(), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"));

    final SNode whereToMove = MoveNodeDialog.getSelectedObject(project.getProject(), target, new MoveNodeDialog.NodeFilter("Select class to move: refactoring can't be applied to selected node") {
      @Override
      public boolean check(SNode selectedObject, SNode nodeToMove, SModel modelOfSelectedNode) {
        return SNodeOperations.isInstanceOf(selectedObject, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")) && !(ListSequence.fromList(SNodeOperations.getNodeAncestors(nodeToMove, null, false)).contains(selectedObject));
      }
    });
    if (whereToMove == null) {
      return;
    }
    project.getRepository().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        MoveNodesUtil.moveTo(project, getName(), MapSequence.<MoveNodesUtil.NodeProcessor, List<SNode>>fromMapAndKeysArray(new HashMap<MoveNodesUtil.NodeProcessor, List<SNode>>(), new MoveNodesUtil.NodeCreatingProcessor(new MoveStaticField.NodeLocationClassifierMember(SNodeOperations.cast(whereToMove, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))), project) {
          @Override
          public List<SNode> getNodesToSearch(SNode nodeToMove) {
            return ListSequence.fromListAndArray(new ArrayList<SNode>(), nodeToMove);
          }
          @Override
          public void process(List<SNode> nodesRootsToMove, Map<SNode, RefactoringParticipant.KeepOldNodes> ifKeepOldNodes, RefactoringSession refactoringSession) {
            MoveNodesUtil.NodeCopyTracker copyMap = MoveNodesUtil.NodeCopyTracker.get(refactoringSession);
            copyMap.copyAndTrack(nodesRootsToMove);
            Map<SNode, SNode> oldMembersToClasses = MapSequence.fromMap(new HashMap<SNode, SNode>());
            for (SNode oldNode : ListSequence.fromList(nodesRootsToMove)) {
              MapSequence.fromMap(oldMembersToClasses).put(oldNode, SNodeOperations.getNodeAncestor(oldNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"), false, false));
            }
            for (SNode oldNode : ListSequence.fromList(nodesRootsToMove)) {
              SNode newNode = MapSequence.fromMap(copyMap.getCopyMap()).get(oldNode);
              if (!(SNodeOperations.isInstanceOf(newNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")))) {
                throw new IllegalStateException();
              }
              SNode originalClass = MapSequence.fromMap(oldMembersToClasses).get(oldNode);
              MoveStaticMethodRefactoring.replaceFields(newNode, originalClass);
              MoveStaticMethodRefactoring.replaceMethods(newNode, originalClass);
              if (MapSequence.fromMap(ifKeepOldNodes).get(oldNode) == RefactoringParticipant.KeepOldNodes.REMOVE) {
                SNodeOperations.detachNode(oldNode);
              }
              myNodeLocation.insertNode(myProject.getRepository(), newNode);
            }
          }
        }).withValues(ListSequence.fromListAndArray(new ArrayList<SNode>(), target)));
      }
    });
  }

}
