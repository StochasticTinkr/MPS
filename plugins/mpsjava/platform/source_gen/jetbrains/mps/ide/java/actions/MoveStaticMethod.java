package jetbrains.mps.ide.java.actions;

/*Generated by MPS */

import jetbrains.mps.ide.platform.actions.core.MoveNodesActionBase;
import jetbrains.mps.smodel.structure.Extension;
import jetbrains.mps.ide.platform.actions.core.MoveNodesAction;
import jetbrains.mps.project.MPSProject;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.ArrayList;
import jetbrains.mps.lang.migration.runtime.base.RefactoringSession;
import java.util.Map;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.MoveStaticMethodRefactoring;

public class MoveStaticMethod extends MoveNodesActionBase {

  public static class MoveStaticMethod_extension extends Extension.Default<MoveNodesAction> {
    public MoveStaticMethod_extension() {
      super("jetbrains.mps.ide.platform.MoveNodesAction");
    }
    public MoveNodesAction get() {
      return new MoveStaticMethod();
    }
  }

  public String getName() {
    return "Move Static Method";
  }
  public boolean isApplicable(MPSProject project, final List<SNode> nodes) {
    final Wrappers._boolean result = new Wrappers._boolean();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result.value = ListSequence.fromList(nodes).count() == 1 && SNodeOperations.isInstanceOf(ListSequence.fromList(nodes).first(), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"));
      }
    });
    return result.value;
  }
  public void execute(final MPSProject project, List<SNode> nodes) {
    final SNode target = SNodeOperations.cast(ListSequence.fromList(nodes).first(), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"));

    MoveStaticMethodExecutable executable = new MoveStaticMethodExecutable();
    final SNode whereToMove = executable.askDestination(project, target);
    if (whereToMove == null) {
      return;
    }
    project.getRepository().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        doMove(project, MapSequence.<MoveNodesActionBase.NodeProcessor, List<SNode>>fromMapAndKeysArray(new HashMap<MoveNodesActionBase.NodeProcessor, List<SNode>>(), new MoveNodesActionBase.NodeCreatingProcessor(new MoveStaticField.NodeLocationClassifierMember(SNodeOperations.cast(whereToMove, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))), project) {
          @Override
          public List<SNode> getNodesToSearch(SNode nodeToMove) {
            return ListSequence.fromListAndArray(new ArrayList<SNode>(), nodeToMove);
          }
          @Override
          public void process(List<SNode> nodesToMove, List<SNode> whichOfThemToRemove, RefactoringSession refactoringSession) {
            MoveNodesActionBase.CopyMapObject copyMap = MoveNodesActionBase.CopyMapObject.getCopyMap(refactoringSession);
            copyMap.copy(nodesToMove);
            Map<SNode, SNode> oldMembersToClasses = MapSequence.fromMap(new HashMap<SNode, SNode>());
            for (SNode oldNode : ListSequence.fromList(nodesToMove)) {
              MapSequence.fromMap(oldMembersToClasses).put(oldNode, SNodeOperations.getNodeAncestor(oldNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"), false, false));
            }
            for (SNode oldNode : ListSequence.fromList(whichOfThemToRemove)) {
              SNodeOperations.detachNode(oldNode);
            }
            for (SNode oldNode : ListSequence.fromList(nodesToMove)) {
              SNode newNode = MapSequence.fromMap(copyMap.getCopyMap()).get(oldNode);
              if (!(SNodeOperations.isInstanceOf(newNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")))) {
                throw new IllegalStateException();
              }
              SNode originalClass = MapSequence.fromMap(oldMembersToClasses).get(oldNode);
              MoveStaticMethodRefactoring.replaceFields(newNode, originalClass);
              MoveStaticMethodRefactoring.replaceMethods(newNode, originalClass);
              myNodeLocation.insertNode(myProject.getRepository(), newNode);
            }
          }
        }).withValues(ListSequence.fromListAndArray(new ArrayList<SNode>(), target)), null);
      }
    });
  }

}
