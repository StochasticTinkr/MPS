package jetbrains.mps.ide.java.platform.highlighters;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.EditorCheckerAdapter;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import com.intellij.openapi.util.Pair;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.smodel.event.SModelReplacedEvent;
import jetbrains.mps.nodeEditor.EditorMessage;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.typesystem.inference.ITypechecking;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.extapi.module.TransientSModule;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.event.SModelEventVisitor;
import jetbrains.mps.smodel.event.SModelEventVisitorAdapter;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.ide.ThreadUtils;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.search.MethodResolveUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.SNodePointer;

public class MethodDeclarationsFixer extends EditorCheckerAdapter {
  private static boolean DISABLED = false;
  private Set<SNodeReference> myCheckedMethodCalls = new HashSet<SNodeReference>();
  private Map<SNodeReference, Set<SNodeReference>> myMethodDeclsToCheckedMethodCalls = new HashMap<SNodeReference, Set<SNodeReference>>();
  private Map<Pair<String, String>, Set<SNodeReference>> myMethodConceptsAndNamesToCheckedMethodCalls = new HashMap<Pair<String, String>, Set<SNodeReference>>();
  private Map<SNodeReference, SNodeReference> myMethodCallsToSetDecls = new HashMap<SNodeReference, SNodeReference>();
  private boolean myCachesCleared = false;

  @Override
  public boolean hasDramaticalEvent(List<SModelEvent> list) {
    for (SModelEvent event : list) {
      if (event instanceof SModelReplacedEvent) {
        return true;
      }
    }
    return super.hasDramaticalEvent(list);
  }
  @Override
  protected Set<EditorMessage> createMessages(final SNode rootNode, final List<SModelEvent> events, final boolean wasCheckedOnce, final EditorContext editorContext) {
    return TypeContextManager.getInstance().runTypeCheckingComputation(((EditorComponent) editorContext.getEditorComponent()).getTypecheckingContextOwner(), rootNode, new ITypechecking.Computation<Set<EditorMessage>>() {
      @Override
      public Set<EditorMessage> compute(TypeCheckingContext p0) {
        return doCreateMessages(rootNode, events, wasCheckedOnce, editorContext);
      }
    });
  }
  public Set<EditorMessage> doCreateMessages(SNode rootNode, List<SModelEvent> events, boolean wasCheckedOnce, final EditorContext editorContext) {
    if (DISABLED) {
      return new HashSet<EditorMessage>();
    }
    SModel model = SNodeOperations.getModel(rootNode);
    if (!(model instanceof EditableSModel) || model.getModule() instanceof TransientSModule || jetbrains.mps.util.SNodeOperations.isModelDisposed(model)) {
      return new HashSet<EditorMessage>(0);
    }
    final Map<SNode, SNode> reResolvedTargets = new HashMap<SNode, SNode>();
    if (!(wasCheckedOnce) || myCachesCleared) {
      myCachesCleared = false;
      for (SNode methodCall : SNodeOperations.getNodeDescendants(rootNode, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, "jetbrains.mps.baseLanguage.structure.IMethodCall"), false, new SAbstractConcept[]{})) {
        testAndFixMethodCall(methodCall, reResolvedTargets);
      }
    } else {
      SModelEventVisitor visitor = new SModelEventVisitorAdapter() {
        @Override
        public void visitChildEvent(SModelChildEvent event) {
          SNode child = event.getChild();
          if (event.isAdded() && child.getModel() != null) {
            nodeAdded(child, reResolvedTargets);
          } else {
            nodeRemoved(child, event.getParent(), event.getModel(), reResolvedTargets);
          }
        }
        @Override
        public void visitReferenceEvent(SModelReferenceEvent event) {
          SReference reference = event.getReference();
          SNode sourceNode = reference.getSourceNode();
          if (SNodeOperations.isInstanceOf(sourceNode, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, "jetbrains.mps.baseLanguage.structure.IMethodCall")) && MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration").equals(reference.getLink())) {
            methodCallDeclarationChanged(SNodeOperations.cast(sourceNode, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, "jetbrains.mps.baseLanguage.structure.IMethodCall")), reResolvedTargets);
          }
        }
        @Override
        public void visitPropertyEvent(SModelPropertyEvent event) {
          SNode node = event.getNode();
          SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"));
          if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) && MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name").getName().equals(event.getPropertyName())) {
            methodDeclarationNameChanged(node, reResolvedTargets);
            methodDeclarationSignatureChanged(node, reResolvedTargets);
          }
        }
        @Override
        public void visitReplacedEvent(SModelReplacedEvent event) {
          clearCaches();
        }
      };
      for (SModelEvent event : events) {
        if (event.getAffectedRoot() != rootNode) {
          continue;
        }
        event.accept(visitor);
      }
    }
    if (!(reResolvedTargets.isEmpty()) && editorContext != null && editorContext.getRepository() != null) {
      ThreadUtils.runInUIThreadNoWait(new Runnable() {
        public void run() {
          final SRepository repo = editorContext.getRepository();
          repo.getModelAccess().executeUndoTransparentCommand(new Runnable() {
            public void run() {
              for (SNode methodCall : reResolvedTargets.keySet()) {
                SNode referent = reResolvedTargets.get(methodCall);
                if (referent != null && SNodeUtil.isAccessible(referent, repo)) {
                  SLinkOperations.setTarget(methodCall, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"), referent);
                }
              }
            }
          });
        }
      });
    }
    return new HashSet<EditorMessage>();
  }
  public void clearCaches() {
    myCheckedMethodCalls.clear();
    myMethodDeclsToCheckedMethodCalls.clear();
    myMethodConceptsAndNamesToCheckedMethodCalls.clear();
    myMethodCallsToSetDecls.clear();
    myCachesCleared = true;
  }
  public void testAndFixMethodCall(@NotNull SNode methodCallNode, Map<SNode, SNode> reResolvedTargets) {
    SNode baseMethodDeclaration = SLinkOperations.getTarget(methodCallNode, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
    String methodName = getMethodName(methodCallNode);

    Tuples._2<SNode, Boolean> resolveResult = MethodResolveUtil.resolveMethod(methodCallNode, methodName);
    SNode newTarget = resolveResult._0();
    boolean good = (boolean) resolveResult._1();

    if (newTarget != null) {
      if (baseMethodDeclaration == null || (good && newTarget != baseMethodDeclaration)) {
        reResolvedTargets.put(methodCallNode, newTarget);
      }
      SNodeReference methodCallPointer = SNodeOperations.getPointer(methodCallNode);
      SNodeReference newTargetPointer = SNodeOperations.getPointer(newTarget);
      myMethodCallsToSetDecls.put(methodCallPointer, newTargetPointer);
      myCheckedMethodCalls.add(methodCallPointer);
      Set<SNodeReference> nodeSet = myMethodDeclsToCheckedMethodCalls.get(newTargetPointer);
      if (nodeSet == null) {
        nodeSet = new HashSet<SNodeReference>();
        myMethodDeclsToCheckedMethodCalls.put(newTargetPointer, nodeSet);
      }
      nodeSet.add(methodCallPointer);
      Pair<String, String> key = new Pair<String, String>(newTarget.getConcept().getQualifiedName(), methodName);
      Set<SNodeReference> nodesByNameAndConcept = myMethodConceptsAndNamesToCheckedMethodCalls.get(key);
      if (nodesByNameAndConcept == null) {
        nodesByNameAndConcept = new HashSet<SNodeReference>();
        myMethodConceptsAndNamesToCheckedMethodCalls.put(key, nodesByNameAndConcept);
      }
      nodesByNameAndConcept.add(methodCallPointer);
    }
  }
  private String getMethodName(SNode methodCall) {
    SNode baseMethodDeclaration = SLinkOperations.getTarget(methodCall, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
    if (baseMethodDeclaration == null) {
      if (SLinkOperations.getTarget(SNodeOperations.as(methodCall, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, 0x1107e0fd2a0L, "classifier")) != null) {
        return SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.as(methodCall, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, 0x1107e0fd2a0L, "classifier")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"));
      } else {
        return SLinkOperations.getResolveInfo(SNodeOperations.getReference(methodCall, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration")));
      }
    } else {
      return SPropertyOperations.getString(baseMethodDeclaration, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"));
    }
  }
  private void methodDeclarationNameChanged(SNode method, Map<SNode, SNode> resolveTargets) {
    Set<SNodeReference> methodCallPointers = myMethodDeclsToCheckedMethodCalls.get(SNodeOperations.getPointer(method));
    for (SNode methodCall : Sequence.fromIterable(getMethodCalls(methodCallPointers))) {
      testAndFixMethodCall(methodCall, resolveTargets);
    }
  }
  private Iterable<SNode> getMethodCalls(Set<SNodeReference> methodCallPointers) {
    if (methodCallPointers == null) {
      return Sequence.fromIterable(Collections.<SNode>emptyList());
    }
    return SNodeOperations.ofConcept(SetSequence.fromSet(methodCallPointers).where(new IWhereFilter<SNodeReference>() {
      public boolean accept(SNodeReference it) {
        return it != null;
      }
    }).select(new ISelector<SNodeReference, SNode>() {
      public SNode select(SNodeReference it) {
        return it.resolve(MPSModuleRepository.getInstance());
      }
    }), MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, "jetbrains.mps.baseLanguage.structure.IMethodCall"));
  }
  private void methodDeclarationSignatureChanged(SNode method, Map<SNode, SNode> resolveTargets) {
    Set<SNodeReference> methodCallPointers = myMethodConceptsAndNamesToCheckedMethodCalls.get(new Pair<String, String>(method.getConcept().getQualifiedName(), method.getName()));
    for (SNode methodCall : Sequence.fromIterable(getMethodCalls(methodCallPointers))) {
      testAndFixMethodCall(methodCall, resolveTargets);
    }
  }
  private void methodCallDeclarationChanged(SNode methodCall, Map<SNode, SNode> resolveTargets) {
    SNodeReference methodCallPointer = new SNodePointer(methodCall);
    if (myCheckedMethodCalls.contains(methodCallPointer) && SLinkOperations.getTarget(methodCall, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration")) == myMethodCallsToSetDecls.get(methodCallPointer).resolve(MPSModuleRepository.getInstance())) {
      return;
    }
    testAndFixMethodCall(methodCall, resolveTargets);
  }
  private void nodeAdded(SNode child, Map<SNode, SNode> resolveTargets) {
    for (SNode methodCall : SNodeOperations.getNodeDescendants(child, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, "jetbrains.mps.baseLanguage.structure.IMethodCall"), true, new SAbstractConcept[]{})) {
      testAndFixMethodCall(methodCall, resolveTargets);
    }
    SNode parent = SNodeOperations.getParent(child);
    SNodeReference parentPointer = new SNodePointer(parent);
    if (myCheckedMethodCalls.contains(parentPointer)) {
      SNode p = SNodeOperations.cast(parent, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, "jetbrains.mps.baseLanguage.structure.IMethodCall"));
      testAndFixMethodCall(p, resolveTargets);
    }
    SNode formalParam = SNodeOperations.getNodeAncestor(child, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e94L, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration"), true, false);
    if ((SNodeOperations.getParent(formalParam) != null)) {
      methodDeclarationSignatureChanged(SNodeOperations.getParent(formalParam), resolveTargets);
    }
  }
  private void nodeRemoved(SNode child, SNode formerParent, SModel m, Map<SNode, SNode> resolveTargets) {
    if (myCheckedMethodCalls.contains(new SNodePointer(m.getReference(), formerParent.getNodeId()))) {
      testAndFixMethodCall(SNodeOperations.cast(formerParent, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, "jetbrains.mps.baseLanguage.structure.IMethodCall")), resolveTargets);
    }
    if (SNodeOperations.isInstanceOf(child, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e94L, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration"))) {
      methodDeclarationSignatureChanged(formerParent, resolveTargets);
    } else {
      SNode formalParam = SNodeOperations.getNodeAncestor(formerParent, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e94L, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration"), true, false);
      if ((SNodeOperations.getParent(formalParam) != null)) {
        methodDeclarationSignatureChanged(SNodeOperations.getParent(formalParam), resolveTargets);
      }
    }
  }
  @Override
  public void clear(SNode node, EditorComponent editor) {
    clearCaches();
  }
}
