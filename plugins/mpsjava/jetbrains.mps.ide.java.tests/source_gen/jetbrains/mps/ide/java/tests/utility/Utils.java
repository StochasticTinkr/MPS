package jetbrains.mps.ide.java.tests.utility;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.text.TextGeneratorEngine;
import jetbrains.mps.ide.java.newparser.JavaParser;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.java.newparser.FeatureKind;
import java.util.List;
import junit.framework.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.extapi.model.SModelBase;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.test.matcher.NodeDifference;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.util.Computable;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.ide.java.newparser.JavaParseException;
import jetbrains.mps.ide.java.sourceStubs.JavaSourceStubModelRoot;
import jetbrains.mps.extapi.module.SModuleBase;
import java.util.Iterator;
import java.util.ArrayList;
import jetbrains.mps.project.Project;
import jetbrains.mps.util.FileUtil;
import org.jetbrains.mps.openapi.persistence.Memento;
import jetbrains.mps.persistence.MementoImpl;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import jetbrains.mps.project.structure.model.ModelRootDescriptor;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import java.util.Collections;
import jetbrains.mps.ide.java.newparser.DirParser;
import jetbrains.mps.vfs.FileSystem;
import java.io.IOException;
import jetbrains.mps.persistence.java.library.JavaClassStubsModelRoot;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.behavior.Classifier__BehaviorDescriptor;

public class Utils {
  private final SRepository myRepo;
  public Utils(SRepository repository) {
    myRepo = repository;
  }
  private static SModule getModule() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("c3786d2b-aba2-45e5-8de0-1124fd14259b(jetbrains.mps.ide.java.tests)"));
  }
  public static String generateCode(SNode node) {
    return TextGeneratorEngine.generateText(node);
  }

  public static void checkStringStubs(String code, SNode expected) {
    checkString(code, expected, true);
  }

  public static void checkString(String code, final SNode expected, boolean onlyStubs) {
    try {
      JavaParser parser = new JavaParser();
      SModel mdl;
      mdl = new ModuleRepositoryFacade(SNodeOperations.getModel(expected).getRepository()).getModelByName("jetbrains.mps.ide.java.testMaterial.placeholder");
      FeatureKind howToParse = (onlyStubs ? FeatureKind.CLASS_STUB : FeatureKind.CLASS);
      List<SNode> res = parser.parse(code, howToParse, null, true).getNodes();
      Assert.assertSame(ListSequence.fromList(res).count(), 1);

      final SNode result = SNodeOperations.cast(res.get(0), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"));
      SModelOperations.addRootNode(mdl, result);
      if (mdl instanceof SModelBase && SNodeOperations.getModel(expected) instanceof SModelBase) {
        for (SLanguage langref : ((SModelBase) SNodeOperations.getModel(expected)).importedLanguageIds()) {
          ((SModelBase) mdl).addLanguage(langref);
        }
      }

      if (onlyStubs) {
        NodePatcher.removeStatements(expected);
      } else {
        JavaParser.tryResolveUnknowns(Sequence.<SNode>singleton(result));
      }
      NodePatcher.fixNonStatic(expected);
      NodePatcher.fixNonStatic(result);
      NodePatcher.copyImportAttrs(result, expected);

      final Map<SNode, SNode> nodeMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      buildClassifierNodeMap(result, expected, nodeMap);
      NodeDifference diff = TypeContextManager.getInstance().runResolveAction(new Computable<NodeDifference>() {
        public NodeDifference compute() {
          return new NodesMatcher(nodeMap).match(result, expected);
        }
      });

      Assert.assertEquals(null, diff);

    } catch (JavaParseException e) {
      throw new RuntimeException(e);
    }
  }

  public static void checkFile(String path, SNode expected) {
    JavaSourceStubModelRoot mr = new JavaSourceStubModelRoot();
    mr.setModule((SModuleBase) getModule());
    mr.setContentRoot(path);
    mr.addFile(JavaSourceStubModelRoot.SOURCE_ROOTS, path);

    Iterator<SModel> models = mr.loadModels().iterator();
    Assert.assertTrue("No models returned from model root", models.hasNext());

    Iterator<? extends SNode> roots = models.next().getRootNodes().iterator();
    Assert.assertTrue("The model has no roots", roots.hasNext());
    SNode result = SNodeOperations.cast((roots.next()), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"));
    result = SNodeOperations.copyNode(result);
    expected = SNodeOperations.copyNode(expected);

    NodePatcher.removeStatements(expected);
    NodePatcher.fixNonStatic(expected);
    NodePatcher.fixNonStatic(result);
    NodePatcher.copyImportAttrs(result, expected);

    mr.dispose();

    {
      List<SNode> nodesBefore = ListSequence.fromListAndArray(new ArrayList<SNode>(), expected);
      List<SNode> nodesAfter = ListSequence.fromListAndArray(new ArrayList<SNode>(), result);
      Assert.assertNull("The nodes '" + nodesBefore + "' and '" + nodesAfter + "' do not match!", new NodesMatcher().match(nodesBefore, nodesAfter));
    }

  }

  public static void checkStubModel(String dirPath, SModel expected) {
    checkStubModels(dirPath, ListSequence.fromListAndArray(new ArrayList<SModel>(), expected));
  }

  public static void checkStubModels(String dirPath, List<SModel> expected) {
    JavaSourceStubModelRoot mr = new JavaSourceStubModelRoot();
    mr.setModule((SModuleBase) getModule());
    mr.setContentRoot(dirPath);
    mr.addFile(JavaSourceStubModelRoot.SOURCE_ROOTS, dirPath);
    mr.attach();

    List<SModel> models = ListSequence.fromList(new ArrayList<SModel>());
    for (SModel md : Sequence.fromIterable(mr.getModels())) {
      ListSequence.fromList(models).addElement(md);
    }

    // normalizing 
    for (SModel m : ListSequence.fromList(expected)) {
      for (SNode root : ListSequence.fromList(SModelOperations.roots(m, null))) {
        NodePatcher.removeStatements(SNodeOperations.cast(root, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
        NodePatcher.fixNonStatic(SNodeOperations.cast(root, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
      }
    }
    compare(models, expected);
  }
  public static void checkSourceModel(Project project, String dirPath, SModel expected) {
    try {
      SModule testMaterials = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("49166c31-952a-46f6-8970-ea45964379d0(jetbrains.mps.ide.java.testMaterial)"));

      String tmpDir = FileUtil.createTmpDir().getAbsolutePath();

      Memento mem = new MementoImpl();
      mem.put("contentPath", tmpDir);
      mem.put("type", PersistenceRegistry.DEFAULT_MODEL_ROOT);

      Memento memIn = mem.createChild(FileBasedModelRoot.SOURCE_ROOTS);
      memIn.put("path", tmpDir);

      ModelRootDescriptor mrDesc = new ModelRootDescriptor(PersistenceRegistry.DEFAULT_MODEL_ROOT, mem);

      TempModuleOptions tempModOpts = TempModuleOptions.forNewModule(Collections.singleton(mrDesc), false, true);
      testMaterials = tempModOpts.createModule();

      DirParser dirParser = new DirParser(testMaterials, project.getModelAccess(), FileSystem.getInstance().getFileByPath(dirPath));

      dirParser.parseDirs();

      List<SModel> parsedModels = dirParser.getAffectedModels();
      assert ListSequence.fromList(parsedModels).count() == 1;
      final SModel resultModel = ListSequence.fromList(parsedModels).getElement(0);

      for (SNode root : ListSequence.fromList(SModelOperations.roots(expected, null))) {
        NodePatcher.fixNonStatic(SNodeOperations.cast(root, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
      }

      Map<SNode, SNode> referentMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      buildModelNodeMap(resultModel, expected, referentMap);

      boolean wereErrors = compare2models(resultModel, expected, referentMap);
      Assert.assertFalse(wereErrors);

    } catch (JavaParseException e) {
      throw new RuntimeException(e);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }
  public void compareBinAndSrcStubs(String binPath, String sourcePath) {
    JavaSourceStubModelRoot src2 = new JavaSourceStubModelRoot();

    // just 2 distinct modules 
    SModule mod1 = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("c3786d2b-aba2-45e5-8de0-1124fd14259b(jetbrains.mps.ide.java.tests)"));
    SModule mod2 = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("49166c31-952a-46f6-8970-ea45964379d0(jetbrains.mps.ide.java.testMaterial)"));

    List<SModel> binModels = ListSequence.fromList(new ArrayList<SModel>());
    JavaClassStubsModelRoot binSRoot = new JavaClassStubsModelRoot();
    binSRoot.setModule((SModuleBase) mod1);
    binSRoot.setContentRoot(binPath);
    binSRoot.addFile(JavaClassStubsModelRoot.SOURCE_ROOTS, binPath);
    Iterable<SModel> binStubModels = binSRoot.loadModels();
    for (SModel md : Sequence.fromIterable(binStubModels)) {
      SModel m = md;
      ListSequence.fromList(binModels).addElement(m);

      for (SNode binRoot : ListSequence.fromList(SModelOperations.roots(m, null))) {
        NodePatcher.fixNonStatic(binRoot);
        NodePatcher.removeConstructorName(binRoot);
        NodePatcher.removeExtendsObject(binRoot);
        NodePatcher.removeInitializers(binRoot);

        NodePatcher.sortNestedClass(SNodeOperations.cast(binRoot, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));

        // FIXME should be fixed in java source stubs 
        NodePatcher.removeStatements(binRoot);
      }
    }

    Iterable<SModel> srcModels;
    List<SModel> srcModelsX = ListSequence.fromList(new ArrayList<SModel>());

    src2.setModule((SModuleBase) mod2);
    src2.setContentRoot(sourcePath);
    src2.addFile(JavaSourceStubModelRoot.SOURCE_ROOTS, sourcePath);
    srcModels = src2.loadModels();

    for (SModel m : Sequence.fromIterable(srcModels)) {

      SModel zzz = m;
      ListSequence.fromList(srcModelsX).addElement(zzz);

      for (SNode srcRoot : ListSequence.fromList(SModelOperations.roots(zzz, null))) {
        NodePatcher.fixNonStatic(srcRoot);
        NodePatcher.removeSourceLevelAnnotations(srcRoot, myRepo);

        NodePatcher.sortNestedClass(SNodeOperations.cast(srcRoot, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
      }
    }

    compare(binModels, srcModelsX);
  }
  public static void compare(Iterable<SModel> leftModels, Iterable<SModel> rightModels) {
    Assert.assertSame("Different number of models: " + Sequence.fromIterable(leftModels).count() + " and " + Sequence.fromIterable(rightModels).count(), Sequence.fromIterable(leftModels).count(), Sequence.fromIterable(rightModels).count());
    Map<String, SModel> leftModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : Sequence.fromIterable(leftModels)) {
      MapSequence.fromMap(leftModelMap).put(jetbrains.mps.util.SNodeOperations.getModelLongName(m), m);
    }

    Map<String, SModel> rightModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : Sequence.fromIterable(rightModels)) {
      MapSequence.fromMap(rightModelMap).put(jetbrains.mps.util.SNodeOperations.getModelLongName(m), m);
    }

    Assert.assertTrue(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet())) && SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())));

    // constructing the map of corresponding nodes 
    Map<SNode, SNode> classMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    for (String name : MapSequence.fromMap(leftModelMap).keySet()) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      buildModelNodeMap(binModel, srcModel, classMap);
    }


    boolean errors = false;

    for (String name : MapSequence.fromMap(leftModelMap).keySet()) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      errors = compare2models(binModel, srcModel, classMap) || errors;
    }

    Assert.assertFalse("Models differ", errors);
  }
  public static boolean compare2models(SModel left, SModel right, Map<SNode, SNode> nodeMap) {
    boolean wereErrors = false;
    List<SNode> binRoots = SModelOperations.roots(left, null);
    List<SNode> srcRoots = SModelOperations.roots(right, null);

    binRoots = ListSequence.fromList(binRoots).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"));
      }
    }, true).toListSequence();
    srcRoots = ListSequence.fromList(srcRoots).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"));
      }
    }, true).toListSequence();

    List<NodeDifference> diff = NodesMatcher.matchNodes(binRoots, srcRoots, nodeMap);
    if (diff != null) {
      wereErrors = true;
      System.out.println("Diff: " + diff);
    }
    return wereErrors;
  }
  public static void buildModelNodeMap(SModel left, SModel right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightRootIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightRoot : ListSequence.fromList(SModelOperations.roots(right, null))) {
      MapSequence.fromMap(rightRootIndex).put(SPropertyOperations.getString(SNodeOperations.cast(rightRoot, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11a3afa8c0dL, "jetbrains.mps.baseLanguage.structure.IValidIdentifier")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), rightRoot);
    }

    for (SNode leftRoot : ListSequence.fromList(SModelOperations.roots(left, null))) {
      SNode rightBrother = MapSequence.fromMap(rightRootIndex).get(SPropertyOperations.getString(SNodeOperations.cast(leftRoot, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11a3afa8c0dL, "jetbrains.mps.baseLanguage.structure.IValidIdentifier")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
      if ((rightBrother != null)) {
        NodePatcher.copyImportAttrs(leftRoot, rightBrother);
      }
      buildClassifierNodeMap(SNodeOperations.cast(leftRoot, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), SNodeOperations.cast(rightBrother, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), nodeMap);
    }
  }
  public static void buildClassifierNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    // handling this class and nested classes 
    Map<String, SNode> rightNestedIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode cl : ListSequence.fromList(SNodeOperations.getNodeDescendants(right, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), true, new SAbstractConcept[]{}))) {
      MapSequence.fromMap(rightNestedIndex).put(SPropertyOperations.getString(cl, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), cl);
    }

    for (SNode cl : ListSequence.fromList(SNodeOperations.getNodeDescendants(left, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), true, new SAbstractConcept[]{}))) {
      SNode rightBrother = SNodeOperations.cast(MapSequence.fromMap(rightNestedIndex).get(SPropertyOperations.getString(cl, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"));


      Assert.assertNull(MapSequence.fromMap(nodeMap).get(cl));
      MapSequence.fromMap(nodeMap).put(cl, rightBrother);

      buildJustNodeMap(SLinkOperations.getChildren(left, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x102463b447aL, 0x102463bb98eL, "typeVariableDeclaration")), SLinkOperations.getChildren(right, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x102463b447aL, 0x102463bb98eL, "typeVariableDeclaration")), nodeMap);
      buildMethodsNodeMap(left, right, nodeMap);

    }

    if (SNodeOperations.isInstanceOf(left, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a69dc80cL, "jetbrains.mps.baseLanguage.structure.Annotation")) && SNodeOperations.isInstanceOf(right, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a69dc80cL, "jetbrains.mps.baseLanguage.structure.Annotation"))) {
      Map<String, SNode> rightMethodIndex = MapSequence.fromMap(new HashMap<String, SNode>());
      for (SNode mthd : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(right, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a69dc80cL, "jetbrains.mps.baseLanguage.structure.Annotation")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x101f2cc410bL, "method")))) {
        MapSequence.fromMap(rightMethodIndex).put(SPropertyOperations.getString(mthd, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), mthd);
      }

      for (SNode mthd : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(left, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a69dc80cL, "jetbrains.mps.baseLanguage.structure.Annotation")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x101f2cc410bL, "method")))) {
        Assert.assertNull(MapSequence.fromMap(nodeMap).get(mthd));
        MapSequence.fromMap(nodeMap).put(mthd, MapSequence.fromMap(rightMethodIndex).get(SPropertyOperations.getString(mthd, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))));
      }
    }
  }
  public static void buildMethodsNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    List<SNode> leftMethods = new ArrayList<SNode>();
    List<SNode> rightMethods = new ArrayList<SNode>();
    ListSequence.fromList(leftMethods).addSequence(Sequence.fromIterable(Classifier__BehaviorDescriptor.methods_id4_LVZ3pBKCn.invoke(left)));
    ListSequence.fromList(rightMethods).addSequence(Sequence.fromIterable(Classifier__BehaviorDescriptor.methods_id4_LVZ3pBKCn.invoke(right)));

    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightMthd : ListSequence.fromList(rightMethods)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightMthd, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), rightMthd);
    }

    for (SNode leftMthd : ListSequence.fromList(leftMethods)) {
      MapSequence.fromMap(nodeMap).put(leftMthd, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftMthd, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))));
      buildMethodBodyNodeMap(leftMthd, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftMthd, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))), nodeMap);
    }
  }
  public static void buildMethodBodyNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {

    //  type vars 
    buildJustNodeMap(SLinkOperations.getChildren(left, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x102463b447aL, 0x102463bb98eL, "typeVariableDeclaration")), SLinkOperations.getChildren(right, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x102463b447aL, 0x102463bb98eL, "typeVariableDeclaration")), nodeMap);

    // local vars and params 
    List<SNode> leftVars = new ArrayList<SNode>();
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SLinkOperations.getChildren(left, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, "parameter"))));
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(left, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7efL, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration"), false, new SAbstractConcept[]{MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass")})));

    List<SNode> rightVars = new ArrayList<SNode>();
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SLinkOperations.getChildren(right, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, "parameter"))));
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(right, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7efL, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration"), false, new SAbstractConcept[]{MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass")})));

    buildJustNodeMap(leftVars, rightVars, nodeMap);

    // anonymous classes and their insides 


  }
  public static void buildJustNodeMap(List<SNode> left, List<SNode> right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightNode : ListSequence.fromList(right)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightNode, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), rightNode);
    }

    for (SNode leftNode : ListSequence.fromList(left)) {
      MapSequence.fromMap(nodeMap).put(leftNode, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftNode, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))));
    }
  }
}
