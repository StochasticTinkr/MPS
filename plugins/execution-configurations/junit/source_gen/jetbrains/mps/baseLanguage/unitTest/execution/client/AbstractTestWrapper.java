package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.annotations.Nullable;
import java.util.function.Function;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Set;
import com.intellij.openapi.application.PathMacros;
import java.util.List;
import jetbrains.mps.baseLanguage.execution.api.JvmArgs;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.unitTest.execution.server.WithPlatformTestExecutor;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public abstract class AbstractTestWrapper<N extends SNode> implements ITestNodeWrapper<N> {
  @NotNull
  protected final SNodeReference myNodePointer;
  private final SRepository myRepo;
  private final boolean myRunsInProcess;
  protected final boolean myNeedsMPS;

  public AbstractTestWrapper(@NotNull N node) {
    this(node, false, false);
  }

  public AbstractTestWrapper(@NotNull N node, boolean runsInProcess, boolean needsMPS) {
    myNodePointer = new SNodePointer(node);
    myRepo = SNodeOperations.getModel(node).getRepository();
    myRunsInProcess = runsInProcess;
    myNeedsMPS = needsMPS;
  }

  /*package*/ SRepository getRepo() {
    return myRepo;
  }

  /**
   * 
   * @deprecated dangerous to use. Are you going to grab model access to deal with the node?
   */
  @Nullable
  @Override
  @Deprecated
  public N getNode() {
    return withNode(Function.<N>identity());
  }

  protected final <T> T withNode(final Function<N, T> fun) {
    return new ModelAccessHelper(myRepo).runReadAction(new Computable<T>() {
      public T compute() {
        N resolved = (N) myNodePointer.resolve(myRepo);
        return fun.apply(resolved);
      }
    });
  }

  @NotNull
  @Override
  public SNodeReference getNodePointer() {
    return myNodePointer;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    AbstractTestWrapper that = (AbstractTestWrapper) o;
    return myNodePointer.equals(that.myNodePointer);
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((this.myNodePointer != null ? this.myNodePointer.hashCode() : 0));
    return result;
  }

  @Nullable
  @Override
  public ITestNodeWrapper getTestCase() {
    return null;
  }

  @NotNull
  @Override
  public Iterable<ITestNodeWrapper> getTestMethods() {
    return ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
  }

  @NotNull
  @Override
  public TestParameters getTestRunParameters() {
    TestParameters rp = TestParameters.calcDefault(myRepo);
    if (myNeedsMPS) {
      // FIXME move macros into JUnit_Command, too 
      // FIXME Use same PathMacros instance 
      Set<String> userMacroNames = PathMacros.getInstance().getUserMacroNames();
      List<String> jvmArgsWithMacros = ListSequence.fromList(JvmArgs.getDefaultJvmArgs()).union(SetSequence.fromSet(userMacroNames).select(new ISelector<String, String>() {
        public String select(String key) {
          return String.format("-Dpath.macro.%s=\"%s\"", key, jetbrains.mps.project.PathMacros.getInstance().getValue(key));
        }
      })).toListSequence();
      return new TestParameters(WithPlatformTestExecutor.class, true, ListSequence.fromList(rp.getClassPath()).toListSequence(), jvmArgsWithMacros);
    } else {
      return rp;
    }
  }

  @Override
  public String getName() {
    return withNode(new Function<N, String>() {
      public String apply(N node) {
        if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept"))) {
          return SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"));
        } else if (node != null) {
          throw new UnsupportedOperationException("Should override getName for not INamedConcept: " + SNodeOperations.getConcept(node));
        }
        return null;
      }
    });
  }

  @Override
  public String getFqName() {
    ITestNodeWrapper testCase;
    if (isTestCase() || (testCase = getTestCase()) == null) {
      return getName();
    }
    return testCase.getFqName() + "." + getName();
  }

  @Override
  public String getCachedFqName() {
    return getFqName();
  }

  @Override
  public boolean canRunInProcess() {
    return myRunsInProcess;
  }

  /**
   * Check if class or any its superclass got MPSLaunch annotation, or extends/implements EnvironmentAware. 
   * If true, we assume the class needs running MPS instance to get executed.
   * Note, this method doesn't look into annotations on distinct test methods (therefore, we could use it for both JUnit3 and JUnit4 ClassConcepts)
   * 
   * @return true if a test represented by the class needs MPS instance
   */
  /*package*/ static boolean needsMPS(@Nullable SNode clazz) {
    while (clazz != null) {
      if (isAnnotatedToLaunch(clazz)) {
        return true;
      }
      // check java stub target only to avoid dependency from j.m.testbench module which is not part of MPS build (only via Testbench stub solution) 
      if (SNodeOperations.is(clazz, new SNodePointer("920eaa0e-ecca-46bc-bee7-4e5c59213dd6/java:jetbrains.mps.testbench(Testbench/)", "~EnvironmentAwareTestCase"))) {
        return true;
      }
      // check both java stub and regular node for EnvironmentAware as  j.m.tool.environment is part of MPS build (unlike j.m.testbench) 
      if (ListSequence.fromList(SLinkOperations.getChildren(clazz, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xff2ac0b419L, "implementedInterface"))).any(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.is(SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")), new SNodePointer("920eaa0e-ecca-46bc-bee7-4e5c59213dd6/java:jetbrains.mps.tool.environment(Testbench/)", "~EnvironmentAware")) || SNodeOperations.is(SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")), new SNodePointer("r:2876f1ee-0b45-4db5-8c09-0682cdee5c67(jetbrains.mps.tool.environment)", "8946405811982722281"));
        }
      })) {
        return true;
      }
      clazz = SNodeOperations.as(SLinkOperations.getTarget(SLinkOperations.getTarget(clazz, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
    }
    return false;
  }
  /*package*/ static boolean isAnnotatedToLaunch(SNode withAnnotation) {
    // MPSLaunch lives in j.m.testbench which is not part of MPS build, therefore check here for java stub only 
    return ListSequence.fromList(SLinkOperations.getChildren(withAnnotation, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a6be947aL, 0x114a6beb0bdL, "annotation"))).any(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.is(SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a6b4ccabL, 0x114a6b85d40L, "annotation")), new SNodePointer("920eaa0e-ecca-46bc-bee7-4e5c59213dd6/java:jetbrains.mps(Testbench/)", "~MPSLaunch"));
      }
    });
  }
}
