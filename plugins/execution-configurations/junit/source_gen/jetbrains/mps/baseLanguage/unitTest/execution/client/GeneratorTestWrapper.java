package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.core.behavior.INamedConcept__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.util.NameUtil;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NonNls;

/*package*/ class GeneratorTestWrapper extends AbstractTestWrapper<SNode> {
  private final String myQualifiedName;
  private final List<ITestNodeWrapper> myMethods;

  public GeneratorTestWrapper(@NotNull final SNode node) {
    super(node, true, true);
    myQualifiedName = INamedConcept__BehaviorDescriptor.getFqName_idhEwIO9y.invoke(node);
    myMethods = ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0x68015e26cc4d49dbL, 0x8715b643faea1769L, 0x7b1db36ecf092beL, 0x7b1db36ecf0d067L, "tests"))).select(new ISelector<SNode, GeneratorTestWrapper.TransformMatchStatementWrapper>() {
      public GeneratorTestWrapper.TransformMatchStatementWrapper select(SNode it) {
        final int i = ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0x68015e26cc4d49dbL, 0x8715b643faea1769L, 0x7b1db36ecf092beL, 0x7b1db36ecf0d067L, "tests"))).indexOf(it);
        // FIXME this is a hack. I don't want to introduce getMethodName into TestAssertion, and the only information passed during test  
        // execution is method name (JUnit's Request/Description), therefore I'm forced to use method name to match ITestNodeWrappers in UI. 
        // Perhaps, with JUnit5 there's a way to pass additional identification of a test so that we are not bound to generated method names. 
        final String methodName = "testTransformAndMatch" + i;
        return new GeneratorTestWrapper.TransformMatchStatementWrapper(GeneratorTestWrapper.this, it, methodName);
      }
    }).ofType(ITestNodeWrapper.class).toListSequence();
  }

  public boolean isTestCase() {
    return true;
  }

  @Override
  public String getName() {
    return NameUtil.shortNameFromLongName(myQualifiedName);
  }

  @Override
  public String getFqName() {
    return myQualifiedName;
  }

  @NotNull
  @Override
  public Iterable<ITestNodeWrapper> getTestMethods() {
    return myMethods;
  }

  private static class TransformMatchStatementWrapper extends AbstractTestWrapper<SNode> {
    private final GeneratorTestWrapper myTestCase;
    private String myName;

    /*package*/ TransformMatchStatementWrapper(GeneratorTestWrapper testCase, SNode testNode, String name) {
      super(testNode, true, true);
      myTestCase = testCase;
      myName = name;
    }

    @Override
    public boolean isTestCase() {
      return false;
    }

    @Nullable
    @Override
    public ITestNodeWrapper getTestCase() {
      return myTestCase;
    }

    @NonNls
    public String getName() {
      return myName;
    }
  }
}
