package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.annotations.Immutable;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import org.jetbrains.annotations.Nullable;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;

/**
 * Each test kind (represented by ITestWrapper) uses this class to pass process startup information 
 * to JUnit command. Of most importance is Java class to start and to receive set of arguments
 * that describe tests to run. Besides, there's extra classpath and jvmArgs that help the process to start.
 * 
 * Note, generally classpath shall include executorClass, though for executors coming with MPS ({@link jetbrains.mps.baseLanguage.unitTest.execution.server.DefaultTestExecutor },
 * {@link jetbrains.mps.baseLanguage.unitTest.execution.server.WithPlatformTestExecutor }, classpath is provided by JUnit command itself (it adds bl.unitTest.execution module 
 * into CP). If the story of TestParameters class evolves, we might want to move this information here (as in fact it's
 * TestParameters instantiating code that knows where executorClass resides). I'd combine this activity with a replacement
 * of Class of executorClass, as JUnit command needs nothing but its FQN, and the only place we use its Class nature is 
 * dubious #comprises method, that assumes subclassing is used for executors. node-ptr[ClassConcept] might be one 
 * (though not necessarily the best) alternative.
 * 
 * OTOH, if there's no use case for custom executorClass (which I believe to be true), the only information vital here
 * would be needsMPS, and JUnit command could pick proper executor itself. I feel it's much more appealing to provide
 * extra initialization code by means of unitTest language features (transformed into JUnit5 facilities), rather than 
 * allowing some class runner that has to fulfil odd contract (subclassing, argument processing).
 */
@Immutable
public final class TestParameters {
  private final Class<?> myExecutorClass;
  private final List<String> myClassPath;
  private final List<String> myAdditionalJvmArgs;
  private final boolean myNeedsMPS;

  public TestParameters(Class<?> executorClass, List<String> classPath, List<String> jvmArgs) {
    this(executorClass, false, classPath, jvmArgs);
  }

  public TestParameters(Class<?> executorClass, List<String> classPath) {
    this(executorClass, false, classPath, ListSequence.fromList(new LinkedList<String>()));
  }

  public TestParameters(Class<?> executorClass, boolean mpsRequired, @Nullable List<String> classPath, @Nullable List<String> jvmArgs) {
    myExecutorClass = executorClass;
    myClassPath = (classPath == null ? ListSequence.fromList(new ArrayList<String>()) : classPath);
    myAdditionalJvmArgs = (jvmArgs == null ? ListSequence.fromList(new ArrayList<String>()) : jvmArgs);
    myNeedsMPS = mpsRequired;
  }

  public Class<?> getExecutorClass() {
    return myExecutorClass;
  }

  public List<String> getJvmArgs() {
    return ListSequence.fromList(myAdditionalJvmArgs).asUnmodifiable();
  }

  public List<String> getClassPath() {
    return ListSequence.fromList(myClassPath).asUnmodifiable();
  }

  public boolean comprises(@NotNull TestParameters other) {
    if (this == other) {
      return true;
    }
    if (other.getExecutorClass().isAssignableFrom(getExecutorClass())) {
      if (!(myNeedsMPS) && other.myNeedsMPS) {
        // tests that don't need MPS can run from within MPS instance, but not other way round. 
        return false;
      }
      if (ListSequence.fromList(myClassPath).containsSequence(ListSequence.fromList(other.getClassPath()))) {
        if (ListSequence.fromList(myAdditionalJvmArgs).containsSequence(ListSequence.fromList(other.getJvmArgs()))) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * 
   * @return {@code true} if tests need a running MPS instance to get executed.
   */
  public boolean needsMPS() {
    return myNeedsMPS;
  }
}
