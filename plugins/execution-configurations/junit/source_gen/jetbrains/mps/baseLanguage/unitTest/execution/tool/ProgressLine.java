package jetbrains.mps.baseLanguage.unitTest.execution.tool;

/*Generated by MPS */

import javax.swing.JPanel;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunStateUpdateListener;
import com.intellij.openapi.progress.util.ColorProgressBar;
import javax.swing.JLabel;
import java.awt.GridLayout;
import java.awt.GridBagLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunData;
import com.intellij.execution.process.ProcessOutputTypes;
import javax.swing.SwingUtilities;
import com.intellij.execution.process.ProcessListener;
import com.intellij.execution.process.ProcessAdapter;
import com.intellij.execution.process.ProcessEvent;
import com.intellij.openapi.application.ApplicationManager;

public class ProgressLine extends JPanel implements TestRunStateUpdateListener {
  private final ColorProgressBar myProgressBar = new ColorProgressBar();
  private final JLabel myStateLabel = new JLabel("Starting...");
  private boolean myTestsBuilt = false;

  public ProgressLine() {
    super(new GridLayout(1, 2));
    add(myStateLabel);
    final JPanel progress = new JPanel(new GridBagLayout());
    progress.add(myProgressBar, new GridBagConstraints(0, 0, 0, 0, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(2, 0, 0, 2), 0, 0));
    myProgressBar.setColor(ColorProgressBar.GREEN);
    add(progress);
    myTestsBuilt = true;
  }

  @Override
  public void update(@NotNull final TestRunData data) {
    if (data.getAvailableText() != null || ProcessOutputTypes.SYSTEM.equals(data.getKey())) {
      return;
    }
    final int defectedTests = data.getFailedTests();
    final int totalTests = data.getTotalTests();
    final int completedTests = data.getCompletedTests();
    final String testName = data.getCurrentMethod();
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        updateProgressBar(data.isTerminated(), defectedTests, totalTests, completedTests);
        updateLabel(data.isTerminated(), defectedTests, totalTests, completedTests, testName);
      }
    });
  }

  public void init() {
  }

  private void updateProgressBar(boolean isTerminated, int defected, int total, int completed) {
    if (defected > 0) {
      myProgressBar.setColor(ColorProgressBar.RED);
    } else if (isTerminated && !((total == completed))) {
      myProgressBar.setColor(ColorProgressBar.YELLOW);
    }
    if (total != 0) {
      myProgressBar.setFraction(completed * 1. / total);
    }
  }

  private void updateLabel(boolean isTerminated, int defected, int total, int completed, String testName) {
    StringBuilder sb = new StringBuilder();
    boolean done = total == completed || testName == null;
    if (done) {
      sb.append(" Done: " + completed + " of " + total + " ");
      testName = "";
    } else if (isTerminated) {
      sb.append(" Terminated: " + completed + " of " + total + " ");
      testName = "";
    }
    if (defected > 0) {
      sb.append(" Failed: " + defected);
    }
    if (!(isTerminated) && !(done)) {
      sb.append(" Running: " + completed + " of " + total);
    }
    myStateLabel.setText(sb + "  " + testName);
  }

  public ProcessListener getProcessListener() {
    return new ProcessAdapter() {
      @Override
      public void processTerminated(ProcessEvent p0) {
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          @Override
          public void run() {
            if (!(myTestsBuilt) && myProgressBar.getFraction() == 0.0) {
              myProgressBar.setColor(ColorProgressBar.RED);
              myProgressBar.setFraction(1.0);
              myStateLabel.setText("Failed to start");
            }
          }
        });
      }
    };
  }
}
