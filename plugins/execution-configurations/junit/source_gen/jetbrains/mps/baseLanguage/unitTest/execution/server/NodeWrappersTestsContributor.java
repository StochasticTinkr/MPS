package jetbrains.mps.baseLanguage.unitTest.execution.server;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.testbench.junit.runners.PushEnvironmentRunnerBuilder;
import com.intellij.execution.runners.ExecutionUtil;
import com.intellij.openapi.wm.ToolWindowId;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.HyperlinkEvent;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.openapi.navigation.EditorNavigator;
import org.junit.runner.Request;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.NotNull;
import org.junit.runner.Description;
import jetbrains.mps.module.ModuleClassLoaderIsNullException;
import jetbrains.mps.module.ReloadableModule;
import jetbrains.mps.tool.environment.AbstractEnvironment;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.project.Project;
import java.io.File;
import jetbrains.mps.project.ProjectManager;
import org.junit.AssumptionViolatedException;
import jetbrains.mps.ide.ThreadUtils;
import java.io.IOException;

/**
 * Knows hot to launch TransformationTest with TestRunner suited for in-process test execution
 * XXX similar to ScriptTestContributor (for tests executed from command line), although unlike STE supports individual test methods.
 */
public class NodeWrappersTestsContributor implements TestsContributor {
  private final String myConfigurationName;
  private final Iterable<? extends ITestNodeWrapper> myTestNodes;
  private final MPSProject myProject;
  private final ClassLoaderManager myClassloaderManager;
  private final PushEnvironmentRunnerBuilder myRunnerBuilder;

  public NodeWrappersTestsContributor(MPSProject mpsProject, String runConfigurationName, Iterable<? extends ITestNodeWrapper> testNodes) {
    myConfigurationName = runConfigurationName;
    myTestNodes = testNodes;
    myProject = mpsProject;
    myClassloaderManager = mpsProject.getComponent(ClassLoaderManager.class);
    myRunnerBuilder = new PushEnvironmentRunnerBuilder(new NodeWrappersTestsContributor.InProcessEnvironment());
  }

  private void notifyByBaloon(String msg, final ITestNodeWrapper<?> wrapper, Exception e) {
    String msgWithLink = String.format(msg, "<a href=\"\">" + wrapper.getFqName() + "</a>");
    ExecutionUtil.handleExecutionError(myProject.getProject(), ToolWindowId.RUN, myConfigurationName, e, msgWithLink, new HyperlinkListener() {
      public void hyperlinkUpdate(HyperlinkEvent event) {
        if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
          SNodeReference nodeRef = wrapper.getNodePointer();
          new EditorNavigator(myProject).shallFocus(true).open(nodeRef);
        }
      }
    });
  }

  @Override
  public Iterable<Request> gatherTests() {
    return new ModelAccessHelper(myProject.getModelAccess()).runReadAction(new Computable<List<Request>>() {
      public List<Request> compute() {
        final List<Request> requestList = new ArrayList<Request>();
        InProcessExecutionFilter filter = new InProcessExecutionFilter();
        for (ITestNodeWrapper testNode : myTestNodes) {
          String fqName = testNode.getFqName();
          final SModule testModule = testNode.getTestNodeModule().resolve(myProject.getRepository());
          SNode testNodeSrc = testNode.getNodePointer().resolve(myProject.getRepository());
          SModel testModel = (testNodeSrc == null ? null : testNodeSrc.getModel());
          if (testNode.isTestCase()) {
            requestList.add(processTestCase(filter, testNode, testModule, testModel, fqName));
          } else {
            requestList.add(processTestMethod(filter, testNode, testModule, testModel, fqName));
          }
        }
        return requestList;
      }
    });
  }

  @NotNull
  private Request processTestCase(InProcessExecutionFilter filter, ITestNodeWrapper testNode, SModule testModule, SModel testModel, String fqName) {
    try {
      filter.check(testNode, testModel);
      return requestForTestClass(fqName, testModule);
    } catch (InProcessExecutionFilter.InProcessCheckException e) {
      notifyByBaloonCheckException(e, testNode);
      return createRequestForClass(fqName, e);
    } catch (ClassNotFoundException e) {
      notifyByBaloonCLNF(e, testNode);
      return createRequestForClass(fqName, e);
    } catch (Exception e) {
      return createRequestForClass(fqName, e);
    }
  }

  @NotNull
  private Request processTestMethod(InProcessExecutionFilter filter, ITestNodeWrapper testNode, SModule testModule, SModel testModel, String fqName) {
    int index = fqName.lastIndexOf('.');
    String testFqName = fqName.substring(0, index);
    String methodName = fqName.substring(index + 1);
    try {
      filter.check(testNode, testModel);
      final Request classRequest = requestForTestClass(testFqName, testModule);
      return classRequest.filterWith(Description.createTestDescription(testFqName, methodName));
    } catch (InProcessExecutionFilter.InProcessCheckException e) {
      notifyByBaloonCheckException(e, testNode);
      return createRequestForMethod(testFqName, methodName, e);
    } catch (ClassNotFoundException e) {
      notifyByBaloonCLNF(e, testNode);
      return createRequestForMethod(testFqName, methodName, e);
    } catch (Exception e) {
      return createRequestForMethod(testFqName, methodName, e);
    }
  }

  private void notifyByBaloonCLNF(ClassNotFoundException e, ITestNodeWrapper<?> testNode) {
    notifyByBaloon("The class of the test could not be found.<br>Please ensure that the test %s is built and deployed.", testNode, e);
  }

  private void notifyByBaloonCheckException(InProcessExecutionFilter.InProcessCheckException e, ITestNodeWrapper<?> testNode) {
    notifyByBaloon(e.getFormattedMsg(), testNode, e);
  }

  private Request createRequestForClass(String fqName, Exception e) {
    return Request.runner(new AssumptionFailedRunner(e, Description.createSuiteDescription(fqName)));
  }

  private Request createRequestForMethod(String testFqName, String methodName, Exception e) {
    return Request.runner(new AssumptionFailedRunner(e, Description.createTestDescription(testFqName, methodName)));
  }

  private Request requestForTestClass(String fqName, SModule module) throws ClassNotFoundException, ModuleClassLoaderIsNullException {
    final Class<?> aClass = loadTestClass(fqName, module);
    return Request.runner(myRunnerBuilder.safeRunnerForClass(aClass));
  }

  @NotNull
  private Class<?> loadTestClass(String fqName, SModule module) throws ClassNotFoundException, ModuleClassLoaderIsNullException {
    if (module instanceof ReloadableModule && myClassloaderManager.isLoadedByMPS(((ReloadableModule) module))) {
      return ((ReloadableModule) module).getOwnClass(fqName);
    } else {
      throw new ClassNotFoundException("Module's " + module + " classes are managed by MPS (try setting compileInMPS flag to true)");
    }
  }

  /**
   * Access existing runtime instance through Environment API. Looks up test projects among active, doesn't close any.
   */
  private static class InProcessEnvironment extends AbstractEnvironment {
    /*package*/ InProcessEnvironment() {
      super(ApplicationManager.getApplication().getComponent(MPSCoreComponents.class).getPlatform());
    }

    @NotNull
    @Override
    public Project openProject(@NotNull File projectFile) {
      for (Project project : ProjectManager.getInstance().getOpenedProjects()) {
        if (projectHasPath(project, projectFile)) {
          return project;
        }
      }
      // todo show balloon and ignore the tests 
      throw new AssumptionViolatedException(String.format("Test project '%s' is not opened. Aborted.", projectFile));
    }

    @Override
    public void closeProject(@NotNull Project project) {
      // no-op, do not allow to close project 
    }


    @Override
    public void flushAllEvents() {
      ThreadUtils.runInUIThreadAndWait(new Runnable() {
        public void run() {
        }
      });
    }

    private static boolean projectHasPath(Project project, File path) {
      File projectFile = project.getProjectFile();
      if (projectFile == null) {
        return false;
      }
      try {
        String projectPath = projectFile.getCanonicalPath();
        String testedPath = path.getCanonicalPath();
        return projectPath.equals(testedPath);
      } catch (IOException e) {
        e.printStackTrace();
      }
      return false;
    }

  }
}
