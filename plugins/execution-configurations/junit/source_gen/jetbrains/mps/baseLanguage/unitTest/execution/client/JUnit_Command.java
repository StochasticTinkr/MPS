package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.io.File;
import com.intellij.execution.process.ProcessHandler;
import java.util.List;
import jetbrains.mps.baseLanguage.execution.api.JavaRunParameters;
import com.intellij.execution.ExecutionException;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.baseLanguage.execution.api.Java_Command;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.debug.api.IDebugger;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.apache.log4j.Level;
import java.util.LinkedList;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Computable;
import java.util.Set;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.net.URL;
import jetbrains.mps.core.tool.environment.classloading.ClassloaderUtil;
import java.net.URISyntaxException;
import com.intellij.openapi.application.PathManager;
import jetbrains.mps.debug.api.run.IDebuggerConfiguration;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.debug.api.IDebuggerSettings;
import jetbrains.mps.debugger.java.api.settings.LocalConnectionSettings;
import jetbrains.mps.debug.api.Debuggers;

public class JUnit_Command {
  private static final Logger LOG = LogManager.getLogger(JUnit_Command.class);
  private String myDebuggerSettings_String;
  private String myVirtualMachineParameter_String;
  private String myJrePath_String;
  private File myWorkingDirectory_File = new File(".");
  public JUnit_Command() {
  }
  public JUnit_Command setDebuggerSettings_String(String debuggerSettings) {
    if (debuggerSettings != null) {
      myDebuggerSettings_String = debuggerSettings;
    }
    return this;
  }
  public JUnit_Command setVirtualMachineParameter_String(String virtualMachineParameter) {
    if (virtualMachineParameter != null) {
      myVirtualMachineParameter_String = virtualMachineParameter;
    }
    return this;
  }
  public JUnit_Command setJrePath_String(String jrePath) {
    if (jrePath != null) {
      myJrePath_String = jrePath;
    }
    return this;
  }
  public JUnit_Command setWorkingDirectory_File(File workingDirectory) {
    if (workingDirectory != null) {
      myWorkingDirectory_File = workingDirectory;
    }
    return this;
  }

  public ProcessHandler createProcess(List<ITestNodeWrapper> tests, JavaRunParameters javaRunParameters) throws ExecutionException {
    return new JUnit_Command().setVirtualMachineParameter_String(check_txeh3_a1a0a0a(javaRunParameters)).setJrePath_String((check_txeh3_a0c0a0a0(javaRunParameters) ? javaRunParameters.jrePath() : null)).setWorkingDirectory_File((isEmptyString(check_txeh3_a0a3a0a0a(javaRunParameters)) ? null : new File(javaRunParameters.workingDirectory()))).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(tests);
  }
  public ProcessHandler createProcess(List<ITestNodeWrapper> tests) throws ExecutionException {
    if (tests == null) {
      throw new ExecutionException("Tests to run are null.");
    }
    List<ITestNodeWrapper> testsNoNull = ListSequence.fromList(tests).where(new NotNullWhereFilter<ITestNodeWrapper>()).toListSequence();
    if (ListSequence.fromList(testsNoNull).isEmpty()) {
      throw new ExecutionException("No tests to run");
    }
    TestsWithParameters testsToRun = JUnit_Command.getTestsToRunWithParameters(testsNoNull);
    if (ListSequence.fromList(tests).isEmpty()) {
      throw new ExecutionException("Could not find tests to run.");
    }
    return new Java_Command().setVirtualMachineParameter_String(IterableUtils.join(ListSequence.fromList(testsToRun.getParameters().getJvmArgs()), " ") + (((myVirtualMachineParameter_String != null && myVirtualMachineParameter_String.length() > 0) ? " " + myVirtualMachineParameter_String : ""))).setClassPath_ListString(ListSequence.fromList(JUnit_Command.getClasspath(testsToRun)).toListSequence()).setJrePath_String(myJrePath_String).setWorkingDirectory_File(myWorkingDirectory_File).setProgramParameter_String(JUnit_Command.getProgramParameters(testsToRun.getTests())).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(testsToRun.getParameters().getExecutorClass().getName());
  }

  public static IDebugger getDebugger() {
    return getDebuggerConfiguration().getDebugger();
  }

  private static String getProgramParameters(List<ITestNodeWrapper> tests) {
    List<String> testsCommandLine = ListSequence.fromList(new ArrayList<String>(ListSequence.fromList(tests).count() * 2));
    for (ITestNodeWrapper test : ListSequence.fromList(tests)) {
      ListSequence.fromList(testsCommandLine).addElement((test.isTestCase() ? "-c" : "-m"));
      ListSequence.fromList(testsCommandLine).addElement(test.getFqName());
    }
    return IterableUtils.join(ListSequence.fromList(testsCommandLine), " ");
  }
  private static TestsWithParameters getTestsToRunWithParameters(@NotNull List<ITestNodeWrapper> tests) throws ExecutionException {
    TestParameters runParams = JUnit_Command.getMaxParams(tests);
    List<ITestNodeWrapper> testsToRun = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
    List<ITestNodeWrapper> testsToSkip = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
    for (ITestNodeWrapper test : ListSequence.fromList(tests)) {
      TestParameters testRunParameters = test.getTestRunParameters();
      if (runParams.comprises(testRunParameters)) {
        ListSequence.fromList(testsToRun).addElement(test);
      } else {
        ListSequence.fromList(testsToSkip).addElement(test);
      }
    }
    String skipped = IterableUtils.join(ListSequence.fromList(testsToSkip).select(new ISelector<ITestNodeWrapper, String>() {
      public String select(ITestNodeWrapper it) {
        return it.getName();
      }
    }), " ");
    if ((skipped != null && skipped.length() > 0)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("All tests could not be executed together. Skipped: " + skipped);
      }
    }
    return new TestsWithParameters(testsToRun, runParams);
  }
  private static TestParameters getMaxParams(List<ITestNodeWrapper> tests) {
    TestParameters maxParams = ListSequence.fromList(tests).first().getTestRunParameters();
    for (ITestNodeWrapper test : ListSequence.fromList(tests)) {
      TestParameters newRunParams = test.getTestRunParameters();
      if (newRunParams.comprises(maxParams)) {
        maxParams = newRunParams;
      }
    }
    return maxParams;
  }
  private static List<String> getClasspath(final TestsWithParameters tests) {
    List<String> classpath = ListSequence.fromList(new LinkedList<String>());
    if (tests.getParameters().needsMPS()) {
      // FIXME In fact, at the moment, DefaultTestExecutor always starts IDEA environment, and we need to control this better 
      ListSequence.fromList(classpath).addSequence(ListSequence.fromList(JUnit_Command.collectFromLibFolder()).distinct());
      ListSequence.fromList(classpath).addSequence(ListSequence.fromList(JUnit_Command.collectFromPreInstalledPluginsFolder()).distinct());
    }
    // FIXME i'm going to get rid of ITestNodeWrapper.getNode access anyway, therefore left MA.instance() as is. 
    //       The idea is to pass list of SModuleReference through TestParameters 
    ListSequence.fromList(classpath).addSequence(ListSequence.fromList(ModelAccess.instance().runReadAction(new Computable<List<String>>() {
      public List<String> compute() {
        Set<SModule> uniqueModules = SetSequence.fromSet(new HashSet<SModule>());
        for (ITestNodeWrapper testable : tests.getTests()) {
          SModule module = SNodeOperations.getModel(testable.getNode()).getModule();
          SetSequence.fromSet(uniqueModules).addElement(module);
        }
        return Java_Command.getClasspath(uniqueModules);
      }
    })));
    return ListSequence.fromList(tests.getParameters().getClassPath()).union(ListSequence.fromList(classpath)).toListSequence();
  }
  private static List<String> collectFromLibFolder() {
    List<URL> urls = ListSequence.fromList(new ArrayList<URL>());
    ClassloaderUtil.addIDEALibraries(urls);
    // FIXME Look, this is stupid. First, we collect library location as files, then translate them to toURI().toURL() only to get File path back here. 
    List<String> rv = ListSequence.fromList(new ArrayList<String>(ListSequence.fromList(urls).count()));
    for (URL u : ListSequence.fromList(urls)) {
      // NOTE, URL.getPath() gives URL segment with escaped characters (e.g. %20), therefore we resort to toURI to get them unescaped. 
      try {
        ListSequence.fromList(rv).addElement(u.toURI().getPath());
      } catch (URISyntaxException ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Bad library location", ex);
        }
      }
    }
    return rv;
  }
  private static List<String> collectFromPreInstalledPluginsFolder() {
    List<String> result = ListSequence.fromList(new ArrayList<String>());
    File preinstalledFolder = new File(PathManager.getPreInstalledPluginsPath());
    final File[] pluginFiles = preinstalledFolder.listFiles();
    if (pluginFiles != null) {
      for (final File pluginFile : pluginFiles) {
        if (!(ClassloaderUtil.isJarOrZip(pluginFile))) {
          File classesDir = new File(pluginFile, "classes");
          if (classesDir.exists()) {
            ListSequence.fromList(result).addElement(classesDir.getAbsolutePath());
          }
          File libDir = new File(pluginFile, "lib");
          if (libDir.exists()) {
            ListSequence.fromList(result).addSequence(ListSequence.fromList(JUnit_Command.allJarsUnderRoot(libDir)));
          }
        }
      }
    }
    ListSequence.fromList(result).addSequence(ListSequence.fromList(JUnit_Command.allJarsUnderRoot(preinstalledFolder)));
    return result;
  }
  private static List<String> allJarsUnderRoot(File root) {
    List<String> res = ListSequence.fromList(new ArrayList<String>());
    File[] children = root.listFiles();
    if (children != null) {
      for (final File childFile : children) {
        if (ClassloaderUtil.isJarOrZip(childFile)) {
          ListSequence.fromList(res).addElement(childFile.getAbsolutePath());
        }
      }
    }

    return res;
  }

  public static IDebuggerConfiguration getDebuggerConfiguration() {
    return new IDebuggerConfiguration() {
      @Nullable
      public IDebuggerSettings createDebuggerSettings() {
        return new LocalConnectionSettings(true);
      }
      public IDebugger getDebugger() {
        return Debuggers.getInstance().getDebuggerByName("Java");
      }
    };
  }
  private static String check_txeh3_a1a0a0a(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.vmOptions();
    }
    return null;
  }
  private static boolean check_txeh3_a0c0a0a0(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return (boolean) checkedDotOperand.useAlternativeJre();
    }
    return false;
  }
  private static String check_txeh3_a0a3a0a0a(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.workingDirectory();
    }
    return null;
  }
  private static boolean isEmptyString(String str) {
    return str == null || str.length() == 0;
  }
}
