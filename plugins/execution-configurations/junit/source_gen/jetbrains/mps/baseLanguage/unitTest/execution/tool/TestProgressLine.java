package jetbrains.mps.baseLanguage.unitTest.execution.tool;

/*Generated by MPS */

import javax.swing.JPanel;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunStateUpdateListener;
import javax.swing.JProgressBar;
import javax.swing.JLabel;
import com.intellij.ui.components.panels.NonOpaquePanel;
import java.awt.BorderLayout;
import com.intellij.openapi.progress.util.ColorProgressBar;
import javax.swing.BorderFactory;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunData;
import javax.swing.SwingUtilities;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeKey;

/**
 * todo no reflection of ignore/assumptions/skipped tests whatsoever
 * the prototype is the idea test tool
 */
public class TestProgressLine extends JPanel implements TestRunStateUpdateListener {
  private static final int TOTAL_UNITS = 100;
  private final JProgressBar myProgressBar = new JProgressBar();
  private final JLabel myStateLabel = new JLabel("Starting...");
  private final JPanel myProgressPanel = new NonOpaquePanel(new BorderLayout());

  public TestProgressLine() {
    super(new BorderLayout());
    add(myProgressPanel, BorderLayout.SOUTH);
    myProgressBar.putClientProperty("ProgressBar.stripeWidth", 3);
    myProgressBar.putClientProperty("ProgressBar.flatEnds", Boolean.TRUE);
    myProgressBar.setMaximum(TOTAL_UNITS);
    myProgressBar.setForeground(ColorProgressBar.GREEN);
    JPanel labelWrapper = new NonOpaquePanel(new BorderLayout());
    labelWrapper.add(myStateLabel, BorderLayout.NORTH);
    myProgressBar.setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 2));
    myProgressBar.setIndeterminate(true);
    add(labelWrapper, BorderLayout.CENTER);
    myProgressPanel.add(myProgressBar, BorderLayout.NORTH);
  }

  @Override
  public void update(@NotNull final TestRunData data) {
    if (data.getAvailableText() != null) {
      return;
    }
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        updateProgressBar(data);
        updateLabel(data);
      }
    });
  }

  private void updateProgressBar(@NotNull TestRunData data) {
    int failed = data.getFailedCount();
    int ignored = data.getIgnoredCount();
    int skipped = data.getSkippedCount();
    int total = data.getTotalCount();
    int completed = data.getCompletedCount();

    myProgressBar.setIndeterminate(false);
    if (failed + ignored + skipped > 0) {
      myProgressBar.setForeground(ColorProgressBar.RED);
    } else if (data.isTerminated() && total > completed) {
      myProgressBar.setForeground(ColorProgressBar.YELLOW);
    }
    if (total != 0) {
      myProgressBar.setValue((completed * TOTAL_UNITS) / total);
    }
  }

  private void updateLabel(@NotNull TestRunData data) {
    int failed = data.getFailedCount();
    int ignored = data.getIgnoredCount();
    int skipped = data.getSkippedCount();
    int total = data.getTotalCount();
    int completed = data.getCompletedCount();
    int passed = data.getPassedCount();
    TestNodeKey testNode = data.getCurrentTestNode();
    if (data.isTerminated()) {

    }
    StringBuilder sb = new StringBuilder();
    boolean done = (total == completed);
    if (data.isTerminated()) {
      if (data.isTerminatedCorrectly()) {
        sb.append("Stopped. ");
      } else {
        sb.append("Terminated. ");
      }
    }
    boolean smthWrittenAlready = false;
    if (failed > 0) {
      sb.append("Tests failed: " + failed);
      smthWrittenAlready = true;
    } else {
      sb.append("Tests ");
    }
    if (passed > 0 || ignored + failed + skipped == 0) {
      if (smthWrittenAlready) {
        sb.append(", ");
      }
      smthWrittenAlready = true;
      sb.append("passed: " + passed);
    }
    if (ignored > 0) {
      if (smthWrittenAlready) {
        sb.append(", ");
      }
      smthWrittenAlready = true;
      sb.append("ignored: " + ignored);
    }
    if (skipped > 0) {
      if (smthWrittenAlready) {
        sb.append(", ");
      }
      sb.append("skipped: " + skipped);
    }
    if (total > 0) {
      sb.append(" of " + total + " test" + ((total > 1 ? "s" : "")));
    }
    String qualifiedName = (testNode == null ? "" : testNode.getQualifiedName());
    if (!(data.isTerminated()) && !(done) && testNode != null) {
      sb.append(". Running now: " + qualifiedName);
    }
    myStateLabel.setText(sb.toString());
  }
}
