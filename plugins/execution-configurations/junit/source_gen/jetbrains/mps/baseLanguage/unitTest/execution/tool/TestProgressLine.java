package jetbrains.mps.baseLanguage.unitTest.execution.tool;

/*Generated by MPS */

import javax.swing.JPanel;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunStateUpdateListener;
import javax.swing.JProgressBar;
import javax.swing.JLabel;
import com.intellij.ui.components.panels.NonOpaquePanel;
import java.awt.BorderLayout;
import com.intellij.openapi.progress.util.ColorProgressBar;
import javax.swing.BorderFactory;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunData;
import com.intellij.execution.process.ProcessOutputTypes;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeKey;
import javax.swing.SwingUtilities;
import org.jetbrains.annotations.Nullable;

/**
 * todo no reflection of ignore/assumptions/skipped tests whatsoever
 * the prototype is the idea test tool
 */
public class TestProgressLine extends JPanel implements TestRunStateUpdateListener {
  private static final int TOTAL_UNITS = 100;
  private final JProgressBar myProgressBar = new JProgressBar();
  private final JLabel myStateLabel = new JLabel("Starting...");
  private final JPanel myProgressPanel = new NonOpaquePanel(new BorderLayout());

  public TestProgressLine() {
    super(new BorderLayout());
    add(myProgressPanel, BorderLayout.SOUTH);
    myProgressBar.putClientProperty("ProgressBar.stripeWidth", 3);
    myProgressBar.putClientProperty("ProgressBar.flatEnds", Boolean.TRUE);
    myProgressBar.setMaximum(TOTAL_UNITS);
    myProgressBar.setForeground(ColorProgressBar.GREEN);
    JPanel labelWrapper = new NonOpaquePanel(new BorderLayout());
    labelWrapper.add(myStateLabel, BorderLayout.NORTH);
    myProgressBar.setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 2));
    myProgressBar.setIndeterminate(true);
    add(labelWrapper, BorderLayout.CENTER);
    myProgressPanel.add(myProgressBar, BorderLayout.NORTH);
  }

  @Override
  public void update(@NotNull final TestRunData data) {
    if (data.getAvailableText() != null || ProcessOutputTypes.SYSTEM.equals(data.getTextType())) {
      return;
    }
    final int defectedTests = data.getFailedTests();
    final int totalTests = data.getTotalTests();
    final int completedTests = data.getCompletedTests();
    final TestNodeKey currentTestNode = data.getCurrentTestNode();
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        updateProgressBar(data.isTerminated(), defectedTests, totalTests, completedTests);
        updateLabel(data.isTerminated(), defectedTests, totalTests, completedTests, currentTestNode);
      }
    });
  }

  private void updateProgressBar(boolean isTerminated, int defected, int total, int completed) {
    myProgressBar.setIndeterminate(false);
    if (defected > 0) {
      myProgressBar.setForeground(ColorProgressBar.RED);
    } else if (isTerminated && total > completed) {
      myProgressBar.setForeground(ColorProgressBar.YELLOW);
    }
    if (total != 0) {
      myProgressBar.setValue((completed * TOTAL_UNITS) / total);
    }
  }

  private void updateLabel(boolean isTerminated, int defected, int total, int completed, @Nullable TestNodeKey currentTest) {
    StringBuilder sb = new StringBuilder();
    boolean done = total == completed;
    if (done) {
      sb.append(" Done: " + completed + " of " + total + " ");
      currentTest = null;
    } else if (isTerminated) {
      sb.append(" Terminated: " + completed + " of " + total + " ");
      currentTest = null;
    }
    if (defected > 0) {
      sb.append(" Failed: " + defected);
    }
    if (!(isTerminated) && !(done)) {
      sb.append(" Running: " + completed + " of " + total);
    }
    String qualifiedName = (currentTest == null ? "" : currentTest.getQualifiedName());
    myStateLabel.setText(sb + "  " + qualifiedName);
  }
}
