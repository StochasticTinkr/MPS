package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.annotations.Mutable;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.annotations.Immutable;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.unitTest.execution.TestMethodNodeKey;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeEvent;
import jetbrains.mps.baseLanguage.unitTest.execution.TestRawEvent;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeKey;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.annotations.Internal;
import jetbrains.mps.baseLanguage.unitTest.execution.TestCaseNodeKey;
import org.apache.log4j.Level;
import jetbrains.mps.baseLanguage.unitTest.execution.TerminationTestEvent;
import com.intellij.openapi.util.Key;
import jetbrains.mps.baseLanguage.unitTest.execution.TextTestEvent;
import org.jetbrains.mps.annotations.ImmutableReturn;
import java.util.Collections;
import org.jetbrains.annotations.TestOnly;

/**
 * State of test execution; updates associated {@link jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunStateUpdateListener } when there's a change.
 * fix mutability by implementing TestStateListener in all listeners
 * 
 * probable fix: store the state for each test here (not in TestTree for instance), since we use the state notion at least in TestTree, TestProgressLine (and TestStatisticsTable)
 */
@Mutable
public final class TestRunState {
  private static final Logger LOG = LogManager.getLogger(TestRunState.class);
  private final Set<TestRunStateUpdateListener> myUpdateListenersList = SetSequence.fromSet(new HashSet<TestRunStateUpdateListener>());
  private final List<TestStateListener> myListeners = ListSequence.fromList(new ArrayList<TestStateListener>());
  @Immutable
  private final Map<ITestNodeWrapper, List<ITestNodeWrapper>> myTestCase2MethodsMap = MapSequence.fromMap(new LinkedHashMap<ITestNodeWrapper, List<ITestNodeWrapper>>(16, (float) 0.75, false));

  private final String2NodeTestKeyConverter myConverter;

  private final List<ITestNodeWrapper> myTestsWithProblems = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());

  /**
   * to remove
   */
  private final TestRunData myInnerData = new TestRunData();

  private void processTestCases(List<ITestNodeWrapper> tests) {
    for (ITestNodeWrapper testCase : ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return it.isTestCase();
      }
    })) {
      MapSequence.fromMap(myTestCase2MethodsMap).put(testCase, ListSequence.fromListWithValues(new ArrayList<ITestNodeWrapper>(), testCase.getTestMethods()));
    }
  }

  private void processTestMethods(List<ITestNodeWrapper> tests) {
    for (ITestNodeWrapper testMethod : ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return !(it.isTestCase());
      }
    })) {
      ITestNodeWrapper enclosingTestCase = testMethod.getTestCase();
      List<ITestNodeWrapper> currentTestMethods = getMethodsForTestCase(enclosingTestCase);
      if (currentTestMethods == null) {
        currentTestMethods = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
      }
      if (!(ListSequence.fromList(currentTestMethods).contains(testMethod))) {
        ListSequence.fromList(currentTestMethods).addElement(testMethod);
      }
      MapSequence.fromMap(myTestCase2MethodsMap).put(enclosingTestCase, currentTestMethods);
    }
    for (ITestNodeWrapper testCase : MapSequence.fromMap(myTestCase2MethodsMap).keySet()) {
      for (ITestNodeWrapper testMethod : getMethodsForTestCase(testCase)) {
        ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).addElement(new TestMethodNodeKey(testMethod));
      }
    }
  }

  public TestRunState(@NotNull List<ITestNodeWrapper> tests) {
    processTestCases(tests);
    processTestMethods(tests);
    myInnerData.myTotalTests = ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).count();
    myConverter = new String2NodeTestKeyConverter(myTestCase2MethodsMap);
  }

  private void notifyUpdateListeners() {
    for (TestRunStateUpdateListener listener : myUpdateListenersList) {
      listener.update(myInnerData.copy());
    }
  }

  public void addUpdateListener(TestRunStateUpdateListener updateListener) {
    SetSequence.fromSet(myUpdateListenersList).addElement(updateListener);
  }

  public void removeUpdateListener(TestRunStateUpdateListener updateListener) {
    SetSequence.fromSet(myUpdateListenersList).removeElement(updateListener);
  }

  @NotNull
  private TestNodeEvent convertRawEventToNodeEvent(@NotNull TestRawEvent rawEvent) {
    TestNodeKey nodeKey = myConverter.convert(rawEvent.getTestKey());
    return new TestNodeEvent(rawEvent, nodeKey);
  }

  /*package*/ void onTestStarted(TestRawEvent event) {
    log("test started : " + event);
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestStart(nodeEvent);
      }
    });
    startTest(nodeEvent);
  }

  /*package*/ void onTestFinished(TestRawEvent event) {
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    log("test finished : " + event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestFinish(nodeEvent);
      }
    });
    myInnerData.myCompletedTests += getCurrentEventTestsCount(nodeEvent);
    notifyUpdateListeners();
    myInnerData.myCurrentTestNode = null;
    removeFinishedTestEvent(event);
  }

  @Internal
  private void log(String msg) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(msg);
    }
  }

  /*package*/ void onTestRunStarted() {
    log("test run started : ");
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestRunStarted();
      }
    });
  }

  /*package*/ void onTestRunFinished() {
    log("test run finished : ");
    myInnerData.myFinished = true;
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestRunFinished();
      }
    });
  }

  /*package*/ void onTestAssumptionFailure(TestRawEvent event) {
    log("test assumption failed : ");
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestAssumptionFailure(nodeEvent);
      }
    });
    myInnerData.mySkippedTests += getCurrentNotProblemTestsCount(nodeEvent);
  }

  /**
   * Almost always the event comes for each method. However sometimes it might come only for the whole test case.
   * I guess the only place where we can have a whole testcase started and failed is
   * when we fail with assumptionfailedrunner but still lets have the common code for all the counters
   */
  private int getCurrentEventTestsCount(@NotNull TestNodeEvent nodeEvent) {
    if (nodeEvent.isTestCaseEvent()) {
      return ListSequence.fromList(getMethodsForTestCase(nodeEvent.getTestKey().getNode())).count();
    } else {
      return 1;
    }
  }

  /**
   * here we fix up the possible multiple #onTestFailed, #onTestIgnored events.
   * in order to adjust the counters in the InnerData we record already seen errors in the #myTestsWithProblems
   * 
   * it is to be replaced with the honest state recording like we can see currently in the TestTree implementation
   */
  private int getCurrentNotProblemTestsCount(@NotNull TestNodeEvent nodeEvent) {
    ITestNodeWrapper node = nodeEvent.getTestKey().getNode();
    if (ListSequence.fromList(myTestsWithProblems).contains(node)) {
      return 0;
    }
    ListSequence.fromList(myTestsWithProblems).addElement(node);
    if (nodeEvent.isTestCaseEvent()) {
      int result = 0;
      for (ITestNodeWrapper method : ListSequence.fromList(getMethodsForTestCase(node))) {
        if (!(ListSequence.fromList(myTestsWithProblems).contains(method))) {
          ListSequence.fromList(myTestsWithProblems).addElement(node);
          ++result;
        }
      }
      return result;
    } else {
      // test case node cannot get in the list without all the containing methods 
      return 1;
    }
  }

  private List<ITestNodeWrapper> getMethodsForTestCase(ITestNodeWrapper node) {
    return MapSequence.fromMap(myTestCase2MethodsMap).get(node);
  }

  public void onTestIgnored(TestRawEvent event) {
    log("test ignored : ");
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestIgnored(nodeEvent);
      }
    });
    myInnerData.myIgnoredTests += getCurrentNotProblemTestsCount(nodeEvent);
  }

  public void onTestFailure(TestRawEvent event) {
    log("test failed : " + event);
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestFailure(nodeEvent);
      }
    });
    myInnerData.myFailedTests += getCurrentNotProblemTestsCount(nodeEvent);
  }

  private void removeFinishedTestEvent(TestRawEvent event) {
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    if (nodeEvent.isTestCaseEvent()) {
      ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).removeWhere(new IWhereFilter<TestMethodNodeKey>() {
        public boolean accept(TestMethodNodeKey it) {
          TestCaseNodeKey testCaseKey = (TestCaseNodeKey) nodeEvent.getTestKey();
          return it.getTestCaseNodeKey().equals(testCaseKey);
        }
      });
    } else {
      @NotNull TestMethodNodeKey methodKey = (TestMethodNodeKey) nodeEvent.getTestKey();
      ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).removeElement(methodKey);
    }
  }

  private void startTest(@NotNull TestNodeEvent event) {
    if (myInnerData.getCurrentTestNode() != null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Seems that the previous test is not finished yet");
      }
    }
    checkConsistency();
    myInnerData.myCurrentTestNode = event.getTestKey();
    notifyUpdateListeners();
  }

  public void onTermination(boolean terminatingOnException) {
    checkConsistency();
    myInnerData.myTerminated = true;
    log("tests terminated : " + terminatingOnException);
    myInnerData.myTerminatedCorrectly = !(terminatingOnException);
    // these are the tests which have not been executed yet 
    List<TestMethodNodeKey> testsNotRunDueToError = myInnerData.myTestMethodsLeftToRun;
    final TerminationTestEvent event = new TerminationTestEvent(myInnerData.myCurrentTestNode, testsNotRunDueToError, !(terminatingOnException));
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTermination(event);
      }
    });
    notifyUpdateListeners();
  }

  public void onStartNotified() {
    checkConsistency();
    log("tests notified : ");
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onProcessNotified();
      }
    });
  }

  private void checkConsistency() {
    if (!(myNotified)) {
      myNotified = true;
      if (myInnerData.getPassedCount() < 0) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("consistency is broken: passedCount < 0", new Throwable());
        }
      }
      if (myInnerData.myCompletedTests > myInnerData.myTotalTests) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("consistency is broken: completed > total", new Throwable());
        }
      }
    }
  }

  private boolean myNotified = false;

  public void onTextAvailable(@NotNull String text, @NotNull Key key) {
    myInnerData.myAvailableText = text;
    myInnerData.myTextType = key;
    final TextTestEvent event = new TextTestEvent(text, key, myInnerData.myCurrentTestNode);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTextAvailable(event);
      }
    });
    notifyUpdateListeners();
    myInnerData.myAvailableText = null;
    myInnerData.myTextType = null;
  }

  public void addListener(TestStateListener listener) {
    ListSequence.fromList(myListeners).addElement(listener);
  }

  public void removeListener(TestStateListener listener) {
    ListSequence.fromList(myListeners).removeElement(listener);
  }

  @ImmutableReturn
  public Map<ITestNodeWrapper, List<ITestNodeWrapper>> getTestsMap() {
    return Collections.unmodifiableMap(myTestCase2MethodsMap);
  }

  @TestOnly
  public int getCompletedTests() {
    return myInnerData.myCompletedTests;
  }

  @TestOnly
  public int getFailedTests() {
    return myInnerData.myFailedTests;
  }
}
