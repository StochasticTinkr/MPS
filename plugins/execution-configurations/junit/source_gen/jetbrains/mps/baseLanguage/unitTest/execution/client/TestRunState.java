package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.annotations.Mutable;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.intellij.openapi.util.Key;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.execution.TestEvent;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Level;

/**
 * State of test execution; updates associated {@link jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunStateUpdateListener } when there's a change.
 */
@Mutable
public final class TestRunState {
  private static final Logger LOG = LogManager.getLogger(TestRunState.class);
  private static final Object LOCK = new Object();

  private final Map<ITestNodeWrapper, List<ITestNodeWrapper>> myTestToMethodsMap = MapSequence.fromMap(new LinkedHashMap<ITestNodeWrapper, List<ITestNodeWrapper>>(16, (float) 0.75, false));
  private final Set<TestRunStateUpdateListener> myUpdateListenersList = SetSequence.fromSet(new HashSet<TestRunStateUpdateListener>());
  private final List<TestStateListener> myListeners = ListSequence.fromList(new ArrayList<TestStateListener>());

  /**
   * mutable fields below
   */
  private final List<TestMethodKey> myTestMethodsLeftToRun = ListSequence.fromList(new ArrayList<TestMethodKey>());
  private String myCurrentClass;
  private String myCurrentMethod;
  private String myCurrentToken;
  private String myCurrentNotExecutedDueToErrorTest;
  private String myCurrentNotExecutedDueToErrorMethod;

  private int myTotalTests;
  private int myCompletedTests = 0;
  private int myFailedTests = 0;
  private boolean myIsTerminated;
  private String myAvailableText = null;
  private Key myKey = null;

  private void processTestCases(List<ITestNodeWrapper> tests) {
    for (ITestNodeWrapper testCase : ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return it.isTestCase();
      }
    })) {
      MapSequence.fromMap(myTestToMethodsMap).put(testCase, ListSequence.fromListWithValues(new ArrayList<ITestNodeWrapper>(), testCase.getTestMethods()));
    }
  }

  private void processTestMethods(List<ITestNodeWrapper> tests) {
    for (ITestNodeWrapper testMethod : ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return !(it.isTestCase());
      }
    })) {
      ITestNodeWrapper enclosingTestCase = testMethod.getTestCase();
      List<ITestNodeWrapper> currentTestMethods = MapSequence.fromMap(myTestToMethodsMap).get(enclosingTestCase);
      if (currentTestMethods == null) {
        currentTestMethods = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
        MapSequence.fromMap(myTestToMethodsMap).put(enclosingTestCase, currentTestMethods);
      }
      if (!(ListSequence.fromList(currentTestMethods).contains(testMethod))) {
        ListSequence.fromList(currentTestMethods).addElement(testMethod);
      }
    }
    for (ITestNodeWrapper testCase : MapSequence.fromMap(myTestToMethodsMap).keySet()) {
      for (ITestNodeWrapper testMethod : MapSequence.fromMap(myTestToMethodsMap).get(testCase)) {
        ListSequence.fromList(myTestMethodsLeftToRun).addElement(new TestMethodKey(testCase.getFqName(), testMethod.getName()));
      }
    }
  }

  public TestRunState(@NotNull List<ITestNodeWrapper> tests) {
    processTestCases(tests);
    processTestMethods(tests);
    myTotalTests = ListSequence.fromList(myTestMethodsLeftToRun).count();
  }

  private void notifyUpdateListeners() {
    for (TestRunStateUpdateListener listener : myUpdateListenersList) {
      listener.update();
    }
  }

  public void addUpdateListener(TestRunStateUpdateListener updateListener) {
    SetSequence.fromSet(myUpdateListenersList).addElement(updateListener);
  }

  public void removeUpdateListener(TestRunStateUpdateListener updateListener) {
    SetSequence.fromSet(myUpdateListenersList).removeElement(updateListener);
  }

  private void setToken(@NotNull String token) {
    myCurrentToken = token;
  }

  public void onTestStarted(final TestEvent event) {
    synchronized (LOCK) {
      setToken(event.getToken());
      ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
        public void visit(TestStateListener it) {
          it.onTestStart(event);
        }
      });
      startTest(event.getTestCaseName(), event.getTestMethodName());
    }
  }

  public void onTestFinished(final TestEvent event) {
    synchronized (LOCK) {
      setToken(event.getToken());
      ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
        public void visit(TestStateListener it) {
          it.onTestFinish(event);
        }
      });
      finishTest();
      completeTestEvent(event);
    }
  }

  public void onTestAssumptionFailure(final TestEvent event) {
    synchronized (LOCK) {
      setToken(event.getToken());
      ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
        public void visit(TestStateListener it) {
          it.onTestAssumptionFailure(event);
        }
      });
      notifyUpdateListeners();
    }
  }

  public void onTestFailure(final TestEvent event) {
    synchronized (LOCK) {
      setToken(event.getToken());
      ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
        public void visit(TestStateListener it) {
          it.onTestFailure(event);
        }
      });
      myFailedTests++;
      notifyUpdateListeners();
    }
  }

  private void completeTestEvent(TestEvent event) {
    String testCaseName = event.getTestCaseName();
    String testMethodName = event.getTestMethodName();
    if (testMethodName == null) {
      removeFinishedTestCase(testCaseName);
    } else {
      removeFinishedTestMethod(testCaseName, testMethodName);
    }
  }

  private void startTest(String className, String methodName) {
    if (myCurrentMethod != null && myCurrentClass != null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Seems that the previous test is not finished yet");
      }
    }
    checkConsistency();
    myCurrentClass = className;
    myCurrentMethod = methodName;
    notifyUpdateListeners();
  }

  private void finishTest() {
    myCompletedTests++;
    notifyUpdateListeners();
    myCurrentClass = null;
    myCurrentMethod = null;
  }

  private void looseTestInternal(String test, String method) {
    myCurrentNotExecutedDueToErrorTest = test;
    myCurrentNotExecutedDueToErrorMethod = method;
    notifyUpdateListeners();
    myCurrentNotExecutedDueToErrorTest = null;
    myCurrentNotExecutedDueToErrorMethod = null;
  }

  public void terminate(boolean terminatingCorrectly) {
    synchronized (LOCK) {
      checkConsistency();
      myIsTerminated = true;
      // these are the tests which have not been executed yet 
      if (!(terminatingCorrectly)) {
        List<TestMethodKey> testsNotRunDueToError = myTestMethodsLeftToRun;
        for (TestMethodKey notRunTest : testsNotRunDueToError) {
          final String methodName = notRunTest.getTestCaseFqName();
          final String className = notRunTest.getTestMethodFqName();
          ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
            public void visit(TestStateListener it) {
              it.onLooseTest(className, methodName);
            }
          });
          looseTestInternal(className, methodName);
        }
      } else {
        notifyUpdateListeners();
      }
    }
  }

  private void checkConsistency() {
    assert myCompletedTests <= myTotalTests;
    assert myFailedTests <= myCompletedTests;
  }

  public void outputText(String text, @NotNull Key key) {
    synchronized (LOCK) {
      myAvailableText = text;
      myKey = key;
      notifyUpdateListeners();
      myAvailableText = null;
      myKey = null;
    }
  }

  private void removeFinishedTestMethod(String testCaseName, String testMethodName) {
    TestMethodKey methodKey = new TestMethodKey(testCaseName, testMethodName);
    ListSequence.fromList(myTestMethodsLeftToRun).removeElement(methodKey);
  }

  private void removeFinishedTestCase(@NotNull final String testCaseName) {
    ListSequence.fromList(myTestMethodsLeftToRun).removeWhere(new IWhereFilter<TestMethodKey>() {
      public boolean accept(TestMethodKey it) {
        return testCaseName.equals(it.getTestCaseFqName());
      }
    });
  }

  public int getTotalTests() {
    synchronized (LOCK) {
      return myTotalTests;
    }
  }

  public int getFailedTests() {
    synchronized (LOCK) {
      return myFailedTests;
    }
  }

  public int getCompletedTests() {
    synchronized (LOCK) {
      return myCompletedTests;
    }
  }

  public String getCurrentClass() {
    synchronized (LOCK) {
      return myCurrentClass;
    }
  }

  public String getCurrentMethod() {
    synchronized (LOCK) {
      return myCurrentMethod;
    }
  }

  public String getToken() {
    synchronized (LOCK) {
      return myCurrentToken;
    }
  }

  public String getLostMethod() {
    synchronized (LOCK) {
      return myCurrentNotExecutedDueToErrorMethod;
    }
  }

  public String getLostClass() {
    synchronized (LOCK) {
      return myCurrentNotExecutedDueToErrorTest;
    }
  }

  public boolean isTerminated() {
    synchronized (LOCK) {
      return myIsTerminated;
    }
  }

  public String getAvailableText() {
    synchronized (LOCK) {
      return myAvailableText;
    }
  }

  public Key getKey() {
    synchronized (LOCK) {
      return myKey;
    }
  }

  public void addListener(TestStateListener listener) {
    ListSequence.fromList(myListeners).addElement(listener);
  }

  public void removeListener(TestStateListener listener) {
    ListSequence.fromList(myListeners).removeElement(listener);
  }

  public Map<ITestNodeWrapper, List<ITestNodeWrapper>> getTestsMap() {
    synchronized (LOCK) {
      // fix MUTATOR 
      return myTestToMethodsMap;
    }
  }
}
