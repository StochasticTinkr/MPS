package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.annotations.Mutable;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.annotations.Immutable;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.unitTest.execution.TestMethodNodeKey;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeEvent;
import jetbrains.mps.baseLanguage.unitTest.execution.TestRawEvent;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeKey;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.baseLanguage.unitTest.execution.TestCaseNodeKey;
import org.apache.log4j.Level;
import jetbrains.mps.baseLanguage.unitTest.execution.TerminationTestEvent;
import com.intellij.openapi.util.Key;
import jetbrains.mps.baseLanguage.unitTest.execution.TextTestEvent;
import org.jetbrains.mps.annotations.ImmutableReturn;
import java.util.Collections;
import org.jetbrains.annotations.TestOnly;

/**
 * State of test execution; updates associated {@link jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunStateUpdateListener } when there's a change.
 * fix mutability by implementing TestStateListener in all listeners
 */
@Mutable
public final class TestRunState {
  private static final Logger LOG = LogManager.getLogger(TestRunState.class);
  private final Set<TestRunStateUpdateListener> myUpdateListenersList = SetSequence.fromSet(new HashSet<TestRunStateUpdateListener>());
  private final List<TestStateListener> myListeners = ListSequence.fromList(new ArrayList<TestStateListener>());
  @Immutable
  private final Map<ITestNodeWrapper, List<ITestNodeWrapper>> myTestCase2MethodsMap = MapSequence.fromMap(new LinkedHashMap<ITestNodeWrapper, List<ITestNodeWrapper>>(16, (float) 0.75, false));

  private final String2NodeTestKeyConverter myConverter;

  /**
   * to remove
   */
  private final TestRunData myInnerData = new TestRunData();

  private void processTestCases(List<ITestNodeWrapper> tests) {
    for (ITestNodeWrapper testCase : ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return it.isTestCase();
      }
    })) {
      MapSequence.fromMap(myTestCase2MethodsMap).put(testCase, ListSequence.fromListWithValues(new ArrayList<ITestNodeWrapper>(), testCase.getTestMethods()));
    }
  }

  private void processTestMethods(List<ITestNodeWrapper> tests) {
    for (ITestNodeWrapper testMethod : ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return !(it.isTestCase());
      }
    })) {
      ITestNodeWrapper enclosingTestCase = testMethod.getTestCase();
      List<ITestNodeWrapper> currentTestMethods = MapSequence.fromMap(myTestCase2MethodsMap).get(enclosingTestCase);
      if (currentTestMethods == null) {
        currentTestMethods = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
        MapSequence.fromMap(myTestCase2MethodsMap).put(enclosingTestCase, currentTestMethods);
      }
      if (!(ListSequence.fromList(currentTestMethods).contains(testMethod))) {
        ListSequence.fromList(currentTestMethods).addElement(testMethod);
      }
    }
    for (ITestNodeWrapper testCase : MapSequence.fromMap(myTestCase2MethodsMap).keySet()) {
      for (ITestNodeWrapper testMethod : MapSequence.fromMap(myTestCase2MethodsMap).get(testCase)) {
        ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).addElement(new TestMethodNodeKey(testMethod));
      }
    }
  }

  public TestRunState(@NotNull List<ITestNodeWrapper> tests) {
    processTestCases(tests);
    processTestMethods(tests);
    myInnerData.myTotalTests = ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).count();
    myConverter = new String2NodeTestKeyConverter(myTestCase2MethodsMap);
  }

  private void notifyUpdateListeners() {
    for (TestRunStateUpdateListener listener : myUpdateListenersList) {
      listener.update(myInnerData.copy());
    }
  }

  public void addUpdateListener(TestRunStateUpdateListener updateListener) {
    SetSequence.fromSet(myUpdateListenersList).addElement(updateListener);
  }

  public void removeUpdateListener(TestRunStateUpdateListener updateListener) {
    SetSequence.fromSet(myUpdateListenersList).removeElement(updateListener);
  }

  @NotNull
  private TestNodeEvent convertRawEventToNodeEvent(@NotNull TestRawEvent rawEvent) {
    TestNodeKey nodeKey = myConverter.convert(rawEvent.getTestKey());
    return new TestNodeEvent(rawEvent, nodeKey);
  }

  /*package*/ void onTestStarted(TestRawEvent event) {
    log("test started : " + event);
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestStart(nodeEvent);
      }
    });
    startTest(nodeEvent);
  }

  /*package*/ void onTestFinished(TestRawEvent event) {
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    log("test finished : " + event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestFinish(nodeEvent);
      }
    });
    myInnerData.myCompletedTests++;
    notifyUpdateListeners();
    myInnerData.myCurrentTestNode = null;
    removeFinishedTestEvent(event);
  }

  private void log(String msg) {
  }

  /*package*/ void onTestRunStarted() {
    log("test run started : ");
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestRunStarted();
      }
    });
  }

  /*package*/ void onTestRunFinished() {
    log("test run finished : ");
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestRunFinished();
      }
    });
  }

  /*package*/ void onTestAssumptionFailure(TestRawEvent event) {
    log("test assumption failed : ");
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestAssumptionFailure(nodeEvent);
      }
    });
    myInnerData.mySkippedTests++;
  }

  public void onTestIgnored(TestRawEvent event) {
    log("test ignored : ");
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestIgnored(nodeEvent);
      }
    });
    myInnerData.myIgnoredTests++;
  }

  public void onTestFailure(TestRawEvent event) {
    log("test failed : " + event);
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestFailure(nodeEvent);
      }
    });
    myInnerData.myFailedTests++;
  }

  private void removeFinishedTestEvent(TestRawEvent event) {
    final TestNodeEvent nodeEvent = convertRawEventToNodeEvent(event);
    if (nodeEvent.isTestCaseEvent()) {
      ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).removeWhere(new IWhereFilter<TestMethodNodeKey>() {
        public boolean accept(TestMethodNodeKey it) {
          TestCaseNodeKey testCaseKey = (TestCaseNodeKey) nodeEvent.getTestKey();
          return it.getTestCaseNodeKey().equals(testCaseKey);
        }
      });
    } else {
      @NotNull TestMethodNodeKey methodKey = (TestMethodNodeKey) nodeEvent.getTestKey();
      ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).removeElement(methodKey);
    }
  }

  private void startTest(@NotNull TestNodeEvent event) {
    if (myInnerData.getCurrentTestNode() != null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Seems that the previous test is not finished yet");
      }
    }
    checkConsistency();
    myInnerData.myCurrentTestNode = event.getTestKey();
    notifyUpdateListeners();
  }

  public void onTermination(boolean terminatingOnException) {
    checkConsistency();
    myInnerData.myTerminated = true;
    log("tests terminated : " + terminatingOnException);
    myInnerData.myTerminatedCorrectly = !(terminatingOnException);
    // these are the tests which have not been executed yet 
    List<TestMethodNodeKey> testsNotRunDueToError = myInnerData.myTestMethodsLeftToRun;
    final TerminationTestEvent event = new TerminationTestEvent(myInnerData.myCurrentTestNode, testsNotRunDueToError, !(terminatingOnException));
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTermination(event);
      }
    });
    notifyUpdateListeners();
  }

  public void onStartNotified() {
    checkConsistency();
    log("tests notified : ");
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onProcessNotified();
      }
    });
  }

  private void checkConsistency() {
    assert myInnerData.myCompletedTests <= myInnerData.myTotalTests;
    assert myInnerData.myFailedTests <= myInnerData.myCompletedTests;
  }

  public void onTextAvailable(@NotNull String text, @NotNull Key key) {
    myInnerData.myAvailableText = text;
    myInnerData.myTextType = key;
    final TextTestEvent event = new TextTestEvent(text, key, myInnerData.myCurrentTestNode);
    ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTextAvailable(event);
      }
    });
    notifyUpdateListeners();
    myInnerData.myAvailableText = null;
    myInnerData.myTextType = null;
  }

  public void addListener(TestStateListener listener) {
    ListSequence.fromList(myListeners).addElement(listener);
  }

  public void removeListener(TestStateListener listener) {
    ListSequence.fromList(myListeners).removeElement(listener);
  }

  @ImmutableReturn
  public Map<ITestNodeWrapper, List<ITestNodeWrapper>> getTestsMap() {
    return Collections.unmodifiableMap(myTestCase2MethodsMap);
  }

  @TestOnly
  public int getCompletedTests() {
    return myInnerData.myCompletedTests;
  }

  @TestOnly
  public int getFailedTests() {
    return myInnerData.myFailedTests;
  }
}
