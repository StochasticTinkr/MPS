package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.annotations.Mutable;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.annotations.Immutable;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.execution.TestEvent;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Level;
import com.intellij.openapi.util.Key;
import org.jetbrains.mps.annotations.ImmutableReturn;
import java.util.Collections;
import org.jetbrains.annotations.TestOnly;

/**
 * State of test execution; updates associated {@link jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunStateUpdateListener } when there's a change.
 */
@Mutable
public final class TestRunState {
  private static final Logger LOG = LogManager.getLogger(TestRunState.class);
  private static final Object LOCK = new Object();

  private final Set<TestRunStateUpdateListener> myUpdateListenersList = SetSequence.fromSet(new HashSet<TestRunStateUpdateListener>());
  private final List<TestStateListener> myListeners = ListSequence.fromList(new ArrayList<TestStateListener>());
  @Immutable
  private final Map<ITestNodeWrapper, List<ITestNodeWrapper>> myTestToMethodsMap = MapSequence.fromMap(new LinkedHashMap<ITestNodeWrapper, List<ITestNodeWrapper>>(16, (float) 0.75, false));

  private final TestRunData myInnerData = new TestRunData();

  private void processTestCases(List<ITestNodeWrapper> tests) {
    for (ITestNodeWrapper testCase : ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return it.isTestCase();
      }
    })) {
      MapSequence.fromMap(myTestToMethodsMap).put(testCase, ListSequence.fromListWithValues(new ArrayList<ITestNodeWrapper>(), testCase.getTestMethods()));
    }
  }

  private void processTestMethods(List<ITestNodeWrapper> tests) {
    for (ITestNodeWrapper testMethod : ListSequence.fromList(tests).where(new IWhereFilter<ITestNodeWrapper>() {
      public boolean accept(ITestNodeWrapper it) {
        return !(it.isTestCase());
      }
    })) {
      ITestNodeWrapper enclosingTestCase = testMethod.getTestCase();
      List<ITestNodeWrapper> currentTestMethods = MapSequence.fromMap(myTestToMethodsMap).get(enclosingTestCase);
      if (currentTestMethods == null) {
        currentTestMethods = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
        MapSequence.fromMap(myTestToMethodsMap).put(enclosingTestCase, currentTestMethods);
      }
      if (!(ListSequence.fromList(currentTestMethods).contains(testMethod))) {
        ListSequence.fromList(currentTestMethods).addElement(testMethod);
      }
    }
    for (ITestNodeWrapper testCase : MapSequence.fromMap(myTestToMethodsMap).keySet()) {
      for (ITestNodeWrapper testMethod : MapSequence.fromMap(myTestToMethodsMap).get(testCase)) {
        ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).addElement(new TestMethodKey(testCase.getFqName(), testMethod.getName()));
      }
    }
  }

  public TestRunState(@NotNull List<ITestNodeWrapper> tests) {
    processTestCases(tests);
    processTestMethods(tests);
    myInnerData.myTotalTests = ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).count();
  }

  private void notifyUpdateListeners() {
    for (TestRunStateUpdateListener listener : myUpdateListenersList) {
      listener.update(myInnerData.copy());
    }
  }

  public void addUpdateListener(TestRunStateUpdateListener updateListener) {
    SetSequence.fromSet(myUpdateListenersList).addElement(updateListener);
  }

  public void removeUpdateListener(TestRunStateUpdateListener updateListener) {
    SetSequence.fromSet(myUpdateListenersList).removeElement(updateListener);
  }

  private void setToken(@NotNull String token) {
    myInnerData.myCurrentToken = token;
  }

  public void onTestStarted(final TestEvent event) {
    synchronized (LOCK) {
      setToken(event.getToken());
      ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
        public void visit(TestStateListener it) {
          it.onTestStart(event);
        }
      });
      startTest(event.getTestCaseName(), event.getTestMethodName());
    }
  }

  public void onTestFinished(final TestEvent event) {
    synchronized (LOCK) {
      setToken(event.getToken());
      ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
        public void visit(TestStateListener it) {
          it.onTestFinish(event);
        }
      });
      finishTest();
      completeTestEvent(event);
    }
  }

  public void onTestAssumptionFailure(final TestEvent event) {
    synchronized (LOCK) {
      setToken(event.getToken());
      ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
        public void visit(TestStateListener it) {
          it.onTestAssumptionFailure(event);
        }
      });
      notifyUpdateListeners();
    }
  }

  public void onTestFailure(final TestEvent event) {
    synchronized (LOCK) {
      setToken(event.getToken());
      ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
        public void visit(TestStateListener it) {
          it.onTestFailure(event);
        }
      });
      myInnerData.myFailedTests++;
      notifyUpdateListeners();
    }
  }

  private void completeTestEvent(TestEvent event) {
    String testCaseName = event.getTestCaseName();
    String testMethodName = event.getTestMethodName();
    if (testMethodName == null) {
      removeFinishedTestCase(testCaseName);
    } else {
      removeFinishedTestMethod(testCaseName, testMethodName);
    }
  }

  private void startTest(String className, String methodName) {
    if (myInnerData.myCurrentMethod != null && myInnerData.myCurrentClass != null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Seems that the previous test is not finished yet");
      }
    }
    checkConsistency();
    myInnerData.myCurrentClass = className;
    myInnerData.myCurrentMethod = methodName;
    notifyUpdateListeners();
  }

  private void finishTest() {
    myInnerData.myCompletedTests++;
    notifyUpdateListeners();
    myInnerData.myCurrentClass = null;
    myInnerData.myCurrentMethod = null;
  }

  private void looseTestInternal(String test, String method) {
    myInnerData.myCurrentNotExecutedDueToTerminationClass = test;
    myInnerData.myCurrentNotExecutedDueToTerminationMethod = method;
    notifyUpdateListeners();
    myInnerData.myCurrentNotExecutedDueToTerminationClass = null;
    myInnerData.myCurrentNotExecutedDueToTerminationMethod = null;
  }

  public void terminate(boolean terminatingCorrectly) {
    synchronized (LOCK) {
      checkConsistency();
      myInnerData.myIsTerminated = true;
      // these are the tests which have not been executed yet 
      if (!(terminatingCorrectly)) {
        List<TestMethodKey> testsNotRunDueToError = myInnerData.myTestMethodsLeftToRun;
        for (TestMethodKey notRunTest : testsNotRunDueToError) {
          final String methodName = notRunTest.getTestCaseFqName();
          final String className = notRunTest.getTestMethodFqName();
          ListSequence.fromList(myListeners).visitAll(new IVisitor<TestStateListener>() {
            public void visit(TestStateListener it) {
              it.onLooseTest(className, methodName);
            }
          });
          looseTestInternal(className, methodName);
        }
      } else {
        notifyUpdateListeners();
      }
    }
  }

  private void checkConsistency() {
    assert myInnerData.myCompletedTests <= myInnerData.myTotalTests;
    assert myInnerData.myFailedTests <= myInnerData.myCompletedTests;
  }

  public void outputText(String text, @NotNull Key key) {
    synchronized (LOCK) {
      myInnerData.myAvailableText = text;
      myInnerData.myKey = key;
      notifyUpdateListeners();
      myInnerData.myAvailableText = null;
      myInnerData.myKey = null;
    }
  }

  private void removeFinishedTestMethod(String testCaseName, String testMethodName) {
    TestMethodKey methodKey = new TestMethodKey(testCaseName, testMethodName);
    ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).removeElement(methodKey);
  }

  private void removeFinishedTestCase(@NotNull final String testCaseName) {
    ListSequence.fromList(myInnerData.myTestMethodsLeftToRun).removeWhere(new IWhereFilter<TestMethodKey>() {
      public boolean accept(TestMethodKey it) {
        return testCaseName.equals(it.getTestCaseFqName());
      }
    });
  }


  public void addListener(TestStateListener listener) {
    ListSequence.fromList(myListeners).addElement(listener);
  }

  public void removeListener(TestStateListener listener) {
    ListSequence.fromList(myListeners).removeElement(listener);
  }

  @ImmutableReturn
  public Map<ITestNodeWrapper, List<ITestNodeWrapper>> getTestsMap() {
    return Collections.unmodifiableMap(myTestToMethodsMap);
  }

  @TestOnly
  public int getCompletedTests() {
    return myInnerData.myCompletedTests;
  }

  @TestOnly
  public int getFailedTests() {
    return myInnerData.myFailedTests;
  }
}
