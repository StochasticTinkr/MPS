package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.util.annotation.ToRemove;

/**
 * FIXME  external code sometimes wraps access to methods of this class with model read. It's odd an confusing.
 * Implementation sometime wrap node access to own model read, sometimes not (e.g. JUnit4TestWrapper does getNode()?.getFqName(), where 
 * getNode() grabs model read, but there's no explicit read for getFqName, and it's up to external code to contribute some. This has to be refactored, 
 * and clear contract what to expect from methods of this class has to be established. I.e. if getTestCase() of a wrapper with !isTestCase (i.e. test method)
 * is allowed to return new instance each time; if a name (getFqnName) is expected to change and what's in getName().
 * To me, the need to wrap access to the methods of this class with model read is an indicator of poor design.
 */
public interface ITestNodeWrapper<N extends SNode> {
  /**
   * 
   * @deprecated 
   */
  @Deprecated
  N getNode();

  SNodeReference getNodePointer();

  /**
   * ITestNodeWrapper represents a test that originates at some node. Here, we tell which module this node lives in.
   * 
   * PROVISIONAL API, DON'T USE OUTSIDE OF MPS
   * 
   * Perhaps, we have to replace this one with a generic 'DependencyConsumer' callback, with distinct methods to register
   * required deployed modules vs required project/source modules, and to keep the number of this dependencies != exactly 1 as in 
   * present approach. However, first need to figure out what's TestParameters role would be.
   * 
   * @return module of the test node represented by this wrapper
   */
  @NotNull
  SModuleReference getTestNodeModule();

  /**
   * Seemingly there are test cases (java class) and test methods depending on this method
   */
  boolean isTestCase();

  /**
   * 
   * @return enclosing test case if it is not a test case itself, null otherwise
   */
  @Nullable
  ITestNodeWrapper getTestCase();

  @NotNull
  Iterable<ITestNodeWrapper> getTestMethods();

  /**
   * name is a simple name (not fq name), ie for a test = java class we would see a simple name
   */
  @NonNls
  String getName();

  /**
   * fqname for test classes
   */
  @NonNls
  String getFqName();
  /**
   * 
   * @deprecated identical to {@link jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper#getFqName() }
   */
  @Deprecated
  @ToRemove(version = 2018.1)
  String getCachedFqName();

  @NotNull
  TestParameters getTestRunParameters();

  boolean canRunInProcess();
}
