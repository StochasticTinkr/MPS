package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import java.util.List;
import com.intellij.openapi.util.Key;
import jetbrains.mps.baseLanguage.unitTest.execution.TestEvent;
import java.util.regex.Pattern;

/**
 * Updates {@link jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunState } with {@link jetbrains.mps.baseLanguage.unitTest.execution.TestEvent } and other events from a futher unspecified source (usually a listener of a test execution process)
 */
public class TestEventsDispatcher {
  private final TestRunState myState;

  public TestEventsDispatcher(TestRunState testState) {
    this.myState = testState;
  }

  public void onProcessTerminated(String message) {
    // FIXME this message mangling looks suspicious 
    if (message != null && REGEXP_d0rws9_a0a0b0e.matcher(REPLREGEXP_a0a1a4.matcher(message).replaceAll("")).matches()) {
      // message looks like "Process exited with code 0" 
      // something, space, zero, then non-digit and maybe something else, or line end 
      // normal termination means we lost all unused tests 
      // (which means they has errors -- could not be found or something) 
      List<String> lostTests = this.myState.getUnusedMethods();
      for (String lostTest : lostTests) {
        String lostMethodName = lostTest.substring(lostTest.lastIndexOf(".") + 1);
        String lostClassName = lostTest.substring(0, lostTest.lastIndexOf("."));
        this.myState.looseTest(lostClassName, lostMethodName);
      }
      // FIXME it's odd to see an external code to manipulate with TestRunState internal stuff. 
      // TestRunState could do it itself on terminate(). However, need to figure out if the message matching is vital here. 
    }
    this.myState.terminate();
  }

  public void onSimpleTextAvailable(String text, Key key) {
    // FIXME Key makes TestRunState depend from idea's execution API, which is not clean. 
    this.myState.outputText(text, key);
  }

  public void onTestEvent(TestEvent event) {
    String token = event.getToken();
    this.myState.setToken(token);
    if (TestEvent.START_TEST_PREFIX.equals(token)) {
      this.myState.onTestStarted(event);
    } else if (TestEvent.FINISH_TEST_PREFIX.equals(token)) {
      this.myState.onTestFinished(event);
    } else if (TestEvent.ASSUMPTION_FAILURE_TEST_PREFIX.equals(token)) {
      this.myState.onTestAssumptionFailure(event);
    } else if (TestEvent.IGNORE_FAILURE_TEST_PREFIX.equals(token)) {
      this.myState.onTestAssumptionFailure(event);
    } else if (TestEvent.FAILURE_TEST_PREFIX.equals(token)) {
      this.myState.onTestFailure(event);
    }
  }
  private static Pattern REGEXP_d0rws9_a0a0b0e = Pattern.compile(".*\\s0(?:\\D+.*|$)", 0);
  private static Pattern REPLREGEXP_a0a1a4 = Pattern.compile("\\n", 0);
}
