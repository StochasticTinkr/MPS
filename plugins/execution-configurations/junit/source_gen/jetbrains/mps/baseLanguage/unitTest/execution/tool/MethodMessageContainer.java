package jetbrains.mps.baseLanguage.unitTest.execution.tool;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.unitTest.execution.TestMethodNodeKey;
import java.io.File;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.execution.TextTestEvent;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeKey;
import java.util.Objects;
import jetbrains.mps.util.FileUtil;
import java.io.DataOutputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import com.intellij.util.io.IOUtil;
import java.io.IOException;
import org.apache.log4j.Level;
import java.io.DataInputStream;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import com.intellij.openapi.util.Key;
import com.intellij.execution.process.ProcessOutputTypes;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class MethodMessageContainer extends MessageContainerBase<LeafTestMessage> implements TestMessage {
  private static final Logger LOG = LogManager.getLogger(MethodMessageContainer.class);
  @Nullable
  private final TestMethodNodeKey myMethodNode;
  private File myFile = null;

  public MethodMessageContainer(@Nullable TestMethodNodeKey methodNode, MessageFilter filter) {
    super(filter);
    myMethodNode = methodNode;
  }

  @Override
  public boolean matches(@NotNull MessageFilter filter) {
    // here nodes must coincide if not null 
    return filter.accept(myMethodNode);
  }

  @Override
  @NotNull
  public LeafTestMessage createChildMessage(@NotNull TextTestEvent event) {
    return new LeafTestMessage(myMethodNode, event.getText(), event.getKey());
  }

  @Override
  public int size() {
    return ListSequence.fromList(getChildren()).count();
  }

  @Override
  public boolean accepts(@NotNull TextTestEvent event) {
    TestNodeKey testNodeKey = event.getCurrentTestNode();
    return Objects.equals(myMethodNode, testNodeKey);
  }

  @Override
  public void flush() {
    if (myFile == null) {
      myFile = FileUtil.createTmpFile();
      myFile.deleteOnExit();
    }
    DataOutputStream stream = null;
    try {
      stream = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(myFile, true)));
      for (LeafTestMessage child : ListSequence.fromList(getChildren())) {
        String key = child.myKey.toString();
        String text = child.myText;
        IOUtil.writeString(key + text, stream);
      }
      stream.flush();
      clear();
    } catch (IOException e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Cant write messages for " + myMethodNode, e);
      }
    } finally {
      if (stream != null) {
        try {
          stream.close();
        } catch (IOException ignore) {
        }
      }
    }
  }

  @Override
  public void printOn(@NotNull Printer printer) {
    if (getFilter().accept(myMethodNode)) {
      if (myFile != null) {
        DataInputStream stream = null;
        try {
          stream = new DataInputStream(new BufferedInputStream(new FileInputStream(myFile)));
          while (stream.available() > 0) {
            String line = IOUtil.readString(stream);
            if (line == null) {
              break;
            }
            Key contentType = findKey(line);
            if (contentType != null) {
              String lineWithoutType = line.substring(contentType.toString().length());
              printer.print(lineWithoutType, contentType);
            } else {
              printer.print("Could not parse line:\n" + line + "\n", ProcessOutputTypes.SYSTEM);
            }
          }
        } catch (IOException e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Cant read messages for test " + myMethodNode, e);
          }
        } finally {
          if (stream != null) {
            try {
              stream.close();
            } catch (IOException ignore) {
            }
          }
        }
      }

      super.printOn(printer);
    }
  }

  @Nullable
  private Key findKey(final String line) {
    return ListSequence.fromList(ListSequence.fromListAndArray(new ArrayList<Key>(), ProcessOutputTypes.STDERR, ProcessOutputTypes.SYSTEM, ProcessOutputTypes.STDOUT)).findFirst(new IWhereFilter<Key>() {
      public boolean accept(Key it) {
        return line.startsWith(it.toString());
      }
    });
  }
}
