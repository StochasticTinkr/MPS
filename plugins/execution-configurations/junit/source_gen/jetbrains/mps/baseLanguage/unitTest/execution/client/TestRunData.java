package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.baseLanguage.unitTest.execution.TestMethodNodeKey;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeKey;
import com.intellij.openapi.util.Key;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.unitTest.execution.TestType;

/**
 * A pack of test data which needs to be transferred between the model and the clients of the model updates
 */
public final class TestRunData {
  /**
   * mutable fields below
   */
  /*package*/ final List<TestMethodNodeKey> myTestMethodsLeftToRun = ListSequence.fromList(new ArrayList<TestMethodNodeKey>());
  /*package*/ TestNodeKey myCurrentTestNode;
  /*package*/ String myCurrentNotExecutedDueToTerminationClass;
  /*package*/ String myCurrentNotExecutedDueToTerminationMethod;

  /*package*/ int myTotalTests;
  /*package*/ int myCompletedTests = 0;
  /*package*/ int myFailedTests = 0;
  /*package*/ boolean myTerminated;
  /*package*/ boolean myTerminatedCorrectly;
  /*package*/ String myAvailableText = null;
  /*package*/ Key myKey = null;

  public int getTotalTests() {
    return myTotalTests;
  }

  public int getFailedTests() {
    return myFailedTests;
  }

  public int getCompletedTests() {
    return myCompletedTests;
  }

  @NotNull
  public String getCurrentTestCase() {
    return myCurrentTestNode.getTestCaseFqName();
  }

  @Nullable
  public String getCurrentMethod() {
    if (myCurrentTestNode.getType() == TestType.METHOD) {
      return ((TestMethodNodeKey) myCurrentTestNode).getTestMethodName();
    }
    return null;
  }

  public String getNotExecutedMethod() {
    return myCurrentNotExecutedDueToTerminationMethod;
  }

  public String getNotExecutedTestCase() {
    return myCurrentNotExecutedDueToTerminationClass;
  }

  public boolean isTerminated() {
    return myTerminated;
  }

  public boolean isTerminatedCorrectly() {
    return myTerminated;
  }

  public String getAvailableText() {
    return myAvailableText;
  }

  public Key getKey() {
    return myKey;
  }

  @NotNull
  public TestRunData copy() {
    TestRunData dataCopy = new TestRunData();
    ListSequence.fromList(dataCopy.myTestMethodsLeftToRun).addSequence(ListSequence.fromList(myTestMethodsLeftToRun));
    dataCopy.myCurrentTestNode = myCurrentTestNode;
    dataCopy.myCurrentNotExecutedDueToTerminationClass = myCurrentNotExecutedDueToTerminationClass;
    dataCopy.myCurrentNotExecutedDueToTerminationMethod = myCurrentNotExecutedDueToTerminationMethod;
    dataCopy.myTotalTests = myTotalTests;
    dataCopy.myCompletedTests = myCompletedTests;
    dataCopy.myFailedTests = myFailedTests;
    dataCopy.myTerminated = myTerminated;
    dataCopy.myTerminatedCorrectly = myTerminatedCorrectly;
    dataCopy.myAvailableText = myAvailableText;
    dataCopy.myKey = myKey;
    return dataCopy;
  }
}
