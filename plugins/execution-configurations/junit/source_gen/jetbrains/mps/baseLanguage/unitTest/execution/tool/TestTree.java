package jetbrains.mps.baseLanguage.unitTest.execution.tool;

/*Generated by MPS */

import jetbrains.mps.ide.ui.tree.MPSTree;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestView;
import com.intellij.openapi.Disposable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunState;
import com.intellij.openapi.util.Disposer;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import com.intellij.openapi.actionSystem.ActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.unitTest.execution.TestEvent;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelReadRunnable;
import jetbrains.mps.ide.ui.tree.TextTreeNode;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.openapi.navigation.EditorNavigator;

public class TestTree extends MPSTree implements TestView, Disposable {
  @NotNull
  private final Project myProject;
  private final TestRunState myState;
  private TestNameMap<TestCaseTreeNode, TestMethodTreeNode> myMap;
  private boolean myAllTree = true;
  private final TestTreeIconAnimator myAnimator;

  public TestTree(TestRunState state, @NotNull Project project, Disposable disposable) {
    Disposer.register(disposable, this);
    myState = state;
    myProject = project;
    myMap = new TestNameMap<TestCaseTreeNode, TestMethodTreeNode>();
    myAllTree = !(UnitTestOptions.isHidePassed());
    myAnimator = new TestTreeIconAnimator(this);
    myAnimator.init(state);
  }

  private void updateState(@Nullable TestMethodTreeNode methodNode, TestCaseTreeNode testCaseNode, TestState testState) {
    if (methodNode != null) {
      methodNode.setState(testState);
    }
    Iterable<TestState> priorityList = Sequence.fromArray(TestState.values());
    TestState oldState = testCaseNode.getState();
    if (Sequence.fromIterable(priorityList).indexOf(oldState) < Sequence.fromIterable(priorityList).indexOf(testState)) {
      if (TestState.PASSED.equals(testState)) {
        for (MPSTreeNode method : testCaseNode) {
          if (!(TestState.PASSED.equals(((TestMethodTreeNode) method).getState()))) {
            return;
          }
        }
      }
      testCaseNode.setState(testState);
    }
  }

  @Override
  protected ActionGroup createPopupActionGroup(MPSTreeNode node) {
    if (node instanceof TestCaseTreeNode) {
      return ActionUtils.getGroup("jetbrains.mps.ide.actions.JUnitTestCaseActions_ActionGroup");
    }
    if (node instanceof TestMethodTreeNode) {
      return ActionUtils.getGroup("jetbrains.mps.ide.actions.JUnitTestMethodActions_ActionGroup");
    }
    return null;
  }

  @Override
  public void update() {
    if (myState.getAvailableText() != null) {
      return;
    }
    String lostTest = myState.getLostClass();
    String lostMethod = myState.getLostMethod();
    String test = myState.getCurrentClass();
    String method = myState.getCurrentMethod();
    final Wrappers._T<TestMethodTreeNode> methodNode = new Wrappers._T<TestMethodTreeNode>();
    if (lostTest != null && lostMethod != null) {
      methodNode.value = get(lostTest, lostMethod);
      TestCaseTreeNode testCaseNode = get(lostTest);
      if (methodNode.value != null && testCaseNode != null) {
        updateState(methodNode.value, testCaseNode, TestState.ERROR);
      }
    } else {
      TestCaseTreeNode testCaseNode = get(test);
      methodNode.value = get(test, method);
      if (testCaseNode != null) {
        if (myState.isTerminated()) {
          updateState(methodNode.value, testCaseNode, TestState.TERMINATED);
          myAnimator.stopMovie();
        } else if (TestEvent.START_TEST_PREFIX.equals(myState.getToken())) {
          updateState(methodNode.value, testCaseNode, TestState.IN_PROGRESS);
          SwingUtilities.invokeLater(new Runnable() {
            public void run() {
              myAnimator.scheduleRepaint();
            }
          });
          if (UnitTestOptions.isTrackRunning()) {
            if (methodNode.value != null) {
              SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                  setCurrentNode(methodNode.value);
                }
              });
            }
          }
        } else if (TestEvent.FINISH_TEST_PREFIX.equals(myState.getToken())) {
          if (methodNode.value != null && TestState.IN_PROGRESS.equals(methodNode.value.getState())) {
            updateState(methodNode.value, testCaseNode, TestState.PASSED);
          }
        } else if (TestEvent.ASSUMPTION_FAILURE_TEST_PREFIX.equals(myState.getToken()) || TestEvent.IGNORE_FAILURE_TEST_PREFIX.equals(myState.getToken())) {
          updateState(methodNode.value, testCaseNode, TestState.IGNORED);
        } else if (TestEvent.FAILURE_TEST_PREFIX.equals(myState.getToken())) {
          if (methodNode.value != null) {
            methodNode.value.setState(TestState.FAILED);
            updateState(methodNode.value, testCaseNode, TestState.ERROR);
          }
        }
      }
    }
    if (isFailed(methodNode.value) && UnitTestOptions.isSelectFirstFailded()) {
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          selectFirstDefectNode();
        }
      });
    }
    if (UnitTestOptions.isHidePassed()) {
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          hidePassed(true);
        }
      });
    }
  }

  @Override
  public void dispose() {
    if (!(isDisposed())) {
      super.dispose();
    }
    myAnimator.dispose();
  }

  @Override
  protected void runRebuildAction(Runnable rebuildAction, boolean saveExpansion) {
    super.runRebuildAction(new ModelReadRunnable(myProject.getModelAccess(), rebuildAction), saveExpansion);
  }

  @Override
  public void init() {
    rebuildNow();
    expandAll();
  }

  @Override
  public MPSTreeNode rebuild() {
    MPSTreeNode root = new TextTreeNode("Tests");
    setRootVisible(false);
    TestNameMap<TestCaseTreeNode, TestMethodTreeNode> temp = new TestNameMap<TestCaseTreeNode, TestMethodTreeNode>();
    for (ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myState.getTestsMap()).keySet())) {
      if (testCase == null) {
        continue;
      }
      TestCaseTreeNode testCaseTreeNode = myMap.get(testCase.getFqName());
      if (testCaseTreeNode == null) {
        testCaseTreeNode = new TestCaseTreeNode(testCase);
      }
      testCaseTreeNode.removeAllChildren();
      boolean hasTestNotPassed = false;
      for (ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myState.getTestsMap()).get(testCase))) {
        TestMethodTreeNode oldMethodTreeNode = myMap.get(testCase.getFqName(), method.getName());
        TestMethodTreeNode newMethodTreeNode = new TestMethodTreeNode(method);
        TestMethodTreeNode methodTreeNode = (oldMethodTreeNode == null ? newMethodTreeNode : oldMethodTreeNode);
        boolean isNotPassedMethod = !(isPassed(methodTreeNode));
        hasTestNotPassed = hasTestNotPassed || isNotPassedMethod;
        if (myAllTree || isNotPassedMethod) {
          if (methodTreeNode == null) {
            continue;
          }
          testCaseTreeNode.add(methodTreeNode);
          temp.put(testCase, method, methodTreeNode);
        } else {
          temp.put(testCase, method, methodTreeNode);
        }
      }
      if (myAllTree || hasTestNotPassed) {
        root.add(testCaseTreeNode);
        temp.put(testCase, testCaseTreeNode);
      } else {
        temp.put(testCase, testCaseTreeNode);
      }
    }
    myMap = temp;
    return root;
  }

  public boolean hasFailedTests() {
    for (ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myState.getTestsMap()).keySet())) {
      if (testCase == null) {
        continue;
      }
      for (ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myState.getTestsMap()).get(testCase))) {
        String className = testCase.getFqName();
        String methodName = method.getName();
        TestMethodTreeNode treeNode = myMap.get(className, methodName);
        if (method == null) {
          continue;
        }
        if (!(isPassed(treeNode))) {
          return true;
        }
      }
    }
    return false;
  }

  public void hidePassed(boolean hide) {
    myAllTree = !(hide);
    rebuildNow();
    expandAll();
  }

  public void buildFailedTestTree() {
    myAllTree = false;
    rebuildNow();
  }

  public List<String> getMethodName() {
    List<String> result = ListSequence.fromList(new ArrayList<String>());
    for (List<ITestNodeWrapper> values : MapSequence.fromMap(myState.getTestsMap()).values()) {
      for (ITestNodeWrapper value : values) {
        ListSequence.fromList(result).addElement(value.getName());
      }
    }
    return result;
  }

  public TestCaseTreeNode get(String className) {
    return myMap.get(className);
  }

  public TestMethodTreeNode get(String className, String methodName) {
    return myMap.get(className, methodName);
  }

  public void selectFirstDefectNode() {
    for (ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myState.getTestsMap()).keySet())) {
      for (ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myState.getTestsMap()).get(testCase))) {
        String className = testCase.getFqName();
        String methodName = method.getName();
        // FIXME Is it true myMap.get(string, string) is the best way to find failed test??? 
        TestMethodTreeNode testMethodTreeNode = myMap.get(className, methodName);
        if (isFailed(testMethodTreeNode)) {
          setCurrentNode(testMethodTreeNode);
          return;
        }
      }
    }
  }

  public static boolean isFailed(MPSTreeNode node) {
    if (node == null || !(node.isLeaf())) {
      return false;
    }
    TestMethodTreeNode leaf = (TestMethodTreeNode) node;
    TestState state = leaf.getState();
    return state.equals(TestState.ERROR) || state.equals(TestState.FAILED);
  }

  public static boolean isPassed(TestMethodTreeNode method) {
    if (method == null) {
      return true;
    }
    return method.getState() != null && method.getState().equals(TestState.PASSED);
  }

  @Override
  protected void doubleClick(@NotNull MPSTreeNode nodeToClick) {
    if (nodeToClick instanceof BaseTestTreeNode) {
      BaseTestTreeNode tn = ((BaseTestTreeNode) nodeToClick);
      new EditorNavigator(myProject).shallFocus(true).shallSelect(tn.isLeaf()).open(tn.getTestWrapper().getNodePointer());
    } else {
      super.doubleClick(nodeToClick);
    }
  }
}
