package jetbrains.mps.baseLanguage.unitTest.execution.tool;

/*Generated by MPS */

import jetbrains.mps.ide.ui.tree.MPSTree;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunStateUpdateListener;
import com.intellij.openapi.Disposable;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.Project;
import java.util.Map;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import java.util.List;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunState;
import com.intellij.openapi.util.Disposer;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.intellij.openapi.actionSystem.ActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunData;
import org.apache.log4j.Level;
import jetbrains.mps.baseLanguage.unitTest.execution.TestEvent;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelReadRunnable;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.openapi.navigation.EditorNavigator;

public class TestTree extends MPSTree implements TestRunStateUpdateListener, Disposable {
  private static final Logger LOG_1836409113 = LogManager.getLogger(TestTree.class);
  @NotNull
  private final Project myProject;
  private volatile TestNameMap<TestCaseTreeNode, TestMethodTreeNode> myTreeNodeMap;
  private boolean myShowPassedTests = true;
  private final TestTreeIconRepainter myAnimator;
  private final Map<ITestNodeWrapper, List<ITestNodeWrapper>> myTestsMap;
  /**
   * set to false once and then always false
   */
  private boolean myNoTestIsRunning = true;

  public TestTree(@NotNull TestRunState state, @NotNull Project project, Disposable disposable) {
    Disposer.register(disposable, this);
    myTestsMap = state.getTestsMap();
    myProject = project;
    myTreeNodeMap = new TestNameMap<TestCaseTreeNode, TestMethodTreeNode>();
    myShowPassedTests = !(UnitTestOptions.isHidePassed());
    myAnimator = new TestTreeIconRepainter(this);
  }

  private void updateState(@NotNull TestTreeNode treeNode, TestState testState) {
    updateState1(treeNode, testState, true);
  }

  private void updateState1(@NotNull TestTreeNode treeNode, TestState testState, boolean propagateToAncestor) {
    updateState0(treeNode, testState);
    // propagate to children by default 
    for (MPSTreeNode child : Sequence.fromIterable(treeNode)) {
      updateState1((TestTreeNode) child, testState, false);
    }
    if (propagateToAncestor) {
      TestTreeNode ancestor = treeNode;
      while ((ancestor = (TestTreeNode) ancestor.getParent()) != null) {
        updateState0(ancestor, testState);
      }
    }
    myAnimator.scheduleRepaint(treeNode);
  }

  private void updateState0(TestTreeNode treeNode, TestState newState) {
    TestState oldState = treeNode.getState();
    if (oldState.ordinal() < newState.ordinal()) {
      treeNode.setState(newState);
      myAnimator.scheduleRepaint(treeNode);
    }
  }

  @Override
  protected ActionGroup createPopupActionGroup(MPSTreeNode node) {
    if (node instanceof TestCaseTreeNode) {
      return ActionUtils.getGroup("jetbrains.mps.ide.actions.JUnitTestCaseActions_ActionGroup");
    }
    if (node instanceof TestMethodTreeNode) {
      return ActionUtils.getGroup("jetbrains.mps.ide.actions.JUnitTestMethodActions_ActionGroup");
    }
    return null;
  }

  @Override
  public void update(@NotNull TestRunData data) {
    if (data.getAvailableText() != null) {
      return;
    }
    myNoTestIsRunning = false;
    String currentTest = data.getCurrentTestCase();
    String currentMethod = data.getCurrentMethod();
    TestCaseTreeNode currentTestCaseNode = getClassTreeNode(currentTest);
    final TestMethodTreeNode currentTestMethodNode = getMethodTreeNode(currentTest, currentMethod);
    TestTreeNode currentNonNullNode = (currentTestMethodNode == null ? currentTestCaseNode : currentTestMethodNode);
    if (currentNonNullNode == null) {
      if (LOG_1836409113.isEnabledFor(Level.WARN)) {
        LOG_1836409113.warn("all current nodes are null", new Throwable());
      }
      return;
    }
    if (data.isTerminated()) {
      TestState newState = (data.isTerminatedCorrectly() ? TestState.TERMINATED : TestState.ERROR);
      updateState(currentNonNullNode, newState);
      myAnimator.stopMovie();
      if (!(data.isTerminatedCorrectly())) {
        String lostTest = data.getNotExecutedTestCase();
        String lostMethod = data.getNotExecutedMethod();
        if (lostTest != null && lostMethod != null) {
          TestMethodTreeNode lostMethodNode = getMethodTreeNode(lostTest, lostMethod);
          TestCaseTreeNode lostTestCaseNode = getClassTreeNode(lostTest);
          if (lostMethodNode != null && lostTestCaseNode != null) {
            updateState(lostMethodNode, TestState.ERROR);
          }
        }
      }
    } else {
      if (currentTestCaseNode != null) {
        String token = data.getToken();
        if (TestEvent.START_TEST_PREFIX.equals(token)) {
          updateState(currentNonNullNode, TestState.IN_PROGRESS);
          TestTree.invokeLater(new Runnable() {
            public void run() {
              myAnimator.scheduleRepaint(currentTestMethodNode);
            }
          });
          if (UnitTestOptions.isTrackRunning()) {
            if (currentTestMethodNode != null) {
              TestTree.invokeLater(new Runnable() {
                public void run() {
                  setCurrentNode(currentTestMethodNode);
                }
              });
            }
          }
        } else if (TestEvent.FINISH_TEST_PREFIX.equals(token)) {
          if (TestState.IN_PROGRESS.equals(currentNonNullNode.getState())) {
            updateStateSpecial(currentNonNullNode, TestState.PASSED);
          }
        } else if (TestEvent.ASSUMPTION_FAILURE_TEST_PREFIX.equals(token)) {
          updateState(currentNonNullNode, TestState.ERROR);
        } else if (TestEvent.IGNORE_FAILURE_TEST_PREFIX.equals(token)) {
          updateStateSpecial(currentNonNullNode, TestState.IGNORED);
        } else if (TestEvent.FAILURE_TEST_PREFIX.equals(token)) {
          updateState(currentNonNullNode, TestState.FAILED);
        }
      }
    }
    if (isFailed(currentTestMethodNode) && UnitTestOptions.isSelectFirstFailed()) {
      TestTree.invokeLater(new Runnable() {
        public void run() {
          selectFirstDefectNode();
        }
      });
    }
    if (UnitTestOptions.isHidePassed()) {
      TestTree.invokeLater(new Runnable() {
        public void run() {
          hidePassed(true);
        }
      });
    }
  }

  private static void invokeLater(Runnable r) {
    SwingUtilities.invokeLater(r);
  }

  /**
   * updates test node for the passed & ignored states which have a different parent-children TestState relation
   */
  private void updateStateSpecial(@NotNull TestTreeNode testNode, TestState terminalNonErrorState) {
    assert terminalNonErrorState.isFinished() && !(terminalNonErrorState.isErrored());
    updateState0(testNode, terminalNonErrorState);
    while ((testNode = (TestTreeNode) testNode.getParent()) != null) {
      if (getTestNodeState(testNode).isFinished()) {
        return;
      }
      // not yet set 
      TestState newState = terminalNonErrorState;
      for (MPSTreeNode child : Sequence.fromIterable(testNode)) {
        TestState childState = getTestNodeState(child);
        assert !(childState.isErrored());
        if (!(childState.isFinished())) {
          return;
        }
        // all children are finished and no errors 
        if (newState.ordinal() < childState.ordinal()) {
          newState = childState;
        }
      }
      updateState0(testNode, newState);
    }
  }

  @NotNull
  private TestState getTestNodeState(@NotNull MPSTreeNode node) {
    return ((TestTreeNode) node).getState();
  }

  @Override
  public void dispose() {
    if (!(isDisposed())) {
      super.dispose();
    }
    myAnimator.dispose();
  }

  @Override
  protected void runRebuildAction(Runnable rebuildAction, boolean saveExpansion) {
    super.runRebuildAction(new ModelReadRunnable(myProject.getModelAccess(), rebuildAction), saveExpansion);
  }

  public void init() {
    rebuildNow();
    expandAll();
  }

  @Override
  public MPSTreeNode rebuild() {
    TestTreeNode root = new RootTestTreeNode();
    setRootVisible(true);
    TestNameMap<TestCaseTreeNode, TestMethodTreeNode> newTree = new TestNameMap<TestCaseTreeNode, TestMethodTreeNode>();
    for (ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myTestsMap).keySet())) {
      if (testCase == null) {
        continue;
      }
      TestCaseTreeNode testCaseTreeNode = myTreeNodeMap.get(testCase.getFqName());
      if (testCaseTreeNode == null) {
        testCaseTreeNode = new TestCaseTreeNode(testCase);
      }
      testCaseTreeNode.removeAllChildren();
      boolean hasTestNotPassed = false;
      for (ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myTestsMap).get(testCase))) {
        TestMethodTreeNode oldMethodTreeNode = myTreeNodeMap.get(testCase.getFqName(), method.getName());
        TestMethodTreeNode newMethodTreeNode = new TestMethodTreeNode(method);
        TestMethodTreeNode methodTreeNode = (oldMethodTreeNode == null ? newMethodTreeNode : oldMethodTreeNode);
        boolean isNotPassedMethod = !(isPassed(methodTreeNode));
        hasTestNotPassed = hasTestNotPassed || isNotPassedMethod;
        if (myShowPassedTests || isNotPassedMethod) {
          testCaseTreeNode.add(methodTreeNode);
          newTree.put(testCase, method, methodTreeNode);
        } else {
          newTree.put(testCase, method, methodTreeNode);
        }
      }
      if (myShowPassedTests || hasTestNotPassed) {
        root.add(testCaseTreeNode);
        newTree.put(testCase, testCaseTreeNode);
      } else {
        newTree.put(testCase, testCaseTreeNode);
      }
    }
    if (myNoTestIsRunning) {
      updateState0(root, TestState.IN_PROGRESS);
      myAnimator.scheduleRepaint(root);
    }

    myTreeNodeMap = newTree;
    return root;
  }

  public boolean hasFailedTests() {
    for (ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myTestsMap).keySet())) {
      if (testCase == null) {
        continue;
      }
      for (ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myTestsMap).get(testCase))) {
        String className = testCase.getFqName();
        String methodName = method.getName();
        TestMethodTreeNode treeNode = myTreeNodeMap.get(className, methodName);
        if (method == null) {
          continue;
        }
        if (!(isPassed(treeNode))) {
          return true;
        }
      }
    }
    return false;
  }

  public void hidePassed(boolean hide) {
    myShowPassedTests = !(hide);
    rebuildNow();
    expandAll();
  }

  public void buildFailedTestTree() {
    myShowPassedTests = false;
    rebuildNow();
  }

  public TestCaseTreeNode getClassTreeNode(String className) {
    return myTreeNodeMap.get(className);
  }

  public TestMethodTreeNode getMethodTreeNode(String className, String methodName) {
    return myTreeNodeMap.get(className, methodName);
  }

  private void selectFirstDefectNode() {
    for (ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myTestsMap).keySet())) {
      for (ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myTestsMap).get(testCase))) {
        String className = testCase.getFqName();
        String methodName = method.getName();
        // FIXME Is it true myMap.get(string, string) is the best way to find failed test??? 
        TestMethodTreeNode testMethodTreeNode = myTreeNodeMap.get(className, methodName);
        if (isFailed(testMethodTreeNode)) {
          setCurrentNode(testMethodTreeNode);
          return;
        }
      }
    }
  }

  /*package*/ static boolean isFailed(MPSTreeNode node) {
    if (node == null || !(node.isLeaf())) {
      return false;
    }
    TestMethodTreeNode leaf = (TestMethodTreeNode) node;
    TestState state = leaf.getState();
    return state.equals(TestState.ERROR) || state.equals(TestState.FAILED);
  }

  /*package*/ static boolean isPassed(TestMethodTreeNode method) {
    if (method == null) {
      return true;
    }
    return method.getState() != null && method.getState().equals(TestState.PASSED);
  }

  @Override
  protected void doubleClick(@NotNull MPSTreeNode nodeToClick) {
    if (nodeToClick instanceof NonRootTestTreeNode) {
      NonRootTestTreeNode tn = ((NonRootTestTreeNode) nodeToClick);
      new EditorNavigator(myProject).shallFocus(true).shallSelect(tn.isLeaf()).open(tn.getTestWrapper().getNodePointer());
    } else {
      super.doubleClick(nodeToClick);
    }
  }
}
