package jetbrains.mps.baseLanguage.unitTest.execution.tool;

/*Generated by MPS */

import jetbrains.mps.ide.ui.tree.MPSTree;
import com.intellij.openapi.Disposable;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestStateListener;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.annotations.Immutable;
import java.util.Map;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunState;
import com.intellij.openapi.util.Disposer;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.actionSystem.ActionGroup;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import jetbrains.mps.workbench.action.ActionUtils;
import javax.swing.SwingUtilities;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.openapi.navigation.EditorNavigator;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeEvent;
import jetbrains.mps.baseLanguage.unitTest.execution.TerminationTestEvent;
import jetbrains.mps.baseLanguage.unitTest.execution.TestNodeKey;
import jetbrains.mps.baseLanguage.unitTest.execution.TestMethodNodeKey;
import jetbrains.mps.baseLanguage.unitTest.execution.TextTestEvent;

/**
 * we need to remove string association aka TestNameMap
 */
public class TestTree extends MPSTree implements Disposable, TestStateListener {
  private final RootTestTreeNode myRoot = new RootTestTreeNode();

  @NotNull
  private final Project myProject;
  private final TestTreeIconRepainter myAnimator;
  @Immutable
  private final Map<ITestNodeWrapper, List<ITestNodeWrapper>> myTestCase2MethodsMap;
  private final Map<ITestNodeWrapper, TestTreeNode> myNode2UINodeMap;

  /**
   * ordered!
   */
  private final Map<ITestNodeWrapper, TestState> myTests2State = MapSequence.fromMap(new LinkedHashMap<ITestNodeWrapper, TestState>(16, (float) 0.75, false));

  public TestTree(@NotNull TestRunState state, @NotNull Project project, Disposable disposable) {
    Disposer.register(disposable, this);
    myTestCase2MethodsMap = state.getTestsMap();
    myNode2UINodeMap = buildModelUIMapping();
    myProject = project;
    myAnimator = new TestTreeIconRepainter(this);
  }

  private Map<ITestNodeWrapper, TestTreeNode> buildModelUIMapping() {
    Map<ITestNodeWrapper, TestTreeNode> result = MapSequence.fromMap(new LinkedHashMap<ITestNodeWrapper, TestTreeNode>(16, (float) 0.75, false));
    for (ITestNodeWrapper testCase : MapSequence.fromMap(myTestCase2MethodsMap).keySet()) {
      MapSequence.fromMap(result).put(testCase, new TestCaseTreeNode(testCase));
      Iterable<ITestNodeWrapper> testMethods = testCase.getTestMethods();
      for (ITestNodeWrapper testMethod : Sequence.fromIterable(testMethods)) {
        MapSequence.fromMap(result).put(testMethod, new TestMethodTreeNode(testMethod));
      }
    }
    return result;
  }

  private void updateState(@NotNull ITestNodeWrapper node, TestState testState) {
    updateState1(node, testState, true);
  }

  private void updateState1(@NotNull ITestNodeWrapper node, TestState testState, boolean propagateToParent) {
    updateState0(node, testState);
    // propagate to children by default 
    for (ITestNodeWrapper child : ListSequence.fromList(getChildren(node))) {
      updateState1(child, testState, false);
    }
    if (propagateToParent) {
      ITestNodeWrapper ancestor = node;
      while ((ancestor = getParent(ancestor)) != null) {
        updateState0(ancestor, testState);
      }
    }
  }

  private void updateState0(@NotNull ITestNodeWrapper node, TestState newState) {
    TestState oldState = getTestNodeState(node);
    if (oldState.ordinal() < newState.ordinal()) {
      MapSequence.fromMap(myTests2State).put(node, newState);
      TestTreeNode treeNode = getUINodeByModelNode(node);
      updateStateUI(treeNode, newState);
    }
  }

  private void updateStateUI(@NotNull TestTreeNode treeNode, TestState newState) {
    treeNode.setState(newState);
    myAnimator.scheduleRepaint(treeNode);
  }

  @Override
  protected ActionGroup createPopupActionGroup(MPSTreeNode node) {
    if (node instanceof TestCaseTreeNode) {
      return ActionUtils.getGroup("jetbrains.mps.ide.actions.JUnitTestCaseActions_ActionGroup");
    }
    if (node instanceof TestMethodTreeNode) {
      return ActionUtils.getGroup("jetbrains.mps.ide.actions.JUnitTestMethodActions_ActionGroup");
    }
    return null;
  }

  private static void invokeLater(Runnable r) {
    SwingUtilities.invokeLater(r);
  }

  /**
   * updates test node for the passed & ignored states which have a different parent-children TestState relation
   */
  private void updateStateSpecial(@NotNull ITestNodeWrapper testNode, TestState terminalNonErrorState) {
    assert terminalNonErrorState.isFinished() && !(terminalNonErrorState.isErrored());
    updateState0(testNode, terminalNonErrorState);
    while ((testNode = getParent(testNode)) != null) {
      if (getTestNodeState(testNode).isFinished()) {
        return;
      }
      // not yet set 
      TestState newState = terminalNonErrorState;
      for (ITestNodeWrapper child : ListSequence.fromList(getChildren(testNode))) {
        TestState childState = getTestNodeState(child);
        assert !(childState.isErrored());
        if (!(childState.isFinished())) {
          return;
        }
        // all children are finished and no errors 
        if (newState.ordinal() < childState.ordinal()) {
          newState = childState;
        }
      }
      updateState0(testNode, newState);
    }
  }

  private ITestNodeWrapper getParent(@NotNull ITestNodeWrapper testNode) {
    return testNode.getTestCase();
  }

  @NotNull
  private List<ITestNodeWrapper> getChildren(@NotNull ITestNodeWrapper testNode) {
    Iterable<ITestNodeWrapper> testMethods = testNode.getTestMethods();
    return Sequence.fromIterable(testMethods).toListSequence();
  }

  @NotNull
  private TestState getTestNodeState(@NotNull ITestNodeWrapper node) {
    TestState state = MapSequence.fromMap(myTests2State).get(node);
    if (state == null) {
      return TestState.NOT_RAN;
    }
    return state;
  }

  @Override
  public void dispose() {
    if (!(isDisposed())) {
      super.dispose();
    }
    myAnimator.dispose();
  }


  public void init() {
    rebuildNow();
    expandAll();
  }

  @Override
  public MPSTreeNode rebuild() {
    boolean hidePassed = UnitTestOptions.isHidePassed();

    boolean allTestCasesPassed = true;
    myRoot.removeAllChildren();
    for (ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myTestCase2MethodsMap).keySet())) {
      assert testCase != null;
      boolean allTestMethodsPassed = true;
      TestCaseTreeNode testCaseTreeNode = (TestCaseTreeNode) getUINodeByModelNode(testCase);
      testCaseTreeNode.removeAllChildren();
      for (ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myTestCase2MethodsMap).get(testCase))) {
        TestMethodTreeNode methodTreeNode = (TestMethodTreeNode) getUINodeByModelNode(method);
        if (!(hidePassed) || !(isPassed(method))) {
          testCaseTreeNode.add(methodTreeNode);
        }
        allTestMethodsPassed &= isPassed(method);
      }
      if (!(hidePassed) || !(isPassed(testCase))) {
        myRoot.add(testCaseTreeNode);
      }
      allTestCasesPassed &= allTestMethodsPassed;
    }
    if (hidePassed && allTestCasesPassed) {
      myRoot.setText("All Tests Passed");
    } else {
      myRoot.setText("<root>");
    }
    return myRoot;
  }

  public boolean hasNotPassedTests() {
    return MapSequence.fromMap(myTests2State).any(new IWhereFilter<IMapping<ITestNodeWrapper, TestState>>() {
      public boolean accept(IMapping<ITestNodeWrapper, TestState> it) {
        return it.value() != TestState.PASSED;
      }
    });
  }

  /*package*/ boolean isPassed(@NotNull ITestNodeWrapper node) {
    TestState state = MapSequence.fromMap(myTests2State).get(node);
    return state == TestState.PASSED;
  }

  @Override
  protected void doubleClick(@NotNull MPSTreeNode nodeToClick) {
    if (nodeToClick instanceof NonRootTestTreeNode) {
      NonRootTestTreeNode treeNode = (NonRootTestTreeNode) nodeToClick;
      new EditorNavigator(myProject).shallFocus(true).shallSelect(treeNode.isLeaf()).open(treeNode.getTestNode().getNodePointer());
    } else {
      super.doubleClick(nodeToClick);
    }
  }

  @Override
  public void onTestRunStarted() {
  }

  private void selectFirstFailedTestIfNeeded() {
    if (UnitTestOptions.isSelectFirstFailed()) {
      IMapping<ITestNodeWrapper, TestState> state = MapSequence.fromMap(myTests2State).findFirst(new IWhereFilter<IMapping<ITestNodeWrapper, TestState>>() {
        public boolean accept(IMapping<ITestNodeWrapper, TestState> it) {
          return it.value() != TestState.PASSED;
        }
      });
      if (state == null) {
        return;
      }
      ITestNodeWrapper firstNotPassed = state.key();
      final TestTreeNode treeNode = getUINodeByModelNode(firstNotPassed);
      TestTree.invokeLater(new Runnable() {
        public void run() {
          setCurrentNode(treeNode);
        }
      });
    }
  }

  @Override
  public void onTestRunFinished() {
    updateRootStateWithMaxInSubtree();
    selectFirstFailedTestIfNeeded();
  }

  private void updateRootStateWithMaxInSubtree() {
    TestState max = TestState.NOT_RAN;
    for (IMapping<ITestNodeWrapper, TestState> entry : MapSequence.fromMap(myTests2State)) {
      if (max.ordinal() < entry.value().ordinal()) {
        max = entry.value();
      }
    }
    updateStateUI(myRoot, max);
  }

  @Override
  public void onTestStart(TestNodeEvent event) {
    final ITestNodeWrapper currentNode = event.getTestKey().getNode();
    updateState(currentNode, TestState.IN_PROGRESS);
    if (UnitTestOptions.isTrackRunning()) {
      TestTree.invokeLater(new Runnable() {
        public void run() {
          setCurrentNode(getUINodeByModelNode(currentNode));
        }
      });
    }
  }

  @Override
  public void onTestFinish(TestNodeEvent event) {
    ITestNodeWrapper currentNode = event.getTestKey().getNode();
    updateStateSpecial(currentNode, TestState.PASSED);
  }

  @Override
  public void onTestFailure(TestNodeEvent event) {
    ITestNodeWrapper currentNode = event.getTestKey().getNode();
    updateState(currentNode, TestState.FAILED);
  }

  @Override
  public void onTestAssumptionFailure(TestNodeEvent event) {
    ITestNodeWrapper currentNode = event.getTestKey().getNode();
    updateState(currentNode, TestState.ERROR);
  }

  @Override
  public void onTestIgnored(TestNodeEvent event) {
    ITestNodeWrapper currentNode = event.getTestKey().getNode();
    updateStateSpecial(currentNode, TestState.IGNORED);
  }

  @Override
  public void onTermination(@NotNull TerminationTestEvent event) {
    updateCurrentNodeOnTermination(event);
    updateNotRanTestsOnTermination(event.getNotRanTests(), event.isTerminatedCorrectly());
    updateRootStateWithMaxInSubtree();
  }

  private void updateCurrentNodeOnTermination(TerminationTestEvent event) {
    TestState newTerminatedState = (event.isTerminatedCorrectly() ? TestState.TERMINATED : TestState.ERROR);
    TestNodeKey lastExecutingTest = event.getCurrentRunningTest();
    if (lastExecutingTest != null) {
      updateState(lastExecutingTest.getNode(), newTerminatedState);
    }
  }

  private void updateNotRanTestsOnTermination(List<TestMethodNodeKey> testMethods, boolean correctTermination) {
    TestState newState = (correctTermination ? TestState.TERMINATED : TestState.SKIPPED);
    for (TestMethodNodeKey testMethod : ListSequence.fromList(testMethods)) {
      updateState(testMethod.getNode(), newState);
    }
  }

  @NotNull
  private TestTreeNode getUINodeByModelNode(@NotNull ITestNodeWrapper testNode) {
    return MapSequence.fromMap(myNode2UINodeMap).get(testNode);
  }

  @Override
  public void onProcessNotified() {
    updateStateUI(myRoot, TestState.IN_PROGRESS);
  }

  @Override
  public void onTextAvailable(@NotNull TextTestEvent event) {
  }
}
