package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestCase__BehaviorDescriptor;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestable__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestMethod__BehaviorDescriptor;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import java.util.Objects;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.facets.JavaModuleFacet;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.annotations.NonNls;

public class LanguageTestWrapper extends AbstractTestWrapper<SNode> {
  private final ITestNodeWrapper myTestCase;
  private final String myName;
  private final String myQualifiedName;
  private List<ITestNodeWrapper> myMethods;

  public LanguageTestWrapper(SNode test) {
    super(test, (boolean) ITestCase__BehaviorDescriptor.canRunInProcess_id5_jSk8paieB.invoke(test), (boolean) ITestable__BehaviorDescriptor.isMpsStartRequired_id2RMg39tmiFh.invoke(test));
    myTestCase = null;
    myName = ITestCase__BehaviorDescriptor.getSimpleClassName_idhSQIE8p.invoke(test);
    myQualifiedName = ITestCase__BehaviorDescriptor.getClassName_idhGBnqtL.invoke(test);
    // It used to be TestNodeWrapperFactory.tryWrap for test.getTestMethods(), however, with EditorTestCase being both ITestCase AND ITestMethod, 
    // there's no chance for TNWF to guess proper LTW constructor without further refactoring (it ends up with two identical LTW instances, both isTestCase == true),  
    // therefore, we use explicit cons for child LTW (used to be a hack 919afafa, that gave method's name if node happens to be ITestMethod).  
    // With that, indeed, we loose extensibility of TNWF, but I don't care too much as it's MPS-controlled factory anyway (let alone I doubt there's ever need to  
    // have anything else under a wrapper for ITestCase). 
    //  Proper fix would be to introduce tryToWrap(ITestNodeWrapper container, node<>) method, that would respect owner testcase explicitly. 
    myMethods = ListSequence.fromList(ITestCase__BehaviorDescriptor.getTestMethods_id1RfJDyhAUar.invoke(test)).select(new ISelector<SNode, LanguageTestWrapper>() {
      public LanguageTestWrapper select(SNode it) {
        return new LanguageTestWrapper(LanguageTestWrapper.this, it);
      }
    }).ofType(ITestNodeWrapper.class).toListSequence();
  }

  public LanguageTestWrapper(@NotNull ITestNodeWrapper testCase, @NotNull SNode testMethod) {
    // perhaps, shall derive MPS requirement form ITestNodeWrapper, but as long as isMpsStartRequired is in ITestable, don't see a reason. 
    super(testMethod, testCase.canRunInProcess(), (boolean) ITestable__BehaviorDescriptor.isMpsStartRequired_id2RMg39tmiFh.invoke(testMethod));
    myTestCase = testCase;
    myName = ITestMethod__BehaviorDescriptor.getTestName_idhGBohAB.invoke(testMethod);
    myQualifiedName = testCase.getFqName() + '.' + myName;
    myMethods = ListSequence.fromList(new ArrayList<ITestNodeWrapper>(0));
  }

  @Override
  public final boolean isTestCase() {
    return myTestCase == null;
  }

  @Nullable
  @Override
  public ITestNodeWrapper getTestCase() {
    return myTestCase;
  }

  @NotNull
  @Override
  public Iterable<ITestNodeWrapper> getTestMethods() {
    return myMethods;
  }

  @Override
  public int hashCode() {
    // I need this for the EditorTestCase for which two LTW were equal 
    return Objects.hash(myNodePointer, isTestCase());
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    LanguageTestWrapper that = (LanguageTestWrapper) o;
    // I need this for the EditorTestCase for which two LTW were equal 
    return myNodePointer.equals(that.myNodePointer) && isTestCase() == that.isTestCase();
  }

  /**
   * FIXME Dead code. Left as a reminder to check if there's need to do anything about classpath of runtime modules of lang.test; I don't see a reason to import them explicitly as
   * they have to get there as a dependency of a test module anyway (after all, it's written using test languages)
   */
  private void getIdeaClasspath() {
    final List<String> result = ListSequence.fromList(new ArrayList<String>());
    Iterable<SModuleReference> languageRuntimes = MetaAdapterFactory.getLanguage(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, "jetbrains.mps.lang.test").getLanguageRuntimes();
    for (SModuleReference dep : Sequence.fromIterable(languageRuntimes)) {
      SModule module = dep.resolve(getRepo());
      JavaModuleFacet facet = module.getFacet(JavaModuleFacet.class);
      if (facet != null) {
        ListSequence.fromList(result).addSequence(SetSequence.fromSet(facet.getClassPath()));
      }
    }
  }

  @NonNls
  @Override
  public String getFqName() {
    return myQualifiedName;
  }

  @NonNls
  @Override
  public String getName() {
    return myName;
  }
}
