package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestCase__BehaviorDescriptor;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestable__BehaviorDescriptor;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestMethod__BehaviorDescriptor;
import org.jetbrains.annotations.Nullable;
import java.util.function.Function;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import java.util.Set;
import com.intellij.openapi.application.PathMacros;
import java.util.List;
import jetbrains.mps.baseLanguage.execution.api.JvmArgs;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.baseLanguage.unitTest.execution.server.WithPlatformTestExecutor;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.facets.JavaModuleFacet;
import org.jetbrains.annotations.NonNls;

public class LanguageTestWrapper extends AbstractTestWrapper<SNode> {
  private final ITestNodeWrapper myTestCase;
  private final String myName;
  private final String myQualifiedName;
  private final boolean myNeedsMPS;

  public LanguageTestWrapper(SNode test) {
    super(test, (boolean) ITestCase__BehaviorDescriptor.canRunInProcess_id5_jSk8paieB.invoke(test));
    myTestCase = null;
    myName = ITestCase__BehaviorDescriptor.getSimpleClassName_idhSQIE8p.invoke(test);
    myQualifiedName = ITestCase__BehaviorDescriptor.getClassName_idhGBnqtL.invoke(test);
    myNeedsMPS = (boolean) ITestable__BehaviorDescriptor.isMpsStartRequired_id2RMg39tmiFh.invoke(test);
  }

  public LanguageTestWrapper(@NotNull ITestNodeWrapper testCase, @NotNull SNode testMethod) {
    super(testMethod, testCase.canRunInProcess());
    myTestCase = testCase;
    myName = ITestMethod__BehaviorDescriptor.getTestName_idhGBohAB.invoke(testMethod);
    myQualifiedName = testCase.getFqName() + '.' + myName;
    // perhaps, shall derive MPS requirement form ITestNodeWrapper, but as long as isMpsStartRequired is in ITestable, don't see a reason. 
    myNeedsMPS = (boolean) ITestable__BehaviorDescriptor.isMpsStartRequired_id2RMg39tmiFh.invoke(testMethod);
  }

  @Override
  public boolean isTestCase() {
    return myTestCase == null;
  }

  @Nullable
  @Override
  public ITestNodeWrapper getTestCase() {
    return myTestCase;
  }

  @NotNull
  @Override
  public Iterable<ITestNodeWrapper> getTestMethods() {
    return withNode(new Function<SNode, Iterable<ITestNodeWrapper>>() {
      public Iterable<ITestNodeWrapper> apply(SNode node) {
        if (!(SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xf61473f9130f42f6L, 0xb98d6c438812c2f6L, 0x11b2709bd56L, "jetbrains.mps.baseLanguage.unitTest.structure.ITestCase")))) {
          return LanguageTestWrapper.super.getTestMethods();
        }
        return ListSequence.fromList(ITestCase__BehaviorDescriptor.getTestMethods_id1RfJDyhAUar.invoke(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xf61473f9130f42f6L, 0xb98d6c438812c2f6L, 0x11b2709bd56L, "jetbrains.mps.baseLanguage.unitTest.structure.ITestCase")))).select(new ISelector<SNode, ITestNodeWrapper>() {
          public ITestNodeWrapper select(SNode it) {
            return TestNodeWrapperFactory.tryToWrap(it);
          }
        }).where(new NotNullWhereFilter<ITestNodeWrapper>()).toListSequence();
      }
    });
  }

  @Override
  @NotNull
  public TestParameters getTestRunParameters() {
    TestParameters rp = super.getTestRunParameters();
    if (myNeedsMPS) {
      // FIXME move macros into JUnit_Command, too 
      Set<String> userMacroNames = PathMacros.getInstance().getUserMacroNames();
      List<String> jvmArgsWithMacros = ListSequence.fromList(JvmArgs.getDefaultJvmArgs()).union(SetSequence.fromSet(userMacroNames).select(new ISelector<String, String>() {
        public String select(String key) {
          return String.format("-Dpath.macro.%s=\"%s\"", key, jetbrains.mps.project.PathMacros.getInstance().getValue(key));
        }
      })).toListSequence();
      return new TestParameters(WithPlatformTestExecutor.class, true, ListSequence.fromList(rp.getClassPath()).toListSequence(), jvmArgsWithMacros);
    } else {
      return rp;
    }
  }


  /**
   * FIXME Dead code. Left as a reminder to check if there's need to do anything about classpath of runtime modules of lang.test; I don't see a reason to import them explicitly as
   * they have to get there as a dependency of a test module anyway (after all, it's written using test languages)
   */
  private void getIdeaClasspath() {
    final List<String> result = ListSequence.fromList(new ArrayList<String>());
    Iterable<SModuleReference> languageRuntimes = MetaAdapterFactory.getLanguage(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, "jetbrains.mps.lang.test").getLanguageRuntimes();
    for (SModuleReference dep : Sequence.fromIterable(languageRuntimes)) {
      SModule module = dep.resolve(getRepo());
      JavaModuleFacet facet = module.getFacet(JavaModuleFacet.class);
      if (facet != null) {
        ListSequence.fromList(result).addSequence(SetSequence.fromSet(facet.getClassPath()));
      }
    }
  }

  @NonNls
  @Override
  public String getFqName() {
    return myQualifiedName;
  }

  @NonNls
  @Override
  public String getName() {
    return myName;
  }
}
