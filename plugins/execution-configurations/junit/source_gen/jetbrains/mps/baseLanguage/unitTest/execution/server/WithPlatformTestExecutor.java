package jetbrains.mps.baseLanguage.unitTest.execution.server;

/*Generated by MPS */

import java.io.IOException;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.util.test.CachesUtil;
import jetbrains.mps.tool.environment.IdeaEnvironment;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import java.util.Properties;
import jetbrains.mps.core.tool.environment.util.CanonicalPath;
import java.io.File;

/**
 * Command-line front-end to launch MPS tests that need MPS environment (ITestable, incliding BTestCase, and JUnit3/JUnit4 ClassConcept with respective annotation/superclass) 
 * 
 * FIXME At the moment, starts MPS on top of IDEA platform with no explicitly specified plugins (effectively means any available). 
 *       Would be great to configure that.
 */
public class WithPlatformTestExecutor extends DefaultTestExecutor {
  private static final String PATH_MACRO_PREFIX = "path.macro.";

  public WithPlatformTestExecutor(TestsContributor testsContributor) {
    super(testsContributor);
  }

  /**
   * Called when ITestCase is executed (except for BTestCase)
   */
  public static void main(String[] args) throws IOException {
    Environment env = startIdea();
    WithPlatformTestExecutor executor = new WithPlatformTestExecutor(new CommandLineTestsContributor(env, args));
    try {
      executor.run();
    } finally {
      env.dispose();
      CachesUtil.cleanupCaches();
      executor.exit();
    }
  }

  /*package*/ static IdeaEnvironment startIdea() {
    CachesUtil.setupCaches();

    // XXX would be great to have this code as part of init() method, but it's too much of refactoring now. Shall drop init/dispose of TestExecutor. 
    EnvironmentConfig cfg = EnvironmentConfig.defaultConfigNoPluginsSpecified();
    // test parameters of LanguageTestWrapper may supply path variables this way. Not sure it's the right way to move on, though. 
    // There are mps.macro. values in MpsTestsSuite that end up as EnvironmentConfig's macros and eventually as PathMacros's PathMacrosProvider, 
    // why do we duplicate same logic here but with "path.macro." prefix? 
    // FWIW, comment in TransformationTestRunner used to read: "to enable such macros as ${charisma}; see MPS-10568" 
    Properties sysProps = System.getProperties();
    for (String key : sysProps.stringPropertyNames()) {
      String value = sysProps.getProperty(key);
      if (key.startsWith(PATH_MACRO_PREFIX) && (value != null && value.length() > 0)) {
        CanonicalPath path = new CanonicalPath(value);
        if (path.isValidDirectory()) {
          // XXX the reason we limit path macros to directories only is hidden deep in the history, perhaps, there's no reason to? 
          // Besides, I don't like the idea we restrict this to *paths*, it's just a macro/property with a value, after all. 
          cfg.addMacro(key.substring(PATH_MACRO_PREFIX.length()), new File(path.getValue()));
        }
      }
    }
    IdeaEnvironment rv = new IdeaEnvironment(cfg);
    rv.init();
    return rv;
  }

}
