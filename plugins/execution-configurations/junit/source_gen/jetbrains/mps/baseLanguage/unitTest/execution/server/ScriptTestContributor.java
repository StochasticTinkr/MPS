package jetbrains.mps.baseLanguage.unitTest.execution.server;

/*Generated by MPS */

import jetbrains.mps.tool.environment.Environment;
import org.junit.runners.model.RunnerBuilder;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.testbench.junit.runners.PushEnvironmentRunnerBuilder;
import org.junit.runner.Request;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.module.ReloadableModule;
import org.junit.runner.Description;

/**
 * Contributes JUnit tests based on their serialized description in {@link jetbrains.mps.baseLanguage.unitTest.execution.server.ExecutorScript } using MPS module classloaders to access classes.
 * Note, this class doesn't care about {@link jetbrains.mps.baseLanguage.unitTest.execution.server.ExecutorScript#getStartupArguments() }, the value may be empty.
 * 
 * FIXME pretty much resembles MpsTestsSuite which is a runner for tests invoked from Ant. 
 *       Unlike this one, MpsTestsSuite runs all ITestCase found in the modules. Shall refactor both to reuse similar code.
 * 
 * XXX NodeWrappersTestsContributor is quite similar, too, with the only distinction that it uses ITestNodeWrapper instead of TestRecord
 * 
 * 
 * XXX This class may get relocated to j.m.tool.builder module along with ExecutorScript once I refactor MpsTestSuite to share classloading code.
 * 
 */
/*package*/ class ScriptTestContributor implements TestsContributor {
  private final Environment myEnv;
  private final ExecutorScript myExecScript;
  private final RunnerBuilder myRunnerBuilder;

  /*package*/ ScriptTestContributor(@NotNull Environment env, @NotNull ExecutorScript execScript) {
    myEnv = env;
    myExecScript = execScript;
    myRunnerBuilder = new PushEnvironmentRunnerBuilder(env);
  }

  @Override
  public Iterable<Request> gatherTests() throws Exception {
    // XXX likely, need better control over context repository to load test modules from 
    final SRepository repo = myEnv.getPlatform().findComponent(MPSModuleRepository.class);
    return new ModelAccessHelper(repo).runReadAction(new Computable<ArrayList<Request>>() {
      public ArrayList<Request> compute() {
        final PersistenceFacade pf = myEnv.getPlatform().findComponent(PersistenceRegistry.class);
        final ArrayList<Request> rv = new ArrayList<Request>();
        for (ExecutorScript.TestRecord tr : CollectionSequence.fromCollection(myExecScript.getTests())) {
          SModule testModule = pf.createModuleReference(tr.myTestModule).resolve(repo);
          final Exception failure;
          ReloadableModule classProvider = null;
          if (testModule instanceof ReloadableModule) {
            classProvider = (ReloadableModule) testModule;
            failure = null;
          } else {
            if (testModule == null) {
              failure = new Exception(String.format("Failed to find test module %s", tr.myTestModule));
            } else {
              failure = new Exception(String.format("Test module %s is not capable to load classes", tr.myTestModule));
            }
          }

          for (int i = 0; i < tr.myTestQualifiedName.size(); i++) {
            String qualifiedName = tr.myTestQualifiedName.get(i);
            String isTestCase = tr.isTestCase.get(i);
            String classFqName;
            if (Boolean.valueOf(isTestCase) == Boolean.TRUE) {
              classFqName = qualifiedName;
            } else {
              int indexOfLastDot = qualifiedName.lastIndexOf(".");
              classFqName = qualifiedName.substring(0, indexOfLastDot);
            }
            if (classProvider == null) {
              assert failure != null;
              rv.add(Request.runner(new AssumptionFailedRunner(failure, Description.createSuiteDescription(classFqName))));
            } else {
              try {
                Class<?> testClass = classProvider.getOwnClass(classFqName);
                rv.add(Request.runner(myRunnerBuilder.safeRunnerForClass(testClass)));
              } catch (Exception ex) {
                rv.add(Request.runner(new AssumptionFailedRunner(failure, Description.createSuiteDescription(classFqName))));
              }
            }
          }
        }
        return rv;
      }
    });
  }
}
