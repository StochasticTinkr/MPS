package jetbrains.mps.baseLanguage.unitTest.execution.tool;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.annotations.ImmutableReturn;
import jetbrains.mps.baseLanguage.unitTest.execution.TextTestEvent;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;

/**
 * A message which also has children and defines a recursive logic of text printing
 */
public abstract class MessageContainerBase<MSG extends TestMessage> implements MessagesContainer<MSG> {
  private final List<MSG> myChildren = ListSequence.fromList(new ArrayList<MSG>());

  private final MessageFilter myFilter;

  private int myNextFlush = 0;
  private int myCachedSize = -1;

  protected MessageContainerBase(@NotNull MessageFilter filter) {
    myFilter = filter;
  }

  @NotNull
  protected MessageFilter getFilter() {
    return myFilter;
  }

  @Override
  public void printOn(@NotNull Printer printer) {
    for (MSG childMessage : ListSequence.fromList(myChildren)) {
      if (childMessage.matches(myFilter)) {
        childMessage.printOn(printer);
      }
    }
  }

  @NotNull
  @ImmutableReturn
  @Override
  public List<MSG> getChildren() {
    return ListSequence.fromList(myChildren).asUnmodifiable();
  }

  protected void clearChildrenPreserveSize() {
    ListSequence.fromList(myChildren).clear();
  }

  @NotNull
  public TestMessage addMessage(@NotNull TextTestEvent textEvent) {
    if (!(accepts(textEvent))) {
      throw new MessagesContainer.EventIsNotAcceptedException(textEvent);
    }
    myCachedSize = -1;
    if (ListSequence.fromList(myChildren).isNotEmpty() && ListSequence.fromList(myChildren).last() instanceof MessagesContainer) {
      MessagesContainer last = (MessagesContainer) ListSequence.fromList(myChildren).last();
      if (last.accepts(textEvent)) {
        return last.addMessage(textEvent);
      }
    }
    MSG message = createChildMessage(textEvent);
    ListSequence.fromList(myChildren).addElement(message);
    return message;
  }

  /**
   * the contract is the same as for #addMessage: the method #accepts(textEvent) must return true
   */
  @NotNull
  public abstract MSG createChildMessage(@NotNull TextTestEvent textEvent);

  public void clear() {
    ListSequence.fromList(myChildren).clear();
    myCachedSize = -1;
  }

  public void flush() {
    MessageContainerBase nextFlush = (MessageContainerBase) ListSequence.fromList(myChildren).getElement(myNextFlush);
    while (!(nextFlush.canFlush())) {
      myNextFlush++;
      nextFlush = (MessageContainerBase) ListSequence.fromList(myChildren).getElement(myNextFlush);
    }
    nextFlush.flush();
    myCachedSize = -1;
  }

  public boolean canFlush() {
    for (MSG child : ListSequence.fromList(myChildren)) {
      if (child instanceof MessageContainerBase) {
        if (((MessageContainerBase) child).canFlush()) {
          return true;
        }
      } else {
        return true;
      }
    }
    return false;
  }

  public int size() {
    if (myCachedSize < 0) {
      myCachedSize = ListSequence.fromList(myChildren).foldLeft(0, new ILeftCombinator<MSG, Integer>() {
        public Integer combine(Integer s, MSG it) {
          return ((it instanceof MessageContainerBase) ? s + ((MessageContainerBase) it).size() : s + 1);
        }
      });
    }
    return myCachedSize;
  }
}
