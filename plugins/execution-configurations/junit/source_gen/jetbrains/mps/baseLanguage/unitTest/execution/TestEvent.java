package jetbrains.mps.baseLanguage.unitTest.execution;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.annotations.Nullable;
import org.junit.runner.Description;
import java.util.Objects;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public final class TestEvent {
  public static final String START_TEST_PREFIX = "<START_TEST>";
  public static final String FINISH_TEST_PREFIX = "<FINISH_TEST>";
  public static final String FAILURE_TEST_PREFIX = "<TEST_FAILURE_BEGIN>";
  public static final String ASSUMPTION_FAILURE_TEST_PREFIX = "<TEST_ASSUMPTION_FAILURE_BEGIN>";
  public static final String IGNORE_FAILURE_TEST_PREFIX = "<TEST_IGNORE_BEGIN>";

  private static List<String> ALL_TOKENS;
  private final String myToken;
  private final String myTestCaseName;
  @Nullable
  private final String myTestMethodName;
  private final long myMemoryUsage;
  private final long myTime;

  public TestEvent(String token, Description description) {
    myToken = token;
    // description.getTestClass() may be null (e.g. when failure indicates an issue with loading of test class) 
    myTestCaseName = description.getClassName();
    myTestMethodName = description.getMethodName();
    Runtime runtime = Runtime.getRuntime();
    myMemoryUsage = runtime.totalMemory() - runtime.freeMemory();
    myTime = System.currentTimeMillis();
  }

  public TestEvent(String token, String testCaseName, String testMethodName, long memoryUsage, long time) {
    myToken = token;
    myTestCaseName = testCaseName;
    myTestMethodName = testMethodName;
    myMemoryUsage = memoryUsage;
    myTime = time;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(this.myToken);
    builder.append(this.myTestCaseName);
    if (this.myTestMethodName != null) {
      builder.append(':').append(this.myTestMethodName);
    }
    builder.append(":memory=").append(this.myMemoryUsage);
    builder.append(":time=").append(this.myTime);
    return builder.toString();
  }

  public String getToken() {
    return this.myToken;
  }

  public String getTestCaseName() {
    return this.myTestCaseName;
  }

  public String getTestMethodName() {
    return this.myTestMethodName;
  }

  public long getMemoryUsage() {
    return this.myMemoryUsage;
  }

  public long getTime() {
    return this.myTime;
  }

  public boolean isTestCaseEvent() {
    return myTestMethodName == null;
  }

  @Override
  public boolean equals(Object p0) {
    if (p0 == null || !(p0 instanceof TestEvent)) {
      return false;
    }
    TestEvent event = (TestEvent) p0;
    return event.myToken.equals(this.myToken) && event.myTestCaseName.equals(this.myTestCaseName) && event.myTestMethodName.equals(this.myTestMethodName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(myToken, myTestCaseName, myTestMethodName);
  }

  public static String getEventToken(String messageString) {
    String token = null;
    for (String expectedToken : TestEvent.ALL_TOKENS) {
      if (messageString.startsWith(expectedToken)) {
        token = expectedToken;
        break;
      }
    }
    return token;
  }

  public static TestEvent parse(String messageString) {
    TestEvent testEvent = null;
    String expectedToken = getEventToken(messageString);
    if (expectedToken != null) {
      testEvent = parse(expectedToken, messageString);
    }
    return testEvent;
  }

  private static TestEvent parse(String expectedToken, String messageString) {
    TestEvent testEvent = null;
    if (messageString.startsWith(expectedToken)) {
      String params = messageString.substring(expectedToken.length());
      {
        Pattern _pattern_0 = REGEXP_6m48zo_a0a0b0b0nb;
        Matcher _matcher_0 = _pattern_0.matcher(params);
        if (_matcher_0.matches()) {
          testEvent = new TestEvent(expectedToken, _matcher_0.group(1), _matcher_0.group(2), Long.parseLong(_matcher_0.group(3)), Long.parseLong(_matcher_0.group(4)));
        }
      }
    }
    return testEvent;
  }

  static {
    TestEvent.ALL_TOKENS = ListSequence.fromListAndArray(new ArrayList<String>(), TestEvent.START_TEST_PREFIX, TestEvent.FINISH_TEST_PREFIX, TestEvent.FAILURE_TEST_PREFIX, TestEvent.ASSUMPTION_FAILURE_TEST_PREFIX, TestEvent.IGNORE_FAILURE_TEST_PREFIX);
  }
  private static Pattern REGEXP_6m48zo_a0a0b0b0nb = Pattern.compile("([^:]+)(?::([^:]+))?:memory=(\\d+):time=(\\d+)", 0);
}
