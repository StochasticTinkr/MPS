package jetbrains.mps.baseLanguage.execution.api;

/*Generated by MPS */

import java.util.List;
import java.net.URI;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.io.File;
import java.util.jar.Manifest;
import java.util.jar.Attributes;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import java.io.IOException;
import java.util.jar.JarOutputStream;
import java.io.FileOutputStream;

/**
 * Utility class to deal with classpath length limitation.
 * Creates a temporary jar file with META-INF/MANIFEST.MF holding Main-Class and Class-Path entries one could pass to java executable
 * (e.g. 'java -jar filename args').
 * Kept local to Java command though likely shall find a place somewhere in a shared location as it's not the 
 * only place in MPS we deal with long classpath issue.
 * Package-private as 'api' is not the best package for this utility class. Besides, the whole 'api' model has
 * to be restructured so that Java command is separate from JavaConfigurationEditorComponent
 */
/*package*/ class JarManifestBuilder {
  private String myMainClass;
  /**
   * We use URI to deal with file names that contain spaces and other non-friendly manifest characters
   * Class-Path entry value is treated as URI, therefore characters need to get escaped.
   * At the moment, I don't care about duplicates, though might be the right thing to do.
   */
  private final List<URI> myClassPath = ListSequence.fromList(new ArrayList<URI>());

  /**
   * 
   * @param mainClass overrides executable class setting
   */
  public JarManifestBuilder withMainClass(String mainClass) {
    myMainClass = mainClass;
    return this;
  }

  /**
   * 
   * @param paths augments class path
   */
  public JarManifestBuilder withFilenameClassPath(Iterable<String> paths) {
    withFilesClassPath(Sequence.fromIterable(paths).select(new ISelector<String, File>() {
      public File select(String it) {
        return new File(it);
      }
    }));
    return this;
  }

  /**
   * 
   * 
   * @param paths augments class path
   */
  public JarManifestBuilder withFilesClassPath(Iterable<File> paths) {
    withClassPath(Sequence.fromIterable(paths).select(new ISelector<File, URI>() {
      public URI select(File it) {
        return it.toURI();
      }
    }));
    return this;
  }

  /**
   * 
   * @param paths augments class path
   */
  public JarManifestBuilder withClassPath(Iterable<URI> paths) {
    ListSequence.fromList(myClassPath).addSequence(Sequence.fromIterable(paths));
    return this;
  }

  private Manifest createManifest() {
    Manifest m = new Manifest();
    // Manfest-Version is a mandatory attribute, though I didn't find this in the jar/manifest documentation 
    // I believe it's a defect in Attributes.writeMain, which doesn't save anything unless version has been specified. 
    m.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
    m.getMainAttributes().put(Attributes.Name.MAIN_CLASS, myMainClass);
    m.getMainAttributes().put(Attributes.Name.CLASS_PATH, IterableUtils.join(ListSequence.fromList(myClassPath).select(new ISelector<URI, String>() {
      public String select(URI it) {
        return it.toString();
      }
    }), " "));
    return m;
  }

  public File toTempFile() throws IOException {
    File tempJar = File.createTempFile("jmb", ".jar");
    tempJar.deleteOnExit();
    Manifest m = createManifest();
    JarOutputStream jarStream = new JarOutputStream(new FileOutputStream(tempJar), m);
    jarStream.close();
    return tempJar;
  }

}
