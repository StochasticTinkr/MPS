package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.baseLanguage.unitTest.execution.server.NodeWrappersTestsContributor;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestEventsDispatcher;
import jetbrains.mps.lang.test.util.TestInProcessRunState;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.lang.test.util.RunStateEnum;
import com.intellij.execution.process.ProcessHandler;
import com.intellij.execution.ExecutionException;
import jetbrains.mps.baseLanguage.unitTest.execution.server.TestInProcessExecutor;
import java.util.concurrent.Future;
import jetbrains.mps.baseLanguage.unitTest.execution.server.AbstractTestExecutor;
import com.intellij.openapi.application.ApplicationManager;
import org.apache.log4j.Level;
import jetbrains.mps.baseLanguage.unitTest.execution.server.DefaultTestExecutor;
import com.intellij.util.WaitFor;
import org.jetbrains.annotations.Nullable;
import java.io.OutputStream;
import com.intellij.execution.process.ProcessOutputTypes;

public class JUnitInProcessExecutor implements Executor {
  private static final Logger LOG = LogManager.getLogger(JUnitInProcessExecutor.class);
  private static final int MSECS_TO_WAIT_FOR_START = 50 * 1000;
  private final NodeWrappersTestsContributor myTestsContributor;
  private final TestEventsDispatcher myDispatcher;
  private final FakeProcess myFakeProcess = new FakeProcess();
  private static volatile TestInProcessRunState ourTestRunState = new TestInProcessRunState();

  public JUnitInProcessExecutor(Project mpsProject, Iterable<ITestNodeWrapper> testNodeWrappers, TestEventsDispatcher dispatcher) {
    myDispatcher = dispatcher;
    myTestsContributor = new NodeWrappersTestsContributor(mpsProject, testNodeWrappers);
  }

  private synchronized boolean checkExecutionIsPossible() {
    boolean isPossible = ourTestRunState.advance(RunStateEnum.IDLE, RunStateEnum.INITIALIZED);
    return isPossible;
  }

  @Override
  public ProcessHandler execute() throws ExecutionException {
    if (!(checkExecutionIsPossible())) {
      return new JUnitInProcessExecutor.EmptyProcessHandler();
    }
    final TestInProcessExecutor executor = new TestInProcessExecutor(myTestsContributor);
    final Future<?> future = doExecute(executor);
    // can use TestInProcessRunState instead of both process and future parameter, isDone == TERMINATED, init() == INITIALIZED -> READYTOEXECUTE 
    final FakeProcessHandler process = new FakeProcessHandler(myFakeProcess, future) {
      @Override
      public void startNotify() {
        super.startNotify();
        setReady();
      }

      @Override
      protected void requestTerminate() {
        // XXX why not isRunning() or at least !isTerminating && !isTerminated(); do we care to request stop few times? 
        if (!(ourTestRunState.isTerminated())) {
          ourTestRunState.advance(RunStateEnum.RUNNING, RunStateEnum.TERMINATING);
          executor.stopRun();
        }
        // once test execution is over, the runnable at thread pool get control, myFakeProcess receives exit code and is destroyed. 
        // Eventually, BaseOSProcessHandler dispaches notification that the process has been terminated. 

        // XXX Perhaps, we shall leave implementation of this method to BaseOSProcessHandler (which does Process.destroy()), and handle process destroy request instead? 
      }
    };
    return process;
  }

  private Future<?> doExecute(final AbstractTestExecutor executor) {
    return ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
      @Override
      public void run() {
        try {
          executor.init();
          waitUnlessProcessIsReady();
          assert ourTestRunState.isReady();
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Be aware of the execution of your own test code and its consequences when running tests in-process. " + "The code is being executed within the current MPS environment and might do a lot of damage if written without caution.");
          }
          if (LOG.isInfoEnabled()) {
            LOG.info("Executing tests in-process");
          }
          ourTestRunState.advance(RunStateEnum.READYTOEXECUTE, RunStateEnum.RUNNING);
          executor.execute();
          // regular test execution ends in RUNNING state. If we are in TERMINATING state here already, it means PH.requestTerminate triggered execution stop. 
          boolean cancelled = ourTestRunState.isTerminating();
          ourTestRunState.advance(RunStateEnum.RUNNING, RunStateEnum.TERMINATING);
          if (executor.getExecutionError() != null) {
            myFakeProcess.setExitCode(DefaultTestExecutor.EXIT_CODE_FOR_EXCEPTION);
          } else if (cancelled) {
            myFakeProcess.setExitCode(FakeProcess.TERMINATION_CODE);
          } else {
            myFakeProcess.setExitCode(executor.getFailureCount());
          }
          // copied from TestInProcessExecutor#terminateProcess(int), though not sure I see the point in TestEventsDispatcher use 
          String terminateMessage = "Process finished with exit code " + myFakeProcess.exitValue();
          if (LOG.isInfoEnabled()) {
            LOG.info(terminateMessage);
          }
          myDispatcher.onProcessTerminated(terminateMessage);
        } finally {
          executor.dispose();
          ourTestRunState.set(RunStateEnum.TERMINATED);
          JUnitInProcessExecutor.this.dispose();
        }
      }
    });
  }

  /*package*/ void setReady() {
    ourTestRunState.advance(RunStateEnum.INITIALIZED, RunStateEnum.READYTOEXECUTE);
  }

  /*package*/ void waitUnlessProcessIsReady() {
    // pooled thread waits for IDEA to fire off execution via ProcessHandler.startNotify 
    new WaitFor(MSECS_TO_WAIT_FOR_START) {
      @Override
      protected boolean condition() {
        return ourTestRunState.isReady();
      }
    };
    if (!(ourTestRunState.isReady())) {
      throw new IllegalStateException("Process is not ready");
    }
  }

  /**
   * FOR TEST USE ONLY
   */
  public static TestInProcessRunState getRunState() {
    return ourTestRunState;
  }

  private void dispose() {
    // BaseOSProcessHandler waits for the process to be destroyed (FakeProcess.waitFor), and then dispatches ProcessHandler.notifyProcessTerminated 
    myFakeProcess.destroy();
    ourTestRunState.reset();
  }

  private class EmptyProcessHandler extends ProcessHandler {
    protected void destroyProcessImpl() {
      //  shall never get here as the process is terminated from the very start 
    }

    protected void detachProcessImpl() {
      //  shall never get here as the process is terminated from the very start 
    }

    public boolean detachIsDefault() {
      return false;
    }

    @Nullable
    public OutputStream getProcessInput() {
      return null;
    }

    @Override
    public boolean isProcessTerminated() {
      return true;
    }

    @Override
    public void startNotify() {
      super.startNotify();
      String terminateMessage = "Only one test instance is allowed to run in process.\n" + "To run in the outer process change the corresponding property in the junit run configuration.\n" + "Process finished with exit code " + -1 + ".\n";
      myDispatcher.onSimpleTextAvailable(terminateMessage, ProcessOutputTypes.STDERR);
      myDispatcher.onProcessTerminated(terminateMessage);
      this.notifyProcessTerminated(-1);
    }
  }
}
