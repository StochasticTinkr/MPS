package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.Project;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.extapi.module.SRepositoryExt;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import org.jetbrains.mps.openapi.model.SNode;
import java.io.File;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.SModelOperations;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.ide.make.DefaultMakeMessageHandler;
import jetbrains.mps.make.IMakeService;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.resources.ModelsToResources;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import org.apache.log4j.Level;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.smodel.tempmodel.TempModule;
import java.util.Collections;
import jetbrains.mps.project.structure.model.ModelRootDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;

public class DeployScript {
  private static final Logger LOG = LogManager.getLogger(DeployScript.class);
  private final DeployScript.TemporalModuleWithDescriptorFile myModule;
  private final Project myProject;
  private final Set<SModel> myModelsToMake = SetSequence.fromSet(new HashSet<SModel>());
  private final String myDeployScriptPath;
  private final String myArtifactsPath;

  public DeployScript(@NotNull Project project, List<SNodeReference> plugins) {
    myProject = project;
    myModule = new DeployScript.TemporalModuleWithDescriptorFile();
    SRepository projectRepo = project.getRepository();
    assert projectRepo instanceof SRepositoryExt;
    (((SRepositoryExt) projectRepo)).registerModule(myModule, myModule);

    SModel model = TemporaryModels.getInstance().create(false, TempModuleOptions.forExistingModule(myModule));
    SetSequence.fromSet(myModelsToMake).addElement(model);

    SNode deployScriptNode = DeployScriptCreator.createDeployScript(myProject, plugins, myModule.getBaseDirectory());
    model.addRootNode(deployScriptNode);
    myDeployScriptPath = new File(myModule.getBaseDirectory(), ((String) BHReflection.invoke(deployScriptNode, SMethodTrimmedId.create("getOutputFileName", MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, "jetbrains.mps.build.structure.BuildProject"), "4gSHdTptyu0")))).getAbsolutePath();
    myArtifactsPath = new File(new File(new File(myModule.getBaseDirectory(), "build"), "artifacts"), SPropertyOperations.getString(deployScriptNode, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))).getAbsolutePath();

    SModelOperations.validateLanguagesAndImports(model, true, true);
  }

  @Nullable
  public String make() {
    MakeSession session = new MakeSession(myProject, new DefaultMakeMessageHandler(myProject), false);
    if (IMakeService.INSTANCE.get().openNewSession(session)) {
      Future<IResult> future = IMakeService.INSTANCE.get().make(session, new ModelsToResources(myModelsToMake).resources(false));
      IResult result = null;
      try {
        result = future.get();
      } catch (CancellationException ignore) {
      } catch (InterruptedException ignore) {
      } catch (ExecutionException ignore) {
      }
      if (result == null || !(result.isSucessful())) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Can not generate deploy script");
        }
        return null;
      }
      return myDeployScriptPath;
    }
    return null;
  }

  public String getArtifactsPath() {
    return myArtifactsPath;
  }
  public String getDeployScriptLocation() {
    return myDeployScriptPath;
  }

  public void dispose() {
    myProject.getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        SRepository projectRepo = myProject.getRepository();
        ((SRepositoryExt) projectRepo).unregisterModule(myModule, myProject);
        FileUtil.delete(myModule.getBaseDirectory());
      }
    });
  }

  private static class TemporalModuleWithDescriptorFile extends TempModule {
    private final File myDescriptorFile;
    private final File myBaseDir;
    private TemporalModuleWithDescriptorFile() {
      super(Collections.<ModelRootDescriptor>emptySet(), true, false);
      myBaseDir = FileUtil.createTmpDir();
      // just anything 
      myDescriptorFile = new File(myBaseDir, "module.msd");
    }
    @Override
    public IFile getDescriptorFile() {
      // who cares if this module has descriptor file? Do we need to extend TempModule? 
      return FileSystem.getInstance().getFileByPath(myDescriptorFile.getAbsolutePath().replace("\\", "/"));
    }
    public File getBaseDirectory() {
      return myBaseDir;
    }
    public boolean isPackaged() {
      // don't ask 
      return false;
    }
  }
}
