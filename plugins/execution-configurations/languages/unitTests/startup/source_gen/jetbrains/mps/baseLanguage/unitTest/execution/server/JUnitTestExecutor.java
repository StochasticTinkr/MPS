package jetbrains.mps.baseLanguage.unitTest.execution.server;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.junit.runner.notification.RunListener;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.test.util.RunEventsDispatcher;
import org.junit.runner.Request;
import org.junit.runner.JUnitCore;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.junit.runner.Result;
import org.junit.runner.notification.StoppedByUserException;
import org.apache.log4j.Level;

/**
 * Mechanism to execute tests using JUnit.
 * Tests are executed in the same thread.
 */
public class JUnitTestExecutor implements TestExecutor {
  private static final Logger LOG = LogManager.getLogger(JUnitTestExecutor.class);

  private StoppableRunner myCurrentRunner = null;
  private RunListener myListener;
  private volatile boolean myStopping = false;
  private final TestsContributor myTestContributor;
  private int myFailureCount = -1;
  private Throwable myException;

  public JUnitTestExecutor(@NotNull TestsContributor testContributor) {
    myTestContributor = testContributor;
  }

  @Nullable
  private StoppableRunner getCurrentRunner() {
    return myCurrentRunner;
  }

  @Override
  public void init() {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Initializing " + getClass().getSimpleName());
    }
  }

  @Override
  public void dispose() {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Disposing " + getClass().getSimpleName());
    }
  }

  @Override
  public void execute() {
    myFailureCount = 0;
    try {
      RunEventsDispatcher.getInstance().onTestRunStarted();
      Iterable<Request> requests = myTestContributor.gatherTests();
      JUnitCore jUnitCore = prepareJUnitCore(requests);
      doExecute(jUnitCore, requests);
      if (myListener != null) {
        // no real reason, just it's nice to clean up after yourself 
        jUnitCore.removeListener(myListener);
      }
    } catch (Throwable t) {
      // XXX myFailureCount may get invalid if exception is thrown from core.run 
      processThrowable(t);
    } finally {
      RunEventsDispatcher.getInstance().onTestRunFinished();
    }
  }

  private JUnitCore prepareJUnitCore(Iterable<Request> requests) {
    Iterable<Request> reqSeq = Sequence.fromIterable(requests);
    JUnitCore core = new JUnitCore();
    myListener = createListener(requests);
    core.addListener(myListener);
    if (!(Sequence.fromIterable(reqSeq).isEmpty())) {
      Request firstRequest = Sequence.fromIterable(reqSeq).first();
      updateRunner(firstRequest);
    }
    return core;
  }

  protected void doExecute(JUnitCore core, Iterable<Request> requests) throws Throwable {
    for (Request request : requests) {
      updateRunner(request);
      Result res = core.run(myCurrentRunner);
      myFailureCount += res.getFailureCount();
    }
  }

  public void stopRun() {
    StoppableRunner currentRunner = this.getCurrentRunner();
    assert currentRunner != null;
    currentRunner.pleaseStop();
    myStopping = true;
  }

  protected void processThrowable(Throwable t) {
    if (!(t instanceof StoppedByUserException)) {
      // StoppedByUserException means external intention to stop tests, no reason to log 
      myException = t;
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception in the test framework", t);
      }
    }
  }

  private void updateRunner(Request request) {
    //  FIXME boolean flag and extra runnable to monitor it is a bit too much, no? 
    // when we updateRunner() on each step, why can't we check myStoping == true inside doExecute()? 
    myCurrentRunner = new StoppableRunner(request, myStopping);
  }

  /**
   * 
   * @return -1 if tests were not executed, or number of failed tests otherwise.
   */
  public int getFailureCount() {
    return myFailureCount;
  }

  /**
   * 
   * @return non-null if there's an unexpected exception during JUnit run
   */
  @Nullable
  public Throwable getExecutionError() {
    return myException;
  }

  @Nullable
  protected RunListener getListener() {
    return myListener;
  }

  @NotNull
  protected RunListener createListener(Iterable<Request> requests) {
    return new DefaultRunListener(new CommandOutputStream(System.out));
  }
}
