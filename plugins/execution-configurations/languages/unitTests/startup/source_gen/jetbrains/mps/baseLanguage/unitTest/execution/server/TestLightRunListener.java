package jetbrains.mps.baseLanguage.unitTest.execution.server;

/*Generated by MPS */

import org.junit.runner.notification.RunListener;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestEventsDispatcher;
import org.junit.runner.notification.Failure;
import java.io.StringWriter;
import java.io.PrintWriter;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.junit.runner.Result;
import com.intellij.execution.process.ProcessOutputTypes;
import org.junit.runner.Description;
import jetbrains.mps.baseLanguage.unitTest.execution.TestEvent;
import org.junit.internal.AssumptionViolatedException;

public class TestLightRunListener extends RunListener {
  private final TestLightExecutor myExecutor;
  private final TestEventsDispatcher myDispatcher;
  private final int myRequestCount;
  private final TestLightRunListener.TestEventFactory myFactory;
  private int currentRequest;


  public TestLightRunListener(TestLightExecutor executor, int requestCount) {
    myExecutor = executor;
    myDispatcher = executor.getDispatcher();
    myRequestCount = requestCount;
    myFactory = new TestLightRunListener.TestEventFactory();
  }

  private String getStackTrace(Failure failure) {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    failure.getException().printStackTrace(pw);
    return sw.toString();
  }

  protected static Logger LOG = LogManager.getLogger(TestLightRunListener.class);
  @Override
  public void testRunFinished(Result result) throws Exception {
    if (++currentRequest == myRequestCount) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("TESTS WERE SUCCESSFUL " + result.wasSuccessful());
      }
      int code = result.getFailureCount();
      myExecutor.terminateProcess(code);
    } else {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Request #" + currentRequest + " is finished -- proceeding to the next request");
      }
    }
  }

  private void onTestErrorEvent(String startToken, String endToken, Failure failure) {
    myDispatcher.onTestEvent(myFactory.create(startToken, failure.getDescription()));
    final String text = getStackTrace(failure);
    myDispatcher.onSimpleTextAvailable(text, ProcessOutputTypes.STDERR);
    myDispatcher.onTestEvent(myFactory.create(endToken, failure.getDescription()));
  }

  private void onTestEvent(String token, Description description) throws Exception {
    myDispatcher.onTestEvent(myFactory.create(token, description));
  }

  @Override
  public void testFailure(Failure failure) throws Exception {
    if (LOG.isDebugEnabled()) {
      LOG.debug(TestEvent.FAILURE_TEST_PREFIX + failure.getDescription());
    }
    onTestErrorEvent(TestEvent.FAILURE_TEST_PREFIX, TestEvent.FAILURE_TEST_SUFFIX, failure);
  }

  @Override
  public void testAssumptionFailure(Failure failure) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(TestEvent.ASSUMPTION_FAILURE_TEST_PREFIX + failure.getDescription());
    }
    onTestErrorEvent(TestEvent.ASSUMPTION_FAILURE_TEST_PREFIX, TestEvent.ASSUMPTION_FAILURE_TEST_SUFFIX, failure);
  }

  @Override
  public void testIgnored(Description description) throws Exception {
    // testIgnored is the only event which does not come with testStarted and testEnded 
    // we emulate this behaviour below 
    Failure failure = new Failure(description, new AssumptionViolatedException("The test was ignored"));
    if (LOG.isDebugEnabled()) {
      LOG.debug("Ignore " + TestEvent.ASSUMPTION_FAILURE_TEST_PREFIX + failure.getDescription());
    }
    testStarted(description);
    onTestErrorEvent(TestEvent.ASSUMPTION_FAILURE_TEST_PREFIX, TestEvent.ASSUMPTION_FAILURE_TEST_SUFFIX, failure);
    testFinished(description);
  }

  @Override
  public void testStarted(Description description) throws Exception {
    if (LOG.isDebugEnabled()) {
      LOG.debug(TestEvent.START_TEST_PREFIX + description.getDisplayName());
    }
    onTestEvent(TestEvent.START_TEST_PREFIX, description);
  }

  @Override
  public void testFinished(Description description) throws Exception {
    if (LOG.isDebugEnabled()) {
      LOG.debug(TestEvent.FINISH_TEST_PREFIX + description.getDisplayName());
    }
    onTestEvent(TestEvent.FINISH_TEST_PREFIX, description);
  }

  private class TestEventFactory {
    public TestEvent create(String token, Description description) {
      String fqName = description.getClassName();
      String methodName = description.getMethodName();
      Runtime runtime = Runtime.getRuntime();
      long memory = runtime.totalMemory() - runtime.freeMemory();
      long time = System.currentTimeMillis();
      return new TestEvent(token, fqName, methodName, memory, time);
    }
  }
}
