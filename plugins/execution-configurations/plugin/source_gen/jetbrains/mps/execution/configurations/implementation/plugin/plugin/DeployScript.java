package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.Project;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.extapi.module.SRepositoryExt;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import org.jetbrains.mps.openapi.model.SNode;
import java.io.File;
import jetbrains.mps.build.behavior.BuildProject__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.ModelDependencyUpdate;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.ide.make.DefaultMakeMessageHandler;
import jetbrains.mps.make.IMakeService;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import org.apache.log4j.Level;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.smodel.tempmodel.TempModule;
import java.util.Collections;
import jetbrains.mps.project.structure.model.ModelRootDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.impl.IoFileSystem;

public class DeployScript {
  private static final Logger LOG = LogManager.getLogger(DeployScript.class);
  private final DeployScript.TemporalModuleWithDescriptorFile myModule;
  private final Project myProject;
  private final Set<SModel> myModelsToMake = SetSequence.fromSet(new HashSet<SModel>());
  private final String myDeployScriptPath;
  private final String myArtifactsPath;

  public DeployScript(@NotNull Project project, List<SNodeReference> plugins) {
    myProject = project;
    myModule = new DeployScript.TemporalModuleWithDescriptorFile();
    SRepository projectRepo = project.getRepository();
    assert projectRepo instanceof SRepositoryExt;
    ((SRepositoryExt) projectRepo).registerModule(myModule, myModule);

    SModel model = TemporaryModels.getInstance().create(false, TempModuleOptions.forExistingModule(myModule));
    SetSequence.fromSet(myModelsToMake).addElement(model);

    SNode deployScriptNode = DeployScriptCreator.createDeployScript(myProject, plugins, myModule.getBaseDirectory());
    model.addRootNode(deployScriptNode);
    myDeployScriptPath = new File(myModule.getBaseDirectory(), BuildProject__BehaviorDescriptor.getOutputFileName_id4gSHdTptyu0.invoke(deployScriptNode)).getAbsolutePath();
    myArtifactsPath = new File(new File(new File(myModule.getBaseDirectory(), "build"), "artifacts"), SPropertyOperations.getString(deployScriptNode, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))).getAbsolutePath();

    new ModelDependencyUpdate(model).updateUsedLanguages().updateImportedModels(projectRepo).updateModuleDependencies(projectRepo);
  }

  @Nullable
  public String make() {
    MakeSession session = new MakeSession(myProject, new DefaultMakeMessageHandler(myProject), false);
    if (IMakeService.INSTANCE.get().openNewSession(session)) {
      Future<IResult> future = IMakeService.INSTANCE.get().make(session, new ModelsToResources(myModelsToMake).canGenerateCondition(new _FunctionTypes._return_P1_E0<Boolean, SModel>() {
        public Boolean invoke(SModel m) {
          return true;
        }
      }).resources());
      IResult result = null;
      try {
        result = future.get();
      } catch (CancellationException ignore) {
      } catch (InterruptedException ignore) {
      } catch (ExecutionException ignore) {
      }
      if (result == null || !(result.isSucessful())) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Can not generate deploy script");
        }
        return null;
      }
      return myDeployScriptPath;
    }
    return null;
  }

  public String getArtifactsPath() {
    return myArtifactsPath;
  }
  public String getDeployScriptLocation() {
    return myDeployScriptPath;
  }

  public void dispose() {
    myProject.getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        SRepository projectRepo = myProject.getRepository();
        ((SRepositoryExt) projectRepo).unregisterModule(myModule, myProject);
        FileUtil.delete(myModule.getBaseDirectory());
      }
    });
  }

  private static class TemporalModuleWithDescriptorFile extends TempModule {
    private final File myDescriptorFile;
    private final File myBaseDir;

    private TemporalModuleWithDescriptorFile() {
      super(Collections.<ModelRootDescriptor>emptySet(), true, true);
      myBaseDir = FileUtil.createTmpDir();
      // just anything 
      myDescriptorFile = new File(myBaseDir, "module.msd");
    }

    @Override
    public IFile getDescriptorFile() {
      // who cares if this module has descriptor file? Do we need to extend TempModule? 
      return IoFileSystem.INSTANCE.getFile(myDescriptorFile.getAbsolutePath());
    }

    public File getBaseDirectory() {
      return myBaseDir;
    }

    public boolean isPackaged() {
      // don't ask 
      return false;
    }
  }
}
