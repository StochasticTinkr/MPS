package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.baseLanguage.unitTest.execution.server.NodeWrappersTestsContributor;
import jetbrains.mps.lang.test.util.TestInProcessRunState;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.lang.test.util.RunStateEnum;
import com.intellij.execution.process.ProcessHandler;
import com.intellij.execution.ExecutionException;
import jetbrains.mps.baseLanguage.unitTest.execution.server.JUnitTestExecutor;
import java.util.concurrent.Future;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.TestMode;
import jetbrains.mps.RuntimeFlags;
import org.apache.log4j.Level;
import jetbrains.mps.baseLanguage.unitTest.execution.server.DefaultTestExecutor;
import com.intellij.util.WaitFor;
import org.jetbrains.annotations.Nullable;
import java.io.OutputStream;
import com.intellij.execution.process.ProcessOutputTypes;

public class JUnitInProcessExecutor implements Executor {
  private static final Logger LOG = LogManager.getLogger(JUnitInProcessExecutor.class);
  private static final int MSECS_TO_WAIT_FOR_START = 50 * 1000;
  private final NodeWrappersTestsContributor myTestsContributor;
  private final FakeProcess myFakeProcess = new FakeProcess();
  private final TestInProcessRunState myTestRunState;

  public JUnitInProcessExecutor(Project mpsProject, Iterable<ITestNodeWrapper> testNodeWrappers) {
    myTestsContributor = new NodeWrappersTestsContributor(mpsProject, testNodeWrappers);
    myTestRunState = TestInProcessRunState.getInstance();
  }

  private synchronized boolean checkExecutionIsPossible() {
    boolean isPossible = myTestRunState.advance(RunStateEnum.IDLE, RunStateEnum.INITIALIZED);
    return isPossible;
  }

  @Override
  public ProcessHandler execute() throws ExecutionException {
    if (!(checkExecutionIsPossible())) {
      return new JUnitInProcessExecutor.EmptyProcessHandler();
    }
    final JUnitTestExecutor executor = new JUnitTestExecutor(myTestsContributor);
    final Future<?> future = doExecute(executor);
    // can use TestInProcessRunState instead of both process and future parameter, isDone == TERMINATED, startNotify() == INITIALIZED -> READYTOEXECUTE 
    // Alternatively, FakeProcess.init may do INITIALIZED -> READYTOEXECUTE, and rely on default ProcessHandler.isProcessTerminated implementation instead of Future.isDone 
    final FakeProcessHandler process = new FakeProcessHandler(myFakeProcess, future) {
      @Override
      public void startNotify() {
        super.startNotify();
        setReady();
      }

      @Override
      protected void requestTerminate() {
        // XXX why not isRunning() or at least !isTerminating && !isTerminated(); do we care to request stop few times? 
        if (!(myTestRunState.isTerminated())) {
          myTestRunState.advance(RunStateEnum.RUNNING, RunStateEnum.TERMINATING);
          executor.stopRun();
        }
        // once test execution is over, the runnable at thread pool get control, myFakeProcess receives exit code and is destroyed. 
        // Eventually, BaseOSProcessHandler dispaches notification that the process has been terminated. 

        // XXX Perhaps, we shall leave implementation of this method to BaseOSProcessHandler (which does Process.destroy()), and handle process destroy request instead? 
      }
    };
    return process;
  }

  private Future<?> doExecute(final JUnitTestExecutor executor) {
    return ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
      @Override
      public void run() {
        TestMode oldTestMode = RuntimeFlags.getTestMode();
        // Though there's dedicated JUnit runner in NodeWrappersTestsContributor that provides proper in-process TestRunner runner for BaseTransformationTest instances, 
        // it doesn't hurt to have this flag set anyway, just in case anyone asks if we are TestMode.isInsideTestEnvironment 
        RuntimeFlags.setTestMode(TestMode.IN_PROCESS);
        try {
          executor.init();
          waitUnlessProcessIsReady();
          assert myTestRunState.isReady();
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Be aware of the execution of your own test code and its consequences when running tests in-process. " + "The code is being executed within the current MPS environment and might do a lot of damage if written without caution.");
          }
          if (LOG.isInfoEnabled()) {
            LOG.info("Executing tests in-process");
          }
          myTestRunState.advance(RunStateEnum.READYTOEXECUTE, RunStateEnum.RUNNING);
          executor.execute();
          // regular test execution ends in RUNNING state. If we are in TERMINATING state here already, it means PH.requestTerminate triggered execution stop. 
          boolean cancelled = myTestRunState.isTerminating();
          myTestRunState.advance(RunStateEnum.RUNNING, RunStateEnum.TERMINATING);
          if (executor.getExecutionError() != null) {
            myFakeProcess.setExitCode(DefaultTestExecutor.EXIT_CODE_FOR_EXCEPTION);
          } else if (cancelled) {
            myFakeProcess.setExitCode(FakeProcess.TERMINATION_CODE);
          } else {
            myFakeProcess.setExitCode(executor.getFailureCount());
          }
          // copied from TestInProcessExecutor#terminateProcess(int), though not sure I see the point in TestEventsDispatcher use 
          String terminateMessage = "in-process test execution finished with exit code " + myFakeProcess.exitValue();
          if (LOG.isInfoEnabled()) {
            LOG.info(terminateMessage);
          }
          // once this Future is completed (isDone() == true), FakeProcessHandler terminates and process listeners  
          // have a change to notify others (e.g. TestRunState though UnitTestProcessListener with TestEventsDispatcher) 
        } finally {
          RuntimeFlags.setTestMode(oldTestMode);
          executor.dispose();
          myTestRunState.set(RunStateEnum.TERMINATED);
          JUnitInProcessExecutor.this.dispose();
        }
      }
    });
  }

  /*package*/ void setReady() {
    myTestRunState.advance(RunStateEnum.INITIALIZED, RunStateEnum.READYTOEXECUTE);
  }

  /*package*/ void waitUnlessProcessIsReady() {
    // pooled thread waits for IDEA to fire off execution via ProcessHandler.startNotify 
    new WaitFor(MSECS_TO_WAIT_FOR_START) {
      @Override
      protected boolean condition() {
        return myTestRunState.isReady();
      }
    };
    if (!(myTestRunState.isReady())) {
      throw new IllegalStateException("Process is not ready");
    }
  }

  private void dispose() {
    // BaseOSProcessHandler waits for the process to be destroyed (FakeProcess.waitFor), and then dispatches ProcessHandler.notifyProcessTerminated 
    myFakeProcess.destroy();
    myTestRunState.reset();
  }

  private class EmptyProcessHandler extends ProcessHandler {
    protected void destroyProcessImpl() {
      //  shall never get here as the process is terminated from the very start 
    }

    protected void detachProcessImpl() {
      //  shall never get here as the process is terminated from the very start 
    }

    public boolean detachIsDefault() {
      return false;
    }

    @Nullable
    public OutputStream getProcessInput() {
      return null;
    }

    @Override
    public boolean isProcessTerminated() {
      return true;
    }

    @Override
    public void startNotify() {
      super.startNotify();
      String terminateMessage = "Only one test instance is allowed to run in process.\n" + "To run in the outer process change the corresponding property in the junit run configuration.\n" + "Process finished with exit code " + -1 + ".\n";
      notifyTextAvailable(terminateMessage, ProcessOutputTypes.STDERR);
      this.notifyProcessTerminated(-1);
    }
  }
}
