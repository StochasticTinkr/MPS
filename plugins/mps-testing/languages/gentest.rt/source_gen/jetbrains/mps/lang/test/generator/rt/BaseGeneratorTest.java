package jetbrains.mps.lang.test.generator.rt;

/*Generated by MPS */

import jetbrains.mps.tool.environment.EnvironmentAware;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.project.Project;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.List;
import jetbrains.mps.lang.test.matcher.NodeDifference;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.generator.ModelGenerationPlan;

public class BaseGeneratorTest implements EnvironmentAware {
  private Environment myEnv;
  private Project myProject;


  @Override
  public void setEnvironment(@NotNull Environment env) {
    myEnv = env;
    myProject = myEnv.createEmptyProject();
  }

  protected final TransformHelper newTransformer() {
    return new TransformHelper(myProject);
  }

  protected final boolean match(SModel m1, SModel m2) {
    // Next is wishful thinking, imagined contract, not necessarily real at the moment, 
    // IOW, what I'd like match(m1,m2) contract to look like. Have to refactor  
    // NodesMatcher first, and write some tests for it to ensure the contract: 
    // return true if models are the same from structure, metadata, value and reference perspectives 
    // equality from reference perspective means that references within the same model point to  
    // equal (in aforementioned sense) nodes, for external references that the target is equal is java sense. 
    List<NodeDifference> diff = new NodesMatcher().match(SModelOperations.roots(m1, null), SModelOperations.roots(m2, null));
    return diff == null || diff.isEmpty();
  }

  protected final ModelGenerationPlan planFromModel(SModel gpm) {
    return null;
  }

  protected final SModel findModel(String modelRef) {
    return null;
  }
}
