package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.tool.environment.IdeaEnvironment;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import org.junit.Before;
import jetbrains.mps.lang.test.util.MpsTestRunListener;
import jetbrains.mps.lang.test.util.RunEventsDispatcher;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.generator.impl.CloneUtil;

public abstract class BaseTransformationTest implements TransformationTest {
  private Project myProject;
  private SModel myModel;
  private SModel myTransientModel;
  private TestRunner myRunner;

  /*package*/ static final TestModelSaver CACHE = new TestModelSaver();

  @NotNull
  private static TestRunner defaultTestRunner() {
    // it's expected that IDEA MPS plugin or in-process executor supply proper TestRunner using TransformationTestInitJUnitRunner 
    Environment ideaEnv = IdeaEnvironment.getOrCreate(EnvironmentConfig.defaultConfigNoPluginsSpecified());
    return new TransformationTestRunner(ideaEnv);
  }

  public BaseTransformationTest() {
  }

  @Override
  public void setTestRunner(TestRunner runner) {
    myRunner = runner;
  }

  @Override
  public TestRunner getTestRunner() {
    return myRunner;
  }

  @Before
  public void initTestRunner() {
    if (myRunner == null) {
      initTests();
    }
  }

  public void initTest(@NotNull String projectName, final String model) throws Exception {
    initTest(projectName, model, false);
  }

  public void initTest(@NotNull String projectName, final String model, boolean reOpenProject) throws Exception {
    myRunner.initTest(this, projectName, model, reOpenProject);
  }

  private void initTests() {
    setTestRunner(defaultTestRunner());
    // FIXME yes, listener is not registered when myRunner is initialized from outside; no, it's not intended. 
    //       try to replace with regular @AfterClass or drop CACHE altogether. 
    registerTestsListener();
  }

  private void registerTestsListener() {
    MpsTestRunListener listener = new MpsTestRunListener() {
      @Override
      public void testRunFinished() {
        CACHE.clean();
        RunEventsDispatcher.getInstance().removeListener(this);
      }

      @Override
      public void testRunStarted() {
      }
    };
    // FWIW, RunEventsDispatcher is likely to have sent testRunStarted already, as it's dispatched prior to Request processing (which leads to instantiation of this class) 
    // XXX if there are hundreds of tests running, does this code mean we have hundreds of listeners? 
    RunEventsDispatcher.getInstance().addListener(listener);
  }

  public void runTest(String className, final String methodName, final boolean runInCommand) throws Throwable {
    myRunner.runTest(this, className, methodName, runInCommand);
  }

  @Override
  public void init() {
    this.myTransientModel = TemporaryModels.getInstance().create(false, TempModuleOptions.forDefaultModule());
    new CloneUtil(this.myModel, this.myTransientModel).cloneModelWithAllImports();
  }

  @Override
  public void dispose() {
    TemporaryModels.getInstance().dispose(myTransientModel);
    myTransientModel = null;
  }

  @Override
  public SModel getModelDescriptor() {
    return myModel;
  }

  @Override
  public void setModelDescriptor(SModel descriptor) {
    myModel = descriptor;
  }

  @Override
  public void setTransientModelDescriptor(SModel descriptor) {
    myTransientModel = descriptor;
  }

  @Override
  public SModel getTransientModelDescriptor() {
    return myTransientModel;
  }

  @Override
  public Project getProject() {
    return myProject;
  }

  @Override
  public void setProject(Project project) {
    myProject = project;
  }
}
