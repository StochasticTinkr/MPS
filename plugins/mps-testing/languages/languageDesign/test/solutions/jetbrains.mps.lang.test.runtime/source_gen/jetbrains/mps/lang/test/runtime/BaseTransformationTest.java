package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.tool.environment.IdeaEnvironment;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import org.junit.Before;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.module.ReloadableModule;
import jetbrains.mps.ide.ThreadUtils;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.generator.impl.CloneUtil;
import org.junit.After;

public abstract class BaseTransformationTest implements TransformationTest {
  private static final Logger LOG = LogManager.getLogger(BaseTransformationTest.class);
  private Project myProject;
  private SModel myModel;
  private SModel myTransientModel;
  private TestRunner myRunner;
  private final TestParametersCache myParamCache;

  @NotNull
  private static TestRunner defaultTestRunner() {
    // it's expected that IDEA MPS plugin or in-process executor supply proper TestRunner using TransformationTestInitJUnitRunner 
    Environment ideaEnv = IdeaEnvironment.getOrCreate(EnvironmentConfig.defaultConfigNoPluginsSpecified());
    return new TransformationTestRunner(ideaEnv);
  }

  public BaseTransformationTest() {
    myParamCache = null;
  }

  public BaseTransformationTest(TestParametersCache paramCache) {
    myParamCache = paramCache;
  }

  @Override
  public void setTestRunner(TestRunner runner) {
    myRunner = runner;
  }

  @Override
  public TestRunner getTestRunner() {
    return myRunner;
  }

  @Before
  public void setup() throws Exception {
    if (myRunner == null) {
      setTestRunner(defaultTestRunner());
    }
    if (myParamCache != null) {
      //  invokes runner.iniTest() directly, without this.initTest() intermediary 
      myParamCache.populate(this);
    }
  }

  public void initTest(@NotNull String projectName, final String model) throws Exception {
    initTest(projectName, model, false);
  }

  public void initTest(@NotNull String projectName, final String model, boolean reOpenProject) throws Exception {
    myRunner.initTest(this, projectName, model, reOpenProject);
  }

  public void runTest(final String className, final String methodName, final boolean runInCommand) throws Throwable {
    if (LOG.isInfoEnabled()) {
      LOG.info("Running the test " + methodName);
    }
    final Wrappers._T<Class> clazz = new Wrappers._T<Class>();
    final Throwable[] error = new Throwable[1];

    getProject().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        final SModule module = getModelDescriptor().getModule();
        if (!(module instanceof ReloadableModule)) {
          error[0] = new IllegalArgumentException("module" + module + " is not reloadable -- cannot run tests in it");
          return;
        }
        try {
          clazz.value = ((ReloadableModule) module).getOwnClass(className);
        } catch (Throwable t) {
          error[0] = t;
        }
      }
    });
    if (error[0] != null) {
      throw error[0];
    }

    final Object obj = clazz.value.newInstance();
    clazz.value.getField("myModel").set(obj, getTransientModelDescriptor());
    clazz.value.getField("myProject").set(obj, getProject());
    if (runInCommand) {
      ThreadUtils.runInUIThreadAndWait(new Runnable() {
        public void run() {
          getProject().getModelAccess().executeCommand(new Runnable() {
            public void run() {
              error[0] = BaseTransformationTest.this.tryToRunTest(clazz.value, methodName, obj);
            }
          });
        }
      });
    } else {
      error[0] = this.tryToRunTest(clazz.value, methodName, obj);
    }
    if (error[0] != null) {
      if (LOG.isInfoEnabled()) {
        LOG.info("Test failed");
      }
      throw error[0];
    }
    if (LOG.isInfoEnabled()) {
      LOG.info("Test passed");
    }
  }

  /*package*/ Throwable tryToRunTest(Class clazz, String methodName, Object obj) {
    Throwable exception = null;
    try {
      clazz.getMethod(methodName).invoke(obj);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      exception = e.getTargetException();
    }
    return exception;
  }

  /**
   * FIXME Poor/unspecified contract. The method used to be invoked only once for a class with tests, although it's not apparent from the name.
   */
  @Override
  public void init() {
    // if we got here with myParamCache != null, it means it is being initialized, has invoked runner.initTest() which in turn got here. 
    // In this case, the code below shall move into TestParametersCache which is responsible to manage (i.e. dispose) transient model. 
    // However, for transition/migration period, we create a transient model here and let TPC pick it afterwards. This is to support tests that do not use 
    // TestParametersCache as ClassRule 
    this.myTransientModel = TemporaryModels.getInstance().create(false, TempModuleOptions.forDefaultModule());
    new CloneUtil(this.myModel, this.myTransientModel).cloneModelWithAllImports();
  }

  /**
   * FIXME explain/justify contract, see {@link jetbrains.mps.lang.test.runtime.BaseTransformationTest#init() }
   */
  @Override
  public void dispose() {
    TemporaryModels.getInstance().dispose(myTransientModel);
    myTransientModel = null;
  }

  @After
  public void tearDown() {
    if (myParamCache == null) {
      getProject().getModelAccess().runWriteInEDT(new Runnable() {
        public void run() {
          dispose();
        }
      });
      // otherwise, TPC does this for us after all tests of the class are executed 
    }
  }

  @Override
  public SModel getModelDescriptor() {
    return myModel;
  }

  @Override
  public void setModelDescriptor(SModel descriptor) {
    myModel = descriptor;
  }

  @Override
  public void setTransientModelDescriptor(SModel descriptor) {
    myTransientModel = descriptor;
  }

  @Override
  public SModel getTransientModelDescriptor() {
    return myTransientModel;
  }

  @Override
  public Project getProject() {
    return myProject;
  }

  @Override
  public void setProject(Project project) {
    myProject = project;
  }
}
