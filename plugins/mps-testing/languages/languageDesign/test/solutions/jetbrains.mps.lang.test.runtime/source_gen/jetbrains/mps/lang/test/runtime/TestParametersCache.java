package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import org.junit.rules.TestRule;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import org.junit.runners.model.Statement;
import org.junit.runner.Description;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.util.MacrosFactory;
import java.io.File;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.ide.ThreadUtils;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.generator.impl.CloneUtil;
import jetbrains.mps.tool.environment.EnvironmentSetupException;
import org.junit.AssumptionViolatedException;

/**
 * Th problem is: we need to initialize, dispose and share data between instances of the same class (JUnit by default gets new instance for each test method).
 * We need something like instance field, but preserved for all instances of the same class. As long as there's no easy way to have external configuration for a test 
 * (I didn't find any standard mechanism, and writing custom runner is not the task I'd like to address now), we use static field in each generated test class.
 * 
 * Intended use: static field with {@link org.junit.ClassRule } annotation in specific test class.
 */
public final class TestParametersCache implements TestRule {
  private static final Logger LOG = LogManager.getLogger(TestParametersCache.class);
  private final Class<?> myOwner;
  private final String myProjectPath;
  private final String myModelRef;
  private final boolean myReOpenProject;

  private Project myProject;
  private SModel myTestModel;
  private SModel myTransientModel;
  private boolean myInitialized = false;

  public TestParametersCache(Class<?> owner, String projectPath, String modelRef, boolean reOpenProject) {
    // FIXME can refactor this class to be responsible just for project/models initialization and cleanup, and keep BaseTransformatioTest-related 
    //       stuff in BTT iteself. Facilitates reuse of this cache for other tests. 
    myOwner = owner;
    myProjectPath = projectPath;
    myModelRef = modelRef;
    myReOpenProject = reOpenProject;
  }

  @Override
  public Statement apply(final Statement statement, Description description) {
    return new Statement() {
      public void evaluate() throws Throwable {
        statement.evaluate();
        //  NOTE, with in-process execution, TestParametersCache instance kept in a static field would be re-used, hence clean shall 
        // leave a state we can re-initialize in once again. 
        clean();
      }
    };
  }

  public void initializeOnce(Object ownerInstance, Environment environment) throws Exception {
    // both arguments are non null 
    assert ownerInstance.getClass() == myOwner;

    if (myInitialized) {
      return;
    }
    initCachedValues(environment);
    assert myProject != null;
    assert myTestModel != null;
    assert myTransientModel != null;
    myInitialized = true;
  }

  public Project getProject() {
    return myProject;
  }

  public SModel getTestModel() {
    return myTestModel;
  }

  public SModel getTransientModel() {
    return myTransientModel;
  }

  /*package*/ void clean() {
    if (myProject == null) {
      return;
    }
    myProject.getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        TemporaryModels.getInstance().dispose(myTransientModel);
        myTransientModel = null;
      }
    });
    myProject = null;
    myTestModel = null;
    myInitialized = false;
  }

  private void initCachedValues(Environment environment) throws Exception {
    // MPS's in-process, out-of-process and ant script executors supply Environment through EnvironmentAware and custom RunnerBuilder  
    // namely, PushEnvironmentRunnerBuilder. IDEA MPS plugin and IDEA test configurations use this RunnerBuilder, too. 
    if (environment == null) {
      throw new EnvironmentIsNullException(this.getClass().getName(), myProjectPath);
    }
    if (LOG.isInfoEnabled()) {
      LOG.info("Initializing the test");
    }

    if ((myProjectPath == null || myProjectPath.length() == 0)) {
      throw new ProjectPathIsNullException();
    }
    // FIXME can access MacrosFactory through environment.getPlatform, if necessary. 
    String expandedProjectPath = MacrosFactory.getGlobal().expandPath(myProjectPath);
    if ((expandedProjectPath == null || expandedProjectPath.length() == 0)) {
      throw new ExpandedProjectPathIsNullException(myProjectPath);
    }
    try {
      File projectToOpen = new File(expandedProjectPath);
      Project p = environment.openProject(projectToOpen);
      if (myReOpenProject) {
        environment.closeProject(p);
        p = environment.openProject(projectToOpen);
      }
      myProject = p;
      final SRepository repository = p.getRepository();
      Exception exception = ThreadUtils.runInUIThreadAndWait(new Runnable() {
        public void run() {
          // FIXME drop command, needed for transient/temp model initialization only 
          repository.getModelAccess().executeCommand(new Runnable() {
            @Override
            public void run() {
              SModelReference modelRef = PersistenceFacade.getInstance().createModelReference(myModelRef);
              SModel modelDescriptor = modelRef.resolve(repository);
              if (modelDescriptor == null) {
                throw new CouldNotFindModelException(String.format("Can't find model %s in supplied repository %s.", myModelRef, repository));
              }
              myTestModel = modelDescriptor;
              SModel transientModel = TemporaryModels.getInstance().create(false, TempModuleOptions.nonReloadableModule());
              new CloneUtil(modelDescriptor, transientModel).cloneModelWithAllImports();
              myTransientModel = transientModel;
            }
          });
        }
      });
      if (exception != null) {
        throw new MPSTestModelInitializationException("Exception during model initialization", exception);
      }
    } catch (EnvironmentSetupException envException) {
      throw new AssumptionViolatedException("Failed to open the project using the given environemnt", envException);
    }
  }
}
