package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import java.util.Collection;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import junit.framework.Assert;
import java.util.Iterator;
import java.util.ArrayList;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.internal.collections.runtime.Sequence;

public abstract class BaseMigrationTestBody extends BaseTestBody {
  public static Collection<SNode> runMigration(Collection<SNode> inputNodes, MigrationScript migrationScript) {
    final SModel model = TemporaryModels.getInstance().create(false, false, TempModuleOptions.forDefaultModule());
    CollectionSequence.fromCollection(inputNodes).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SModelOperations.addRootNode(model, SNodeOperations.copyNode(it));
      }
    });
    migrationScript.execute(model.getModule());
    List<SNode> result = ListSequence.fromList(SModelOperations.roots(model, null)).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.copyNode(it);
      }
    }).toListSequence();
    TemporaryModels.getInstance().dispose(model);
    return result;
  }
  public void testMethod() {
    final SModel model = TemporaryModels.getInstance().create(false, false, TempModuleOptions.forDefaultModule());
    CollectionSequence.fromCollection(getInputNodes()).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SModelOperations.addRootNode(model, it);
      }
    });
    MigrationScript script = getMigrationScript();
    script.execute(model.getModule());
    Collection<SNode> outputNodes = getOutputNodes();
    Assert.assertEquals(ListSequence.fromList(SModelOperations.roots(model, null)).count(), CollectionSequence.fromCollection(outputNodes).count());
    {
      Iterator<SNode> found_it = ListSequence.fromList(SModelOperations.roots(model, null)).iterator();
      Iterator<SNode> expected_it = CollectionSequence.fromCollection(outputNodes).iterator();
      SNode found_var;
      SNode expected_var;
      while (found_it.hasNext() && expected_it.hasNext()) {
        found_var = found_it.next();
        expected_var = expected_it.next();
        {
          List<SNode> nodesBefore = ListSequence.fromListAndArray(new ArrayList<SNode>(), found_var);
          List<SNode> nodesAfter = ListSequence.fromListAndArray(new ArrayList<SNode>(), expected_var);
          Assert.assertNull("The nodes '" + nodesBefore + "' and '" + nodesAfter + "' do not match!", new NodesMatcher().match(nodesBefore, nodesAfter));
        }
      }
    }
    for (Problem problem : Sequence.fromIterable(script.check(model.getModule()))) {
      org.junit.Assert.fail(problem.toString());
    }
  }
  public abstract Collection<SNode> getInputNodes();
  public abstract Collection<SNode> getOutputNodes();
  public abstract MigrationScript getMigrationScript();
}
