package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import java.util.Collection;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import junit.framework.Assert;
import java.util.Iterator;
import java.util.ArrayList;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.internal.collections.runtime.Sequence;

public abstract class BaseMigrationTestBody extends BaseTestBody {
  public static Collection<SNode> runMigration(Collection<SNode> inputNodes, MigrationScript migrationScript, final SModel tempModel) {
    CollectionSequence.fromCollection(inputNodes).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SModelOperations.addRootNode(tempModel, SNodeOperations.copyNode(it));
      }
    });
    migrationScript.execute(tempModel.getModule());
    List<SNode> result = ListSequence.fromList(SModelOperations.roots(tempModel, null)).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.copyNode(it);
      }
    }).toListSequence();
    return result;
  }
  public void testMethod() {
    SModel model = TemporaryModels.getInstance().create(false, false, TempModuleOptions.forDefaultModule());
    MigrationScript script = getMigrationScript();
    Collection<SNode> roots = runMigration(getInputNodes(), script, model);
    Collection<SNode> outputNodes = getOutputNodes();
    Assert.assertEquals(CollectionSequence.fromCollection(roots).count(), CollectionSequence.fromCollection(outputNodes).count());
    {
      Iterator<SNode> found_it = CollectionSequence.fromCollection(roots).iterator();
      Iterator<SNode> expected_it = CollectionSequence.fromCollection(outputNodes).iterator();
      SNode found_var;
      SNode expected_var;
      while (found_it.hasNext() && expected_it.hasNext()) {
        found_var = found_it.next();
        expected_var = expected_it.next();
        {
          List<SNode> nodesBefore = ListSequence.fromListAndArray(new ArrayList<SNode>(), found_var);
          List<SNode> nodesAfter = ListSequence.fromListAndArray(new ArrayList<SNode>(), expected_var);
          Assert.assertNull("The nodes '" + nodesBefore + "' and '" + nodesAfter + "' do not match!", new NodesMatcher().match(nodesBefore, nodesAfter));
        }
      }
    }
    for (Problem problem : Sequence.fromIterable(script.check(model.getModule()))) {
      org.junit.Assert.fail(problem.toString());
    }
    TemporaryModels.getInstance().dispose(model);
  }
  public abstract Collection<SNode> getInputNodes();
  public abstract Collection<SNode> getOutputNodes();
  public abstract MigrationScript getMigrationScript();
}
