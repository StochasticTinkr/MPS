package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import jetbrains.mps.util.annotation.ToRemove;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import junit.framework.Assert;
import jetbrains.mps.lang.test.matcher.NodeDifference;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.references.ImmatureReferences;
import jetbrains.mps.smodel.references.UnregisteredNodes;
import java.util.Collection;

public abstract class BaseMigrationTestBody extends BaseTestBody {
  /**
   * 
   * @deprecated left for compilation compatibility with existing generated code
   */
  @Deprecated
  @ToRemove(version = 2018.2)
  protected BaseMigrationTestBody() {
  }

  protected BaseMigrationTestBody(TransformationTest owner) {
    super(owner);
  }

  public static List<SNode> runMigration(List<SNode> inputNodes, SModel tempModel, MigrationScript... migrationScripts) {
    for (SNode root : ListSequence.fromList(CopyUtil.copy(inputNodes))) {
      SModelOperations.addRootNode(tempModel, root);
    }
    for (MigrationScript script : migrationScripts) {
      script.execute(tempModel.getModule());
    }
    return CopyUtil.copy(SModelOperations.roots(tempModel, null));
  }
  public void testMethod() {
    SModel model = TemporaryModels.getInstance().create(false, false, TempModuleOptions.forDefaultModule());
    MigrationScript[] scripts = getMigrationScript();
    List<SNode> roots = runMigration(CollectionSequence.fromCollection(getInputNodes()).toListSequence(), model, scripts);
    List<SNode> outputNodes = CollectionSequence.fromCollection(getOutputNodes()).toListSequence();
    Assert.assertEquals(ListSequence.fromList(roots).count(), ListSequence.fromList(outputNodes).count());
    List<NodeDifference> differences = new NodesMatcher(roots, outputNodes).diff();
    for (NodeDifference difference : ListSequence.fromList(differences)) {
      org.junit.Assert.fail("Migration result differs from expected:\n" + difference.print());
    }
    for (MigrationScript script : scripts) {
      for (Problem problem : Sequence.fromIterable(script.check(model.getModule()))) {
        org.junit.Assert.fail("Post-migration check for script '" + script + "' failed with problem: " + problem.toString());
      }
    }
    // we cannot dispose temporary model in the same command to avoid resolving immature references into detached nodes 
    ImmatureReferences.getInstance().cleanup();
    UnregisteredNodes.instance().clear();
    TemporaryModels.getInstance().dispose(model);
  }
  public abstract Collection<SNode> getInputNodes();
  public abstract Collection<SNode> getOutputNodes();
  public abstract MigrationScript[] getMigrationScript();
}
