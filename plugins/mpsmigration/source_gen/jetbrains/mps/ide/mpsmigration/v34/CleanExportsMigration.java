package jetbrains.mps.ide.mpsmigration.v34;

/*Generated by MPS */

import jetbrains.mps.migration.global.BaseProjectMigration;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import jetbrains.mps.project.Project;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.progress.EmptyProgressMonitor;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.generator.fileGenerator.FileGenerationUtil;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.lang.smodel.query.runtime.CommandUtil;
import jetbrains.mps.lang.smodel.query.runtime.QueryExecutionContext;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.Solution;
import jetbrains.mps.project.DevKit;
import jetbrains.mps.vfs.CachingFile;
import jetbrains.mps.vfs.DefaultCachingContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class CleanExportsMigration extends BaseProjectMigration implements CleanupProjectMigration {
  public static final String ID = "jetbrains.mps.cleanExp_3.4";

  public CleanExportsMigration() {
    super(ID);
  }

  public void forceExecutionNextTime(Project p) {
    setExecuted(p, false);
  }

  @Override
  public String getDescription() {
    return "Clean \"exports\" files";
  }

  @Override
  public boolean doExecute(Project p) {
    removeGeneratedFiles(p);
    return true;
  }

  public static void removeGeneratedFiles(final Project p) {
    ApplicationManager.getApplication().runWriteAction(new Runnable() {
      public void run() {
        removeExports(p);
      }
    });
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
      }
    });
  }

  /**
   * todo. Was originally copied from IdeCommandUtil, then changed. Check whether they could 
   * be combined into one piece of universal code
   */
  private static void removeExports(Project p) {
    Iterable<SModule> modulesToClean;
    Sequence.fromIterable(getModulesForCleanup(p)).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        IFile outputDir = it.getOutputPath();
        IFile testDir = check_cifyrw_a0b0a0a1a21(it.getFacet(TestsFacet.class));
        if (outputDir != null) {
          IFile cacheDir = FileGenerationUtil.getCachesDir(outputDir);
          refreshAndDeleteExports(outputDir);
        }
        if (testDir != null) {
          IFile testCacheDir = FileGenerationUtil.getCachesDir(testDir);
          refreshAndDeleteExports(testDir);
        }
      }
    });
  }

  private static Iterable<SModule> getModulesForCleanup(Project p) {
    {
      final SearchScope scope = CommandUtil.createScope(p);
      QueryExecutionContext context = new QueryExecutionContext() {
        public SearchScope getDefaultSearchScope() {
          return scope;
        }
      };
      return Sequence.fromIterable(CommandUtil.modules(CommandUtil.createConsoleScope(null, false, context))).where(new IWhereFilter<SModule>() {
        public boolean accept(SModule it) {
          return !((Solution.isBootstrapSolution(it.getModuleReference()))) && !((it instanceof DevKit));
        }
      });
    }
  }

  /**
   * Workaround for output locations that are exposed in SModule/SModuleFacet API as IFile, but are
   * populated through java.io.File and hence might not be up to date here.
   * E.g. ModuleMaker compiles classes of a module with sources only into brand new classes_gen. When CleanSourcesMigration tries to remove classes_gen after project re-open, 
   * it fails to find VFS file of JavaModuleFacet.getClassesGen which doesn't exist and hence is not removed. Then, language classes get loaded from this location (despite the 
   * use of VFS file to build module classpath (see JavaModuleFacetImpl.getClassPath(), it's only name of un-existing VFS file being used), and migration fails as it uses stale LanguageRuntime classes.
   * @see https://youtrack.jetbrains.com/issue/MPS-21303
   */
  private static void refreshAndDeleteExports(IFile f) {
    if (f == null) {
      return;
    }
    if (f instanceof CachingFile) {
      ((CachingFile) f).refresh(new DefaultCachingContext(true, false));
    }
    if (f.isDirectory()) {
      for (IFile cf : ListSequence.fromList(f.getChildren())) {
        refreshAndDeleteExports(cf);
      }
    } else if (f.getName().equals("exports")) {
      f.delete();
    }
  }
  private static IFile check_cifyrw_a0b0a0a1a21(TestsFacet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTestsOutputPath();
    }
    return null;
  }
}
