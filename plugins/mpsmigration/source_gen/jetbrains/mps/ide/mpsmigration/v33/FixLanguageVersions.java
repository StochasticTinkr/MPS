package jetbrains.mps.ide.mpsmigration.v33;

/*Generated by MPS */

import jetbrains.mps.migration.global.BaseProjectMigration;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import jetbrains.mps.project.Project;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.HashMap;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.lang.smodel.query.runtime.CommandUtil;
import jetbrains.mps.lang.smodel.query.runtime.QueryExecutionContext;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.Solution;
import jetbrains.mps.project.DevKit;

public class FixLanguageVersions extends BaseProjectMigration implements CleanupProjectMigration {
  public static final String ID = "jetbrains.mps.fixLangVersions";

  public FixLanguageVersions() {
    super(FixLanguageVersions.ID);
  }

  public void forceExecutionNextTime(Project p) {
    setExecuted(p, false);
  }

  @Override
  public String getDescription() {
    return "Correct \"-1\" language versions in models/modules";
  }

  @Override
  public boolean doExecute(Project p) {
    for (AbstractModule m : Sequence.fromIterable(getModulesForCleanup(p))) {
      ModuleDescriptor md = m.getModuleDescriptor();
      if (md == null) {
        continue;
      }

      Map<SLanguage, Integer> oldVersions = md.getLanguageVersions();
      Map<SLanguage, Integer> newVersions = new HashMap<SLanguage, Integer>();
      for (final SLanguage lang : m.getUsedLanguages()) {
        Integer oldV = oldVersions.get(lang);
        if (oldV == null || oldV == -1) {
          oldV = 0;
          newVersions.put(lang, oldV);
        }

        List<SModel> models = m.getModels();
        for (SModelInternal model : ListSequence.fromList(models).ofType(SModelInternal.class).where(new IWhereFilter<SModelInternal>() {
          public boolean accept(SModelInternal it) {
            return it.importedLanguageIds().contains(lang);
          }
        })) {
          if (model.importedLanguageIds().contains(lang) && model.getLanguageImportVersion(lang) != -1) {
            continue;
          }
          model.setLanguageImportVersion(lang, oldV);
        }
      }

      if (newVersions.isEmpty()) {
        continue;
      }

      oldVersions.putAll(newVersions);
      m.setChanged();
    }
    return true;
  }

  private static Iterable<AbstractModule> getModulesForCleanup(Project p) {
    {
      final SearchScope scope = CommandUtil.createScope(p);
      QueryExecutionContext context = new QueryExecutionContext() {
        public SearchScope getDefaultSearchScope() {
          return scope;
        }
      };
      return Sequence.fromIterable(CommandUtil.modules(CommandUtil.createConsoleScope(null, false, context))).where(new IWhereFilter<SModule>() {
        public boolean accept(SModule it) {
          return !((Solution.isBootstrapSolution(it.getModuleReference()))) && !((it instanceof DevKit));
        }
      }).ofType(AbstractModule.class);
    }
  }
}
