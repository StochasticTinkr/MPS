package jetbrains.mps.console.tool;

/*Generated by MPS */

import com.intellij.openapi.fileEditor.DocumentsEditor;
import jetbrains.mps.nodeEditor.EditorComponent;
import com.intellij.openapi.fileEditor.FileEditorState;
import com.intellij.openapi.fileEditor.FileEditorStateLevel;
import org.jetbrains.annotations.NotNull;
import javax.swing.JComponent;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.beans.PropertyChangeListener;
import com.intellij.codeHighlighting.BackgroundEditorHighlighter;
import com.intellij.openapi.fileEditor.FileEditorLocation;
import com.intellij.ide.structureView.StructureViewBuilder;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.editor.Document;
import jetbrains.mps.ide.undo.MPSUndoUtil;

public class ConsoleFileEditor implements DocumentsEditor {
  private EditorComponent myEditor;
  private boolean myDisposed = false;

  private static class MyFileEditorState implements FileEditorState {
    private Object memento;
    public MyFileEditorState(Object memento) {
      this.memento = memento;
    }
    @Override
    public boolean canBeMergedWith(FileEditorState otherState, FileEditorStateLevel level) {
      return false;
    }
    public Object getMemento() {
      return memento;
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || getClass() != o.getClass()) {
        return false;
      }
      ConsoleFileEditor.MyFileEditorState that = (ConsoleFileEditor.MyFileEditorState) o;
      if (!(memento.equals(that.memento))) {
        return false;
      }
      return true;
    }
    @Override
    public int hashCode() {
      return memento.hashCode();
    }
  }

  public ConsoleFileEditor(EditorComponent editor) {
    myEditor = editor;
  }
  @NotNull
  public JComponent getComponent() {
    return myEditor;
  }
  @Nullable
  public JComponent getPreferredFocusedComponent() {
    return null;
  }
  @NonNls
  @NotNull
  public String getName() {
    return myEditor.getName();
  }
  @NotNull
  public FileEditorState getState(@NotNull FileEditorStateLevel level) {
    final Wrappers._T<Object> memento = new Wrappers._T<Object>(null);
    myEditor.getEditorContext().getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        memento.value = myEditor.getEditorContext().createMemento();
      }
    });
    return new ConsoleFileEditor.MyFileEditorState(memento.value);
  }
  public void setState(@NotNull final FileEditorState state) {
    if (state instanceof ConsoleFileEditor.MyFileEditorState) {
      myEditor.getEditorContext().getRepository().getModelAccess().runWriteAction(new Runnable() {
        public void run() {
          myEditor.getEditorContext().setMemento(((ConsoleFileEditor.MyFileEditorState) state).getMemento());
          myEditor.rebuildEditorContent();
        }
      });
    }
  }
  public boolean isModified() {
    return false;
  }
  public boolean isValid() {
    return !(myDisposed);
  }
  public void selectNotify() {
  }
  public void deselectNotify() {
  }
  public void addPropertyChangeListener(@NotNull PropertyChangeListener listener) {
  }
  public void removePropertyChangeListener(@NotNull PropertyChangeListener listener) {
  }
  @Nullable
  public BackgroundEditorHighlighter getBackgroundHighlighter() {
    return null;
  }
  @Nullable
  public FileEditorLocation getCurrentLocation() {
    return null;
  }
  @Nullable
  public StructureViewBuilder getStructureViewBuilder() {
    return null;
  }
  @Nullable
  public <T> T getUserData(@NotNull Key<T> key) {
    return null;
  }
  public <T> void putUserData(@NotNull Key<T> key, @Nullable T t) {
  }
  public void dispose() {
    myDisposed = true;
  }
  public Document[] getDocuments() {
    if (myDisposed) {
      return new Document[0];
    }
    Document doc = MPSUndoUtil.getDoc(myEditor.getEditorContext().getRepository(), myEditor.getEditedNodePointer());
    return (doc == null ? new Document[0] : new Document[]{doc});
  }
}
