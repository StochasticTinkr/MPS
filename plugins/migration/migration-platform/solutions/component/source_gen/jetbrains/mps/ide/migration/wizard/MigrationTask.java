package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import com.intellij.history.LocalHistoryAction;
import java.util.List;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.persistence.PersistenceRegistry;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.project.Project;
import com.intellij.history.LocalHistory;
import jetbrains.mps.ide.project.ProjectHelper;
import java.awt.Color;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import javax.swing.JComponent;
import com.intellij.openapi.wm.impl.status.InlineProgressIndicator;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.application.ApplicationManager;
import org.apache.log4j.Level;
import jetbrains.mps.migration.global.ProjectMigration;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import org.jetbrains.mps.openapi.util.Processor;
import java.util.HashMap;
import jetbrains.mps.util.Pair;
import jetbrains.mps.errors.item.IssueKindReportItem;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.migration.runtime.base.MigrationModuleUtil;
import jetbrains.mps.lang.migration.runtime.base.BaseScriptReference;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;

public class MigrationTask {
  private static final Logger LOG = LogManager.getLogger(MigrationTask.class);
  public static final String STARTED = "Migration started";
  public static final String FINISHED = "Migration finished";
  public static final String APPLY = "Applying migration ";

  private MigrationSession mySession;
  private volatile boolean myIsComplete = false;
  private LocalHistoryAction myCurrentChange = null;
  private List<ScriptApplied> myWereRun = ListSequence.fromList(new ArrayList<ScriptApplied>());

  private ProgressMonitorAdapter myMonitor;

  public MigrationTask(MigrationSession session, ProgressMonitorAdapter monitor) {
    mySession = session;
    myMonitor = monitor;
    mySession.setCurrentStage(0);
    myMonitor.start("Migrating...", 100);
  }

  public void run() {
    PersistenceRegistry.getInstance().disableFastFindUsages();
    try {
      doRun();
      myIsComplete = true;
      myMonitor.step("Done!");
      myMonitor.advance(0);
      myMonitor.done();
    } catch (MigrationError me) {
      error(me);
    } finally {
      PersistenceRegistry.getInstance().enableFastFindUsages();
    }
  }

  protected void doRun() throws MigrationError {
    boolean resave = mySession.getRequiredSteps().contains(MigrationSession.MigrationStepKind.RESAVE);
    boolean migrate = mySession.getRequiredSteps().contains(MigrationSession.MigrationStepKind.MIGRATE);

    if (checkAndIncStage(0)) {
      if (resave) {
        // add label to local history if requested 
        runResave(myMonitor.subTask((migrate ? 10 : 100)));
        if (!(migrate)) {
          return;
        }
      }
    }

    if (checkAndIncStage(1)) {
      List<ScriptApplied> missingMigrations = findMissingMigrations(myMonitor.subTask(5));
      if (ListSequence.fromList(missingMigrations).isNotEmpty()) {
        throw new MigrationsMissingError(missingMigrations);
      }
    }

    if (checkAndIncStage(2)) {
      if (!((runCleanupMigrations(myMonitor.subTask(10))))) {
        throw new MigrationExceptionError();
      }
    }

    if (checkAndIncStage(3)) {
      Map<SModule, SModule> errsToShow = checkMigratedLibs(myMonitor.subTask(5));
      if (MapSequence.fromMap(errsToShow).isNotEmpty()) {
        throw new NotMigratedLibsError(errsToShow);
      }
    }

    if (checkAndIncStage(4)) {
      // null - no error, true - must stop, false - can ignore 
      boolean errors = checkModels(myMonitor.subTask(20));
      if (errors) {
        throw new PreCheckError(mySession.getProject(), errors);
      }
    }

    // from here, we don't ignore errors 
    addGlobalLabel(mySession.getProject(), STARTED);
    if (!((runProjectMigrations(myMonitor.subTask(5))))) {
      throw new MigrationExceptionError();
    }
    if (!((runLanguageMigrations(myMonitor.subTask((resave ? 30 : 40)))))) {
      throw new MigrationExceptionError();
    }
    addGlobalLabel(mySession.getProject(), FINISHED);

    // todo move from here to migration annotations 
    if (findNotMigrated(myMonitor.subTask(15))) {
      throw new PostCheckError(mySession.getProject(), myWereRun, false, mySession.getChecker());
    }
  }

  private boolean checkAndIncStage(int stage) {
    if (mySession.getCurrentStage().equals(stage)) {
      mySession.setCurrentStage(stage + 1);
      return true;
    }
    return false;
  }

  protected static void addGlobalLabel(Project p, String label) {
    LocalHistory.getInstance().putSystemLabel(ProjectHelper.toIdeaProject(p), label, Color.ORANGE.getRGB());
  }

  protected void error(@NotNull MigrationError error) {
    myMonitor.step(error.getShortMessage());
    myMonitor.advance(0);
    myIsComplete = !(error.canIgnore());
    mySession.setError(error);
  }

  public boolean forceComplete() {
    myMonitor.done();
    return myIsComplete = true;
  }

  public boolean isComplete() {
    return myIsComplete;
  }

  private boolean executeSingleStep(final ProgressMonitor m, final String localHistCaption, final _FunctionTypes._void_P0_E0 execute, final _FunctionTypes._return_P0_E0<? extends Boolean> merge) {
    final Wrappers._boolean noException = new Wrappers._boolean(true);

    // todo pass ModalityState to constructor/via session? 
    // in tests, we have EmptyProgressIndicator and use NON_MODAL 
    JComponent modalityComponent = check_ajmasp_a0e0bb(as_ajmasp_a0a0e0cb(myMonitor.getIndicator(), InlineProgressIndicator.class));
    ModalityState modalityState = (modalityComponent == null ? ModalityState.NON_MODAL : ModalityState.stateForComponent(modalityComponent));
    ApplicationManager.getApplication().invokeAndWait(new Runnable() {
      public void run() {
        if (myCurrentChange == null) {
          myCurrentChange = LocalHistory.getInstance().startAction(APPLY + localHistCaption);
        }
        mySession.getProject().getRepository().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            try {
              execute.invoke();
            } catch (Throwable t) {
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Exception during migration", t);
              }
              noException.value = false;
            }
          }
        });

        if (merge == null || !(merge.invoke())) {
          final Project project = mySession.getProject();
          m.step("Saving project...");
          project.getRepository().getModelAccess().runWriteAction(new Runnable() {
            public void run() {
              project.getRepository().saveAll();
            }
          });

          myCurrentChange.finish();
          myCurrentChange = null;
        }
      }
    }, modalityState);

    return noException.value;
  }

  private boolean runCleanupMigrations(ProgressMonitor m) {
    int cleanupStepsCount = projectStepsCount(true);
    m.start("Cleaning...", cleanupStepsCount);
    boolean success = true;
    if (cleanupStepsCount != 0) {
      addGlobalLabel(mySession.getProject(), "Cleanup started");

      while (true) {
        final ProjectMigration pm = mySession.getMigrationRegistry().nextProjectStep(mySession.getOptions(), true);
        if (pm == null) {
          break;
        }

        m.step(pm.getDescription());
        if (!(executeSingleStep(m, pm.getDescription(), new _FunctionTypes._void_P0_E0() {
          public void invoke() {
            pm.execute(mySession.getProject());
          }
        }, null))) {
          success = false;
          if (pm instanceof CleanupProjectMigration) {
            ((CleanupProjectMigration) pm).forceExecutionNextTime(mySession.getProject());
          }
          break;
        }

        m.advance(1);
      }

      addGlobalLabel(mySession.getProject(), "Cleanup finished");
    }
    m.done();
    return success;
  }

  private List<ScriptApplied> findMissingMigrations(ProgressMonitor m) {
    final List<ScriptApplied> res = ListSequence.fromList(new ArrayList<ScriptApplied>());
    mySession.getChecker().checkMigrations(m, new Processor<ScriptApplied>() {
      public boolean process(ScriptApplied sa) {
        ListSequence.fromList(res).addElement(sa);
        return true;
      }
    });
    return res;
  }

  private Map<SModule, SModule> checkMigratedLibs(ProgressMonitor m) {
    final Map<SModule, SModule> res = MapSequence.fromMap(new HashMap<SModule, SModule>());
    mySession.getChecker().checkLibs(m, new Processor<Pair<SModule, SModule>>() {
      public boolean process(Pair<SModule, SModule> p) {
        MapSequence.fromMap(res).put(p.o1, p.o2);
        return true;
      }
    });
    return res;
  }

  private boolean checkModels(ProgressMonitor m) {
    final Wrappers._boolean hasErrors = new Wrappers._boolean(false);
    mySession.getChecker().checkProject(m, new Processor<IssueKindReportItem>() {
      public boolean process(IssueKindReportItem p) {
        hasErrors.value = true;
        return false;
      }
    });
    return hasErrors.value;
  }

  private void runResave(ProgressMonitor m) {
    final Wrappers._T<List<SModule>> allModules = new Wrappers._T<List<SModule>>();
    final Project project = mySession.getProject();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        allModules.value = Sequence.fromIterable(MigrationModuleUtil.getMigrateableModulesFromProject(project)).toListSequence();
      }
    });
    m.start("Resaving modules...", ListSequence.fromList(allModules.value).count() + 10);
    JComponent modalityComponent = check_ajmasp_a0e0lb(as_ajmasp_a0a0e0mb(myMonitor.getIndicator(), InlineProgressIndicator.class));
    ModalityState modalityState = (modalityComponent == null ? ModalityState.NON_MODAL : ModalityState.stateForComponent(modalityComponent));

    for (final SModule module : ListSequence.fromList(allModules.value)) {
      m.advance(1);
      ApplicationManager.getApplication().invokeAndWait(new Runnable() {
        public void run() {
          project.getRepository().getModelAccess().executeCommand(new Runnable() {
            public void run() {
              mySession.getMigrationRegistry().doUpdateImportVersions(module);
            }
          });
        }
      }, modalityState);
    }
    ApplicationManager.getApplication().invokeAndWait(new Runnable() {
      public void run() {
        project.getRepository().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            project.getRepository().saveAll();
          }
        });
      }
    }, modalityState);
    m.done();
  }

  private boolean runProjectMigrations(ProgressMonitor m) {
    m.start("Running project migrations...", projectStepsCount(false));
    boolean success = true;
    while (true) {
      final ProjectMigration pm = mySession.getMigrationRegistry().nextProjectStep(mySession.getOptions(), false);
      if (pm == null) {
        break;
      }

      m.step(pm.getDescription());
      if (!(executeSingleStep(m, pm.getDescription(), new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          mySession.getExecutor().executeProjectMigration(pm);
        }
      }, null))) {
        success = false;
        break;
      }

      m.advance(1);
    }
    m.done();
    return success;
  }

  private boolean runLanguageMigrations(ProgressMonitor m) {
    m.start("Running language migrations...", moduleStepsCount());
    boolean success = true;

    final Wrappers._T<BaseScriptReference> preferredId = new Wrappers._T<BaseScriptReference>(null);
    while (true) {
      final ScriptApplied sa = mySession.getMigrationRegistry().nextModuleStep(preferredId.value);
      if (sa == null) {
        break;
      }

      preferredId.value = sa.getScriptReference();
      String caption = sa.getScriptReference().resolve(mySession.getProject(), false).getCaption();
      m.step(caption + " [" + NameUtil.compactNamespace(sa.getModule().getModuleName()) + "]");
      ListSequence.fromList(myWereRun).addElement(sa);
      if (!(executeSingleStep(m, caption, new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          mySession.getExecutor().executeModuleMigration(sa);
        }
      }, new _FunctionTypes._return_P0_E0<Boolean>() {
        public Boolean invoke() {
          ScriptApplied next = mySession.getMigrationRegistry().nextModuleStep(preferredId.value);
          if (next == null) {
            return false;
          }
          return eq_ajmasp_a0c0a0a3a0h0e0qb(sa.getScriptReference(), next.getScriptReference());
        }
      }))) {
        success = false;
        break;
      }

      m.advance(1);
    }

    m.done();
    return success;
  }

  private boolean findNotMigrated(ProgressMonitor m) {
    final Wrappers._boolean haveNotMigrated = new Wrappers._boolean(false);
    mySession.getChecker().findNotMigrated(m, myWereRun, new Processor<Problem>() {
      public boolean process(Problem p) {
        haveNotMigrated.value = true;
        return false;
      }
    });
    return haveNotMigrated.value;
  }

  private int moduleStepsCount() {
    final Wrappers._int res = new Wrappers._int();
    mySession.getProject().getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Project p = mySession.getProject();
        Iterable<SModule> modules = MigrationModuleUtil.getMigrateableModulesFromProject(p);
        res.value = CollectionSequence.fromCollection(mySession.getMigrationRegistry().getModuleMigrations(modules)).count();
      }
    });
    return res.value;
  }

  private int projectStepsCount(final boolean isCleanup) {
    final Wrappers._int res = new Wrappers._int();
    mySession.getProject().getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<ProjectMigration> migrations = mySession.getMigrationRegistry().getProjectMigrations();
        int cleanupSize = Sequence.fromIterable(migrations).ofType(CleanupProjectMigration.class).count();
        res.value = (isCleanup ? cleanupSize : Sequence.fromIterable(migrations).count() - cleanupSize);
      }
    });
    return res.value;
  }
  private static JComponent check_ajmasp_a0e0bb(InlineProgressIndicator checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getComponent();
    }
    return null;
  }
  private static JComponent check_ajmasp_a0e0lb(InlineProgressIndicator checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getComponent();
    }
    return null;
  }
  private static <T> T as_ajmasp_a0a0e0cb(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_ajmasp_a0a0e0mb(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static boolean eq_ajmasp_a0c0a0a3a0h0e0qb(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
