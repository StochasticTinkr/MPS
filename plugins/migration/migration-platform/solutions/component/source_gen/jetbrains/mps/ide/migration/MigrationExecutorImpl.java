package jetbrains.mps.ide.migration;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.migration.runtime.base.MigrationModuleUtil;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.ide.migration.util.MigrationDataUtil;
import jetbrains.mps.lang.migration.runtime.base.RefactoringScriptReference;
import jetbrains.mps.migration.global.ProjectMigration;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.refactoring.participant.RefactoringSessionImpl;
import jetbrains.mps.lang.migration.runtime.base.RefactoringScript;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.refactoring.participant.RefactoringUI;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import jetbrains.mps.ide.platform.actions.core.RefactoringProcessor;
import jetbrains.mps.ide.findusages.model.scopes.ModulesScope;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.refactoring.participant.RefactoringSession;

public class MigrationExecutorImpl implements MigrationExecutor {
  private Project myProject;
  private MPSProject myMpsProject;

  private DataCollector myDataCollector = new DataCollector() {
    public Map<SModule, SNode> collectData(SModule module, final MigrationScriptReference scriptReference) {
      final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
      SetSequence.fromSet(MigrationModuleUtil.getModuleDependencies(module)).visitAll(new IVisitor<SModule>() {
        public void visit(SModule it) {
          SNode dataString = MigrationDataUtil.readData(it, scriptReference);
          if (dataString != null) {
            MapSequence.fromMap(requiredData).put(it, dataString);
          }
        }
      });
      return requiredData;
    }
  };

  public MigrationExecutorImpl(Project project) {
    myProject = project;
    myMpsProject = ((MPSProject) myProject);
  }

  public void dispose() {
  }

  @Override
  public void executeModuleMigration(ScriptApplied s) {
    // todo remove explicit class mention (map<ref->script>?) 
    if (s.getScriptReference() instanceof MigrationScriptReference) {
      executeMigrationScript(s);
    } else if (s.getScriptReference() instanceof RefactoringScriptReference) {
      executeRefactoringScript(s);
    } else {
      throw new IllegalArgumentException();
    }
  }
  @Override
  public void executeProjectMigration(ProjectMigration pm) {
    pm.execute(myProject);
  }

  private void executeMigrationScript(ScriptApplied<MigrationScriptReference> sa) {
    MigrationScript script = sa.getScriptReference().resolve(myMpsProject, true);
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage fromLanguage = script.getReference().getLanguage();
    Integer usedVersion = module.getModuleDescriptor().getLanguageVersions().get(fromLanguage);
    usedVersion = Math.max(usedVersion, 0);
    assert usedVersion == script.getReference().getFromVersion();

    script.setDataCollector(myDataCollector);
    SNode data = script.execute(module);
    if (data != null) {
      MigrationDataUtil.addData(module, script.getReference(), data);
    }

    int toVersion = script.getReference().getFromVersion() + 1;
    module.getModuleDescriptor().getLanguageVersions().put(fromLanguage, toVersion);
    module.setChanged();

    for (SModel model : ListSequence.fromList(module.getModels())) {
      if (model.isReadOnly()) {
        continue;
      }
      if (!((model instanceof SModelInternal))) {
        continue;
      }
      if (!(((SModelInternal) model).importedLanguageIds().contains(fromLanguage))) {
        continue;
      }

      ((SModelInternal) model).setLanguageImportVersion(fromLanguage, toVersion);
    }
  }

  private void executeRefactoringScript(ScriptApplied<RefactoringScriptReference> sa) {
    RefactoringScriptReference rLog = sa.getScriptReference();
    final AbstractModule module = ((AbstractModule) sa.getModule());
    SModule fromModule = rLog.getModule();
    int importedVersion = MigrationModuleUtil.getDependencyVersion(module, fromModule);
    importedVersion = Math.max(importedVersion, 0);
    assert importedVersion == rLog.getFromVersion();

    final RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();
    RefactoringScript ref = rLog.resolve(myMpsProject, true);
    ref.setSession(refactoringSession);
    ref.setTaskExecutor(new _FunctionTypes._void_P1_E0<Runnable>() {
      public void invoke(Runnable task) {
        MigrationExecutorImpl.RefactoringSessionTaskQueue.getInstance(refactoringSession).putTask(task);
      }
    });
    ref.setRefactoringProcessor(new _FunctionTypes._void_P4_E0<RefactoringUI, RefactoringParticipant.PersistentRefactoringParticipant, Iterable<SNode>, Map<SNode, SNode>>() {
      public void invoke(RefactoringUI ui, RefactoringParticipant.PersistentRefactoringParticipant p, Iterable<SNode> initialState, Map<SNode, SNode> initialToFinal) {
        doRun(module, p, ui, initialState, initialToFinal, refactoringSession);
      }
    });
    ref.execute(module);
    MigrationExecutorImpl.RefactoringSessionTaskQueue.getInstance(refactoringSession).runAll();
    refactoringSession.performAllRegistered();

    int toVersion = rLog.getFromVersion() + 1;
    MigrationModuleUtil.setDepVersion(module, fromModule.getModuleReference(), toVersion);

    // todo: versions in models 
  }

  private <IP, FP> void doRun(AbstractModule module, RefactoringParticipant.PersistentRefactoringParticipant<?, ?, IP, FP> participant, RefactoringUI ui, Iterable<SNode> initialState, final Map<SNode, SNode> initialToFinal, RefactoringSessionImpl refactoringSession) {
    RefactoringProcessor.<IP,FP,SNode,SNode>performRefactoring(new RefactoringParticipant.DeserializingParticipantStateFactory<IP, FP>(), ui, refactoringSession, module.getRepository(), new ModulesScope(module), null, ((Iterable<? extends RefactoringParticipant<?, ?, IP, FP>>) Sequence.<RefactoringParticipant<?, ?, IP, FP>>singleton(participant)), Sequence.fromIterable(initialState).toListSequence(), new _FunctionTypes._return_P1_E0<Map<SNode, SNode>, Iterable<RefactoringParticipant.ParticipantApplied<?, ?, IP, FP, SNode, SNode>>>() {
      public Map<SNode, SNode> invoke(Iterable<RefactoringParticipant.ParticipantApplied<?, ?, IP, FP, SNode, SNode>> changes) {
        return initialToFinal;
      }
    }, null);
  }

  private static class RefactoringSessionTaskQueue {
    private static final String myId = "refactoringSession.migrationAssistant.taskQueue";
    private List<Runnable> myTasks = ListSequence.fromList(new ArrayList<Runnable>());
    public static MigrationExecutorImpl.RefactoringSessionTaskQueue getInstance(RefactoringSession session) {
      MigrationExecutorImpl.RefactoringSessionTaskQueue result = ((MigrationExecutorImpl.RefactoringSessionTaskQueue) session.getObject(myId));
      if (result == null) {
        result = new MigrationExecutorImpl.RefactoringSessionTaskQueue();
        session.putObject(myId, result);
      }
      return result;
    }
    public void putTask(Runnable task) {
      ListSequence.fromList(myTasks).addElement(task);
    }
    public void runAll() {
      for (Runnable task : ListSequence.fromList(myTasks)) {
        task.run();
      }
    }
  }
}
