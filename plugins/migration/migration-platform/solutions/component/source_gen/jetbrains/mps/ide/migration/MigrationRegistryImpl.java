package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.Project;
import jetbrains.mps.migration.global.ProjectMigration;
import java.util.Collection;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.migration.runtime.base.MigrationModuleUtil;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.language.LanguageRegistry;
import java.util.LinkedHashSet;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import org.apache.log4j.Level;
import jetbrains.mps.migration.global.MigrationOptions;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.migration.runtime.base.BaseScriptReference;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.migration.runtime.base.RefactoringScriptReference;
import java.util.ArrayList;

public class MigrationRegistryImpl extends AbstractProjectComponent implements MigrationRegistry {
  private static final Logger LOG = LogManager.getLogger(MigrationRegistryImpl.class);
  private Project myMpsProject;
  private ProjectMigration lastProjectMigration = null;

  public MigrationRegistryImpl(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    myMpsProject = mpsProject;
  }

  @Override
  public Collection<ProjectMigration> getProjectMigrations() {
    final Wrappers._T<List<ProjectMigration>> res = new Wrappers._T<List<ProjectMigration>>();
    myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        res.value = ProjectMigrationsRegistry.getInstance().getMigrations();
        res.value = ListSequence.fromList(res.value).where(new IWhereFilter<ProjectMigration>() {
          public boolean accept(ProjectMigration it) {
            return it.shouldBeExecuted(myMpsProject);
          }
        }).toListSequence();
      }
    });
    return res.value;
  }

  @Override
  public Collection<ScriptApplied> getModuleMigrations(final Iterable<SModule> modules) {
    final Wrappers._T<List<ScriptApplied>> res = new Wrappers._T<List<ScriptApplied>>();
    myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        res.value = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ScriptApplied>() {
          public Iterable<ScriptApplied> translate(SModule module) {
            return getAllSteps(module, false);
          }
        }).toListSequence();
      }
    });
    return res.value;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationModuleUtil.getMigrateableModulesFromProject(myMpsProject);
        result.value = CollectionSequence.fromCollection(getProjectMigrations()).isNotEmpty() || CollectionSequence.fromCollection(getModuleMigrations(modules)).isNotEmpty();
      }
    });
    return result.value;
  }

  public boolean importVersionsUpdateRequired(Iterable<SModule> modules) {
    myMpsProject.getModelAccess().checkReadAccess();

    for (SModule module : Sequence.fromIterable(modules)) {
      AbstractModule abstractModule = (AbstractModule) module;
      ModuleDescriptor md = abstractModule.getModuleDescriptor();
      if (md == null) {
        throw new IllegalStateException("Module " + modules + " has not module descriptor.");
      }

      Map<SModuleReference, Integer> oldDepVersions = Collections.unmodifiableMap(md.getDependencyVersions());
      Map<SModuleReference, Integer> newDepVersions = collectDependencyVersions(abstractModule, oldDepVersions);
      if (!(oldDepVersions.keySet().equals(newDepVersions.keySet()))) {
        return true;
      }

      Map<SLanguage, Integer> oldLangVersions = Collections.unmodifiableMap(md.getLanguageVersions());
      Map<SLanguage, Integer> newLangVersions = collectLanguageVersions(abstractModule, oldLangVersions);
      checkModelVersionsAreValid(module, newLangVersions);
      if (!(oldLangVersions.equals(newLangVersions))) {
        return true;
      }
    }

    return false;
  }

  public void doUpdateImportVersions(SModule module) {
    module.getRepository().getModelAccess().checkWriteAccess();

    AbstractModule abstractModule = (AbstractModule) module;
    ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + module + " has not module descriptor.");
    }

    Map<SModuleReference, Integer> depVersions = md.getDependencyVersions();
    Map<SModuleReference, Integer> newDepVersions = collectDependencyVersions(abstractModule, depVersions);
    if (!(depVersions.equals(newDepVersions))) {
      abstractModule.setChanged();
      depVersions.clear();
      depVersions.putAll(newDepVersions);
    }

    Map<SLanguage, Integer> langVersions = md.getLanguageVersions();
    Map<SLanguage, Integer> newLangVersions = collectLanguageVersions(abstractModule, langVersions);
    if (!(langVersions.equals(newLangVersions))) {
      abstractModule.setChanged();
      langVersions.clear();
      langVersions.putAll(newLangVersions);
    }
  }

  private Map<SLanguage, Integer> collectLanguageVersions(SModule module, Map<SLanguage, Integer> oldLangVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    Map<SLanguage, Integer> newLangVersions = new HashMap<SLanguage, Integer>();
    Set<SLanguage> usedLanguages = module.getUsedLanguages();
    SLanguageHierarchy languageHierarchy = new SLanguageHierarchy(LanguageRegistry.getInstance(myMpsProject.getRepository()), usedLanguages);
    Set<SLanguage> extendingLangsClosure = languageHierarchy.getExtended();
    for (SLanguage lang : extendingLangsClosure) {
      if (oldLangVersions.containsKey(lang)) {
        newLangVersions.put(lang, oldLangVersions.get(lang));
      } else {
        newLangVersions.put(lang, lang.getLanguageVersion());
      }
    }
    return newLangVersions;
  }

  private Map<SModuleReference, Integer> collectDependencyVersions(SModule module, Map<SModuleReference, Integer> oldDepVersions) {
    module.getRepository().getModelAccess().checkReadAccess();

    Map<SModuleReference, Integer> newDepVersions = new HashMap<SModuleReference, Integer>();
    Set<SModule> visible = new LinkedHashSet<SModule>();
    visible.add(module);
    Collection<SModule> dependentModules = new GlobalModuleDependenciesManager(module).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE);
    visible.addAll(dependentModules);
    for (SModule dep : visible) {
      if (oldDepVersions.containsKey(dep.getModuleReference())) {
        newDepVersions.put(dep.getModuleReference(), oldDepVersions.get(dep.getModuleReference()));
      } else {
        newDepVersions.put(dep.getModuleReference(), ((AbstractModule) dep).getModuleVersion());
      }
    }
    return newDepVersions;
  }

  private void checkModelVersionsAreValid(SModule module, Map<SLanguage, Integer> langVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    for (SModel m : module.getModels()) {
      SModelInternal modelInternal = (SModelInternal) m;
      for (SLanguage lang : CollectionSequence.fromCollection(modelInternal.importedLanguageIds())) {
        int currentVersion = langVersions.get(lang);
        int modelVer = modelInternal.getLanguageImportVersion(lang);
        if (modelVer != -1 && modelVer != currentVersion) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Migration assistant detected inconsistency in language versions. Module " + module + " uses language " + lang + " with version " + currentVersion + " while its model " + m.getName() + " uses this language with version " + modelVer);
          }
        }
      }
    }
  }

  public ProjectMigration nextProjectStep(MigrationOptions options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(myMpsProject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    return current;
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        // this is xor, which is absent in bl 
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      // was: cleanup, now: not cleanup 
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }


  public ScriptApplied nextModuleStep(@Nullable final BaseScriptReference preferredId) {
    final Wrappers._T<ScriptApplied> result = new Wrappers._T<ScriptApplied>(null);
    myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        // .toList is important here, makes it not to perform calculation many times 
        Project p = ProjectHelper.toMPSProject(myProject);
        Iterable<SModule> modules = MigrationModuleUtil.getMigrateableModulesFromProject(p);
        if (preferredId == null) {
          result.value = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ScriptApplied>() {
            public Iterable<ScriptApplied> translate(SModule module) {
              return getAllSteps(module, true);
            }
          }).findFirst(new IWhereFilter<ScriptApplied>() {
            public boolean accept(ScriptApplied it) {
              return canBeExecutedImmediately(it);
            }
          });
          return;
        }

        if (preferredId instanceof MigrationScriptReference) {
          final MigrationScriptReference mid = as_ufn3ol_a0a0a5a0a0a0a1a72(preferredId, MigrationScriptReference.class);
          SModule byId = Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              return SetSequence.fromSet(MigrationModuleUtil.getUsedLanguages(it)).contains(mid.getLanguage());
            }
          }).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              int ver = Math.max(0, ((AbstractModule) it).getUsedLanguageVersion(mid.getLanguage()));
              return ver == mid.getFromVersion();
            }
          }).findFirst(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              return canBeExecutedImmediately(new ScriptApplied(it, mid));
            }
          });
          if (byId != null) {
            result.value = new ScriptApplied(byId, mid);
            return;
          }
        } else if (preferredId instanceof RefactoringScriptReference) {
          final RefactoringScriptReference rid = as_ufn3ol_a0a0a0f0a0a0a0b0bb(preferredId, RefactoringScriptReference.class);
          SModule byId = Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              return SetSequence.fromSet(MigrationModuleUtil.getModuleDependencies(it)).contains(rid.getModule());
            }
          }).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              int ver = Math.max(0, ((AbstractModule) it).getDependencyVersion(rid.getModule()));
              return ver == rid.getFromVersion();
            }
          }).findFirst(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              return canBeExecutedImmediately(new ScriptApplied(it, rid));
            }
          });
          if (byId != null) {
            result.value = new ScriptApplied(byId, rid);
            return;
          }
        } else {
          // todo get rid of explicit class mention 
          throw new IllegalArgumentException();
        }

        // no applicable found by id 
        result.value = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ScriptApplied>() {
          public Iterable<ScriptApplied> translate(SModule module) {
            return getAllSteps(module, true);
          }
        }).findFirst(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return canBeExecutedImmediately(it);
          }
        });
      }
    });
    return result.value;
  }


  private boolean canBeExecutedImmediately(ScriptApplied script) {
    // todo remove explicit class mention 

    AbstractModule moduleToMigrate = (AbstractModule) script.getModule();
    if (script.getScriptReference() instanceof MigrationScriptReference) {
      MigrationScriptReference sr = (MigrationScriptReference) script.getScriptReference();
      int v = Math.max(0, moduleToMigrate.getUsedLanguageVersion(sr.getLanguage(), false));
      if (v != sr.getFromVersion()) {
        return false;
      }

      for (MigrationScriptReference s : Sequence.fromIterable(sr.resolve(true).executeAfter())) {
        if (needsToBeApplied(s, moduleToMigrate)) {
          return false;
        }
      }

      for (MigrationScriptReference s : Sequence.fromIterable(sr.resolve(true).requiresData())) {
        for (SModule dep : SetSequence.fromSet(MigrationModuleUtil.getModuleDependencies(moduleToMigrate))) {
          if (needsToBeApplied(s, dep)) {
            return false;
          }
        }
      }
      return true;
    }
    if (script.getScriptReference() instanceof RefactoringScriptReference) {
      RefactoringScriptReference sr = (RefactoringScriptReference) script.getScriptReference();
      int v = Math.max(0, moduleToMigrate.getDependencyVersion(sr.getModule(), false));
      if (v != sr.getFromVersion()) {
        return false;
      }

      for (RefactoringScriptReference s : Sequence.fromIterable(sr.resolve(true).getExecuteAfter())) {
        if (needsToBeApplied(s, moduleToMigrate)) {
          return false;
        }
      }
      return true;
    }
    throw new IllegalArgumentException();
  }

  private boolean needsToBeApplied(MigrationScriptReference ref, SModule m) {
    if (!(SetSequence.fromSet(MigrationModuleUtil.getUsedLanguages(m)).contains(ref.getLanguage()))) {
      return false;
    }
    int dv = Math.max(0, ((AbstractModule) m).getUsedLanguageVersion(ref.getLanguage(), false));
    return dv <= ref.getFromVersion();
  }

  private boolean needsToBeApplied(RefactoringScriptReference ref, SModule m) {
    if (!(SetSequence.fromSet(MigrationModuleUtil.getModuleDependencies(m)).contains(ref.getModule()))) {
      return false;
    }
    int dv = Math.max(0, ((AbstractModule) m).getDependencyVersion(ref.getModule(), false));
    return dv <= ref.getFromVersion();
  }

  private Iterable<ScriptApplied> getAllSteps(SModule module, boolean firstOnly) {
    List<ScriptApplied> result = ListSequence.fromList(new ArrayList<ScriptApplied>());
    for (SLanguage lang : SetSequence.fromSet(MigrationModuleUtil.getUsedLanguages(module))) {
      int currentLangVersion = lang.getLanguageVersion();
      int ver = ((AbstractModule) module).getUsedLanguageVersion(lang, false);

      ver = Math.max(ver, 0);
      currentLangVersion = Math.max(currentLangVersion, 0);

      for (int i = ver; i < currentLangVersion; i++) {
        ListSequence.fromList(result).addElement(new ScriptApplied(module, new MigrationScriptReference(lang, i)));
        if (firstOnly) {
          break;
        }
      }
    }
    for (SModule dep : SetSequence.fromSet(MigrationModuleUtil.getModuleDependencies(module))) {
      int currentDepVersion = ((AbstractModule) dep).getModuleVersion();
      int ver = ((AbstractModule) module).getDependencyVersion(dep, false);

      ver = Math.max(ver, 0);
      currentDepVersion = Math.max(currentDepVersion, 0);

      for (int i = ver; i < currentDepVersion; i++) {
        ListSequence.fromList(result).addElement(new ScriptApplied(module, new RefactoringScriptReference(dep, i)));
        if (firstOnly) {
          break;
        }
      }
    }
    return result;
  }

  private static <T> T as_ufn3ol_a0a0a5a0a0a0a1a72(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_ufn3ol_a0a0a0f0a0a0a0b0bb(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
