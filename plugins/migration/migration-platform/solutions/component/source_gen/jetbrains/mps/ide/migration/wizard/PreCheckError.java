package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import jetbrains.mps.errors.item.IssueKindReportItem;
import com.intellij.openapi.progress.ProgressIndicator;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.ide.migration.MigrationCheckerImpl;
import jetbrains.mps.ide.migration.MigrationRegistry;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import org.jetbrains.mps.openapi.util.Processor;

public class PreCheckError extends MigrationError {
  private boolean myCanIgnore;
  private Project myProject;
  public PreCheckError(Project p, boolean canIgnore) {
    myCanIgnore = canIgnore;
    myProject = p;
  }
  @Override
  public String getShortMessage() {
    return "Errors were found in models";
  }
  public String getMessage() {
    return "Migration Assistant found some problems in the project.\n" + "It is recommended to fix problems before starting the migration.";
  }
  public Iterable<IssueKindReportItem> getProblems(ProgressIndicator progressIndicator) {
    final List<IssueKindReportItem> res = ListSequence.fromList(new ArrayList<IssueKindReportItem>());
    // todo remove this hacky code after reload elimination and intoducing migration annotations 
    new MigrationCheckerImpl(myProject, myProject.getComponent(MigrationRegistry.class)).checkProject(new ProgressMonitorAdapter(progressIndicator), new Processor<IssueKindReportItem>() {
      public boolean process(IssueKindReportItem p) {
        ListSequence.fromList(res).addElement(p);
        return ListSequence.fromList(res).count() < 100;
      }
    });
    return res;
  }
  @Override
  public boolean canIgnore() {
    return myCanIgnore;
  }
}
