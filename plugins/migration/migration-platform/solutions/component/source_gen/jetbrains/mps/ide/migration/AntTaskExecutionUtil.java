package jetbrains.mps.ide.migration;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.Project;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.ide.migration.wizard.MigrationSession;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import com.intellij.openapi.progress.EmptyProgressIndicator;
import java.util.Properties;
import jetbrains.mps.ide.migration.wizard.MigrationTask;
import jetbrains.mps.ide.migration.wizard.MigrationError;
import org.apache.log4j.Level;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import jetbrains.mps.migration.global.MigrationOptions;

public class AntTaskExecutionUtil {
  private static final Logger LOG = LogManager.getLogger(AntTaskExecutionUtil.class);
  private static final String KEY_PREFIX = "mps.migration.";
  /**
   * Coupled with string constant in MigrationTask.ERR_CODE_KEY
   */
  private static final String ERR_CODE_KEY = KEY_PREFIX + "errcode";
  /**
   * Coupled with string constant in MigrationTask.OUT_FILE_NAME
   */
  private static final String OUT_FILE_NAME = "migration_result.properties";

  public static void migrate(final Project project) throws Exception {
    MigrationRegistry m = ProjectHelper.toIdeaProject(project).getComponent(MigrationRegistry.class);
    if (!(m.isMigrationRequired())) {
      return;
    }

    MigrationSession session = new AntTaskExecutionUtil.MyMigrationSession(project);
    ProgressMonitorAdapter progress = new ProgressMonitorAdapter(new EmptyProgressIndicator());

    final Properties properties = new Properties();
    properties.setProperty(ERR_CODE_KEY, "0");

    MigrationTask task = new MigrationTask(session, progress) {
      @Override
      protected void error(MigrationError error) {
        StringBuilder problems = new StringBuilder();
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error(error.getMessage());
        }
        for (final Problem p : Sequence.fromIterable(error.getProblems(new EmptyProgressIndicator()))) {
          final Wrappers._T<String> problemMsg = new Wrappers._T<String>();
          project.getRepository().getModelAccess().runReadAction(new Runnable() {
            public void run() {
              problemMsg.value = p.getMessage() + " (reason object: " + p.getReason() + ")";
            }
          });
          problems.append(problemMsg.value + "; ");
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("- " + problemMsg.value);
          }
        }

        properties.setProperty(ERR_CODE_KEY, "1");
      }
    };
    task.run();

    project.getRepository().getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        project.getRepository().saveAll();
      }
    });

    try {
      File file = new File(OUT_FILE_NAME);
      FileOutputStream fileOut = new FileOutputStream(file);
      properties.store(fileOut, "");
      fileOut.close();
    } catch (IOException e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception on saving result file " + OUT_FILE_NAME, e);
      }
    }
  }

  private static class MyMigrationSession extends MigrationSession.MigrationSessionBase {
    private Project myProject;
    private MigrationOptions myOptions = new MigrationOptions();
    private MigrationCheckerImpl myChecker;
    private MigrationExecutorImpl myExecutor;

    public MyMigrationSession(Project project) {
      myProject = project;
      this.myChecker = new MigrationCheckerImpl(myProject, getMigrationRegistry());
      this.myExecutor = new MigrationExecutorImpl(myProject);
      getRequiredSteps().add(MigrationSession.MigrationStepKind.MIGRATE);
    }
    public Project getProject() {
      return myProject;
    }
    public MigrationRegistry getMigrationRegistry() {
      return myProject.getComponent(MigrationRegistry.class);
    }
    public MigrationChecker getChecker() {
      return myChecker;
    }
    public MigrationOptions getOptions() {
      return myOptions;
    }
    @Override
    public MigrationExecutor getExecutor() {
      return myExecutor;
    }
  }
}
