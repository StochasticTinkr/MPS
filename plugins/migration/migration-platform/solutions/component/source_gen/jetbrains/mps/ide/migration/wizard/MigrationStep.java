package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import com.intellij.openapi.wm.impl.status.InlineProgressIndicator;
import javax.swing.JPanel;
import javax.swing.JLabel;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import javax.swing.JComponent;
import java.awt.BorderLayout;
import javax.swing.BorderFactory;
import com.intellij.ui.IdeBorderFactory;
import com.intellij.openapi.progress.ProcessCanceledException;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.progress.ProgressManager;
import org.apache.log4j.Level;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.progress.TaskInfo;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.ide.ThreadUtils;

public class MigrationStep extends BaseStep {
  private static final Logger LOG = LogManager.getLogger(MigrationStep.class);
  public static final String ID = "migration";

  private InlineProgressIndicator myProgress;
  private MigrationSession mySession;
  private MigrationTask myTask;

  private boolean myShouldSleepOnInit = true;

  private JPanel myErrorPanel;
  private JLabel myErrorLabel;

  public MigrationStep(MigrationSession session) {
    super("Migration in Progress", ID);
    mySession = session;
    myProgress = new MigrationStep.MyInlineProgressIndicator();
    myTask = new MigrationTask(session, new ProgressMonitorAdapter(myProgress));
  }

  @Override
  protected final void doCreateComponent(JComponent mainPanel) {
    mainPanel.setLayout(new BorderLayout());
    mainPanel.add(myProgress.getComponent(), BorderLayout.NORTH);

    this.myErrorPanel = new JPanel(new BorderLayout());
    mainPanel.add(myErrorPanel, BorderLayout.CENTER);

    myErrorPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(20, 0, 10, 0), IdeBorderFactory.createTitledBorder("Error", true)));

    this.myErrorLabel = new JLabel();
    myErrorPanel.add(new JPanel(), BorderLayout.CENTER);
    myErrorPanel.add(this.myErrorLabel, BorderLayout.NORTH);

    myErrorPanel.setVisible(false);
  }

  @Override
  public void _init() {
    super._init();

    if (myShouldSleepOnInit) {
      try {
        // this is to allow Idea UI to finish the "transition" to a new wizard step before running task 
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        // do nothing 
      }
      myShouldSleepOnInit = true;
    }

    executeToFirstError();
  }

  private void executeToFirstError() throws ProcessCanceledException {
    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
      public void run() {
        ProgressManager.getInstance().runProcess(new Runnable() {
          public void run() {
            mySession.setError(null);

            try {
              myTask.run();
            } catch (Throwable t) {
              String errMsg = "Exception occurred in migration wizard";
              myProgress.setText(errMsg);
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error(errMsg, t);
              }
              forceComplete();
              return;
            }

            if (mySession.getError() != null) {
              ApplicationManager.getApplication().invokeLater(new Runnable() {
                public void run() {
                  StringBuilder sb = new StringBuilder();
                  sb.append("<html>").append(mySession.getError().getMessage().replaceAll("\n", "<br>"));
                  if (mySession.getError().canIgnore()) {
                    sb.append("<br><br>Continue migration?");
                  }
                  sb.append("</html>");
                  myErrorLabel.setText(sb.toString());
                  myErrorPanel.setVisible(true);
                }
              }, ModalityState.stateForComponent(myErrorPanel));

              if (!(mySession.getError().canIgnore())) {
                forceComplete();
              }
            }

            fireStateChanged();
          }
        }, myProgress);
      }
    });
  }

  private void forceComplete() {
    myTask.forceComplete();
    myProgress.setFraction(1.0);
    fireStateChanged();
  }

  @Override
  public Object getNextStepId() {
    if (myTask.isComplete()) {
      return null;
    }

    myShouldSleepOnInit = false;
    return ID;
  }

  @Override
  public Object getPreviousStepId() {
    return null;
  }

  @Override
  public boolean isComplete() {
    // finished or is waiting for user response after error 
    return myTask.isComplete() || mySession.getError() != null;
  }

  @Override
  public boolean canBeCancelled() {
    return isErrorReplyState();
  }

  private boolean isErrorReplyState() {
    return mySession.getError() != null && mySession.getError().canIgnore();
  }

  @Override
  public String nextButtonLabel() {
    return (getNextStepId() == null ? super.nextButtonLabel() : "Ignore and Continue");
  }

  @Override
  public String cancelButtonLabel() {
    return (getNextStepId() == null ? super.cancelButtonLabel() : "Stop Migration");
  }

  @Override
  public void nextButtonAction() {
    if (isErrorReplyState()) {
      myErrorPanel.setVisible(false);
    }
    // the "next" action will invoke _init(), which will continue running the task 
  }

  @Override
  public void cancelButtonAction() {
    if (isErrorReplyState()) {
      forceComplete();
    }
  }

  private class MyInlineProgressIndicator extends InlineProgressIndicator {
    public MyInlineProgressIndicator() {
      super(false, new TaskInfo() {
        @NotNull
        public String getTitle() {
          return "Migration in progress";
        }
        public String getCancelText() {
          return "";
        }
        public String getCancelTooltipText() {
          return "";
        }
        public boolean isCancellable() {
          return false;
        }
        @NonNls
        public String getProcessId() {
          return "migration";
        }
      });
      setIndeterminate(false);
      setFraction(0.0);
    }
    @Override
    protected void queueProgressUpdate() {
      if (ThreadUtils.isInEDT()) {
        updateAndRepaint();
      } else {
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            updateAndRepaint();
          }
        }, ModalityState.stateForComponent(getComponent()));
      }
    }
    @Override
    protected void queueRunningUpdate(@NotNull Runnable update) {
      throw new UnsupportedOperationException();
    }
    @Override
    protected boolean isFinished() {
      return myTask.isComplete();
    }
  }
}
