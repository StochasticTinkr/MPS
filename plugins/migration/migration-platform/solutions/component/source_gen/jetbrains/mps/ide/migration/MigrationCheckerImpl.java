package jetbrains.mps.ide.migration;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import org.jetbrains.mps.openapi.util.Processor;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.lang.migration.runtime.base.MigrationModuleUtil;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.List;
import java.util.Collection;
import java.util.HashSet;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.errors.item.IssueKindReportItem;
import jetbrains.mps.ide.migration.check.DependencyProblem;
import java.util.ArrayList;
import jetbrains.mps.module.ReloadableModule;
import jetbrains.mps.classloading.ModuleClassLoaderSupport;
import org.jetbrains.mps.openapi.module.SDependency;
import java.util.Set;
import java.util.Map;
import jetbrains.mps.errors.item.FlavouredItem;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.util.SubProgressKind;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.checkers.IChecker;
import jetbrains.mps.errors.item.NodeReportItem;
import jetbrains.mps.checkers.AbstractNodeCheckerInEditor;
import jetbrains.mps.project.validation.StructureChecker;
import org.jetbrains.mps.openapi.util.Consumer;
import jetbrains.mps.errors.item.UnresolvedReferenceReportItem;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.progress.ProgressMonitorDecorator;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.lang.smodel.query.runtime.CommandUtil;
import jetbrains.mps.lang.smodel.query.runtime.QueryExecutionContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import jetbrains.mps.lang.migration.runtime.base.MigrateManually;

public class MigrationCheckerImpl implements MigrationChecker {
  private Project myProject;
  private MigrationRegistry myManager;

  public MigrationCheckerImpl(Project p, MigrationRegistry manager) {
    myProject = p;
    myManager = manager;
  }

  @Override
  public void checkMigrations(ProgressMonitor m, final Processor<ScriptApplied> processor) {
    m.start("Checking migrations consistency...", 1);
    myProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<ScriptApplied> problems = CollectionSequence.fromCollection(myManager.getModuleMigrations(MigrationModuleUtil.getMigrateableModulesFromProject(myProject))).where(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return it.getScriptReference().resolve(myProject, false) == null;
          }
        });
        for (ScriptApplied problem : Sequence.fromIterable(problems)) {
          if (!(processor.process(problem))) {
            break;
          }
        }
      }
    });
    m.done();
  }
  @Override
  public void checkLibs(ProgressMonitor m, final Processor<Pair<SModule, SModule>> processor) {
    m.start("Checking dependencies...", 1);
    myProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        List<SModule> projectModules = Sequence.fromIterable(MigrationModuleUtil.getMigrateableModulesFromProject(myProject)).toListSequence();
        Collection<SModule> depModules = CollectionSequence.fromCollectionWithValues(new HashSet<SModule>(), new GlobalModuleDependenciesManager(projectModules).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE));
        CollectionSequence.fromCollection(depModules).removeSequence(Sequence.fromIterable((Iterable<SModule>) myProject.getModulesWithGenerators()));
        depModules = CollectionSequence.fromCollection(depModules).where(new IWhereFilter<SModule>() {
          public boolean accept(SModule it) {
            return MigrationModuleUtil.wouldBeMigrateableWhenNotPacked(it);
          }
        }).toListSequence();
        Collection<ScriptApplied> depMigrationsToRun = myManager.getModuleMigrations(depModules);
        Iterable<SModule> notMigratedModules = CollectionSequence.fromCollection(depMigrationsToRun).select(new ISelector<ScriptApplied, SModule>() {
          public SModule select(ScriptApplied it) {
            return it.getModule();
          }
        }).distinct();
        for (final SModule notMigrated : Sequence.fromIterable(notMigratedModules)) {
          SModule m = ListSequence.fromList(projectModules).findFirst(new IWhereFilter<SModule>() {
            public boolean accept(SModule depCandidate) {
              return new GlobalModuleDependenciesManager(depCandidate).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE).contains(notMigrated);
            }
          });
          if (m == null) {
            continue;
          }
          processor.process(new Pair(notMigrated, m));
        }
      }
    });
    m.done();
  }
  @Override
  public void checkProject(final ProgressMonitor pm, final Processor<IssueKindReportItem> processor) {
    myProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        // todo inline 
        List<SModule> modules = Sequence.fromIterable(MigrationModuleUtil.getMigrateableModulesFromProject(myProject)).toListSequence();
        pm.start("Checking...", 10 + ListSequence.fromList(modules).count());

        List<DependencyProblem> rv = ListSequence.fromList(new ArrayList<DependencyProblem>());
        Iterable<ReloadableModule> allModules = ListSequence.fromList(modules).ofType(ReloadableModule.class).where(new IWhereFilter<ReloadableModule>() {
          public boolean accept(ReloadableModule it) {
            return ModuleClassLoaderSupport.canCreate(it);
          }
        });
        for (ReloadableModule module : Sequence.fromIterable(allModules)) {
          Iterable<SDependency> deps = Sequence.fromIterable(((Iterable<SDependency>) module.getDeclaredDependencies())).where(new IWhereFilter<SDependency>() {
            public boolean accept(SDependency it) {
              return it.getTarget() == null;
            }
          });
          for (SDependency dep : Sequence.fromIterable(deps)) {
            if (!(processor.process(new DependencyProblem(module, String.format("Unresolved dependency in module %s: Module %s not found in repository", module.getModuleName(), dep.getTargetModule().getModuleName()))))) {
              pm.done();
              return;
            }
          }
        }

        pm.advance(10);

        final Set<Map<FlavouredItem.ReportItemFlavour<?, ?>, Object>> alreadyReported = SetSequence.fromSet(new HashSet<Map<FlavouredItem.ReportItemFlavour<?, ?>, Object>>());

        try {
          for (SModule module : ListSequence.fromList(modules)) {
            List<EditableSModel> models = Sequence.fromIterable(((Iterable<SModel>) module.getModels())).ofType(EditableSModel.class).toListSequence();
            ProgressMonitor moduleSubtask = pm.subTask(1, SubProgressKind.AS_COMMENT);
            moduleSubtask.start(NameUtil.compactNamespace(module.getModuleName()), ListSequence.fromList(models).count());
            // find missing concepts, when language's not missing 
            // find missing concept features when concept's not missing 
            for (EditableSModel model : ListSequence.fromList(models)) {
              final Wrappers._boolean stop = new Wrappers._boolean(false);
              IChecker.AbstractModelChecker<NodeReportItem> checker = IChecker.AbstractModelChecker.wrapToModelChecker(IChecker.AbstractRootChecker.wrapToRootChecker((AbstractNodeCheckerInEditor) (AbstractNodeCheckerInEditor) new StructureChecker(false, true, false, true)));
              checker.check(model, myProject.getRepository(), new Consumer<NodeReportItem>() {
                public void consume(NodeReportItem vp) {
                  if (!(vp instanceof UnresolvedReferenceReportItem)) {
                    Map<FlavouredItem.ReportItemFlavour<?, ?>, Object> kindFlavours = MapSequence.fromMap(new HashMap<FlavouredItem.ReportItemFlavour<?, ?>, Object>());
                    for (FlavouredItem.ReportItemFlavour<?, ?> flavour : SetSequence.fromSet(vp.getIdFlavours())) {
                      MapSequence.fromMap(kindFlavours).put(flavour, flavour.tryToGet(vp));
                    }
                    MapSequence.fromMap(kindFlavours).removeKey(NodeReportItem.FLAVOUR_NODE);
                    if (!(SetSequence.fromSet(alreadyReported).contains(kindFlavours))) {
                      if (!(processor.process(vp))) {
                        stop.value = true;
                      }
                      SetSequence.fromSet(alreadyReported).addElement(kindFlavours);
                    }
                  } else {
                    if (!(processor.process(vp))) {
                      stop.value = true;
                    }
                  }
                }
              }, new ProgressMonitorDecorator(moduleSubtask.subTask(1)) {
                @Override
                public boolean isCanceled() {
                  return super.isCanceled() && !(stop.value);
                }
              });
              if (stop.value) {
                return;
              }
            }
            moduleSubtask.done();
          }
        } finally {
          pm.done();
        }
      }
    });
  }
  @Override
  public void findNotMigrated(final ProgressMonitor m, final Iterable<ScriptApplied> migrationsToCheck, final Processor<Problem> processor) {
    myProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = Sequence.fromIterable(migrationsToCheck).select(new ISelector<ScriptApplied, SModule>() {
          public SModule select(ScriptApplied it) {
            return it.getModule();
          }
        }).distinct();
        Iterable<ScriptApplied> migrations = Sequence.fromIterable(migrationsToCheck).where(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return it.getScriptReference() instanceof MigrationScriptReference;
          }
        });

        m.start("Finding not migrated code...", Sequence.fromIterable(modules).count() + Sequence.fromIterable(migrations).count() * 10);

        final int allSteps = Sequence.fromIterable(migrationsToCheck).count();
        int stepsPassed = 0;

        List<Problem> result = ListSequence.fromList(new ArrayList<Problem>());
        {
          final SearchScope scope = CommandUtil.createScope(modules);
          QueryExecutionContext context = new QueryExecutionContext() {
            public SearchScope getDefaultSearchScope() {
              return scope;
            }
          };
          for (SNode ann : CollectionSequence.fromCollection(CommandUtil.instances(CommandUtil.selectScope(null, context), MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x2274019e61f0c2c8L, "jetbrains.mps.lang.core.structure.MigrationAnnotation_old"), false)).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return ((boolean) (Boolean) BHReflection.invoke0(it, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x2274019e61f0c2c8L, "jetbrains.mps.lang.core.structure.MigrationAnnotation_old"), SMethodTrimmedId.create("showInResults", null, "29O0pTxWdmG")));
            }
          })) {
            if (!(processor.process(new MigrateManually(ann)))) {
              m.done();
              return;
            }
            m.advance(1);
          }
        }

        // todo show only annotations left by our run migrations 
        for (ScriptApplied sa : Sequence.fromIterable(migrations)) {
          for (Problem p : Sequence.fromIterable(((MigrationScriptReference) sa.getScriptReference()).resolve(myProject, false).check(sa.getModule()))) {
            if (!(processor.process(p))) {
              m.done();
              return;
            }
          }
          m.advance(10);
        }
      }
    });
  }
}
