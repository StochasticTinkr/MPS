package jetbrains.mps.migration.workbench.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.migration.wizard.MigrationSession;
import jetbrains.mps.project.MPSProject;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigration;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.ide.migration.MigrationChecker;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import org.jetbrains.mps.openapi.util.Processor;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.util.Pair;
import jetbrains.mps.errors.item.IssueKindReportItem;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.lang.smodel.query.runtime.CommandUtil;
import jetbrains.mps.lang.smodel.query.runtime.QueryExecutionContext;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.errors.item.UnresolvedReferenceReportItem;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.ide.migration.MigrationExecutor;
import jetbrains.mps.project.Project;
import jetbrains.mps.ide.migration.MigrationRegistry;
import jetbrains.mps.migration.global.MigrationOptions;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import java.util.Collection;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.migration.runtime.base.BaseScriptReference;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptBase;
import org.jetbrains.mps.openapi.language.SLanguage;

/*package*/ class TestMigrationSession extends MigrationSession.MigrationSessionBase {
  private TestMigrationSession.MyMigrationManager myManager = new TestMigrationSession.MyMigrationManager();
  private MigrationTestConfigDialog.Result mySettings;
  private MPSProject myProject;

  private List<ProjectMigration> passedP = ListSequence.fromList(new ArrayList<ProjectMigration>());
  private List<ScriptApplied> passedM = ListSequence.fromList(new ArrayList<ScriptApplied>());
  private MigrationChecker myChecker = new MigrationChecker() {
    public void checkMigrations(ProgressMonitor m, Processor<ScriptApplied> processor) {
      if (mySettings.preError != 2) {
        return;
      }
      final Wrappers._T<SModule> module = new Wrappers._T<SModule>();
      final SRepository repo = myProject.getRepository();
      repo.getModelAccess().runReadAction(new Runnable() {
        public void run() {
          module.value = repo.getModules().iterator().next();
        }
      });
      processor.process(new ScriptApplied(module.value, ListSequence.fromList(myManager.getModuleMig()).first().getReference()));
    }
    public void checkLibs(ProgressMonitor m, Processor<Pair<SModule, SModule>> processor) {
      // todo 
    }
    @Override
    public void checkProject(ProgressMonitor m, Processor<IssueKindReportItem> processor) {
      if (mySettings.preError != 1) {
        return;
      }
      final Wrappers._T<SReference> ref = new Wrappers._T<SReference>(null);
      myProject.getRepository().getModelAccess().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<SReference>() {
        public SReference invoke() {
          {
            final SearchScope scope = CommandUtil.createScope(myProject);
            QueryExecutionContext context = new QueryExecutionContext() {
              public SearchScope getDefaultSearchScope() {
                return scope;
              }
            };
            return ref.value = Sequence.fromIterable(CommandUtil.nodes(CommandUtil.selectScope(null, context))).translate(new ITranslator2<SNode, SReference>() {
              public Iterable<SReference> translate(SNode it) {
                return IterableUtil.asCollection(it.getReferences());
              }
            }).first();
          }
        }
      }));
      assert ref.value != null;
      processor.process(new UnresolvedReferenceReportItem(ref.value, null));
    }
    @Override
    public void findNotMigrated(ProgressMonitor m, Iterable<ScriptApplied> toCheck, Processor<Problem> processor) {
      // todo  
    }
  };
  private MigrationExecutor myExecutor = new MigrationExecutor() {
    public void executeModuleMigration(ScriptApplied s) {
      s.getScriptReference().resolve(myProject, true).execute(s.getModule());
      ListSequence.fromList(passedM).addElement(s);
    }
    public void executeProjectMigration(ProjectMigration pm) {
      pm.execute(myProject);
      ListSequence.fromList(passedP).addElement(pm);
    }
  };

  public TestMigrationSession(MPSProject p, MigrationTestConfigDialog.Result settings) {
    mySettings = settings;
    myProject = p;
    getRequiredSteps().add(MigrationSession.MigrationStepKind.MIGRATE);
  }
  public Project getProject() {
    return myProject;
  }
  public MigrationRegistry getMigrationRegistry() {
    return this.myManager;
  }
  public MigrationOptions getOptions() {
    MigrationOptions res = new MigrationOptions();
    for (ProjectMigration pm : CollectionSequence.fromCollection(getMigrationRegistry().getProjectMigrations())) {
      if (pm instanceof ProjectMigrationWithOptions) {
        for (ProjectMigrationWithOptions.Option o : CollectionSequence.fromCollection(((ProjectMigrationWithOptions) pm).getOptions())) {
          res.addOption(o);
        }
      }
    }
    return res;
  }
  private class MyMigrationManager implements MigrationRegistry {
    private List<ProjectMigration> myProjectMig;
    private List<MigrationScript> myModuleMig;

    public MyMigrationManager() {
    }
    public boolean isMigrationRequired() {
      return mySettings.required;
    }
    public boolean isMigrationRequired(Iterable<SModule> modules) {
      return true;
    }
    public boolean importVersionsUpdateRequired(Iterable<SModule> modules) {
      return false;
    }
    public void doUpdateImportVersions(SModule module) {
    }
    @Override
    public Collection<ProjectMigration> getProjectMigrations() {
      return getProjectMig();
    }
    @Override
    public Collection<ScriptApplied> getModuleMigrations(Iterable<SModule> modules) {
      if (Sequence.fromIterable(modules).isEmpty()) {
        return Collections.emptyList();
      }
      final Iterable<SModule> modulesWithGenerators = myProject.getProjectModulesWithGenerators();
      if (Sequence.fromIterable(modules).any(new IWhereFilter<SModule>() {
        public boolean accept(SModule it) {
          return !(Sequence.fromIterable(modulesWithGenerators).contains(it));
        }
      })) {
        return Collections.emptyList();
      }
      return (List<ScriptApplied>) ((List) Sequence.fromIterable(getModuleMigrationsApplied()).toListSequence());
    }
    public ProjectMigration nextProjectStep(MigrationOptions options, final boolean cleanup) {
      final ProjectMigration next = CollectionSequence.fromCollection(getProjectMigrations()).where(new IWhereFilter<ProjectMigration>() {
        public boolean accept(ProjectMigration it) {
          return cleanup == (it instanceof CleanupProjectMigration);
        }
      }).findFirst(new IWhereFilter<ProjectMigration>() {
        public boolean accept(ProjectMigration it) {
          return !(ListSequence.fromList(passedP).contains(it));
        }
      });
      if (next == null) {
        return null;
      }
      ListSequence.fromList(passedP).addElement(next);
      return next;
    }
    public ScriptApplied nextModuleStep(@Nullable BaseScriptReference ref) {
      Iterable<ScriptApplied> applied = getModuleMigrationsApplied();
      final ScriptApplied sa = Sequence.fromIterable(applied).where(new IWhereFilter<ScriptApplied>() {
        public boolean accept(final ScriptApplied sa) {
          return ListSequence.fromList(passedM).all(new IWhereFilter<ScriptApplied>() {
            public boolean accept(ScriptApplied it) {
              return neq_51bgm5_a0a0a0a0a0a0a0a0a0a0a0b0l31(it.getScriptReference(), sa.getScriptReference()) || it.getModule() != sa.getModule();
            }
          });
        }
      }).sort(new ISelector<ScriptApplied, Integer>() {
        public Integer select(ScriptApplied it) {
          return ((MigrationScriptReference) it.getScriptReference()).getFromVersion();
        }
      }, true).first();
      return sa;
    }
    private Iterable<ScriptApplied> getModuleMigrationsApplied() {
      final Wrappers._T<Iterable<ScriptApplied>> res = new Wrappers._T<Iterable<ScriptApplied>>();
      final SRepository repo = myProject.getRepository();
      repo.getModelAccess().runReadAction(new Runnable() {
        public void run() {
          final List<SModule> modules = Sequence.fromIterable(((Iterable<SModule>) repo.getModules())).take(3).toListSequence();
          res.value = ListSequence.fromList(MyMigrationManager.this.getModuleMig()).translate(new ITranslator2<MigrationScript, ScriptApplied>() {
            public Iterable<ScriptApplied> translate(final MigrationScript script) {
              return ListSequence.fromList(modules).where(new IWhereFilter<SModule>() {
                public boolean accept(SModule it) {
                  int si = ListSequence.fromList(getModuleMig()).indexOf(script);
                  int mi = ListSequence.fromList(modules).indexOf(it);
                  return ListSequence.fromList(mySettings.lMigrations).getElement(si).applyToModules[mi];
                }
              }).select(new ISelector<SModule, ScriptApplied>() {
                public ScriptApplied select(SModule module) {
                  return new ScriptApplied(module, script.getReference());
                }
              });
            }
          });
        }
      });
      return res.value;
    }
    private List<ProjectMigration> getProjectMig() {
      if (myProjectMig == null) {
        myProjectMig = createProjectMigs();
      }
      return myProjectMig;
    }
    private List<MigrationScript> getModuleMig() {
      if (myModuleMig == null) {
        myModuleMig = createLanguageMigs();
      }
      return myModuleMig;
    }
  }

  private List<ProjectMigration> createProjectMigs() {
    return ListSequence.fromList(mySettings.pMigrations).select(new ISelector<MigrationTestConfigDialog.Result.PMigration, ProjectMigration>() {
      public ProjectMigration select(MigrationTestConfigDialog.Result.PMigration pmig) {
        if (pmig.isCleanup) {
          return (ProjectMigration) new TestMigrationSession.MyCleanupProjectMigration("cleanup: " + pmig.id, pmig.hasOptions, pmig.error);
        } else {
          return (ProjectMigration) new TestMigrationSession.MyProjectMigration("project: " + pmig.id, pmig.hasOptions, pmig.error);
        }
      }
    }).toListSequence();
  }

  private List<MigrationScript> createLanguageMigs() {
    return ListSequence.fromList(mySettings.lMigrations).select(new ISelector<MigrationTestConfigDialog.Result.LMigration, MigrationScript>() {
      public MigrationScript select(MigrationTestConfigDialog.Result.LMigration lmig) {
        return (MigrationScript) new TestMigrationSession.MyModuleMigration(lmig.language, lmig.version, lmig.error);
      }
    }).toListSequence();
  }

  private class MyModuleMigration extends MigrationScriptBase {
    private SLanguage myLang;
    private int myVersion;
    private boolean myError;

    public MyModuleMigration(SLanguage lang, int version, boolean error) {
      myLang = lang;
      myVersion = version;
      myError = error;
    }
    @Override
    public String getCaption() {
      return myLang + ": " + myVersion;
    }
    public MigrationScriptReference getReference() {
      // todo this is suspicious 
      // todo name is used as id here 
      final TestMigrationSession.MyModuleMigration _this = this;
      return new MigrationScriptReference(myLang, 0) {
        @Override
        public MigrationScript resolve(Project p, boolean silent) {
          return _this;
        }
      };
    }
    @Nullable
    public SNode execute(SModule module) {
      if (myError) {
        throw new UnsupportedOperationException("exception from test migration");
      }
      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
      }
      return null;
    }
  }

  private class MyProjectMigration implements ProjectMigration, ProjectMigrationWithOptions {
    private String myId;
    private boolean myOptions;
    private boolean myError;
    public MyProjectMigration(String id, boolean options, boolean error) {
      myId = id;
      myOptions = options;
      myError = error;
    }
    public String getDescription() {
      return myId;
    }
    public void applyToCreatedProject(Project p0) {
    }
    public boolean shouldBeExecuted(Project p0) {
      return true;
    }
    public boolean isRerunnable() {
      return true;
    }
    public void execute(Project p0) {
      if (myError) {
        throw new UnsupportedOperationException("exception from test migration");
      }
      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
      }
    }
    @Override
    public Collection<ProjectMigrationWithOptions.Option> getOptions() {
      if (myOptions) {
        return ListSequence.fromListAndArray(new ArrayList<ProjectMigrationWithOptions.Option>(), new ProjectMigrationWithOptions.BooleanOption(myId, "option of " + myId, true));
      }
      return Collections.emptyList();
    }
    @Override
    public void setOptionValues(MigrationOptions options) {
    }
  }

  private class MyCleanupProjectMigration extends TestMigrationSession.MyProjectMigration implements CleanupProjectMigration, ProjectMigrationWithOptions {
    public MyCleanupProjectMigration(String id, boolean options, boolean error) {
      super(id, options, error);
    }

    @Override
    public void forceExecutionNextTime(Project project) {
    }
  }

  @Override
  public MigrationChecker getChecker() {
    return this.myChecker;
  }

  @Override
  public MigrationExecutor getExecutor() {
    return myExecutor;
  }
  private static boolean neq_51bgm5_a0a0a0a0a0a0a0a0a0a0a0b0l31(Object a, Object b) {
    return !(((a != null ? a.equals(b) : a == b)));
  }
}
