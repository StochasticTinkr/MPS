package jetbrains.mps.migration.workbench.components;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.migration.global.MigrationProblemHandler;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.ide.findusages.view.UsagesViewTool;
import jetbrains.mps.ide.modelchecker.platform.actions.ModelCheckerTool;
import com.intellij.openapi.project.Project;
import java.util.Collection;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.errors.item.IssueKindReportItem;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.modelchecker.platform.actions.ModelCheckerViewer;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.icons.AllIcons;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.errors.MessageStatus;
import jetbrains.mps.errors.item.FlavouredItem;
import java.util.HashSet;
import jetbrains.mps.errors.item.ReportItemBase;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.errors.item.NodeReportItem;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.errors.item.ModelFlavouredItem;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.errors.item.ModuleFlavouredItem;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import org.apache.log4j.Level;

public class WorkbenchMigrationProblemHandler extends AbstractProjectComponent implements MigrationProblemHandler {
  private static final Logger LOG = LogManager.getLogger(WorkbenchMigrationProblemHandler.class);
  private UsagesViewTool myUsagesTool;
  private ModelCheckerTool myMcTool;

  public WorkbenchMigrationProblemHandler(Project project, UsagesViewTool usagesTool, ModelCheckerTool mcTool) {
    super(project);
    myUsagesTool = usagesTool;
    myMcTool = mcTool;
  }

  public void showProblems(Collection<Problem> problems) {
    Iterable<SearchResult<IssueKindReportItem>> items = CollectionSequence.fromCollection(problems).select(new ISelector<Problem, SearchResult<IssueKindReportItem>>() {
      public SearchResult<IssueKindReportItem> select(Problem p) {
        return new SearchResult<IssueKindReportItem>(issueByProblem(p), p.getReason(), p.getCategory());
      }
    }).where(new IWhereFilter<SearchResult<IssueKindReportItem>>() {
      public boolean accept(SearchResult<IssueKindReportItem> it) {
        return it != null;
      }
    });

    if (Sequence.fromIterable(items).isEmpty()) {
      return;
    }

    ModelCheckerViewer v = new ModelCheckerViewer(myProject, false) {
      @Override
      protected void close() {
        myMcTool.closeTab(this);
        super.close();
      }
    };

    final SearchResults<IssueKindReportItem> result = new SearchResults<IssueKindReportItem>();
    Sequence.fromIterable(items).visitAll(new IVisitor<SearchResult<IssueKindReportItem>>() {
      public void visit(SearchResult<IssueKindReportItem> it) {
        result.add(it);
      }
    });
    v.setSearchResults(result);
    myMcTool.showTabWithResults(v, "Migration issues", AllIcons.Nodes.ModuleGroup);
  }

  public void showNodes(final Map<String, Set<SNode>> toShow) {
    final SearchResults sr = new SearchResults();
    SetSequence.fromSet(MapSequence.fromMap(toShow).keySet()).translate(new ITranslator2<String, SearchResult>() {
      public Iterable<SearchResult> translate(String k) {
        return SetSequence.fromSet(MapSequence.fromMap(toShow).get(k)).select(new ISelector<SNode, SearchResult>() {
          public SearchResult select(SNode node) {
            return new SearchResult();
          }
        });
      }
    }).visitAll(new IVisitor<SearchResult>() {
      public void visit(SearchResult it) {
        sr.add(it);
      }
    });
    myUsagesTool.show(sr, "No results to show");
  }

  public static class MigrationReportItem<T> implements IssueKindReportItem {
    private String myMessage;
    private T myReason;
    public MigrationReportItem(T reason, String message) {
      myMessage = message;
      myReason = reason;
    }
    @Override
    public String getIssueKind() {
      return "migration problem";
    }
    @Override
    public String getMessage() {
      return myMessage;
    }
    @Override
    public MessageStatus getSeverity() {
      return MessageStatus.ERROR;
    }
    public T getReason() {
      return myReason;
    }
    @Override
    public Set<FlavouredItem.ReportItemFlavour<?, ?>> getIdFlavours() {
      return SetSequence.fromSetAndArray(new HashSet<FlavouredItem.ReportItemFlavour<?, ?>>(), ReportItemBase.FLAVOUR_CLASS, ReportItemBase.FLAVOUR_THIS);
    }
  }
  public static class MigrationReportItemNode extends WorkbenchMigrationProblemHandler.MigrationReportItem<SNodeReference> implements NodeReportItem {
    public MigrationReportItemNode(SNodeReference reason, String message) {
      super(reason, message);
    }
    @Override
    public SNodeReference getNode() {
      return getReason();
    }
  }
  public static class MigrationReportItemModel extends WorkbenchMigrationProblemHandler.MigrationReportItem<SModelReference> implements ModelFlavouredItem {
    public MigrationReportItemModel(SModelReference reason, String message) {
      super(reason, message);
    }
    @NotNull
    @Override
    public SModelReference getModel() {
      return getReason();
    }
  }
  public static class MigrationReportItemModule extends WorkbenchMigrationProblemHandler.MigrationReportItem<SModuleReference> implements ModuleFlavouredItem {
    public MigrationReportItemModule(SModuleReference reason, String message) {
      super(reason, message);
    }
    @NotNull
    @Override
    public SModuleReference getModule() {
      return getReason();
    }
  }

  private IssueKindReportItem issueByProblem(Problem p) {
    Object r = p.getReason();
    if (r instanceof SNode) {
      return new WorkbenchMigrationProblemHandler.MigrationReportItemNode(((SNode) r).getReference(), p.getMessage());
    }
    if (r instanceof SModel) {
      return new WorkbenchMigrationProblemHandler.MigrationReportItemModel(((SModel) r).getReference(), p.getMessage());
    }
    if (r instanceof SModule) {
      return new WorkbenchMigrationProblemHandler.MigrationReportItemModule(((SModule) r).getModuleReference(), p.getMessage());
    }

    if (LOG.isEnabledFor(Level.ERROR)) {
      LOG.error("Unknown issue type: " + r.getClass().getName());
    }
    return null;
  }

  @Override
  public void projectOpened() {
  }
  @Override
  public void projectClosed() {
  }
  @Override
  public void initComponent() {
  }
  @Override
  public void disposeComponent() {
  }
  @Override
  @NotNull
  public String getComponentName() {
    return this.getClass().getSimpleName();
  }
}
