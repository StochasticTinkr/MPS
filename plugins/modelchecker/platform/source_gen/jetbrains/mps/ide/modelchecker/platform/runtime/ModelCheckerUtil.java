package jetbrains.mps.ide.modelchecker.platform.runtime;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.checkers.IAbstractChecker;
import jetbrains.mps.errors.item.IssueKindReportItem;
import jetbrains.mps.checkers.IChecker;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.util.Consumer;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.util.SubProgressKind;
import jetbrains.mps.checkers.FilteringChecker;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.errors.item.NodeReportItem;
import org.apache.log4j.Level;
import jetbrains.mps.checkers.SkippingChecker;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.checkers.AggregatingChecker;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.checkers.CatchingChecker;
import jetbrains.mps.checkers.CategoryShowingChecker;

public class ModelCheckerUtil {
  private static final Logger LOG = LogManager.getLogger(ModelCheckerUtil.class);
  /**
   * drops only issues in tests
   * ErrorReportUtil.shouldReportError => SpecificChecker.filterIssue
   */
  public static boolean filterIssue(SNode node) {
    SNode container = AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11b07a3d4b5L, "jetbrains.mps.lang.test.structure.NodeOperationsContainer")));
    if (container == null) {
      return true;
    }
    for (SNode property : SLinkOperations.getChildren(container, MetaAdapterFactory.getContainmentLink(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11b07a3d4b5L, 0x11b07abae7cL, "nodeOperations"))) {
      if (SNodeOperations.isInstanceOf(property, MetaAdapterFactory.getConcept(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11b01e7283dL, "jetbrains.mps.lang.test.structure.NodeErrorCheckOperation"))) {
        return false;
      }
    }
    return true;
  }

  private static List<SModel> getModelDescriptors(SModule module, boolean includeStubs) {
    List<SModel> modelDescrpitors = ListSequence.fromList(new ArrayList<SModel>());
    for (SModel modelDescriptor : Sequence.fromIterable(module.getModels())) {
      if (SModelStereotype.isUserModel(modelDescriptor)) {
        ListSequence.fromList(modelDescrpitors).addElement(modelDescriptor);
      }
      if (includeStubs && SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(modelDescriptor))) {
        ListSequence.fromList(modelDescrpitors).addElement(modelDescriptor);
      }
    }
    return modelDescrpitors;
  }

  public static class ItemsToCheck {
    public List<SModel> models = ListSequence.fromList(new ArrayList<SModel>());
    public List<SModule> modules = ListSequence.fromList(new ArrayList<SModule>());
  }

  public static IAbstractChecker<ModelCheckerUtil.ItemsToCheck, IssueKindReportItem> find(final List<IChecker<SModel, ? extends IssueKindReportItem>> specificModelCheckers, final List<IChecker<SModule, ? extends IssueKindReportItem>> specificModuleCheckers, final boolean includeStubs) {
    return new IAbstractChecker<ModelCheckerUtil.ItemsToCheck, IssueKindReportItem>() {
      public void check(ModelCheckerUtil.ItemsToCheck itemsToCheck, SRepository repository, Consumer<? super IssueKindReportItem> errorCollector, ProgressMonitor monitor) {
        List<SModule> modules = itemsToCheck.modules;
        ListSequence.fromList(modules).addSequence(ListSequence.fromList(modules).ofType(Language.class).translate(new ITranslator2<Language, Generator>() {
          public Iterable<Generator> translate(Language language) {
            return language.getGenerators();
          }
        }));
        int work = ListSequence.fromList(itemsToCheck.models).count() + ListSequence.fromList(itemsToCheck.modules).count() + ListSequence.fromList(modules).translate(new ITranslator2<SModule, SModel>() {
          public Iterable<SModel> translate(SModule it) {
            return getModelDescriptors(it, includeStubs);
          }
        }).count();
        monitor.start("Checking", work);

        try {
          IAbstractChecker<SModule, ? extends IssueKindReportItem> generalModuleChecker = aggreagateSpecificCheckers(specificModuleCheckers, new _FunctionTypes._return_P1_E0<String, SModule>() {
            public String invoke(SModule m) {
              return m.getModuleName();
            }
          });
          IAbstractChecker<SModel, ? extends IssueKindReportItem> generalModelChecker = skipNullModules(aggreagateSpecificCheckers(specificModelCheckers, new _FunctionTypes._return_P1_E0<String, SModel>() {
            public String invoke(SModel m) {
              return m.getName().getLongName();
            }
          }));

          for (SModel model : ListSequence.fromList(itemsToCheck.models)) {
            generalModelChecker.check(model, repository, errorCollector, monitor.subTask(1, SubProgressKind.REPLACING));
            if (monitor.isCanceled()) {
              break;
            }
          }


          for (SModule module : ListSequence.fromList(modules)) {
            generalModuleChecker.check(module, repository, errorCollector, monitor.subTask(1, SubProgressKind.REPLACING));
            if (monitor.isCanceled()) {
              break;
            }
            for (SModel model : ListSequence.fromList(getModelDescriptors(module, includeStubs))) {
              generalModelChecker.check(model, repository, errorCollector, monitor.subTask(1, SubProgressKind.REPLACING));
              if (monitor.isCanceled()) {
                break;
              }
            }
          }
        } finally {
          monitor.done();
        }
      }
    };
  }

  public static <O> IAbstractChecker<O, IssueKindReportItem> wrapWithFiltering(final IAbstractChecker<O, ? extends IssueKindReportItem> specificChecker) {
    return new FilteringChecker<O, IssueKindReportItem>(specificChecker, new _FunctionTypes._return_P2_E0<Boolean, IssueKindReportItem, SRepository>() {
      public Boolean invoke(IssueKindReportItem item, SRepository repository) {
        SNodeReference node = NodeReportItem.FLAVOUR_NODE.tryToGet(item);
        if (node != null) {
          if (filterIssue(node.resolve(repository))) {
            return true;
          } else {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Specific checker " + specificChecker + " returned error that is supposed to be skipped. Node " + node.getNodeId() + " in model " + node.getModelReference());
            }
            return false;
          }
        } else {
          return true;
        }
      }
    });
  }

  public static IAbstractChecker<SModel, IssueKindReportItem> skipNullModules(IAbstractChecker<SModel, IssueKindReportItem> checker) {
    return new SkippingChecker<SModel, IssueKindReportItem>(checker, new _FunctionTypes._return_P2_E0<Boolean, SModel, SRepository>() {
      public Boolean invoke(SModel model, SRepository repository) {
        SModule module = model.getModule();
        if (module == null) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Module is null for " + model.getName() + " model");
          }
          return false;
        }
        return true;
      }
    });
  }

  public static <O> IAbstractChecker<O, IssueKindReportItem> aggreagateSpecificCheckers(@NotNull List<IChecker<O, ? extends IssueKindReportItem>> specificCheckers, final _FunctionTypes._return_P1_E0<? extends String, ? super O> getFqName) {
    AggregatingChecker<O, IssueKindReportItem> aggregation = new AggregatingChecker<O, IssueKindReportItem>(ListSequence.fromList(specificCheckers).select(new ISelector<IChecker<O, ? extends IssueKindReportItem>, CatchingChecker<O, IssueKindReportItem>>() {
      public CatchingChecker<O, IssueKindReportItem> select(IChecker<O, ? extends IssueKindReportItem> specificChecker) {
        return new CatchingChecker<O, IssueKindReportItem>(wrapWithFiltering(new CategoryShowingChecker<O, IssueKindReportItem>(specificChecker)), new _FunctionTypes._return_P3_E0<String, O, Exception, SRepository>() {
          public String invoke(O m, Exception e, SRepository repository) {
            return "Exception while checking model " + getFqName.invoke(m);
          }
        });
      }
    }).toListSequence(), getFqName);
    return aggregation;
  }
}
