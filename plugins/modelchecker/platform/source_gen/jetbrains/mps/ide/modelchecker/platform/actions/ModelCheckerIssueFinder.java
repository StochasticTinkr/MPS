package jetbrains.mps.ide.modelchecker.platform.actions;

/*Generated by MPS */

import jetbrains.mps.ide.findusages.findalgorithm.finders.BaseFinder;
import java.util.List;
import java.util.Arrays;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.errors.item.IssueKindReportItem;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.util.SubProgressKind;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.ide.findusages.model.SearchResult;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.ArrayList;
import jetbrains.mps.errors.item.NodeFlavouredItem;
import jetbrains.mps.checkers.ErrorReportUtil;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.ide.findusages.model.holders.IHolder;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.ide.findusages.model.holders.ModelsHolder;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.errors.MessageStatus;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.findusages.model.CategoryKind;
import jetbrains.mps.ide.messages.Icons;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.util.Pair;

public class ModelCheckerIssueFinder extends BaseFinder {
  private final List<SpecificChecker> myExtraCheckers;

  public ModelCheckerIssueFinder(List<SpecificChecker> extraCheckers) {
    myExtraCheckers = extraCheckers;
  }
  public ModelCheckerIssueFinder(SpecificChecker... extraCheckers) {
    this(Arrays.asList(extraCheckers));
  }
  protected final List<SpecificChecker> getSpecificCheckers() {
    return myExtraCheckers;
  }
  @Override
  public SearchResults<IssueKindReportItem> find(SearchQuery searchQuery, ProgressMonitor monitor) {
    ModelCheckerIssueFinder.ItemsToCheck itemsToCheck = getItemsToCheck(searchQuery);

    int work = ListSequence.fromList(itemsToCheck.modules).count() + ListSequence.fromList(itemsToCheck.models).count() + 1;
    monitor.start("Checking", work);

    try {
      final SearchResults<IssueKindReportItem> rv = new SearchResults<IssueKindReportItem>();

      ModuleChecker moduleChecker = new ModuleChecker();
      for (final SModule module : ListSequence.fromList(itemsToCheck.modules)) {
        List<? extends IssueKindReportItem> results = moduleChecker.checkModule(module, monitor.subTask(1, SubProgressKind.REPLACING));
        rv.getSearchResults().addAll(ListSequence.fromList(results).select(new ISelector<IssueKindReportItem, SearchResult<IssueKindReportItem>>() {
          public SearchResult<IssueKindReportItem> select(IssueKindReportItem it) {
            return getSearchResultForReportItem(it, module.getRepository());
          }
        }).toListSequence());
        if (monitor.isCanceled()) {
          break;
        }
      }

      ModelChecker modelChecker = new ModelChecker(getSpecificCheckers());
      for (final SModel modelDescriptor : ListSequence.fromList(itemsToCheck.models)) {
        List<IssueKindReportItem> results = modelChecker.checkModel(modelDescriptor, monitor.subTask(1, SubProgressKind.REPLACING));
        rv.getSearchResults().addAll(ListSequence.fromList(results).select(new ISelector<IssueKindReportItem, SearchResult<IssueKindReportItem>>() {
          public SearchResult<IssueKindReportItem> select(IssueKindReportItem it) {
            return getSearchResultForReportItem(it, modelDescriptor.getRepository());
          }
        }).toListSequence());
        if (monitor.isCanceled()) {
          break;
        }
      }

      // filter out suppressed 
      List<SearchResult<IssueKindReportItem>> toRemove = ListSequence.fromList(new ArrayList<SearchResult<IssueKindReportItem>>());
      for (SearchResult<IssueKindReportItem> result : ListSequence.fromList(rv.getSearchResults())) {
        if (NodeFlavouredItem.FLAVOUR_NODE.canGet(result.getObject())) {
          if (!(ErrorReportUtil.shouldReportError(((SNode) result.getPathObject())))) {
            ListSequence.fromList(toRemove).addElement(result);
          }
        }
      }
      ListSequence.fromList(toRemove).visitAll(new IVisitor<SearchResult<IssueKindReportItem>>() {
        public void visit(SearchResult<IssueKindReportItem> it) {
          rv.remove(it);
        }
      });

      return rv;
    } finally {
      monitor.done();
    }
  }
  private static class ItemsToCheck {
    public List<SModel> models = ListSequence.fromList(new ArrayList<SModel>());
    public List<SModule> modules = ListSequence.fromList(new ArrayList<SModule>());
  }
  private ModelCheckerIssueFinder.ItemsToCheck getItemsToCheck(SearchQuery searchQuery) {
    IHolder objectHolder = searchQuery.getObjectHolder();
    final SearchScope scope = searchQuery.getScope();
    ModelCheckerIssueFinder.ItemsToCheck itemsToCheck = new ModelCheckerIssueFinder.ItemsToCheck();
    // FIXME IT'S PLAIN WRONG TO PASS SET OF MODELS/MODULES TO CHECK THROUGH IHolder. 
    //       SearchScope tells where to look for, SearchQuery.getObjectHolder tells what to look for 
    //       That's why I didn't change scope.resolve here to use query.getSearchObjectResolver()! 
    if (objectHolder instanceof ModelsHolder) {
      ModelsHolder modelsHolder = (ModelsHolder) objectHolder;
      for (SModelReference ref : modelsHolder.getObject()) {
        SModel resolved = scope.resolve(ref);
        if (resolved != null) {
          ListSequence.fromList(itemsToCheck.models).addElement(resolved);
        }
      }
    } else if (objectHolder.getObject() instanceof SModuleReference) {
      SModuleReference mr = (SModuleReference) objectHolder.getObject();
      SModule resolved = scope.resolve(mr);
      if (resolved != null) {
        ListSequence.fromList(itemsToCheck.modules).addElement(resolved);
        ListSequence.fromList(itemsToCheck.models).addSequence(ListSequence.fromList(ModelCheckerUtils.getModelDescriptors(resolved)));
      }
    } else if (objectHolder.getObject() instanceof SModelReference) {
      SModelReference mr = (SModelReference) objectHolder.getObject();
      SModel resolved = scope.resolve(mr);
      if (resolved != null) {
        ListSequence.fromList(itemsToCheck.models).addElement(resolved);
      }
    } else {
      throw new IllegalArgumentException();
    }
    return itemsToCheck;
  }
  public static String getResultCategory(MessageStatus messageStatus) {
    switch (messageStatus) {
      case ERROR:
        return SEVERITY_ERROR;
      case WARNING:
        return SEVERITY_WARNING;
      case OK:
        return SEVERITY_INFO;
      default:
        return SEVERITY_ERROR;
    }
  }
  /**
   * drops only issues in tests
   * ErrorReportUtil.shouldReportError => SpecificChecker.filterIssue
   */
  public static boolean filterIssue(SNode node) {
    SNode container = AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11b07a3d4b5L, "jetbrains.mps.lang.test.structure.NodeOperationsContainer")));
    if (container == null) {
      return true;
    }
    for (SNode property : SLinkOperations.getChildren(container, MetaAdapterFactory.getContainmentLink(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11b07a3d4b5L, 0x11b07abae7cL, "nodeOperations"))) {
      if (SNodeOperations.isInstanceOf(property, MetaAdapterFactory.getConcept(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11b01e7283dL, "jetbrains.mps.lang.test.structure.NodeErrorCheckOperation"))) {
        return false;
      }
    }
    return true;
  }
  public static final CategoryKind CATEGORY_KIND_SEVERITY = new CategoryKind("Severity", Icons.ERROR_ICON, "Group by severity");
  public static final CategoryKind CATEGORY_KIND_ISSUE_TYPE = new CategoryKind("Issue type", jetbrains.mps.ide.findusages.view.icons.Icons.CATEGORY_ICON, "Group by issue type");
  public static final String SEVERITY_ERROR = "Errors";
  public static final String SEVERITY_WARNING = "Warnings";
  public static final String SEVERITY_INFO = "Infos";
  public static SearchResult<IssueKindReportItem> getSearchResultForReportItem(IssueKindReportItem item, SRepository repository) {
    String issueKind = IssueKindReportItem.FLAVOUR_ISSUE_KIND.get(item);
    return new SearchResult<IssueKindReportItem>(item, IssueKindReportItem.PATH_OBJECT.get(item).resolve(repository), new Pair<CategoryKind, String>(CATEGORY_KIND_SEVERITY, getResultCategory(item.getSeverity())), new Pair<CategoryKind, String>(CATEGORY_KIND_ISSUE_TYPE, issueKind));
  }
}
