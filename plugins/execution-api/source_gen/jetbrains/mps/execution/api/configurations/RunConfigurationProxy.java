package jetbrains.mps.execution.api.configurations;

/*Generated by MPS */

import jetbrains.mps.execution.api.settings.IPersistentConfiguration;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.options.SettingsEditor;
import com.intellij.execution.configurations.RunConfiguration;
import org.jetbrains.annotations.Nullable;
import com.intellij.execution.configurations.RunProfileState;
import com.intellij.execution.Executor;
import com.intellij.execution.runners.ExecutionEnvironment;
import com.intellij.execution.ExecutionException;
import com.intellij.execution.configurations.RuntimeConfigurationException;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.execution.api.settings.PersistentConfigurationContext;
import org.jdom.Element;
import jetbrains.mps.execution.api.settings.SettingsEditorEx;

/**
 * NOT IN USE
 * Idea is to replace generated RunConfiguration classes with this proxy so that IDEA's RunnerAndConfigurationSettingsImpl can hold
 * an instance after generated delegate RunConfiguration class has been disposed/got invalid classloader.
 * I don't use it at the moment as there are producers that expect specific instance of RunConfiguration to come from ConfigurationFactory
 * (see reduce_RunConfigurationCreator), and I'd like to refactor producers first (including switch to RunConfigurationProducer instead of 
 * deprecated RuntimeConfigurationProducer) and then consider options for use of the proxy.
 */
/*package*/ final class RunConfigurationProxy extends BaseMpsRunConfiguration implements IPersistentConfiguration {
  private BaseMpsRunConfiguration myDelegate;

  public RunConfigurationProxy(ConfigFactoryEnvoy configFactory, Project project, BaseMpsRunConfiguration delegate) {
    super(project, configFactory, "");
    myDelegate = delegate;
  }

  @NotNull
  @Override
  public SettingsEditor<? extends RunConfiguration> getConfigurationEditor() {
    return myDelegate.getConfigurationEditor();
  }

  @Nullable
  @Override
  public RunProfileState getState(@NotNull Executor executor, @NotNull ExecutionEnvironment environment) throws ExecutionException {
    return myDelegate.getState(executor, environment);
  }

  @Override
  public void checkConfiguration() throws RuntimeConfigurationException {
    final MPSProject mpsProject = ProjectHelper.fromIdeaProject(getProject());
    checkConfiguration(new PersistentConfigurationContext() {
      public jetbrains.mps.project.Project getProject() {
        return mpsProject;
      }
    });
  }


  @Override
  public boolean canExecute(String executorId) {
    return myDelegate.canExecute(executorId);
  }

  @Override
  public void readExternal(@NotNull Element element) {
    // both IPersistentConfiguration and superclass 
  }

  @Override
  public void writeExternal(Element element) {
    // both IPersistentConfiguration and superclass 
  }

  @Override
  public void checkConfiguration(PersistentConfigurationContext context) throws RuntimeConfigurationException {
    // IPersistentConfiguration 
    ((IPersistentConfiguration) myDelegate).checkConfiguration(context);
  }


  @Override
  public SettingsEditorEx<? extends IPersistentConfiguration> getEditor() {
    // IPersistentConfiguration 
    return ((IPersistentConfiguration) myDelegate).getEditor();
  }

  @Override
  public IPersistentConfiguration createCloneTemplate() {
    // IPersistentConfiguration 

    return null;
  }
}
