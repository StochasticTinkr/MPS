package jetbrains.mps.execution.api.configurations;

/*Generated by MPS */

import com.intellij.execution.configurations.ConfigurationType;
import javax.swing.Icon;
import java.util.concurrent.CopyOnWriteArrayList;
import com.intellij.execution.configurations.ConfigurationFactory;
import org.jetbrains.annotations.NotNull;

/**
 * IDEA doesn't support RunConfiguration instances that come and go (reloadable; see RunnerAndConfigurationSettingsImpl, which stores RunConfiguration instance), therefore, we have to register
 * non-MPS managed (i.e. IDEA-managed) classes to respective extension points, so that reload of an MPS module doesn't lead to classloading exceptions when accessing classes from the previous CL run.
 * 
 * RunConfiguration comes from ConfigurationFactory which is supplied by ConfigurationType. This class is non-reloadable ConfigurationType implementation, aware of imermanent nature of run configurations 
 * contributed by MPS modules.
 * 
 * FIXME This is work in progress, need to introduce proxy classes for factory and run configuration. This class doesn't bear 'proxy' as it is full-fledged implementation (GenericConfigType? NonReloadableConfigType?)
 */
public final class ConfigTypeEnvoy implements ConfigurationType {
  private final String myId;
  private final Icon myIcon;
  private final String myDisplayName;
  private final String myDescription;
  private final CopyOnWriteArrayList<ConfigurationFactory> myFactories = new CopyOnWriteArrayList<ConfigurationFactory>();
  private boolean myIsInvalid;

  public ConfigTypeEnvoy(@NotNull String id, Icon icon, String displayName, String description) {
    myId = id;
    myIcon = icon;
    myDisplayName = displayName;
    myDescription = description;
  }

  @NotNull
  @Override
  public String getId() {
    return myId;
  }

  @Override
  public String getDisplayName() {
    return myDisplayName;
  }

  @Override
  public String getConfigurationTypeDescription() {
    return myDescription;
  }

  @Override
  public Icon getIcon() {
    return myIcon;
  }

  @Override
  public ConfigurationFactory[] getConfigurationFactories() {
    ConfigurationFactory[] rv = new ConfigurationFactory[0];
    return (myIsInvalid ? rv : myFactories.toArray(rv));
  }

  @Override
  public boolean isDumbAware() {
    // generated class didn't implement DumbAware interface, therefore state it's always false 
    return false;
  }

  /**
   * MPS INTERNAL API, DO NOT USE OUTSIDE OF MPS OR MPS-GENERATED CODE
   * 
   * Tells this particular proxy instance for a configuration type is no longer valid and shall not supply configuration factories or anything like that.
   */
  public void invalidate() {
    myIsInvalid = true;
  }
  /**
   * MPS INTERNAL API, DO NOT USE OUTSIDE OF MPS OR MPS-GENERATED CODE
   * 
   * Register a factory with the configuration type
   * 
   */
  public void addFactory(ConfigurationFactory factory) {
    assert !(myIsInvalid);
    myFactories.add(factory);
  }

  /**
   * MPS INTERNAL API, DO NOT USE OUTSIDE OF MPS OR MPS-GENERATED CODE
   * 
   * Unregister a previosul registerd factory with the configuration type
   */
  public void removeFactory(ConfigurationFactory factory) {
    myFactories.remove(factory);
  }
}
