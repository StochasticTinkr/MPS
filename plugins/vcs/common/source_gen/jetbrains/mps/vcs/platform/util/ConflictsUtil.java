package jetbrains.mps.vcs.platform.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.EditableSModel;
import com.intellij.openapi.project.Project;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import com.intellij.openapi.vfs.VirtualFile;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.persistence.DataSource;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.extapi.persistence.FileDataSource;
import jetbrains.mps.persistence.FilePerRootDataSource;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import com.intellij.openapi.vcs.FileStatus;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class ConflictsUtil {
  public ConflictsUtil() {
  }

  public static boolean isModelOrModuleConflicting(EditableSModel emd, Project project) {
    return ListSequence.fromList(getConflictingModelFiles(emd, project)).isNotEmpty() || ListSequence.fromList(getConflictingModuleFiles((emd != null ? emd.getModule() : null), project)).isNotEmpty();
  }

  @NotNull
  public static List<VirtualFile> getConflictingModelFiles(@Nullable SModel model, @NotNull Project project) {
    if (!(model instanceof EditableSModel)) {
      return ListSequence.fromList(new ArrayList<VirtualFile>());
    }
    DataSource ds = model.getSource();
    Iterable<IFile> filesToCheck = Sequence.fromIterable(Collections.<IFile>emptyList());
    if (ds instanceof FileDataSource) {
      filesToCheck = Sequence.<IFile>singleton(((FileDataSource) ds).getFile());
    } else if (ds instanceof FilePerRootDataSource) {
      final FilePerRootDataSource ds1 = (FilePerRootDataSource) ds;
      filesToCheck = Sequence.fromIterable(((Iterable<String>) ds1.getAvailableStreams())).select(new ISelector<String, IFile>() {
        public IFile select(String it) {
          return ds1.getFile(it);
        }
      });
    }
    return getConflictingFiles(filesToCheck, project);
  }

  @NotNull
  public static List<VirtualFile> getConflictingModuleFiles(@Nullable SModule module, @NotNull Project project) {
    Iterable<IFile> filesToCheck = Sequence.fromIterable(Collections.<IFile>emptyList());
    if (module instanceof Generator) {
      module = ((Generator) module).getSourceLanguage();
    }
    if (module instanceof AbstractModule) {
      filesToCheck = Sequence.<IFile>singleton(((AbstractModule) module).getDescriptorFile());
    }
    return getConflictingFiles(filesToCheck, project);
  }

  private static boolean isConflictedFile(IFile file, @NotNull Project project) {
    VirtualFile vf = VirtualFileUtils.getProjectVirtualFile(file);
    if (vf == null) {
      return false;
    }
    FileStatus status = FileStatusManager.getInstance(project).getStatus(vf);
    return FileStatus.MERGED_WITH_CONFLICTS == status || FileStatus.MERGED_WITH_BOTH_CONFLICTS == status;
  }

  private static List<VirtualFile> getConflictingFiles(Iterable<IFile> files, final Project project) {
    return Sequence.fromIterable(files).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile f) {
        return isConflictedFile(f, project);
      }
    }).select(new ISelector<IFile, VirtualFile>() {
      public VirtualFile select(IFile f) {
        return VirtualFileUtils.getProjectVirtualFile(f);
      }
    }).toListSequence();
  }
}
