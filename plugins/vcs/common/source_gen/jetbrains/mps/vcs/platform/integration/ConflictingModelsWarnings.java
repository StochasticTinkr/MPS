package jetbrains.mps.vcs.platform.integration;

/*Generated by MPS */

import jetbrains.mps.ide.editor.warningPanel.EditorWarningsProvider;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.ide.editor.warningPanel.WarningPanel;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.ide.project.ProjectHelper;
import java.util.List;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.vcs.platform.util.ConflictsUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.util.NameUtil;
import com.intellij.openapi.vcs.AbstractVcsHelper;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Generator;

public class ConflictingModelsWarnings implements EditorWarningsProvider {
  public ConflictingModelsWarnings() {
  }

  @Nullable
  @Override
  public WarningPanel getWarningPanel(@NotNull SNode node, @NotNull final Project project) {
    SModel md = node.getModel();
    if (md == null) {
      return null;
    }
    SModule module = md.getModule();
    jetbrains.mps.project.Project mpsProject = ProjectHelper.fromIdeaProject(project);
    if (mpsProject == null || !(mpsProject.getProjectModulesWithGenerators().contains(module))) {
      return null;
    }
    final List<VirtualFile> modelFiles = ConflictsUtil.getConflictingModelFiles(md, project);
    final List<VirtualFile> moduleFiles = ConflictsUtil.getConflictingModuleFiles(check_bmsafs_a0a6a2(md), project);
    if (ListSequence.fromList(moduleFiles).isNotEmpty()) {
      String type = getModuleType(md.getModule());
      assert type != null;
      if (ListSequence.fromList(modelFiles).isNotEmpty()) {
        // conflicting model and module 
        return new WarningPanel(this, String.format("You are viewing model which is not merged yet. It is owned by %s, which is merged neither." + " You need to merge %s and model (this order is important).", type, type), String.format("Merge %s and Model", NameUtil.capitalize(type)), new Runnable() {
          public void run() {
            AbstractVcsHelper.getInstance(project).showMergeDialog(ListSequence.fromList(moduleFiles).addSequence(ListSequence.fromList(modelFiles)));
          }
        });
      } else {
        // conflicting module 
        return new WarningPanel(this, String.format("You are viewing model owned by %s which is not merged yet. You need to merge it before editing.", type), "Merge " + NameUtil.capitalize(type), new Runnable() {
          public void run() {
            AbstractVcsHelper.getInstance(project).showMergeDialog(moduleFiles);
          }
        });
      }
    } else {
      if (ListSequence.fromList(modelFiles).isNotEmpty()) {
        // conflicting model 
        return new WarningPanel(this, "You are viewing model which is not merged yet. You may see very old version of it." + " You need to merge it before editing, otherwise your changes will be lost.", "Merge Model", new Runnable() {
          public void run() {
            AbstractVcsHelper.getInstance(project).showMergeDialog(modelFiles);
          }
        });
      } else {
        return null;
      }
    }
  }

  @Nullable
  private static String getModuleType(@NotNull SModule module) {
    if (module instanceof Language) {
      return "language";
    } else if (module instanceof Solution) {
      return "solution";
    } else if (module instanceof Generator) {
      return "generator";
    }
    return null;
  }
  private static SModule check_bmsafs_a0a6a2(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }
}
