package jetbrains.mps.vcs.changesmanager.editor;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import jetbrains.mps.vcs.diff.ui.common.ChangeGroup;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.vcs.diff.changes.NodeCopier;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.vcs.diff.ui.common.Bounds;
import jetbrains.mps.vcs.diff.changes.ChangeType;
import jetbrains.mps.vcs.diff.ui.common.DiffModelUtil;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.vcs.diff.changes.NodeChange;
import jetbrains.mps.util.IterableUtil;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.ide.datatransfer.CopyPasteUtil;

public class ChangesStripActionsHelper {
  private ChangesStripActionsHelper() {
  }
  @Nullable
  private static ChangeGroup getNeighbourChangeGroup(@NotNull EditorContext editorContext, boolean next) {
    return check_ikrecr_a0a1(getPainter(editorContext), editorContext, next);
  }
  public static boolean isNeighbourGroupAvailable(@NotNull EditorContext editorContext, boolean next) {
    return getNeighbourChangeGroup(editorContext, next) != null;
  }
  public static void goToNeighbourGroup(@NotNull EditorContext editorContext, boolean next) {
    ChangeGroup group = getNeighbourChangeGroup(editorContext, next);
    if (group == null) {
      return;
    }
    EditorComponent editorComponent = (EditorComponent) editorContext.getEditorComponent();
    goToY(editorComponent, (int) group.getBounds(true).end());
    goToY(editorComponent, (int) group.getBounds(true).start());
    check_ikrecr_a5a3(getPainter(editorContext), group);
  }
  private static void goToY(EditorComponent editorComponent, int y) {
    EditorCell editorCell = editorComponent.findCellWeak(1, y + 1);
    if (editorCell != null) {
      editorComponent.changeSelection(editorCell);
    }
  }
  @Nullable
  private static EditorHighlighter getHighlighter(EditorContext editorContext) {
    EditorComponent editorComponent = (EditorComponent) editorContext.getEditorComponent();
    return check_ikrecr_a1a5(editorContext.getOperationContext().getComponent(EditorHighlighterFactory.class), editorComponent);
  }
  @Nullable
  private static ChangeStripsPainter getPainter(EditorContext editorContext) {
    return check_ikrecr_a0a6(getHighlighter(editorContext));
  }
  @Nullable
  private static ChangeGroup getCurrentChangeGroup(@NotNull EditorContext editorContext) {
    return check_ikrecr_a0a7(getPainter(editorContext));
  }
  public static void rollbackChanges(@NotNull final EditorContext editorContext) {
    final List<ModelChange> changes = check_ikrecr_a0a0i(getCurrentChangeGroup(editorContext));
    if (changes == null) {
      return;
    }
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        final SModel model = ListSequence.fromList(changes).first().getChangeSet().getNewModel();
        final NodeCopier nc = new NodeCopier(model);
        Iterable<ModelChange> oppositeChanges = ListSequence.fromList(changes).select(new ISelector<ModelChange, ModelChange>() {
          public ModelChange select(ModelChange ch) {
            return ch.getOppositeChange();
          }
        });
        for (ModelChange ch : Sequence.fromIterable(oppositeChanges)) {
          if (ch instanceof NodeGroupChange) {
            ((NodeGroupChange) ch).prepare();
          }
        }
        Sequence.fromIterable(oppositeChanges).visitAll(new IVisitor<ModelChange>() {
          public void visit(ModelChange ch) {
            ch.apply(model, nc);
          }
        });
        nc.restoreIds(true);
        check_ikrecr_a6a0a0c0i(getPainter(editorContext));
      }
    });
  }
  public static Bounds getCurrentChangeGroupPositionAndHidePopup(@NotNull EditorContext editorContext) {
    ChangeGroup cg = getCurrentChangeGroup(editorContext);
    check_ikrecr_a1a9(ChangesStripActionsHelper.getPainter(editorContext));
    return check_ikrecr_a2a9(cg);
  }
  public static boolean areOldNodesAvailable(@NotNull EditorContext editorContext) {
    ChangeGroup cg = getCurrentChangeGroup(editorContext);
    return cg != null && cg.getChangeType() != ChangeType.ADD;
  }
  public static void copyOldNodes(@NotNull EditorContext editorContext) {
    ChangeGroup changeGroup = getCurrentChangeGroup(editorContext);
    assert changeGroup != null;

    final SModel oldModel = ListSequence.fromList(changeGroup.getChanges()).first().getChangeSet().getOldModel();
    // do we need??? there were no de-registration 
    DiffModelUtil.renameModelAndRegister(oldModel, "old");

    // compute paths to root 
    Iterable<SNode> baseNodes = ListSequence.fromList(changeGroup.getChanges()).translate(new ITranslator2<ModelChange, SNode>() {
      public Iterable<SNode> translate(ModelChange ch) {
        if (ch instanceof NodeChange) {
          return Sequence.<SNode>singleton(oldModel.getNode(((NodeChange) ch).getAffectedNodeId()));
        } else if (ch instanceof NodeGroupChange) {
          NodeGroupChange ngc = (NodeGroupChange) ch;
          List<SNode> changeChildren = IterableUtil.asList(oldModel.getNode(ngc.getParentNodeId()).getChildren(ngc.getRole()));
          return ListSequence.fromList(changeChildren).page(ngc.getBegin(), ngc.getEnd());
        } else {
          return Sequence.fromIterable(Collections.<SNode>emptyList());
        }
      }
    });
    List<List<SNode>> paths = Sequence.fromIterable(baseNodes).select(new ISelector<SNode, List<SNode>>() {
      public List<SNode> select(SNode n) {
        return (List<SNode>) ListSequence.fromList(SNodeOperations.getNodeAncestors(n, null, true)).reversedList();
      }
    }).toListSequence();

    // find common path 
    final Wrappers._T<List<SNode>> commonPath = new Wrappers._T<List<SNode>>(ListSequence.fromList(paths).getElement(0));
    for (List<SNode> pathToRoot : ListSequence.fromList(paths)) {
      for (int i = 0; i < Math.min(ListSequence.fromList(commonPath.value).count(), ListSequence.fromList(pathToRoot).count()); i++) {
        if (ListSequence.fromList(commonPath.value).getElement(i) != ListSequence.fromList(pathToRoot).getElement(i)) {
          commonPath.value = ListSequence.fromList(commonPath.value).take(i).toListSequence();
          break;
        }
      }
      if (ListSequence.fromList(pathToRoot).count() < ListSequence.fromList(commonPath.value).count()) {
        commonPath.value = ListSequence.fromList(commonPath.value).take(ListSequence.fromList(pathToRoot).count()).toListSequence();
      }
    }
    assert !(ListSequence.fromList(commonPath.value).isEmpty());

    // by default, copy common ancestor 
    SNode commonNode = ListSequence.fromList(commonPath.value).last();
    List<SNode> nodesToCopy = Sequence.fromIterable(Sequence.<SNode>singleton(commonNode)).toListSequence();

    if (ListSequence.fromList(paths).all(new IWhereFilter<List<SNode>>() {
      public boolean accept(List<SNode> p) {
        return ListSequence.fromList(p).count() > ListSequence.fromList(commonPath.value).count();
      }
    })) {
      Iterable<SNode> children = ListSequence.fromList(paths).select(new ISelector<List<SNode>, SNode>() {
        public SNode select(List<SNode> p) {
          return ListSequence.fromList(p).getElement(ListSequence.fromList(commonPath.value).count());
        }
      });
      Iterable<String> roles = Sequence.fromIterable(children).select(new ISelector<SNode, String>() {
        public String select(SNode c) {
          return SNodeOperations.getContainingLinkRole(c);
        }
      });
      final String commonRole = Sequence.fromIterable(roles).first();
      if (Sequence.fromIterable(roles).all(new IWhereFilter<String>() {
        public boolean accept(String r) {
          return eq_ikrecr_a0a0a0a0a0d0u0l(r, commonRole);
        }
      })) {
        Iterable<Integer> indices = Sequence.fromIterable(children).select(new ISelector<SNode, Integer>() {
          public Integer select(SNode c) {
            return SNodeOperations.getIndexInParent(c);
          }
        }).distinct();
        int min = Sequence.fromIterable(indices).reduceLeft(new ILeftCombinator<Integer, Integer>() {
          public Integer combine(Integer a, Integer b) {
            return Math.min(a, b);
          }
        });
        int max = Sequence.fromIterable(indices).reduceLeft(new ILeftCombinator<Integer, Integer>() {
          public Integer combine(Integer a, Integer b) {
            return Math.max(a, b);
          }
        });
        ListSequence.fromList(nodesToCopy).clear();
        for (int i = min; i <= max; i++) {
          ListSequence.fromList(nodesToCopy).addElement(IterableUtil.get(commonNode.getChildren(commonRole), i));
        }
      }
    }

    CopyPasteUtil.copyNodesToClipboard(nodesToCopy);
    check_ikrecr_a32a11(getPainter(editorContext));
  }
  private static ChangeGroup check_ikrecr_a0a1(ChangeStripsPainter checkedDotOperand, EditorContext editorContext, Boolean next) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getNeighbourChangeGroup(check_ikrecr_a0a0a1(editorContext), next);
    }
    return null;
  }
  private static EditorCell check_ikrecr_a0a0a1(EditorContext checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getContextCell();
    }
    return null;
  }
  private static void check_ikrecr_a5a3(ChangeStripsPainter checkedDotOperand, ChangeGroup group) {
    if (null != checkedDotOperand) {
      checkedDotOperand.showPopupForGroup(group);
    }

  }
  private static EditorHighlighter check_ikrecr_a1a5(EditorHighlighterFactory checkedDotOperand, EditorComponent editorComponent) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getHighlighter(editorComponent);
    }
    return null;
  }
  private static ChangeStripsPainter check_ikrecr_a0a6(EditorHighlighter checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getStripsPainter();
    }
    return null;
  }
  private static ChangeGroup check_ikrecr_a0a7(ChangeStripsPainter checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getCurrentChangeGroup();
    }
    return null;
  }
  private static List<ModelChange> check_ikrecr_a0a0i(ChangeGroup checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getChanges();
    }
    return null;
  }
  private static void check_ikrecr_a6a0a0c0i(ChangeStripsPainter checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.showPopupForGroup(null);
    }

  }
  private static void check_ikrecr_a1a9(ChangeStripsPainter checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.showPopupForGroup(null);
    }

  }
  private static Bounds check_ikrecr_a2a9(ChangeGroup checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getBounds(true);
    }
    return null;
  }
  private static void check_ikrecr_a32a11(ChangeStripsPainter checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.showPopupForGroup(null);
    }

  }
  private static boolean eq_ikrecr_a0a0a0a0a0d0u0l(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
