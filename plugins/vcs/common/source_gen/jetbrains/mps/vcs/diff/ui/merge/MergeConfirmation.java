package jetbrains.mps.vcs.diff.ui.merge;

/*Generated by MPS */

import java.awt.Component;
import jetbrains.mps.vcs.diff.merge.MergeSession;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.util.NameUtil;
import com.intellij.openapi.ui.Messages;

public class MergeConfirmation {
  public static final int RETURN = 0;
  public static final int SAVE_AS_IS = 1;
  public static final int RESOLVE_AUTOMATICALLY = 2;
  private MergeConfirmation() {
  }
  public static int showMergeConfirmationAndTakeAction(Component parent, final MergeSession mergeSession, Iterable<ModelChange> allRelevantChanges, @Nullable final MergeSession mergeSession2, Iterable<ModelChange> allRelevantChanges2) {
    List<ModelChange> changes = Sequence.fromIterable(allRelevantChanges).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(mergeSession.isChangeResolved(ch));
      }
    }).toListSequence();
    int nChanges = ListSequence.fromList(changes).count();
    int nConflicts = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return Sequence.fromIterable(mergeSession.getConflictedWith(ch)).isNotEmpty();
      }
    }).count();
    if (mergeSession2 != null) {
      changes = Sequence.fromIterable(allRelevantChanges2).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(mergeSession2.isChangeResolved(ch));
        }
      }).toListSequence();
      nChanges += ListSequence.fromList(changes).count();
      nConflicts += ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return Sequence.fromIterable(mergeSession2.getConflictedWith(ch)).isNotEmpty();
        }
      }).count();
    }

    int result = MergeConfirmation.showMergeConfirmationIfNeeded(parent, nChanges, nConflicts);
    return result;
  }
  private static int showMergeConfirmationIfNeeded(Component parent, int changes, int conflicted) {
    if (conflicted != 0) {
      return showUnresolvedConflictsConfirmation(parent, conflicted);
    } else if (changes != 0) {
      return showUnresolvedChangesConfirmation(parent, changes);
    }
    return SAVE_AS_IS;
  }
  private static int showUnresolvedConflictsConfirmation(Component parent, int changes) {
    String msg = String.format("You have %s left. You need to resolve them manually.\n" + "Close merge dialog and save model without remaining conflicts resolving?", NameUtil.formatNumericalString(changes, "unresolved conflicting change"));
    if (Messages.showOkCancelDialog(parent, msg, "Unresolved Conflicting Changes", Messages.getWarningIcon()) == 0) {
      return MergeConfirmation.SAVE_AS_IS;
    } else {
      return MergeConfirmation.RETURN;
    }
  }
  private static int showUnresolvedChangesConfirmation(Component parent, int changes) {
    String message = String.format("You have %s left. You can resolve %s automatically.", NameUtil.formatNumericalString(changes, "unresolved change"), (changes > 1 ? "them" : "it"));
    String title = "Unresolved Change" + ((changes > 1 ? "s" : ""));
    int answer = Messages.showYesNoCancelDialog(parent, message, title, "Resolve automatically and exit", "Exit without remaining changes resolving", "Return to resolving", Messages.getWarningIcon());
    if (answer == 0) {
      return MergeConfirmation.RESOLVE_AUTOMATICALLY;
    } else if (answer == 1) {
      // Do nothing, leave unresolved changes as is 
      return MergeConfirmation.SAVE_AS_IS;
    } else {
      return MergeConfirmation.RETURN;
    }
  }
}
