package jetbrains.mps.vcs.diff.merge;

/*Generated by MPS */

import jetbrains.mps.vcs.diff.ChangeSet;
import java.util.Map;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.vcs.diff.changes.NodeCopier;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.vcs.diff.changes.MetadataChange;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.vcs.diff.changes.NodeChange;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Arrays;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Collections;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.Comparator;
import jetbrains.mps.vcs.util.MergeStrategy;
import jetbrains.mps.vcs.diff.ChangeSetImpl;
import jetbrains.mps.smodel.references.UnregisteredNodes;
import jetbrains.mps.persistence.PersistenceVersionAware;
import jetbrains.mps.smodel.SModelAdapter;
import jetbrains.mps.smodel.event.SModelEvent;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.smodel.event.SModelRootEvent;

public final class MergeSession {
  private ChangeSet myMineChangeSet;
  private ChangeSet myRepositoryChangeSet;
  private Map<ModelChange, List<ModelChange>> myConflictingChanges = MapSequence.fromMap(new HashMap<ModelChange, List<ModelChange>>());
  private Map<ModelChange, List<ModelChange>> mySymmetricChanges = MapSequence.fromMap(new HashMap<ModelChange, List<ModelChange>>());
  private Map<SNodeId, List<ModelChange>> myRootToChanges = MapSequence.fromMap(new HashMap<SNodeId, List<ModelChange>>());
  private Map<SNodeId, List<ModelChange>> myNodeToChanges = MapSequence.fromMap(new HashMap<SNodeId, List<ModelChange>>());
  private List<ModelChange> myMetadataChanges = ListSequence.fromList(new ArrayList<ModelChange>());
  private MergeTemporaryModel myResultModel;
  private Set<ModelChange> myResolvedChanges = SetSequence.fromSet(new HashSet<ModelChange>());
  private NodeCopier myNodeCopier;
  private MergeSession.MyResultModelListener myModelListener = new MergeSession.MyResultModelListener();
  private MergeSession.ChangesInvalidateHandler myChangesInvalidateHandler;

  public static MergeSession createMergeSession(SModel base, SModel mine, SModel repository) {
    MergeTemporaryModel result = MergeTemporaryModel.writableCloneOf(base);
    int pv = Math.max(getPersistenceVersion(base), Math.max(getPersistenceVersion(mine), getPersistenceVersion(repository)));
    result.setPersistenceVersion(pv);
    return new MergeSession(base, mine, repository, result);
  }

  private MergeSession(SModel base, SModel mine, SModel repository, MergeTemporaryModel result) {
    MergeConflictsBuilder conflictsBuilder = new MergeConflictsBuilder(base, mine, repository);
    myMineChangeSet = conflictsBuilder.myMineChangeSet;
    myRepositoryChangeSet = conflictsBuilder.myRepositoryChangeSet;
    myConflictingChanges = conflictsBuilder.myConflictingChanges;
    mySymmetricChanges = conflictsBuilder.mySymmetricChanges;
    fillRootToChangesMap();
    fillNodeToChangesMap();
    myResultModel = result;
    myNodeCopier = new NodeCopier(myResultModel);
  }
  private void fillRootToChangesMap() {
    for (ModelChange change : Sequence.fromIterable(getAllChanges())) {
      SNodeId rootId = change.getRootId();
      if (rootId == null) {
        assert change instanceof MetadataChange;
        ListSequence.fromList(myMetadataChanges).addElement(change);
      } else {
        if (MapSequence.fromMap(myRootToChanges).get(rootId) == null) {
          MapSequence.fromMap(myRootToChanges).put(rootId, ListSequence.fromList(new ArrayList<ModelChange>()));
        }
        ListSequence.fromList(MapSequence.fromMap(myRootToChanges).get(rootId)).addElement(change);
      }
    }
  }
  public void installResultModelListener() {
    myResultModel.addModelListener(myModelListener);
  }
  private void fillNodeToChangesMap() {
    for (ModelChange change : Sequence.fromIterable(getAllChanges())) {
      SNodeId nodeId = null;
      if (change instanceof NodeGroupChange) {
        nodeId = ((NodeGroupChange) change).getParentNodeId();
      } else if (change instanceof NodeChange) {
        nodeId = ((NodeChange) change).getAffectedNodeId();
      } else if (change instanceof AddRootChange || change instanceof DeleteRootChange) {
        nodeId = change.getRootId();
      }
      if (nodeId != null) {
        if (MapSequence.fromMap(myNodeToChanges).get(nodeId) == null) {
          MapSequence.fromMap(myNodeToChanges).put(nodeId, ListSequence.fromList(new ArrayList<ModelChange>()));
        }
        ListSequence.fromList(MapSequence.fromMap(myNodeToChanges).get(nodeId)).addElement(change);
      }
    }
  }
  public Iterable<ModelChange> getApplicableChangesForRoot(SNodeId rootId) {
    return ListSequence.fromList(MapSequence.fromMap(myRootToChanges).get(rootId)).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(SetSequence.fromSet(myResolvedChanges).contains(ch)) && Sequence.fromIterable(getConflictedWith(ch)).isEmpty();
      }
    });
  }
  public Iterable<ModelChange> getApplicableChangesInNonConflictingRoots() {
    return Sequence.fromIterable((Sequence.fromIterable(MapSequence.fromMap(myRootToChanges).values()).concat(ListSequence.fromList(Arrays.asList(myMetadataChanges))))).translate(new ITranslator2<List<ModelChange>, ModelChange>() {
      public Iterable<ModelChange> translate(List<ModelChange> changes) {
        Iterable<ModelChange> unresolvedForRoot = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
          public boolean accept(ModelChange ch) {
            return !(SetSequence.fromSet(myResolvedChanges).contains(ch));
          }
        });
        if (Sequence.fromIterable(unresolvedForRoot).all(new IWhereFilter<ModelChange>() {
          public boolean accept(ModelChange ch) {
            return Sequence.fromIterable(getConflictedWith(ch)).isEmpty();
          }
        })) {
          return unresolvedForRoot;
        } else {
          return Sequence.fromIterable(Collections.<ModelChange>emptyList());
        }
      }
    });
  }
  public Iterable<ModelChange> getAllChanges() {
    return ListSequence.fromList(myMineChangeSet.getModelChanges()).concat(ListSequence.fromList(myRepositoryChangeSet.getModelChanges()));
  }
  public Iterable<SNodeId> getAffectedRoots() {
    return (ListSequence.fromList(myMetadataChanges).isEmpty() ? MapSequence.fromMap(myRootToChanges).keySet() : SetSequence.fromSet(MapSequence.fromMap(myRootToChanges).keySet()).concat(ListSequence.fromList(ListSequence.fromListAndArray(new ArrayList<SNodeId>(), null))));
  }
  public List<ModelChange> getChangesForRoot(@NotNull SNodeId rootId) {
    return MapSequence.fromMap(myRootToChanges).get(rootId);
  }
  public List<ModelChange> getMetadataChanges() {
    return myMetadataChanges;
  }
  public Iterable<ModelChange> getConflictedWith(ModelChange change) {
    return ListSequence.fromList(MapSequence.fromMap(myConflictingChanges).get(change)).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange other) {
        return !(SetSequence.fromSet(myResolvedChanges).contains(other));
      }
    });
  }
  public boolean isChangeResolved(ModelChange change) {
    return SetSequence.fromSet(myResolvedChanges).contains(change);
  }
  public void applyChanges(Iterable<ModelChange> changes) {
    applyChangesNoRestoreIds(changes);
    myNodeCopier.restoreIds(false);
  }
  public void excludeChanges(Iterable<ModelChange> changes) {
    excludeChangesNoRestoreIds(changes);
    myNodeCopier.restoreIds(false);
  }
  private void applyChangesNoRestoreIds(Iterable<ModelChange> changes) {
    Sequence.fromIterable(changes).ofType(NodeGroupChange.class).visitAll(new IVisitor<NodeGroupChange>() {
      public void visit(NodeGroupChange ch) {
        ch.prepare();
      }
    });
    for (ModelChange c : Sequence.fromIterable(changes).sort(new Comparator<ModelChange>() {
      public int compare(ModelChange a, ModelChange b) {
        // sort out nonconflicting changes to the end of list, so they will be ignored if other connected changes exists 
        boolean aa = a.isNonConflicting();
        boolean bb = b.isNonConflicting();
        int result = (aa == bb ? 0 : (aa ? 1 : -1));
        return result;
      }
    }, true)) {
      applyChange(c);
    }
  }
  private void excludeChangesNoRestoreIds(Iterable<ModelChange> changes) {
    for (ModelChange c : Sequence.fromIterable(changes)) {
      excludeChange(c);
    }
  }
  private void applyChange(ModelChange change) {
    if (SetSequence.fromSet(myResolvedChanges).contains(change)) {
      return;
    }

    // for nonconflicting change we can execute symmetric if it suits better 
    if (change.isNonConflicting()) {
      ModelChange symmChange = ListSequence.fromList(MapSequence.fromMap(mySymmetricChanges).get(change)).subtract(SetSequence.fromSet(myResolvedChanges)).first();
      if (symmChange != null) {
        boolean isMineChange = change.getChangeSet() == myMineChangeSet;
        MergeStrategy hint = change.getMergeHint();
        if (hint != null && ((hint == MergeStrategy.OURS) != isMineChange)) {
          // execute more appropriate symmetric change, original change will be excluded 
          change = symmChange;
        }
      }
    }
    if (change instanceof NodeGroupChange && ((NodeGroupChange) change).getRoleLink().isMultiple()) {
      // adjust conflicting changes: leave possibility to reject or insert them separately 
      final NodeGroupChange ngc = (NodeGroupChange) change;
      List<NodeGroupChange> conflictedChanges = Sequence.fromIterable(getConflictedWith(ngc)).ofType(NodeGroupChange.class).where(new IWhereFilter<NodeGroupChange>() {
        public boolean accept(NodeGroupChange ch) {
          return ch.getParentNodeId().equals(ngc.getParentNodeId());
        }
      }).toListSequence();
      int anchorIndex = ngc.getEnd();
      ngc.apply(myResultModel, myNodeCopier);
      for (NodeGroupChange ch : ListSequence.fromList(conflictedChanges)) {
        // add new changes only for insertions, we need ChangeSetImpl to manually add one change there 
        // original conflicted changes will be resolved 
        ChangeSetImpl changeSet = as_bow6nj_a0a2a5a4a13(ch.getChangeSet(), ChangeSetImpl.class);
        assert changeSet != null;
        NodeGroupChange newChange = new NodeGroupChange(changeSet, ch.getParentNodeId(), ch.getRoleLink(), anchorIndex, anchorIndex, ch.getResultBegin(), ch.getResultEnd());
        if (newChange.getBegin() < newChange.getEnd() || newChange.getResultBegin() < newChange.getResultEnd()) {
          changeSet.add(newChange);
          ListSequence.fromList(MapSequence.fromMap(myRootToChanges).get(ch.getRootId())).addElement(newChange);
          ListSequence.fromList(MapSequence.fromMap(myNodeToChanges).get(ch.getParentNodeId())).addElement(newChange);
        }

      }
    } else {
      change.apply(myResultModel, myNodeCopier);
    }
    SetSequence.fromSet(myResolvedChanges).addElement(change);
    SetSequence.fromSet(myResolvedChanges).addSequence(ListSequence.fromList(MapSequence.fromMap(mySymmetricChanges).get(change)));
    excludeChangesNoRestoreIds(getConflictedWith(change));
  }
  private void excludeChange(ModelChange change) {
    if (SetSequence.fromSet(myResolvedChanges).contains(change)) {
      return;
    }
    SetSequence.fromSet(myResolvedChanges).addElement(change);
    SetSequence.fromSet(myResolvedChanges).addSequence(ListSequence.fromList(MapSequence.fromMap(mySymmetricChanges).get(change)));
  }
  public boolean hasIdsToRestore() {
    return myNodeCopier.hasIdsToRestore();
  }
  public SNodeId getReplacementId(SNodeId originalId) {
    return myNodeCopier.getReplacementId(originalId);
  }
  public SModel getResultModel() {
    return myResultModel;
  }
  public SModel getBaseModel() {
    return myMineChangeSet.getOldModel();
  }
  public SModel getMyModel() {
    return myMineChangeSet.getNewModel();
  }
  public SModel getRepositoryModel() {
    return myRepositoryChangeSet.getNewModel();
  }
  public ChangeSet getMyChangeSet() {
    return myMineChangeSet;
  }
  public ChangeSet getRepositoryChangeSet() {
    return myRepositoryChangeSet;
  }
  public boolean isMyChange(ModelChange change) {
    return change.getChangeSet() == myMineChangeSet;
  }
  public MergeSessionState getCurrentState() {
    return new MergeSessionState(myResultModel, myResolvedChanges, myNodeCopier.getState());
  }
  public void restoreState(MergeSessionState state) {
    MergeSessionState stateCopy = new MergeSessionState(state);
    myResultModel.setSModelInternal(stateCopy.myResultModel.getSModel());

    // clear UnregisteredNodes pool to avoid a lot of ERRORs in log: 
    UnregisteredNodes.instance().clear();

    myResolvedChanges = stateCopy.myResolvedChanges;
    myNodeCopier.setState(stateCopy.myIdReplacementCache, myResultModel);
  }
  public void setChangesInvalidateHandler(MergeSession.ChangesInvalidateHandler changesInvalidateHandler) {
    myChangesInvalidateHandler = changesInvalidateHandler;
  }
  private void invalidateChanges() {
    check_bow6nj_a0a54(myChangesInvalidateHandler);
  }
  private void resolveChanges(Iterable<? extends ModelChange> changes) {
    SetSequence.fromSet(myResolvedChanges).addSequence(Sequence.fromIterable(changes));
  }
  private static int getPersistenceVersion(SModel model) {
    if (model instanceof PersistenceVersionAware) {
      return ((PersistenceVersionAware) model).getPersistenceVersion();
    }
    return -1;
  }
  public interface ChangesInvalidateHandler {
    void someChangesInvalidated();
  }
  private class MyResultModelListener extends SModelAdapter {
    private MyResultModelListener() {
    }
    private void invalidateDeletedRoot(SModelEvent event) {
      assert event.getAffectedRoot() != null;
      List<ModelChange> nodeChanges = MapSequence.fromMap(myNodeToChanges).get(event.getAffectedRoot().getNodeId());
      resolveChanges(ListSequence.fromList(nodeChanges).ofType(DeleteRootChange.class));
      invalidateChanges();
    }
    private void beforeNodeRemovedRecursively(SNode node) {
      for (SNode child : ListSequence.fromList(SNodeOperations.getChildren(node))) {
        beforeNodeRemovedRecursively(child);
      }
      // invalidate and resolve changes connected to the node 
      resolveChanges(MapSequence.fromMap(myNodeToChanges).get(node.getNodeId()));
      invalidateChanges();
    }
    private void referenceModified(SModelReferenceEvent event) {
      invalidateChanges();
      invalidateDeletedRoot(event);
    }
    @Override
    public void referenceRemoved(SModelReferenceEvent event) {
      referenceModified(event);
    }
    @Override
    public void referenceAdded(SModelReferenceEvent event) {
      referenceModified(event);
    }
    @Override
    public void beforeChildRemoved(SModelChildEvent event) {
      beforeNodeRemovedRecursively(event.getChild());
      invalidateDeletedRoot(event);
      invalidateChanges();
    }
    @Override
    public void childAdded(SModelChildEvent event) {
      invalidateDeletedRoot(event);
      invalidateChanges();
    }
    @Override
    public void propertyChanged(SModelPropertyEvent event) {
      invalidateChanges();
      invalidateDeletedRoot(event);
    }
    @Override
    public void beforeRootRemoved(SModelRootEvent event) {
      beforeNodeRemovedRecursively(event.getRoot());
      invalidateDeletedRoot(event);
    }
  }
  private static void check_bow6nj_a0a54(MergeSession.ChangesInvalidateHandler checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.someChangesInvalidated();
    }

  }
  private static <T> T as_bow6nj_a0a2a5a4a13(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
