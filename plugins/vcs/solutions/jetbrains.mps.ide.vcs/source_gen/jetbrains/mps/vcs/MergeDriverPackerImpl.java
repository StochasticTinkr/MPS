package jetbrains.mps.vcs;

/*Generated by MPS */

import jetbrains.mps.vcs.platform.mergedriver.MergeDriverPacker;
import com.intellij.openapi.components.ApplicationComponent;
import com.intellij.openapi.application.PathManager;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Arrays;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;

public class MergeDriverPackerImpl extends MergeDriverPacker implements ApplicationComponent {
  public MergeDriverPackerImpl() {
  }
  @Override
  public String getMPSCorePath() {
    return PathManager.getLibPath();
  }
  @Override
  protected Set<String> getClasspathInternal() {
    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());
    final String fsep = File.separator;
    // XXX Guess, the reason we use IDEA's PathManager instead of MPS's own copy is that we are running from sources here, and no chances to get <project home>/lib location 
    //     by using resource root of our own PathManager class. 
    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(MergeDriverPacker.mpsAddJars).select(new ISelector<String, String>() {
      public String select(String it) {
        return PathManager.getLibPath() + fsep + it;
      }
    }));
    // IMPORTANT 
    //       MergeDriverMain uses 'PERSISTENCE' level of the Platform, hence doesn't need to load MPSDataFlow or MPSTextGenerator classes. 
    //       Here, we shall satisfy relevant 'PERSISTANCE'-level dependencies only, not complete mps-core.jar content 
    final Iterable<String> CLASSPATHS = Arrays.asList("kernel", "logging", "openapi", "smodel", "project", "typesystemEngine", "persistence", "components", "platform", "java-stub", "util", "vfs", "aspects" + fsep + "behavior" + fsep + "behavior-api", "aspects" + fsep + "behavior" + fsep + "behavior-runtime");
    String homePath = PathManager.getHomePath();
    final String corePath = homePath + fsep + "core";
    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(CLASSPATHS).select(new ISelector<String, String>() {
      public String select(String it) {
        return corePath + fsep + it + fsep + "classes";
      }
    }));

    final String languagesPath = homePath + fsep + "languages";
    // FIXME likely, 'references' runtime is missing here, Radimir? 
    final Iterable<String> OTHER_CLASSES = Arrays.asList("closures", "collections", "tuples");
    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(OTHER_CLASSES).select(new ISelector<String, String>() {
      public String select(String it) {
        return languagesPath + fsep + "baseLanguage" + fsep + it + fsep + "runtime" + fsep + "classes";
      }
    }));

    // FIXME CommonPaths class knows about distribution jars, while this code works with MPS from sources 
    //       Likely, ClassPathReader shall get employed here. OTOH, with MergeDriverMain restricted to 'PERSISTENCE' platform level, 
    //       we don't need complete set of 'core' class folders here. Please take a look at CLASSPATHS variable above for the actual list 
    //       If not used, at least keep its value for future reference as a comment! 
    SetSequence.fromSet(classpathItems).addElement(getVCSCorePluginPath() + fsep + "lib" + fsep + getVCSCoreFileName());
    return classpathItems;
  }
  @Override
  public void initComponent() {
    MergeDriverPacker.setInstance(this);
  }
  @NonNls
  @NotNull
  @Override
  public String getComponentName() {
    return "MPS-specific Merge Driver Packer implementation";
  }
  @Override
  public void disposeComponent() {
    MergeDriverPacker.setInstance(null);
  }
  @Override
  protected String getVCSCoreFileName() {
    return "vcs-core.jar";
  }
}
