package jetbrains.mps.vcs.platform.integration;

/*Generated by MPS */

import com.intellij.diff.merge.MergeTool;
import java.util.Set;
import com.intellij.openapi.fileTypes.FileType;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import com.intellij.diff.merge.MergeContext;
import com.intellij.diff.merge.MergeRequest;
import com.intellij.diff.merge.TextMergeRequest;
import com.intellij.diff.contents.FileContent;
import com.intellij.diff.contents.DiffContent;
import com.intellij.diff.merge.TextMergeTool;

public class ModelMergeTool implements MergeTool {
  public static final Set<FileType> SUPPORTED_TYPES = SetSequence.fromSetAndArray(new HashSet<FileType>(), ModelDiffTool.DIFF_SUPPORTED_TYPES);

  public static final ModelMergeTool INSTANCE = new ModelMergeTool();

  public boolean canShow(@NotNull MergeContext context, @NotNull MergeRequest request) {
    // all SUPPORTED_TYPES are text files, so we can work with text requests ony. 
    // this will also allow us to fallback to default text merge tool 
    if (!((request instanceof TextMergeRequest))) {
      return false;
    }
    TextMergeRequest textRequest = (TextMergeRequest) request;
    // required to save model 
    if (!((textRequest.getOutputContent() instanceof FileContent))) {
      return false;
    }
    FileType commonType = textRequest.getOutputContent().getContentType();
    for (DiffContent content : textRequest.getContents()) {
      FileType contentType = content.getContentType();
      if (contentType != null && contentType != commonType) {
        return false;
      }
    }
    return SetSequence.fromSet(SUPPORTED_TYPES).contains(commonType);
  }

  @NotNull
  public MergeTool.MergeViewer createComponent(@NotNull MergeContext context, @NotNull MergeRequest request) {
    ModelMergeViewer viewer = ModelMergeViewer.createComponent(context, request);
    if (viewer != null) {
      return viewer;
    } else if (TextMergeTool.INSTANCE.canShow(context, request)) {
      // fallback to text merge 
      return TextMergeTool.INSTANCE.createComponent(context, request);
    } else {
      throw new IllegalArgumentException("Can't show merge");
    }
  }
}
