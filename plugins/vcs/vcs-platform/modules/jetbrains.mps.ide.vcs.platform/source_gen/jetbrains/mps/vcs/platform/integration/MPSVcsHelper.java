package jetbrains.mps.vcs.platform.integration;

/*Generated by MPS */

import com.intellij.openapi.vcs.impl.AbstractVcsHelperImpl;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vcs.merge.MergeProvider;
import com.intellij.openapi.vcs.merge.MergeDialogCustomizer;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import com.intellij.openapi.ui.Messages;
import java.util.Collections;
import com.intellij.openapi.vcs.merge.MergeSession;
import com.intellij.openapi.vcs.merge.MergeProvider2;
import com.intellij.openapi.progress.ProgressManager;

public class MPSVcsHelper extends AbstractVcsHelperImpl {
  public MPSVcsHelper(Project project) {
    super(project);
  }

  @NotNull
  @Override
  public List<VirtualFile> showMergeDialog(List<VirtualFile> files, MergeProvider provider, @NotNull MergeDialogCustomizer customizer) {

    if (ConflictingModelsUtil.hasResolvableConflicts(myProject, provider, ListSequence.fromList(((List<VirtualFile>) files)).where(new IWhereFilter<VirtualFile>() {
      public boolean accept(VirtualFile f) {
        return SetSequence.fromSet(ModelMergeTool.SUPPORTED_TYPES).contains(f.getFileType());
      }
    }))) {

      int answer = Messages.showYesNoCancelDialog(myProject, "Conflicting changes have been detected. Some conflicts in the models can be autoresolved.\nResolve these conflicts automatically?", "Conflict Resolver", Messages.getQuestionIcon());
      if (answer == Messages.CANCEL) {
        return Collections.<VirtualFile>emptyList();
      }
      if (answer == Messages.YES) {
        MergeSession session = (provider instanceof MergeProvider2 ? ((MergeProvider2) provider).createMergeSession(files) : null);
        ConflictingModelsUtil.ModelConflictResolver modelConflictResolverTask = ConflictingModelsUtil.getModelConflictResolverTask(myProject, provider, session, files);
        ProgressManager.getInstance().run(modelConflictResolverTask);
        // update list of files 
        List<VirtualFile> autoResolvedFiles = modelConflictResolverTask.getResolvedFiles();
        List<VirtualFile> unresolvedFiles = modelConflictResolverTask.getUnresolvedFiles();
        if (ListSequence.fromList(unresolvedFiles).isNotEmpty()) {
          String message = "Conflicts in the following model files were not autoresolved:\n";
          for (VirtualFile file : ListSequence.fromList(unresolvedFiles)) {
            message += " " + file.getPath() + "\n";
          }
          message += "This happens when you merge in models in an old persistence format and have not merged and re-generated all of their used languages." + " It is recommended to first merge and re-generate the used languages, and then try to auto resolve the conflicts again.\n" + "Continue with merge?";
          int ans = Messages.showYesNoDialog(myProject, message, "Conflict Resolver", Messages.getWarningIcon());
          if (ans == Messages.NO) {
            return autoResolvedFiles;
          }
        }
        List<VirtualFile> toResolve = ListSequence.fromList(((List<VirtualFile>) files)).subtract(ListSequence.fromList(autoResolvedFiles)).toListSequence();
        List<VirtualFile> resolvedFiles = super.showMergeDialog(toResolve, provider, customizer);
        return ListSequence.fromList(autoResolvedFiles).addSequence(ListSequence.fromList(resolvedFiles));
      }
    }

    return super.showMergeDialog(files, provider, customizer);
  }
}
