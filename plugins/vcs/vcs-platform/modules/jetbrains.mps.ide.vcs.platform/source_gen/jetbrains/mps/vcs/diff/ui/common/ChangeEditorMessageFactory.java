package jetbrains.mps.vcs.diff.ui.common;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.openapi.editor.message.EditorMessageOwner;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.errors.messageTargets.PropertyMessageTarget;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.errors.messageTargets.ReferenceMessageTarget;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.errors.messageTargets.DeletedNodeMessageTarget;

public class ChangeEditorMessageFactory {
  private ChangeEditorMessageFactory() {
  }
  public static List<ChangeEditorMessage> createMessages(SModel editedModel, boolean isOldEditor, ModelChange change, EditorMessageOwner owner, ChangeEditorMessage.ConflictChecker conflictChecker, boolean highlighted) {
    if (change instanceof AddRootChange || change instanceof DeleteRootChange) {
      return ListSequence.fromListAndArray(new LinkedList<ChangeEditorMessage>(), new ChangeEditorMessage(editedModel.getNode(change.getRootId()), new NodeMessageTarget(), owner, change, conflictChecker, highlighted));
    } else if (change instanceof SetPropertyChange) {
      SetPropertyChange chng = (SetPropertyChange) change;
      SNode node = editedModel.getNode(chng.getAffectedNodeId(!(isOldEditor)));
      PropertyMessageTarget target = new PropertyMessageTarget(chng.getPropertyName());
      return ListSequence.fromListAndArray(new LinkedList<ChangeEditorMessage>(), new ChangeEditorMessage(node, target, owner, change, conflictChecker, highlighted));
    } else if (change instanceof SetReferenceChange) {
      SetReferenceChange chng = (SetReferenceChange) change;
      SNode node = editedModel.getNode(chng.getAffectedNodeId(!(isOldEditor)));
      ReferenceMessageTarget target = new ReferenceMessageTarget(chng.getRole());
      return ListSequence.fromListAndArray(new LinkedList<ChangeEditorMessage>(), new ChangeEditorMessage(node, target, owner, change, conflictChecker, highlighted));
    } else if (change instanceof NodeGroupChange) {
      NodeGroupChange chng = (NodeGroupChange) change;
      SModel changeModel = (isOldEditor ? change.getChangeSet().getOldModel() : change.getChangeSet().getNewModel());
      SContainmentLink roleLink = chng.getRoleLink();
      SNodeId parentId = chng.getParentNodeId(!(isOldEditor));
      SNode parentNode = changeModel.getNode(parentId);
      if (parentNode == null) {
        return null;
      }
      List<SNode> changeChildren = IterableUtil.asList(parentNode.getChildren(roleLink));

      int changeBegin = (isOldEditor ? chng.getBegin() : chng.getResultBegin());
      int changeEnd = (isOldEditor ? chng.getEnd() : chng.getResultEnd());

      // We need to check change models because current edited model can have different indices 
      // (for instance, when some changes are already applied) 
      SNodeId beginId = (changeBegin < ListSequence.fromList(changeChildren).count() ? ListSequence.fromList(changeChildren).getElement(changeBegin).getNodeId() : null);
      SNodeId endId = (changeEnd < ListSequence.fromList(changeChildren).count() ? ListSequence.fromList(changeChildren).getElement(changeEnd).getNodeId() : null);
      int currentChildrenSize = ListSequence.fromList(changeChildren).count();

      int beginIndex = (beginId == null ? currentChildrenSize : SNodeOperations.getIndexInParent(((SNode) editedModel.getNode(beginId))));
      int endIndex = (endId == null ? currentChildrenSize : SNodeOperations.getIndexInParent(((SNode) editedModel.getNode(endId))));

      if (!((0 <= beginIndex && beginIndex <= endIndex && endIndex <= currentChildrenSize))) {
        return null;
      }
      if (beginIndex == endIndex) {
        // delete nodes 
        return ListSequence.fromListAndArray(new LinkedList<ChangeEditorMessage>(), new ChangeEditorMessage(editedModel.getNode(parentId), new DeletedNodeMessageTarget(roleLink.getName(), beginIndex), owner, change, conflictChecker, highlighted));
      } else {
        List<? extends SNode> editedChildren = IterableUtil.asList(editedModel.getNode(parentId).getChildren(roleLink));
        List<ChangeEditorMessage> msgs = ListSequence.fromList(new LinkedList<ChangeEditorMessage>());
        for (int i = beginIndex; i < endIndex; i++) {
          ListSequence.fromList(msgs).addElement(new ChangeEditorMessage(editedChildren.get(i), new NodeMessageTarget(), owner, change, conflictChecker, highlighted));
        }
        return msgs;
      }
    }
    return null;
  }

  public static List<ChangeEditorMessage> createMessages(SModel editedModel, boolean isOldEditor, ModelChange change, EditorMessageOwner owner, ChangeEditorMessage.ConflictChecker conflictChecker) {
    return ChangeEditorMessageFactory.createMessages(editedModel, isOldEditor, change, owner, conflictChecker, true);
  }
}
