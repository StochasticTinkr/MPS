package jetbrains.mps.vcs.platform.mergedriver;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import com.intellij.notification.Notification;
import com.intellij.ide.util.PropertiesComponent;
import jetbrains.mps.InternalFlag;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import com.intellij.openapi.vcs.VcsDirectoryMapping;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import com.intellij.openapi.vcs.impl.projectlevelman.AllVcses;
import jetbrains.mps.smodel.LanguageAspect;
import com.intellij.notification.NotificationType;
import com.intellij.notification.NotificationListener;
import org.jetbrains.annotations.NotNull;
import javax.swing.event.HyperlinkEvent;
import com.intellij.ide.BrowserUtil;
import com.intellij.notification.Notifications;

public class MergeDriverNotification {
  private static final String SUPPRESSED_PROPERTY_NAME = "merge.driver.suppressed.notification";
  private Project myProject;
  private AbstractInstaller.State myCompositeState;
  private Notification myLastNotification;
  private MergeDriverNotification(Project project) {
    myProject = project;
  }
  private boolean isNotificationSuppressed() {
    return "true".equals(PropertiesComponent.getInstance().getValue(SUPPRESSED_PROPERTY_NAME));
  }
  public void setNotificationsSuppressed(boolean value) {
    PropertiesComponent.getInstance().setValue(SUPPRESSED_PROPERTY_NAME, Boolean.toString(value));
  }
  private void calculateCompositeState() {
    myCompositeState = MergeDriverInstaller.getCompositeState(myProject, false);
  }
  public void showNotificationIfNeeded() {
    if (isNotificationSuppressed()) {
      return;
    }
    if (myLastNotification != null && !(myLastNotification.isExpired())) {
      return;
    }
    calculateCompositeState();
    if (myCompositeState == AbstractInstaller.State.NOT_ENABLED || myCompositeState == AbstractInstaller.State.INSTALLED) {
      return;
    }
    if (InternalFlag.isInternalMode() && myCompositeState == AbstractInstaller.State.OUTDATED) {
      return;
    }
    showNotifications();
  }
  private void showNotifications() {
    final Set<String> vcsNames = SetSequence.fromSetWithValues(new HashSet<String>(), ListSequence.fromList(((List<VcsDirectoryMapping>) ProjectLevelVcsManager.getInstance(myProject).getDirectoryMappings())).select(new ISelector<VcsDirectoryMapping, String>() {
      public String select(VcsDirectoryMapping dm) {
        return dm.getVcs();
      }
    }).where(new IWhereFilter<String>() {
      public boolean accept(String vn) {
        return (vn != null && vn.length() > 0);
      }
    }));
    ThreadUtils.runInUIThreadNoWait(new Runnable() {
      public void run() {
        String whichVcses = IterableUtils.join(SetSequence.fromSet(vcsNames).select(new ISelector<String, String>() {
          public String select(String vn) {
            return AllVcses.getInstance(myProject).getByName(vn).getDisplayName();
          }
        }), "and");
        String message = "<p>This project uses " + whichVcses + ". For better integration with MPS, it is recommended to update global VCS settings (<a href=\"" + LanguageAspect.CONFLUENCE_BASE + "Version+Control\">More info</a>).<p><a href=\"install\">Update</a>&nbsp;&nbsp;<a href=\"dismiss\">Dismiss</a></p>";
        myLastNotification = new Notification("MergeDriver", "VCS Addons", message, NotificationType.WARNING, new NotificationListener() {
          @Override
          public void hyperlinkUpdate(@NotNull Notification notification, @NotNull HyperlinkEvent e) {
            if (e.getEventType() != HyperlinkEvent.EventType.ACTIVATED) {
              return;
            }
            if (e.getURL() != null) {
              BrowserUtil.launchBrowser(e.getURL().toExternalForm());
              return;
            } else
            if ("install".equals(e.getDescription())) {
              MergeDriverInstaller.installWhereNeeded(myProject);
            } else if ("dismiss".equals(e.getDescription())) {
              setNotificationsSuppressed(true);
            } else {
              assert false;
            }
            notification.expire();
          }
        });
        Notifications.Bus.notify(myLastNotification, myProject);
      }
    });
  }
  public static MergeDriverNotification getInstance(Project project) {
    return new MergeDriverNotification(project);
  }
}
