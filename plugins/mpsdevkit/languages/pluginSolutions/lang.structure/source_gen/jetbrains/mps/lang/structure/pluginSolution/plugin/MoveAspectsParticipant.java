package jetbrains.mps.lang.structure.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.platform.actions.core.RefactoringParticipantBase;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.platform.actions.core.MoveNodeRefactoringParticipant;
import jetbrains.mps.ide.platform.actions.core.RecursiveParticipant;
import jetbrains.mps.smodel.structure.Extension;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.Language;
import java.util.List;
import jetbrains.mps.ide.platform.actions.core.RefactoringParticipant;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import java.util.Map;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.platform.actions.core.RefactoringSession;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import jetbrains.mps.ide.platform.actions.core.MoveNodesDefault;

public class MoveAspectsParticipant extends RefactoringParticipantBase<SNodeReference, SNodeReference, SNode, SNode> implements MoveNodeRefactoringParticipant<SNodeReference, SNodeReference>, RecursiveParticipant<SNodeReference, SNodeReference, SNode, SNode> {

  public static class MoveAspectsParticipant_extension extends Extension.Default<MoveNodeRefactoringParticipant<?, ?>> {
    public MoveAspectsParticipant_extension() {
      super("jetbrains.mps.ide.platform.MoveNodeParticipantEP");
    }
    public MoveNodeRefactoringParticipant<?, ?> get() {
      return new MoveAspectsParticipant();
    }
  }

  private MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference> myDataCollector = new MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference>() {
    public SNodeReference beforeMove(SNode nodeToMove) {
      return nodeToMove.getReference();
    }
    public SNodeReference afterMove(SNode movedNode) {
      return movedNode.getReference();
    }
  };

  public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference> getDataCollector() {
    return myDataCollector;
  }

  public boolean isApplicable(SNodeReference initialState, SRepository repository) {
    return (SNodeOperations.as(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration")) != null) && SNodeOperations.getModel(SNodeOperations.cast(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"))).getModule() instanceof Language;
  }
  public List<RefactoringParticipant.Option> getAvailableOptions(SNodeReference initialState, SRepository repository) {
    if (isApplicable(initialState, repository)) {
      return ListSequence.fromListAndArray(new ArrayList<RefactoringParticipant.Option>(), OPTION);
    } else {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Option>());
    }
  }

  @Override
  public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> getChanges(final SNodeReference initialState, final SRepository repository, List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope, ProgressMonitor progressMonitor) {
    return getChanges(initialState, repository, selectedOptions, searchScope, progressMonitor, Sequence.fromIterable(Collections.<RefactoringParticipant.ParticipantState>emptyList()));
  }

  @Override
  public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> getChanges(final SNodeReference initialState, final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope, final ProgressMonitor progressMonitor, final Iterable<RefactoringParticipant.ParticipantState> parents) {
    if (!((isApplicable(initialState, repository))) || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SNodeReference, SNodeReference>>());
    } else {
      final SNode sourceConcept = SNodeOperations.cast(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"));
      Language sourceLanguage = ((Language) SNodeOperations.getModel(sourceConcept).getModule());

      Map<LanguageAspect, List<SNode>> aspectsMap = MoveConceptUtil.getAspectNodes(sourceLanguage, Sequence.<SNode>singleton(sourceConcept));

      int participantSize = Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects()).count();
      Iterable<SNode> aspects = Sequence.fromIterable(MapSequence.fromMap(aspectsMap).values()).translate(new ITranslator2<List<SNode>, SNode>() {
        public Iterable<SNode> translate(List<SNode> x) {
          return x;
        }
      });
      progressMonitor.start("", participantSize * Sequence.fromIterable(aspects).foldLeft(0, new ILeftCombinator<SNode, Integer>() {
        public Integer combine(Integer s, SNode it) {
          return s + ListSequence.fromList(SNodeOperations.getNodeDescendants(it, null, true, new SAbstractConcept[]{})).count();
        }
      }));

      return MapSequence.fromMap(aspectsMap).translate(new ITranslator2<IMapping<LanguageAspect, List<SNode>>, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {
        public Iterable<RefactoringParticipant.Change<SNodeReference, SNodeReference>> translate(final IMapping<LanguageAspect, List<SNode>> mapping) {
          return ListSequence.fromList(mapping.value()).select(new ISelector<SNode, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {
            public RefactoringParticipant.Change<SNodeReference, SNodeReference> select(final SNode aspect) {

              List<SNode> descendants = SNodeOperations.getNodeDescendants(aspect, null, true, new SAbstractConcept[]{});

              final List<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>> childparticipantStates = ListSequence.fromList(descendants).translate(new ITranslator2<SNode, Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>>() {
                public Iterable<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>> translate(final SNode node) {
                  return Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects()).select(new ISelector<MoveNodeRefactoringParticipant<?, ?>, Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>>() {
                    public Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> select(MoveNodeRefactoringParticipant<?, ?> participant) {
                      RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode> participantState = RecursiveParticipant.RecursiveParticipantState.create(participant, node, parents);
                      participantState.findChanges(repository, selectedOptions, searchScope, progressMonitor.subTask(1));
                      return MultiTuple.<SNode,RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>from(node, participantState);
                    }
                  });
                }
              }).toListSequence();

              final SearchResults results = new SearchResults();
              results.addAll(new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(), sourceConcept), ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(), new SearchResult<SNode>(aspect, "concept aspect"))));
              ListSequence.fromList(childparticipantStates).translate(new ITranslator2<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>, RefactoringParticipant.Change<Object, Object>>() {
                public Iterable<RefactoringParticipant.Change<Object, Object>> translate(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> it) {
                  return ((RefactoringParticipant.ParticipantState) it._1()).getChanges();
                }
              }).select(new ISelector<RefactoringParticipant.Change<Object, Object>, SearchResults>() {
                public SearchResults select(RefactoringParticipant.Change<Object, Object> it) {
                  return it.getSearchResults();
                }
              }).visitAll(new IVisitor<SearchResults>() {
                public void visit(SearchResults it) {
                  results.addAll(it);
                }
              });


              // todo: do not keep nodes but only node references 

              RefactoringParticipant.Change<SNodeReference, SNodeReference> change = new RefactoringParticipant.Change<SNodeReference, SNodeReference>() {
                public SearchResults getSearchResults() {
                  return results;
                }
                public boolean needsToPreserveOldNode() {
                  return ListSequence.fromList(childparticipantStates).translate(new ITranslator2<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>, RefactoringParticipant.Change<Object, Object>>() {
                    public Iterable<RefactoringParticipant.Change<Object, Object>> translate(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> it) {
                      return ((RefactoringParticipant.ParticipantState) it._1()).getChanges();
                    }
                  }).any(new IWhereFilter<RefactoringParticipant.Change<Object, Object>>() {
                    public boolean accept(RefactoringParticipant.Change<Object, Object> it) {
                      return it.needsToPreserveOldNode();
                    }
                  });
                }
                public void confirm(SNodeReference finalState, final SRepository repository, final RefactoringSession refactoringSession) {
                  SNode targetConcept = SNodeOperations.cast(finalState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"));
                  Language targetLanguage = ((Language) SNodeOperations.getModel(targetConcept).getModule());
                  NodeLocation.NodeLocationRootWithAspectModelCreation newLocation = new NodeLocation.NodeLocationRootWithAspectModelCreation(targetLanguage, mapping.key());

                  List<SNode> copied = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).copy(ListSequence.fromListAndArray(new ArrayList<SNode>(), aspect), ListSequence.fromListAndArray(new ArrayList<Boolean>(), needsToPreserveOldNode() || MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).whetherKeepNode(sourceConcept)));
                  final Map<SNode, SNode> copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();
                  newLocation.insertNode(repository, ListSequence.fromList(copied).first());
                  ListSequence.fromList(childparticipantStates).visitAll(new IVisitor<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>>>() {
                    public void visit(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantState<?, ?, SNode, SNode>> pis) {
                      pis._1().confirm(MapSequence.fromMap(copyMap).get(pis._0()), repository, refactoringSession);
                    }
                  });
                }
              };
              return (RefactoringParticipant.Change<SNodeReference, SNodeReference>) change;
            }
          });
        }
      }).toListSequence();
    }
  }
  public static final RefactoringParticipant.Option OPTION = new RefactoringParticipant.Option("moveNode.options.moveConceptAspects", "Move concept aspects");
}
