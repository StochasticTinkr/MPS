package jetbrains.mps.lang.migration.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.refactoring.participant.RefactoringParticipantBase;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.refactoring.participant.MoveNodeRefactoringParticipant;
import jetbrains.mps.smodel.structure.Extension;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.List;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.Language;
import java.util.ArrayList;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.lang.migration.runtime.base.MigrationModuleUtil;
import org.apache.log4j.Level;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.refactoring.participant.RefactoringSession;
import java.util.Iterator;
import org.jetbrains.mps.openapi.model.SModel;

public class MoveNodeRefactoringLogParticipant extends RefactoringParticipantBase<SNodeReference, SNodeReference, SNode, SNode> implements MoveNodeRefactoringParticipant<SNodeReference, SNodeReference> {

  public static class MoveNodeRefactoringLogParticipant_extension extends Extension.Default<MoveNodeRefactoringParticipant<?, ?>> {
    public MoveNodeRefactoringLogParticipant_extension() {
      super("jetbrains.mps.refactoring.participant.MoveNodeParticipantEP");
    }
    public MoveNodeRefactoringParticipant<?, ?> get() {
      return new MoveNodeRefactoringLogParticipant();
    }
  }

  public static class MoveNodeParticipants extends Extension.Default<Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>>> {
    public MoveNodeParticipants() {
      super("jetbrains.mps.refactoring.participant.PersistentRefactoringParticipantsEP");
    }
    public Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>> get() {
      return Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.refactoring.participant.MoveNodeParticipantEP").getObjects()).ofType(RefactoringParticipant.PersistentRefactoringParticipant.class).select(new ISelector<RefactoringParticipant.PersistentRefactoringParticipant, RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>>() {
        public RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?> select(RefactoringParticipant.PersistentRefactoringParticipant it) {
          return (RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>) it;
        }
      });
    }
  }

  private MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference> myDataCollector = new MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference>() {
    public SNodeReference beforeMove(SNode nodeToMove) {
      return nodeToMove.getReference();
    }
    public SNodeReference afterMove(SNode movedNode) {
      return movedNode.getReference();
    }
  };

  public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference> getDataCollector() {
    return myDataCollector;
  }


  public boolean isApplicable(List<SNodeReference> initialStates, SRepository repository) {
    final SModule sourceModule = check_29rp6m_a0a0k(check_29rp6m_a0a0a01(ListSequence.fromList(initialStates).first().resolve(repository)));
    if (!(sourceModule instanceof Language)) {
      return false;
    }
    return true;
  }
  @Override
  public List<RefactoringParticipant.Option> getAvailableOptions(List<SNodeReference> initialStates, SRepository repository) {
    if (isApplicable(initialStates, repository)) {
      return ListSequence.fromListAndArray(new ArrayList<RefactoringParticipant.Option>(), OPTION);
    } else {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Option>());
    }
  }

  protected static Logger LOG = LogManager.getLogger(MoveNodeRefactoringLogParticipant.class);
  @Override
  public List<List<RefactoringParticipant.Change<SNodeReference, SNodeReference>>> getChanges(List<SNodeReference> initialStates, SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor) {
    if (!(isApplicable(initialStates, repository)) || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {
      return ListSequence.fromList(initialStates).select(new ISelector<SNodeReference, List<RefactoringParticipant.Change<SNodeReference, SNodeReference>>>() {
        public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> select(SNodeReference it) {
          return ((List<RefactoringParticipant.Change<SNodeReference, SNodeReference>>) ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SNodeReference, SNodeReference>>()));
        }
      }).toListSequence();
    }
    for (SModule module : Sequence.fromIterable(searchScope.getModules())) {
      if (MigrationModuleUtil.isModuleMigrateable(module) && !(MigrationModuleUtil.allDependenciesActual(module))) {
        String message = "Module " + module + " requires migration. It is recommended to run migration first and then restart refactoring.";
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error(message);
        }
      }
    }
    return super.getChanges(initialStates, repository, selectedOptions, searchScope, progressMonitor);
  }

  public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> getChanges(SNodeReference initialState, SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope) {
    final SNode sourceNode = initialState.resolve(repository);
    final SModule sourceModule = SNodeOperations.getModel(sourceNode).getModule();
    final List<SerializingParticipantState<?, ?, SNode, SNode>> participantStates = Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.refactoring.participant.MoveNodeParticipantEP").getObjects()).select(new ISelector<MoveNodeRefactoringParticipant<?, ?>, SerializingParticipantState<?, ?, SNode, SNode>>() {
      public SerializingParticipantState<?, ?, SNode, SNode> select(MoveNodeRefactoringParticipant<?, ?> participant) {
        return SerializingParticipantState.create(participant);
      }
    }).where(new IWhereFilter<SerializingParticipantState<?, ?, SNode, SNode>>() {
      public boolean accept(SerializingParticipantState<?, ?, SNode, SNode> it) {
        return it != null;
      }
    }).toListSequence();
    if (ListSequence.fromList(participantStates).isEmpty()) {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SNodeReference, SNodeReference>>());
    }
    final List<SNode> initialStates = ListSequence.fromList(participantStates).select(new ISelector<SerializingParticipantState<?, ?, SNode, SNode>, SNode>() {
      public SNode select(SerializingParticipantState<?, ?, SNode, SNode> it) {
        return it.getSerializedInitial(sourceNode);
      }
    }).toListSequence();

    final SearchResults results = new SearchResults();
    results.add(new SearchResult<SModule>(sourceModule, "refactoring log"));

    // todo: write guard migration with 'execute after' 

    RefactoringParticipant.Change<SNodeReference, SNodeReference> change = new MoveNodeRefactoringParticipant.ChangeBase<SNodeReference, SNodeReference>() {
      public SearchResults getSearchResults() {
        return results;
      }
      public void confirm(SNodeReference finalState, SRepository repository, RefactoringSession refactoringSession) {
        SNode targetNode = finalState.resolve(repository);
        SModule targetModule = SNodeOperations.getModel(targetNode).getModule();
        LogBuilder logBuilder = LogBuilder.getBuilder(refactoringSession, searchScope, sourceModule);
        logBuilder.addOptions(selectedOptions);
        {
          Iterator<SerializingParticipantState<?, ?, SNode, SNode>> ps_it = ListSequence.fromList(participantStates).iterator();
          Iterator<SNode> i_it = ListSequence.fromList(initialStates).iterator();
          SerializingParticipantState<?, ?, SNode, SNode> ps_var;
          SNode i_var;
          while (ps_it.hasNext() && i_it.hasNext()) {
            ps_var = ps_it.next();
            i_var = i_it.next();
            if (i_var != null) {
              logBuilder.addPart(ps_var.getParticipant(), i_var, ps_var.getSerializedFinal(targetNode));
            }
          }
        }
      }
    };
    return ListSequence.fromListAndArray(new ArrayList<RefactoringParticipant.Change<SNodeReference, SNodeReference>>(), change);
  }

  public static final RefactoringParticipant.Option OPTION = new RefactoringParticipant.Option("moveNode.options.writeRefactoringLog", "Write refactoring log");

  private static SModule check_29rp6m_a0a0k(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }
  private static SModel check_29rp6m_a0a0a01(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModel();
    }
    return null;
  }
}
