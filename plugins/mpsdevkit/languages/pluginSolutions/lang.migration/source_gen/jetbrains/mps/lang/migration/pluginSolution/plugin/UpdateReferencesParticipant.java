package jetbrains.mps.lang.migration.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.platform.actions.core.RefactoringParticipantBase;
import jetbrains.mps.lang.migration.pluginSolution.plugin.UpdateReferencesParticipant.NamedNodeReference;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.platform.actions.core.MoveNodeRefactoringParticipant;
import jetbrains.mps.ide.platform.actions.core.RefactoringParticipant;
import jetbrains.mps.smodel.structure.Extension;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.lang.migration.util.NodeReferenceUtil;
import java.util.List;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Collections;
import java.util.Collection;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.query.runtime.CommandUtil;
import jetbrains.mps.lang.smodel.query.runtime.QueryExecutionContext;
import java.util.Set;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.ide.platform.actions.core.RefactoringSession;
import jetbrains.mps.ide.platform.actions.core.MoveNodesDefault;
import jetbrains.mps.lang.migration.behavior.AbstractNodeReference__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class UpdateReferencesParticipant extends RefactoringParticipantBase<NamedNodeReference, NamedNodeReference, SNode, SNode> implements MoveNodeRefactoringParticipant<NamedNodeReference, NamedNodeReference>, RefactoringParticipant.PersistentRefactoringParticipant<NamedNodeReference, NamedNodeReference, SNode, SNode> {

  public static class UpdateReferencesParticipant_extension extends Extension.Default<MoveNodeRefactoringParticipant<?, ?>> {
    public UpdateReferencesParticipant_extension() {
      super("jetbrains.mps.ide.platform.MoveNodeParticipantEP");
    }
    public MoveNodeRefactoringParticipant<?, ?> get() {
      return new UpdateReferencesParticipant();
    }
  }

  public static class NamedNodeReference extends MultiTuple._2<SNodeReference, String> {
    public NamedNodeReference() {
      super();
    }
    public NamedNodeReference(SNodeReference reference, String name) {
      super(reference, name);
    }
    public SNodeReference reference(SNodeReference value) {
      return super._0(value);
    }
    public String name(String value) {
      return super._1(value);
    }
    public SNodeReference reference() {
      return super._0();
    }
    public String name() {
      return super._1();
    }
  }

  public String getId() {
    return "moveNode.updateReferences";
  }
  public static final RefactoringParticipant.Option OPTION = new RefactoringParticipant.Option("moveNode.options.updateReferencesParticipant", "Update references");

  protected class MyMoveNodeRefactoringDataCollector implements MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<NamedNodeReference, NamedNodeReference> {
    public NamedNodeReference beforeMove(SNode nodeToMove) {
      return new NamedNodeReference(nodeToMove.getReference(), NodeReferenceUtil.getNodePresentation(nodeToMove));
    }
    public NamedNodeReference afterMove(SNode movedNode) {
      return new NamedNodeReference(movedNode.getReference(), NodeReferenceUtil.getNodePresentation(movedNode));
    }
  }
  private MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<NamedNodeReference, NamedNodeReference> myDataCollector = new UpdateReferencesParticipant.MyMoveNodeRefactoringDataCollector();
  public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<NamedNodeReference, NamedNodeReference> getDataCollector() {
    return myDataCollector;
  }

  public List<RefactoringParticipant.Option> getAvailableOptions(NamedNodeReference initialState, SRepository repository) {
    return ListSequence.fromListAndArray(new ArrayList<RefactoringParticipant.Option>(), OPTION);
  }

  public List<List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>> getChanges(List<NamedNodeReference> initialStates, final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor) {
    if (!(ListSequence.fromList(selectedOptions).contains(OPTION))) {
      return ListSequence.fromList(initialStates).select(new ISelector<NamedNodeReference, List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>>() {
        public List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>> select(NamedNodeReference it) {
          return (List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>) Collections.<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>emptyList();
        }
      }).toListSequence();
    }
    Collection<SReference> usages;
    List<SNode> movedNodes = ListSequence.fromList(initialStates).select(new ISelector<NamedNodeReference, SNode>() {
      public SNode select(NamedNodeReference it) {
        return it.reference().resolve(repository);
      }
    }).toListSequence();
    {
      final SearchScope scope = CommandUtil.createScope(searchScope);
      QueryExecutionContext context = new QueryExecutionContext() {
        public SearchScope getDefaultSearchScope() {
          return scope;
        }
      };
      if (movedNodes != null) {
        progressMonitor.start("References in current project", 1);
        usages = (Set<SReference>) FindUsagesFacade.getInstance().findUsages(searchScope, SetSequence.fromSetWithValues(new HashSet<SNode>(), movedNodes), progressMonitor.subTask(1));
      } else {
        progressMonitor.start("References in current project", Sequence.fromIterable(CommandUtil.references(CommandUtil.createConsoleScope(null, false, context))).count());
        usages = CollectionSequence.fromCollection(new ArrayList<SReference>());
        for (SReference ref : Sequence.fromIterable(CommandUtil.references(CommandUtil.createConsoleScope(null, false, context)))) {
          if (ListSequence.fromList(initialStates).select(new ISelector<NamedNodeReference, SNodeReference>() {
            public SNodeReference select(NamedNodeReference it) {
              return it.reference();
            }
          }).contains(ref.getTargetNodeReference())) {
            CollectionSequence.fromCollection(usages).addElement(ref);
          }
          progressMonitor.advance(1);
          if (progressMonitor.isCanceled()) {
            return null;
          }
        }
      }
    }
    final Map<SNodeReference, List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>> result = MapSequence.fromMap(new HashMap<SNodeReference, List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>>());
    for (SReference ref : CollectionSequence.fromCollection(usages)) {
      final SNodeReference containingNode = ref.getSourceNode().getReference();
      final SNode movingNode = ref.getTargetNode();
      final SReferenceLink role = ref.getLink();
      final String resolveInfo = SLinkOperations.getResolveInfo(ref);
      final SearchResults searchResults = new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(), ref.getTargetNode()), ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(), new SearchResult<SNode>(ref.getSourceNode(), "reference")));
      RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference> change = new RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>() {
        public MoveNodeRefactoringParticipant<NamedNodeReference, NamedNodeReference> getParticipant() {
          return UpdateReferencesParticipant.this;
        }
        public SearchResults getSearchResults() {
          return searchResults;
        }
        public boolean needsToPreserveOldNode() {
          return false;
        }
        public void confirm(final NamedNodeReference finalState, final SRepository repository, final RefactoringSession refactoringSession) {
          refactoringSession.registerChange(new Runnable() {
            public void run() {
              if (shouldUpdateReference(repository, containingNode.resolve(repository), role, movingNode, refactoringSession)) {
                doUpdateReference(repository, containingNode.resolve(repository), role, finalState.reference(), resolveInfo);
                if (ListSequence.fromList(selectedOptions).contains(UpdateModelImports.OPTION)) {
                  doUpdateModelImport(repository, containingNode.resolve(repository), role, finalState.reference());
                }
              }
            }
          });
        }
      };
      if (MapSequence.fromMap(result).get(ref.getTargetNodeReference()) == null) {
        MapSequence.fromMap(result).put(ref.getTargetNodeReference(), ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>()));
      }
      ListSequence.fromList(MapSequence.fromMap(result).get(ref.getTargetNodeReference())).addElement(change);
    }
    return ListSequence.fromList(initialStates).select(new ISelector<NamedNodeReference, List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>>>() {
      public List<RefactoringParticipant.Change<NamedNodeReference, NamedNodeReference>> select(NamedNodeReference initialState) {
        return MapSequence.fromMap(result).get(initialState.reference());
      }
    }).toListSequence();
  }
  protected boolean shouldUpdateReference(SRepository repository, final SNode containingNode, final SReferenceLink role, SNode movingNode, RefactoringSession refactoringSession) {
    MoveNodesDefault.CopyMapObject copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession);
    if (containingNode == null) {
      return false;
    }
    // do not update reference from old node to other old node 
    if (MapSequence.fromMap(copyMap.getCopyMap()).containsKey(containingNode) && movingNode != null && movingNode.getModel() != null) {
      return false;
    }
    return true;
  }
  protected void doUpdateReference(SRepository repository, final SNode containingNode, final SReferenceLink role, SNodeReference newTarget, final String resolveInfo) {
    containingNode.setReference(role, jetbrains.mps.smodel.SReference.create(role, containingNode, newTarget.getModelReference(), newTarget.getNodeId(), resolveInfo));
  }
  protected void doUpdateModelImport(SRepository repository, final SNode containingNode, final SReferenceLink role, SNodeReference newTarget) {
    UpdateModelImports.addModelImport(containingNode.getModel(), newTarget.getModelReference().resolve(repository));
  }
  public SNode serializeInitialState(NamedNodeReference initialState) {
    return NodeReferenceUtil.makeReflection(initialState.reference(), initialState.name());
  }
  public NamedNodeReference deserializeInitialState(SNode serialized) {
    return new NamedNodeReference(AbstractNodeReference__BehaviorDescriptor.getNodeReference_id4uVwhQyQbdz.invoke(serialized), SPropertyOperations.getString(serialized, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x27bf3263be23f0dfL, 0x27bf3263be23f299L, "nodeName")));
  }
  public SNode serializeFinalState(NamedNodeReference finalState) {
    return NodeReferenceUtil.makeReflection(finalState.reference(), finalState.name());
  }
  public NamedNodeReference deserializeFinalState(SNode serialized) {
    return new NamedNodeReference(AbstractNodeReference__BehaviorDescriptor.getNodeReference_id4uVwhQyQbdz.invoke(serialized), SPropertyOperations.getString(serialized, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x27bf3263be23f0dfL, 0x27bf3263be23f299L, "nodeName")));
  }
}
