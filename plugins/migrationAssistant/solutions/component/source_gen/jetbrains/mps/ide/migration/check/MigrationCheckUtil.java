package jetbrains.mps.ide.migration.check;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.progress.ProgressIndicator;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.ide.migration.MigrationComponent;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Collection;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import java.util.List;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.ArrayList;
import java.util.HashSet;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConceptFeature;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.project.validation.ValidationUtil;
import org.jetbrains.mps.openapi.util.Processor;
import jetbrains.mps.project.validation.ValidationProblem;
import jetbrains.mps.project.validation.LanguageMissingError;
import jetbrains.mps.project.validation.ConceptMissingError;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.project.validation.ConceptFeatureMissingError;
import jetbrains.mps.project.validation.BrokenReferenceError;
import jetbrains.mps.module.ReloadableModule;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.classloading.ModuleClassLoaderSupport;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.module.SDependency;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.IFileUtils;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.util.FileUtil;

public class MigrationCheckUtil {

  public static _FunctionTypes._void_P1_E0<? super Double> progressIndicatorToCallback(final ProgressIndicator progressIndicator, final double start, final double stop) {
    progressIndicator.setIndeterminate(false);
    progressIndicator.setFraction(0);
    return new _FunctionTypes._void_P1_E0<Double>() {
      public void invoke(Double fraction) {
        progressIndicator.setFraction(start + fraction * (stop - start));
      }
    };
  }

  public static boolean haveNotMigrated(Iterable<SModule> modules, MigrationComponent mc, @Nullable _FunctionTypes._void_P1_E0<? super Double> progressCallback) {
    return CollectionSequence.fromCollection(getNotMigrated(modules, mc, progressCallback, 1)).isNotEmpty();
  }

  public static Collection<Problem> getNotMigrated(Iterable<SModule> modules, final MigrationComponent mc, @Nullable final _FunctionTypes._void_P1_E0<? super Double> progressCallback, int maxErrors) {
    List<Tuples._2<MigrationScript, SModule>> scriptsApplied = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, Tuples._2<MigrationScript, SModule>>() {
      public Iterable<Tuples._2<MigrationScript, SModule>> translate(final SModule module) {
        Set<SLanguage> allLanguages = new SLanguageHierarchy(LanguageRegistry.getInstance(module.getRepository()), module.getUsedLanguages()).getExtended();
        Iterable<MigrationScript> scripts = SetSequence.fromSet(allLanguages).translate(new ITranslator2<SLanguage, MigrationScript>() {
          public Iterable<MigrationScript> translate(final SLanguage it) {
            return new Iterable<MigrationScript>() {
              public Iterator<MigrationScript> iterator() {
                return new YieldingIterator<MigrationScript>() {
                  private int __CP__ = 0;
                  protected boolean moveToNext() {
__loop__:
                    do {
__switch__:
                      switch (this.__CP__) {
                        case -1:
                          assert false : "Internal error";
                          return false;
                        case 2:
                          this._2_ver = 0;
                        case 3:
                          if (!(_2_ver < it.getLanguageVersion())) {
                            this.__CP__ = 1;
                            break;
                          }
                          this.__CP__ = 4;
                          break;
                        case 5:
                          _2_ver++;
                          this.__CP__ = 3;
                          break;
                        case 8:
                          if (_7_script != null) {
                            this.__CP__ = 9;
                            break;
                          }
                          this.__CP__ = 5;
                          break;
                        case 10:
                          this.__CP__ = 5;
                          this.yield(_7_script);
                          return true;
                        case 0:
                          this.__CP__ = 2;
                          break;
                        case 4:
                          this._7_script = mc.fetchMigrationScript(new MigrationScriptReference(it, _2_ver), true);
                          this.__CP__ = 8;
                          break;
                        case 9:
                          this.__CP__ = 10;
                          break;
                        default:
                          break __loop__;
                      }
                    } while (true);
                    return false;
                  }
                  private int _2_ver;
                  private MigrationScript _7_script;
                };
              }
            };
          }
        });
        return Sequence.fromIterable(scripts).select(new ISelector<MigrationScript, Tuples._2<MigrationScript, SModule>>() {
          public Tuples._2<MigrationScript, SModule> select(MigrationScript script) {
            return MultiTuple.<MigrationScript,SModule>from(script, module);
          }
        });
      }
    }).toListSequence();
    final int allSteps = ListSequence.fromList(scriptsApplied).count();
    final Wrappers._int stepsPassed = new Wrappers._int(0);
    return ListSequence.fromList(scriptsApplied).translate(new ITranslator2<Tuples._2<MigrationScript, SModule>, Problem>() {
      public Iterable<Problem> translate(Tuples._2<MigrationScript, SModule> scriptModule) {
        progressCallback.invoke(0.1 + 0.9 * stepsPassed.value++ / allSteps);
        return scriptModule._0().check(scriptModule._1());
      }
    }).take(maxErrors).toListSequence();
  }

  public static boolean haveProblems(Iterable<SModule> modules, boolean includeBrokenReferences, @Nullable _FunctionTypes._void_P1_E0<? super Double> progressCallback) {
    return CollectionSequence.fromCollection(getProblems(modules, includeBrokenReferences, progressCallback, 1)).isNotEmpty();
  }

  public static Collection<Problem> getProblems(Iterable<SModule> modules, final boolean includeBrokenReferences, @Nullable _FunctionTypes._void_P1_E0<? super Double> progressCallback, int maxErrors) {
    final Wrappers._int _maxErrors = new Wrappers._int(maxErrors);
    final List<Problem> result = ListSequence.fromList(new ArrayList<Problem>());

    Collection<DependencyProblem> badModuleProblems = findBadModules(modules, _maxErrors.value);
    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(badModuleProblems));

    _maxErrors.value -= CollectionSequence.fromCollection(badModuleProblems).count();
    if (_maxErrors.value == 0) {
      return result;
    }

    Collection<BinaryModelProblem> badModelProblems = findBinaryModels(modules, _maxErrors.value);
    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(badModelProblems));

    _maxErrors.value -= CollectionSequence.fromCollection(badModelProblems).count();
    if (_maxErrors.value == 0) {
      return result;
    }

    if (progressCallback != null) {
      progressCallback.invoke(0.1);
    }

    final Set<SLanguage> missingLangs = SetSequence.fromSet(new HashSet<SLanguage>());
    final Set<SAbstractConcept> missingConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());
    final Set<SConceptFeature> missingFeatures = SetSequence.fromSet(new HashSet<SConceptFeature>());

    Iterable<EditableSModel> models = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {
      public Iterable<SModel> translate(SModule it) {
        return it.getModels();
      }
    }).ofType(EditableSModel.class);
    int modelsCount = Sequence.fromIterable(models).count();
    int processedModels = 0;

    // find missing concepts, when language's not missing 
    // find missing concept features when concept's not missing 
    for (EditableSModel model : Sequence.fromIterable(models)) {
      ValidationUtil.validateModelContent(model.getRootNodes(), new Processor<ValidationProblem>() {
        public boolean process(ValidationProblem vp) {
          if (vp instanceof LanguageMissingError) {
            LanguageMissingError err = (LanguageMissingError) vp;
            if (SetSequence.fromSet(missingLangs).contains(err.getLanguage())) {
              return true;
            }
            SetSequence.fromSet(missingLangs).addElement(err.getLanguage());
            if (err.isCompletelyAbsent()) {
              ListSequence.fromList(result).addElement(new LanguageAbsentInRepoProblem(err.getLanguage(), err.getNode()));
            } else {
              ListSequence.fromList(result).addElement(new LanguageNotLoadedProblem(err.getLanguage(), err.getNode()));
            }
          } else if (vp instanceof ConceptMissingError) {
            ConceptMissingError err = (ConceptMissingError) vp;
            SConcept concept = err.getConcept();
            if (SetSequence.fromSet(missingLangs).contains(concept.getLanguage()) || SetSequence.fromSet(missingConcepts).contains(concept)) {
              return true;
            }
            SetSequence.fromSet(missingConcepts).addElement(concept);
            ListSequence.fromList(result).addElement(new ConceptMissingProblem(concept, err.getNode()));
          } else if (vp instanceof ConceptFeatureMissingError) {
            ConceptFeatureMissingError err = (ConceptFeatureMissingError) vp;
            SAbstractConcept concept = err.getFeature().getOwner();
            if (SetSequence.fromSet(missingLangs).contains(concept.getLanguage()) || SetSequence.fromSet(missingConcepts).contains(concept) || SetSequence.fromSet(missingFeatures).contains(err.getFeature())) {
              return true;
            }
            SetSequence.fromSet(missingFeatures).addElement(err.getFeature());
            ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(err.getFeature(), err.getNode(), err.getMessage()));
          } else if (includeBrokenReferences && vp instanceof BrokenReferenceError) {
            BrokenReferenceError err = (BrokenReferenceError) vp;
            ListSequence.fromList(result).addElement(new BrokenReferenceProblem(err.getReference(), err.getMessage()));
          } else {
            // ignore other errors 
            return true;
          }

          _maxErrors.value--;
          return _maxErrors.value > 0;
        }
      });
      if (_maxErrors.value == 0) {
        return result;
      }

      processedModels++;
      if (progressCallback != null) {
        progressCallback.invoke(0.1 + 0.9 * processedModels / modelsCount);
      }
    }

    return result;
  }

  private static Collection<DependencyProblem> findBadModules(Iterable<SModule> modules, int maxErrors) {
    final List<DependencyProblem> rv = ListSequence.fromList(new ArrayList<DependencyProblem>());
    Sequence.fromIterable(modules).ofType(ReloadableModule.class).where(new IWhereFilter<ReloadableModule>() {
      public boolean accept(ReloadableModule it) {
        return ModuleClassLoaderSupport.canCreate(it);
      }
    }).visitAll(new IVisitor<ReloadableModule>() {
      public void visit(final ReloadableModule module) {
        Iterable<SDependency> deps = module.getDeclaredDependencies();
        Sequence.fromIterable(deps).where(new IWhereFilter<SDependency>() {
          public boolean accept(SDependency it) {
            return it.getTarget() == null;
          }
        }).visitAll(new IVisitor<SDependency>() {
          public void visit(SDependency dep) {
            ListSequence.fromList(rv).addElement(new DependencyProblem(module, String.format("Unresolved dependency in module %s: Module %s not found in repository", module.getModuleName(), dep.getTargetModule().getModuleName())));
          }
        });
      }
    });
    return ListSequence.fromList(rv).take(maxErrors).toListSequence();
  }

  private static Collection<BinaryModelProblem> findBinaryModels(Iterable<SModule> modules, int maxErrors) {
    return Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {
      public boolean accept(SModule it) {
        return !(it.isPackaged());
      }
    }).ofType(AbstractModule.class).translate(new ITranslator2<AbstractModule, BinaryModelProblem>() {
      public Iterable<BinaryModelProblem> translate(AbstractModule it) {
        return getBinaryModelsUnder(it);
      }
    }).take(maxErrors).toListSequence();
  }

  public static Collection<BinaryModelProblem> getBinaryModelsUnder(final AbstractModule module) {
    List<BinaryModelProblem> rv = ListSequence.fromList(new ArrayList<BinaryModelProblem>());

    IFile moduleFile = module.getDescriptorFile();
    if (moduleFile == null) {
      return rv;
    }

    List<IFile> allFiles = IFileUtils.getAllFiles(moduleFile.getParent());
    Iterable<IFile> binFiles = ListSequence.fromList(allFiles).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return MPSExtentions.MODEL_BINARY.equals(FileUtil.getExtension(it.getName()));
      }
    });
    ListSequence.fromList(rv).addSequence(Sequence.fromIterable(binFiles).select(new ISelector<IFile, BinaryModelProblem>() {
      public BinaryModelProblem select(IFile it) {
        return new BinaryModelProblem(module, String.format("Can't load binary model: module %s, file %s. Convert the model in MPS 3.1 or remove the model file before migrating. See https://youtrack.jetbrains.com/issue/MPS-21587", module.getModuleName(), it.getPath()));
      }
    }));

    return rv;
  }
}
