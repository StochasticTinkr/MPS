package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import jetbrains.mps.ide.migration.MigrationManager;
import com.intellij.ui.components.JBList;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.wm.impl.status.InlineProgressIndicator;
import java.util.Set;
import java.util.HashSet;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.persistence.PersistenceRegistry;
import org.apache.log4j.Level;
import javax.swing.JComponent;
import javax.swing.DefaultListModel;
import java.util.Collections;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import javax.swing.BorderFactory;
import com.intellij.ui.components.JBScrollPane;
import jetbrains.mps.ide.ThreadUtils;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.progress.ProgressManager;
import java.util.Map;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.ide.migration.ProgressEstimation;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.ide.migration.ScriptApplied;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.migration.check.MigrationCheckUtil;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.ide.migration.MigrationComponent;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.ide.migration.MigrationScriptApplied;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.ide.migration.check.MissingMigrationProblem;
import jetbrains.mps.ide.migration.RefactoringLogApplied;
import jetbrains.mps.lang.migration.runtime.base.RefactoringLogReference;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.ide.migration.check.DependencyOnNotMigratedLibProblem;

public class MigrationsProgressWizardStep extends MigrationWizardStep {
  public static final String ID = "progress";
  public static final String ID_fallback = "progressFallback";
  private MigrationManager myManager;
  private JBList myList;
  private ModalityState myModalityState;
  private Task myTask;
  private InlineProgressIndicator myProgress;
  private Set<String> myExecuted = new HashSet<String>();
  private MigrationProblemsContainer myErrorContainer;
  private boolean myInitialized = false;
  private volatile boolean myIsComplete = true;
  private InitialStep myInitialStep;
  private boolean mySearchBrokenReferences;

  protected static Logger LOG = LogManager.getLogger(MigrationsProgressWizardStep.class);
  public MigrationsProgressWizardStep(Project project, InitialStep initialStep, MigrationManager manager, MigrationProblemsContainer errorContainer, boolean searchBrokenReferences) {
    super(project, "Migration In Progress", (searchBrokenReferences ? ID : ID_fallback));
    myManager = manager;
    myErrorContainer = errorContainer;
    myInitialStep = initialStep;
    mySearchBrokenReferences = searchBrokenReferences;
    this.myTask = new Task.Modal(project, "Migration progress", false) {
      public void run(@NotNull ProgressIndicator progress) {
        PersistenceRegistry.getInstance().disableFastFindUsages();
        try {
          doRun(progress);
        } catch (Throwable t) {
          addElementToMigrationList("Finished with exception");
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("exception occurred on migration", t);
          }
        } finally {
          myIsComplete = true;
          setFraction(progress, 1.0);
          myProgress.setText("Finished");
          PersistenceRegistry.getInstance().enableFastFindUsages();
        }
      }
    };
  }

  @Override
  protected final void doCreateComponent(JComponent mainPanel) {
    myList = new JBList(new DefaultListModel());
    myList.setCellRenderer(new MigrationsListRenderer(myExecuted, Collections.emptySet()));
    JPanel listPanel = new JPanel(new BorderLayout(5, 5));
    listPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(0, 0, 2, 0), BorderFactory.createEtchedBorder()));
    listPanel.add(new JBScrollPane(myList), BorderLayout.CENTER);
    myProgress = new InlineProgressIndicator(true, myTask) {
      @Override
      protected void queueProgressUpdate() {
        if (ThreadUtils.isInEDT()) {
          updateAndRepaint();
        } else {
          ApplicationManager.getApplication().invokeLater(new Runnable() {
            public void run() {
              updateAndRepaint();
            }
          }, myModalityState);
        }
      }
      @Override
      protected void queueRunningUpdate(@NotNull Runnable update) {
        throw new UnsupportedOperationException();
      }
      @Override
      protected boolean isFinished() {
        return myIsComplete;
      }
    };
    myProgress.setIndeterminate(false);
    mainPanel.add(listPanel, BorderLayout.CENTER);
    mainPanel.add(myProgress.getComponent(), BorderLayout.SOUTH);
  }


  @Override
  public void _init() {
    super._init();
    if (!(myInitialized)) {
      myModalityState = ModalityState.stateForComponent(myList);
      myIsComplete = false;
      myErrorContainer.setErrorDescriptor(null);
      myInitialized = true;
    }
  }

  @Override
  public void autostart(final _FunctionTypes._void_P0_E0 later) {
    // this is needed to fully show the step before first migration is started 
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
          public void run() {
            ProgressManager.getInstance().runProcess(new Runnable() {
              public void run() {
                myTask.run(myProgress);
                later.invoke();
              }
            }, myProgress);

          }
        });

      }
    });
  }

  private void doRun(final ProgressIndicator progress) {
    Map<ProjectMigrationWithOptions.Option, Object> options = myInitialStep.getOptions();
    setFraction(progress, ProgressEstimation.initial());

    boolean cleanNotification = false;
    List<MigrationManager.MigrationStep> cleanupMigrations = ListSequence.fromList(new ArrayList<MigrationManager.MigrationStep>());
    int cleanupStepsCount = myManager.projectStepsCount(true);
    int stepNum = 0;
    while (true) {
      MigrationManager.MigrationStep step = myManager.nextProjectStep(options, true);
      if (step == null) {
        break;
      }

      ListSequence.fromList(cleanupMigrations).addElement(step);
      if (!(executeSingleStep(step))) {
        break;
      }

      if (!(cleanNotification)) {
        cleanNotification = true;
        addElementToMigrationList("Cleaning project...");
      }

      stepNum++;
      setFraction(progress, ProgressEstimation.cleanupMigrations(1.0 * stepNum / cleanupStepsCount));
    }

    addElementToMigrationList("Checking migrations consistency...");
    List<ScriptApplied.ScriptAppliedReference> missingMigrations = myManager.getMissingMigrations();
    setFraction(progress, ProgressEstimation.migrationsCheck(0.9));
    if (ListSequence.fromList(missingMigrations).isNotEmpty()) {
      myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.MigrationsMissingError(missingMigrations));
      addElementToMigrationList("Some migrations are missing. Press 'Next' to continue.");
      return;
    }
    final jetbrains.mps.project.Project mpsProject = getMPSProject();
    mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        final List<SModule> projectModules = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).toListSequence();
        Set<SModule> depModules = SetSequence.fromSetWithValues(new HashSet<SModule>(), new GlobalModuleDependenciesManager(projectModules).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE));
        SetSequence.fromSet(depModules).removeSequence(Sequence.fromIterable(((Iterable<SModule>) mpsProject.getModulesWithGenerators())));
        List<ScriptApplied.ScriptAppliedReference> depMigrationsToRun = myManager.getModuleMigrationsToApply(depModules);
        Iterable<SModule> notMigratedModules = ListSequence.fromList(depMigrationsToRun).select(new ISelector<ScriptApplied.ScriptAppliedReference, SModule>() {
          public SModule select(ScriptApplied.ScriptAppliedReference it) {
            return it.getModule();
          }
        }).distinct();
        final Map<SModule, SModule> errsToShow = MapSequence.fromMap(new HashMap<SModule, SModule>());
        Sequence.fromIterable(notMigratedModules).visitAll(new IVisitor<SModule>() {
          public void visit(final SModule notMigrated) {
            MapSequence.fromMap(errsToShow).put(notMigrated, ListSequence.fromList(projectModules).findFirst(new IWhereFilter<SModule>() {
              public boolean accept(SModule depCandidate) {
                return new GlobalModuleDependenciesManager(depCandidate).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE).contains(notMigrated);
              }
            }));
          }
        });
        if (ListSequence.fromList(depMigrationsToRun).isNotEmpty()) {
          myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.NotMigratedLibsError(errsToShow));
        }
      }
    });
    if (myErrorContainer.getErrorDescriptor() != null) {
      addElementToMigrationList("Some dependent modules are not migrated. Press 'Next' to continue.");
      return;
    }
    setFraction(progress, ProgressEstimation.migrationsCheck(1.0));


    addElementToMigrationList("Checking models...");
    mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
        if (MigrationCheckUtil.haveProblems(modules, mySearchBrokenReferences, new _FunctionTypes._void_P1_E0<Double>() {
          public void invoke(Double fraction) {
            setFraction(progress, ProgressEstimation.preCheck(fraction));
          }
        })) {
          boolean canIgnore = mySearchBrokenReferences && !(MigrationCheckUtil.haveProblems(modules, false, new _FunctionTypes._void_P1_E0<Double>() {
            public void invoke(Double fraction) {
              setFraction(progress, ProgressEstimation.fallbackPreCheck(fraction));
            }
          }));
          myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PreCheckError(canIgnore));
        }
      }
    });
    if (myErrorContainer.getErrorDescriptor() != null) {
      // start cleanup migrations next time migration is started 
      for (MigrationManager.MigrationStep cleanupMigration : ListSequence.fromList(cleanupMigrations)) {
        cleanupMigration.forceExecutionNextTime();
      }
      addElementToMigrationList("Can't start migration: errors detected. Press 'Next' to continue.");
      return;
    }

    int projectStepsCount = myManager.projectStepsCount(false);
    stepNum = 0;
    while (executeSingleStep(myManager.nextProjectStep(options, false))) {
      stepNum++;
      setFraction(progress, ProgressEstimation.projectMigrations(1.0 * stepNum / projectStepsCount));
    }
    if (myErrorContainer.getErrorDescriptor() != null) {
      addElementToMigrationList("Exception while running migration. Press 'Next' to continue.");
      return;
    }

    int languageStepsCount = myManager.moduleStepsCount();
    stepNum = 0;
    while (executeSingleStep(myManager.nextModuleStep())) {
      stepNum++;
      setFraction(progress, ProgressEstimation.languageMigrations(1.0 * stepNum / languageStepsCount));
    }
    if (myErrorContainer.getErrorDescriptor() != null) {
      addElementToMigrationList("Exception while running migration. Press 'Next' to continue.");
      return;
    }

    addElementToMigrationList("Saving changed models...");

    mpsProject.getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        mpsProject.getRepository().saveAll();
      }
    });
    setFraction(progress, ProgressEstimation.saving(1.0));

    final Wrappers._boolean haveBadCode = new Wrappers._boolean(false);
    addElementToMigrationList("Checking models...");
    mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
        final Wrappers._int moduleNum = new Wrappers._int(0);

        haveBadCode.value = MigrationCheckUtil.haveProblems(modules, mySearchBrokenReferences, new _FunctionTypes._void_P1_E0<Double>() {
          public void invoke(Double fraction) {
            moduleNum.value++;
            setFraction(progress, ProgressEstimation.postCheck(fraction));
          }
        });
      }
    });

    addElementToMigrationList("Finding not migrated code...");
    mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
        final Wrappers._int moduleNum = new Wrappers._int(0);

        boolean haveNotMigrated = MigrationCheckUtil.haveNotMigrated(modules, getMPSProject().getComponent(MigrationComponent.class), new _FunctionTypes._void_P1_E0<Double>() {
          public void invoke(Double fraction) {
            moduleNum.value++;
            setFraction(progress, ProgressEstimation.nonMigratedCheck(fraction));
          }
        });

        if (haveBadCode.value || haveNotMigrated) {
          myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PostCheckError(haveBadCode.value, haveNotMigrated));
        }
      }
    });
    if (myErrorContainer.getErrorDescriptor() != null) {
      addElementToMigrationList("Problems are detected after executing migrations. Press 'Next' to continue.");
      return;
    }

    addElementToMigrationList("Done!");
  }

  public void setFraction(ProgressIndicator p, double fraction) {
    p.setFraction(fraction);
  }

  private void addElementToMigrationList(final String step) {
    final DefaultListModel model = (DefaultListModel) myList.getModel();
    ApplicationManager.getApplication().invokeAndWait(new Runnable() {
      public void run() {
        model.addElement(step);
        myList.ensureIndexIsVisible(model.lastIndexOf(step));
        myList.repaint();
      }
    }, myModalityState);
  }

  private boolean executeSingleStep(final MigrationManager.MigrationStep result) {
    if (result == null) {
      return false;
    }

    final String step = ((MigrationManager.MigrationStep) result).getDescription();
    addElementToMigrationList(step);

    final Wrappers._boolean noException = new Wrappers._boolean();
    ApplicationManager.getApplication().invokeAndWait(new Runnable() {
      public void run() {
        noException.value = ((MigrationManager.MigrationStep) result).execute();
      }
    }, myModalityState);

    if (!(noException.value)) {
      myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.MigrationExceptionError());
    }

    return noException.value;
  }

  @Override
  public Object getNextStepId() {
    if (!(isComplete())) {
      return null;
    }
    if (myErrorContainer.getErrorDescriptor() == null) {
      return null;
    }

    return MigrationErrorWizardStep.ID;
  }

  @Override
  public Object getPreviousStepId() {
    return null;
  }

  @Override
  public boolean isComplete() {
    return myIsComplete;
  }

  @Override
  public boolean canBeCancelled() {
    return false;
  }

  private class PreCheckError extends MigrationErrorDescriptor {
    private final boolean myCanIgnore;
    public PreCheckError(boolean canIgnore) {
      myCanIgnore = canIgnore;
    }
    public String getMessage() {
      if (!(myCanIgnore)) {
        return "Migration Assistant found some problems that prevent this project from being migrated.<br><br>" + "Try running migrations after correcting your project and/or adding necessary libraries.<br>" + "Migration Assistant will be started again on next project opening or it can be started " + "manually by choosing Tools->Run Migration Assistant from the main menu.<br><br>" + "Problems will be shown in Model Checker tool when the project is loaded.";
      } else {
        return "Migration Assistant found some broken references that prevent this project from being migrated.<br><br>" + "Try running migrations after correcting your project and/or adding necessary libraries.<br>" + "You can ignore all broken references and continue migration, but it can cause some migrations to run improperly.<br>" + "Migration Assistant will be started again on next project opening or it can be started " + "manually by choosing Tools->Run Migration Assistant from the main menu.<br><br>" + "Problems will be shown in Model Checker tool when the project is loaded.";
      }
    }
    public boolean canIgnore() {
      return myCanIgnore;
    }
    public Iterable<Problem> getProblems(ProgressIndicator progressIndicator) {
      Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(getMPSProject());
      return MigrationCheckUtil.getProblems(modules, true, MigrationCheckUtil.progressIndicatorToCallback(progressIndicator, 0, 1), 100);
    }
  }

  private class PostCheckError extends MigrationErrorDescriptor {
    private boolean myError;
    private boolean myHasManuals;

    public PostCheckError(boolean error, boolean hasManuals) {
      assert error || hasManuals;
      myError = error;
      myHasManuals = hasManuals;
    }
    public boolean canIgnore() {
      return false;
    }
    public String getMessage() {
      String res = "Migration Assistant was unable to migrate some nodes in this project.<br><br>";
      if (myError) {
        res += "Problems " + ((myHasManuals ? "and code for manual correction" : "")) + "will be shown in Model Checker tool when the project is loaded.";
      } else {
        res += "Some code can't be migrated automatically and should be changed manually.<br>" + "Places to be changed manually will be shown in Model Checker tool after the project is loaded.<br>";
      }
      if (myHasManuals) {
        res += "You can re-run search for not migrated code at any time by choosing MainMenu->Migrations->Run Pre-Update Check";
      }
      return res;
    }
    public Iterable<Problem> getProblems(ProgressIndicator progressIndicator) {
      Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(getMPSProject());
      return CollectionSequence.fromCollection(MigrationCheckUtil.getNotMigrated(modules, getMPSProject().getComponent(MigrationComponent.class), MigrationCheckUtil.progressIndicatorToCallback(progressIndicator, 0, 0.5), 100)).union(CollectionSequence.fromCollection(MigrationCheckUtil.getProblems(modules, true, MigrationCheckUtil.progressIndicatorToCallback(progressIndicator, 0.5, 1), 100)));
    }
  }
  private class MigrationExceptionError extends MigrationErrorDescriptor {
    public MigrationExceptionError() {
    }
    public String getMessage() {
      return "Exception occurred while running migration. See log file for details.";
    }
    public boolean canIgnore() {
      return false;
    }
    public Iterable<Problem> getProblems(ProgressIndicator progressIndicator) {
      return Collections.<Problem>emptyList();
    }
  }
  private class MigrationsMissingError extends MigrationErrorDescriptor {
    private List<ScriptApplied.ScriptAppliedReference> errors;
    public MigrationsMissingError(List<ScriptApplied.ScriptAppliedReference> errors) {
      this.errors = errors;
    }
    public String getMessage() {
      return "Migration was not started.<br>" + "Some migration scripts are missing or finished with errors.<br><br>" + "Problems will be shown in Model Checker tool after the project is loaded.<br>" + "It's possible to invoke Migration Assistant at any time by selecting Tools->Run Migration Assistant from the main menu.";
    }
    public boolean canIgnore() {
      return false;
    }
    public Iterable<Problem> getProblems(ProgressIndicator progressIndicator) {
      final List<SModule> modules = ListSequence.fromList(errors).select(new ISelector<ScriptApplied.ScriptAppliedReference, SModule>() {
        public SModule select(ScriptApplied.ScriptAppliedReference it) {
          return it.getModule();
        }
      }).toListSequence();
      return ListSequence.fromList(errors).ofType(MigrationScriptApplied.MigrationScriptAppliedReference.class).select(new ISelector<MigrationScriptApplied.MigrationScriptAppliedReference, MigrationScriptReference>() {
        public MigrationScriptReference select(MigrationScriptApplied.MigrationScriptAppliedReference it) {
          return it.getMigrationSciptReference();
        }
      }).distinct().select(new ISelector<MigrationScriptReference, Problem>() {
        public Problem select(final MigrationScriptReference it) {
          List<SModule> languageUsages = ListSequence.fromList(modules).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule module) {
              return SetSequence.fromSet(MigrationsUtil.getUsedLanguages(module)).contains(it.getLanguage());
            }
          }).toListSequence();
          return (Problem) new MissingMigrationProblem.MissingMigrationScriptProblem(it, Collections.min(ListSequence.fromList(languageUsages).select(new ISelector<SModule, Integer>() {
            public Integer select(SModule module) {
              return module.getUsedLanguageVersion(it.getLanguage());
            }
          }).toListSequence()));
        }
      }).concat(ListSequence.fromList(errors).ofType(RefactoringLogApplied.RefactoringLogAppliedReference.class).select(new ISelector<RefactoringLogApplied.RefactoringLogAppliedReference, RefactoringLogReference>() {
        public RefactoringLogReference select(RefactoringLogApplied.RefactoringLogAppliedReference it) {
          return it.getRefactoringLogReference();
        }
      }).distinct().select(new ISelector<RefactoringLogReference, Problem>() {
        public Problem select(final RefactoringLogReference it) {
          List<SModule> languageUsages = ListSequence.fromList(modules).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule module) {
              return SetSequence.fromSet(MigrationsUtil.getModuleDependencies(module)).contains(it.getModule());
            }
          }).toListSequence();
          return (Problem) new MissingMigrationProblem.MissingRefactoringLogProblem(it, Collections.min(ListSequence.fromList(languageUsages).select(new ISelector<SModule, Integer>() {
            public Integer select(SModule module) {
              return ((AbstractModule) module).getDependencyVersion(it.getModule());
            }
          }).toListSequence()));
        }
      }));
    }
  }
  private class NotMigratedLibsError extends MigrationErrorDescriptor {
    private Map<SModule, SModule> errors;
    public NotMigratedLibsError(Map<SModule, SModule> errors) {
      this.errors = errors;
    }
    public String getMessage() {
      return "Migration was not started.<br>" + "The project depends on some external modules that were not fully migrated.<br><br>" + "Problems will be shown in Model Checker tool after the project is loaded.<br>" + "It's possible to invoke Migration Assistant at any time by selecting Tools->Run Migration Assistant from the main menu.";
    }
    public boolean canIgnore() {
      return false;
    }
    public Iterable<Problem> getProblems() {
      return MapSequence.fromMap(errors).select(new ISelector<IMapping<SModule, SModule>, DependencyOnNotMigratedLibProblem>() {
        public DependencyOnNotMigratedLibProblem select(IMapping<SModule, SModule> it) {
          return new DependencyOnNotMigratedLibProblem(it.key(), it.value());
        }
      });
    }
  }
}
