package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import jetbrains.mps.progress.ProgressMonitorAdapter;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.ide.migration.MigrationManager;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.migration.check.MigrationCheckUtil;
import jetbrains.mps.ide.migration.MigrationComponent;

public class MigrationTask extends StepTask {
  public static final String STARTED = "Migration started";
  public static final String FINISHED = "Migration finished";

  public MigrationTask(MigrationSession session) {
    super(session, "Migration progress");
  }

  protected void doRun(ProgressMonitorAdapter progress) {
    // todo move to checking step? 
    mySession.setErrorDescriptor(null);

    progress.start("Migrating...", 100);
    LongBaseStep.addGlobalLabel(mySession.getProject(), STARTED);

    if (!((runProjectMigrations(progress.subTask(10))))) {
      result(progress, new MigrationExceptionError(), "Exception while running migration");
      return;
    }
    if (!((runLanguageMigrations(progress.subTask(60))))) {
      result(progress, new MigrationExceptionError(), "Exception while running migration");
      return;
    }

    LongBaseStep.addGlobalLabel(mySession.getProject(), FINISHED);

    if (!((checkProject(progress.subTask(15))))) {
      result(progress, new PostCheckError(mySession.getProject(), true), "Problems are detected after executing migrations.");
      return;
    }

    // todo move from here to migration annotations 
    if (!((findNotMigrated(progress.subTask(15))))) {
      result(progress, new PostCheckError(mySession.getProject(), false), "Problems are detected after executing migrations.");
      return;
    }

    result(progress, null, "Done!");
  }

  private boolean runProjectMigrations(ProgressMonitor m) {
    int projectStepsCount = mySession.getMigrationManager().projectStepsCount(false);
    m.start("Running project migrations...", projectStepsCount);
    boolean success = true;
    while (true) {
      MigrationManager.MigrationStep step = mySession.getMigrationManager().nextProjectStep(mySession.getOptions(), false);
      if (step == null) {
        break;
      }

      m.step(((MigrationManager.MigrationStep) step).getDescription());
      if (!(executeSingleStep(step, null))) {
        success = false;
        break;
      }

      m.advance(1);
    }
    m.done();
    return success;
  }

  private boolean runLanguageMigrations(ProgressMonitor m) {
    int languageStepsCount = mySession.getMigrationManager().moduleStepsCount();
    m.start("Running language migrations...", languageStepsCount);
    boolean success = true;

    final Wrappers._T<String> preferredId = new Wrappers._T<String>(null);
    while (true) {
      MigrationManager.MigrationStep step = mySession.getMigrationManager().nextModuleStep(preferredId.value);
      if (step == null) {
        break;
      }

      preferredId.value = step.getMergeId();
      m.step(((MigrationManager.MigrationStep) step).getDescription());
      if (!(executeSingleStep(step, new _FunctionTypes._return_P0_E0<MigrationManager.MigrationStep>() {
        public MigrationManager.MigrationStep invoke() {
          return mySession.getMigrationManager().nextModuleStep(preferredId.value);
        }
      }))) {
        success = false;
        break;
      }

      m.advance(1);
    }

    m.done();
    return success;
  }

  public boolean checkProject(final ProgressMonitor m) {
    final Wrappers._boolean haveBadCode = new Wrappers._boolean();
    final Project mpsProject = mySession.getProject();
    mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
        m.start("Checking models...", Sequence.fromIterable(modules).count());

        haveBadCode.value = MigrationCheckUtil.haveProblems(modules, StepTask.frac2inc(Sequence.fromIterable(modules).count(), new _FunctionTypes._void_P1_E0<Integer>() {
          public void invoke(Integer processed) {
            m.advance(processed);
          }
        }));
      }
    });
    return haveBadCode.value;
  }

  public boolean findNotMigrated(final ProgressMonitor m) {
    final Project project = mySession.getProject();
    final Wrappers._boolean haveNotMigrated = new Wrappers._boolean();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(project);
        m.start("Finding not migrated code...", Sequence.fromIterable(modules).count());
        haveNotMigrated.value = MigrationCheckUtil.haveNotMigrated(modules, project.getComponent(MigrationComponent.class), StepTask.frac2inc(Sequence.fromIterable(modules).count(), new _FunctionTypes._void_P1_E0<Integer>() {
          public void invoke(Integer processed) {
            m.advance(processed);
          }
        }));
      }
    });
    return haveNotMigrated.value;
  }
}
