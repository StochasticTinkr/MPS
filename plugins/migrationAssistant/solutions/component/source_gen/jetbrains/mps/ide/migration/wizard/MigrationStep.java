package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import com.intellij.openapi.wm.impl.status.InlineProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import javax.swing.JComponent;
import java.awt.BorderLayout;
import javax.swing.JPanel;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.progress.ProgressManager;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import javax.swing.SwingUtilities;
import com.intellij.openapi.project.Project;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.openapi.ui.Messages;
import java.lang.reflect.InvocationTargetException;
import com.intellij.openapi.progress.TaskInfo;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.ide.ThreadUtils;
import com.intellij.openapi.application.ModalityState;

public class MigrationStep extends BaseStep {
  public static final String ID = "migration";

  private InlineProgressIndicator myProgress;
  private MigrationSession mySession;
  private MigrationTask myTask;

  public MigrationStep(MigrationSession session) {
    super("Migration in Progress", ID);
    mySession = session;
    myProgress = new MigrationStep.MyInlineProgressIndicator();
    myTask = new MigrationTask(session, new ProgressMonitorAdapter(myProgress));
  }

  @Override
  protected final void doCreateComponent(JComponent mainPanel) {
    mainPanel.setLayout(new BorderLayout());
    mainPanel.add(myProgress.getComponent(), BorderLayout.NORTH);
    mainPanel.add(new JPanel(), BorderLayout.CENTER);
  }

  @Override
  public void _init() {
    super._init();

    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
      public void run() {
        try {
          Thread.sleep(1000);
        } catch (InterruptedException e) {
          // do nothing 
        }
        ProgressManager.getInstance().runProcess(new Runnable() {
          public void run() {
            while (!(myTask.isComplete())) {
              myTask.run();
              if (mySession.getErrorDescriptor() != null) {
                if (!(mySession.getErrorDescriptor().canIgnore()) || !(showError())) {
                  myTask.forceComplete();
                  myProgress.setFraction(1.0);
                  fireStateChanged();
                  break;
                }
              }
            }
            fireStateChanged();
          }
        }, myProgress);
      }
    });
  }

  public boolean showError() {
    // false - stop, true - continue 
    final Wrappers._boolean res = new Wrappers._boolean(false);
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          Project project = ProjectHelper.toIdeaProject(mySession.getProject());
          String msg = mySession.getErrorDescriptor().getMessage();
          msg = msg.replaceAll("<br>", "\n");
          res.value = Messages.showYesNoDialog(project, msg, "Errors detected", "Ignore and Migrate", "Stop Migration", null) == Messages.YES;
        }
      });
    } catch (InvocationTargetException e) {
    } catch (InterruptedException e) {
    }
    return res.value;
  }

  @Override
  public Object getNextStepId() {
    return null;
  }

  @Override
  public Object getPreviousStepId() {
    return null;
  }

  @Override
  public boolean isComplete() {
    return myTask.isComplete();
  }

  @Override
  public boolean canBeCancelled() {
    return false;
  }

  private class MyInlineProgressIndicator extends InlineProgressIndicator {
    public MyInlineProgressIndicator() {
      super(false, new TaskInfo() {
        @NotNull
        public String getTitle() {
          return "Migration in progress";
        }
        public String getCancelText() {
          return "";
        }
        public String getCancelTooltipText() {
          return "";
        }
        public boolean isCancellable() {
          return false;
        }
        @NonNls
        public String getProcessId() {
          return "migration";
        }
      });
      setIndeterminate(false);
    }
    @Override
    protected void queueProgressUpdate() {
      if (ThreadUtils.isInEDT()) {
        updateAndRepaint();
      } else {
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            updateAndRepaint();
          }
        }, ModalityState.stateForComponent(getComponent()));
      }
    }
    @Override
    protected void queueRunningUpdate(@NotNull Runnable update) {
      throw new UnsupportedOperationException();
    }
    @Override
    protected boolean isFinished() {
      return myTask.isComplete();
    }
  }
}
