package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import org.jetbrains.mps.openapi.util.Processor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.List;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.ide.migration.check.MigrationCheckUtil;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;

public class MigrationCheckerImpl extends AbstractProjectComponent implements MigrationChecker {
  private Project myProject;
  private MigrationManager myManager;

  public MigrationCheckerImpl(com.intellij.openapi.project.Project ideaProject, Project p, MigrationManager manager) {
    super(ideaProject);
    myProject = p;
    myManager = manager;
  }

  @Override
  public void checkMigrations(ProgressMonitor m, final Processor<ScriptApplied> processor) {
    m.start("Checking migrations consistency...", 1);
    myProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<ScriptApplied> problems = ListSequence.fromList(myManager.getModuleMigrationsToApply(MigrationsUtil.getMigrateableModulesFromProject(myProject))).where(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return it.getScriptReference().resolve(false) == null;
          }
        });
        for (ScriptApplied problem : Sequence.fromIterable(problems)) {
          if (!(processor.process(problem))) {
            break;
          }
        }
      }
    });
    m.done();
  }
  @Override
  public void checkLibs(ProgressMonitor m, final Processor<Pair<SModule, SModule>> processor) {
    m.start("Checking dependencies...", 1);
    myProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        List<SModule> projectModules = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(myProject)).toListSequence();
        Set<SModule> depModules = SetSequence.fromSetWithValues(new HashSet<SModule>(), new GlobalModuleDependenciesManager(projectModules).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE));
        SetSequence.fromSet(depModules).removeSequence(Sequence.fromIterable(((Iterable<SModule>) myProject.getModulesWithGenerators())));
        List<ScriptApplied> depMigrationsToRun = myManager.getModuleMigrationsToApply(depModules);
        Iterable<SModule> notMigratedModules = ListSequence.fromList(depMigrationsToRun).select(new ISelector<ScriptApplied, SModule>() {
          public SModule select(ScriptApplied it) {
            return it.getModule();
          }
        }).distinct();
        for (final SModule notMigrated : Sequence.fromIterable(notMigratedModules)) {
          SModule m = ListSequence.fromList(projectModules).findFirst(new IWhereFilter<SModule>() {
            public boolean accept(SModule depCandidate) {
              return new GlobalModuleDependenciesManager(depCandidate).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE).contains(notMigrated);
            }
          });
          if (m == null) {
            continue;
          }
          processor.process(new Pair(notMigrated, m));
        }
      }
    });
    m.done();
  }
  @Override
  public void checkProject(final ProgressMonitor m, final Processor<Problem> consumer) {
    myProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        // todo inline 
        MigrationCheckUtil.getProblems(Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(myProject)).toListSequence(), m, consumer);
      }
    });
  }
  @Override
  public void findNotMigrated(final ProgressMonitor m, final Iterable<ScriptApplied> toCheck, final Processor<Problem> processor) {
    myProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        // todo inline 
        MigrationCheckUtil.getNotMigrated(toCheck, m, processor);
      }
    });
  }

  @Override
  public void projectOpened() {
  }
  @Override
  public void projectClosed() {
  }
  @Override
  public void initComponent() {
  }
  @Override
  public void disposeComponent() {
  }
  @NonNls
  @NotNull
  @Override
  public String getComponentName() {
    return this.getClass().getSimpleName();
  }
}
