package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.project.Project;
import jetbrains.mps.migration.global.ProjectMigration;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.Set;
import java.util.HashMap;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.language.LanguageRegistry;
import java.util.LinkedHashSet;
import java.util.Collection;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.apache.log4j.Level;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.ArrayList;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class MigrationManagerImpl extends AbstractProjectComponent implements MigrationManager {
  private Project myMpsMproject;
  private ProjectMigration lastProjectMigration = null;
  private MigrationComponent myMigrationComponent;

  public MigrationManagerImpl(com.intellij.openapi.project.Project project, Project mpsProject, MigrationComponent migrationComponent) {
    super(project);
    myMpsMproject = mpsProject;
    myMigrationComponent = migrationComponent;
  }

  public MigrationComponent getMigrationComponent() {
    return myMigrationComponent;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    myMpsMproject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(myMpsMproject);
        result.value = isMigrationRequired(modules);
      }
    });
    return result.value;
  }

  public boolean isMigrationRequired(Iterable<SModule> modules) {
    return Sequence.fromIterable(getProjectMigrationsToApply()).isNotEmpty() || ListSequence.fromList(getModuleMigrationsToApply(modules)).isNotEmpty();
  }

  public Iterable<ProjectMigration> getProjectMigrationsToApply() {
    List<ProjectMigration> allProjectMigrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    return ListSequence.fromList(allProjectMigrations).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(myMpsMproject);
      }
    }).toListSequence();
  }

  public boolean importVersionsUpdateRequired(Iterable<SModule> modules) {
    myMpsMproject.getModelAccess().checkReadAccess();

    for (SModule module : Sequence.fromIterable(modules)) {
      AbstractModule abstractModule = (AbstractModule) module;
      ModuleDescriptor md = abstractModule.getModuleDescriptor();
      if (md == null) {
        throw new IllegalStateException("Module " + modules + " has not module descriptor.");
      }

      Map<SModuleReference, Integer> oldDepVersions = Collections.unmodifiableMap(md.getDependencyVersions());
      Map<SModuleReference, Integer> newDepVersions = collectDependencyVersions(abstractModule, oldDepVersions);
      if (!(oldDepVersions.keySet().equals(newDepVersions.keySet()))) {
        return true;
      }

      Map<SLanguage, Integer> oldLangVersions = Collections.unmodifiableMap(md.getLanguageVersions());
      Map<SLanguage, Integer> newLangVersions = collectLanguageVersions(abstractModule, oldLangVersions);
      checkModelVersionsAreValid(module, newLangVersions);
      if (!(oldLangVersions.equals(newLangVersions))) {
        return true;
      }

      Set<SModuleReference> devkits = abstractModule.collectLanguagesAndDevkits().devkits;
      if (!(md.getUsedDevkits().containsAll(devkits))) {
        return true;
      }
    }

    return false;
  }

  public void doUpdateImportVersions(SModule module) {
    module.getRepository().getModelAccess().checkWriteAccess();

    AbstractModule abstractModule = (AbstractModule) module;
    ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + module + " has not module descriptor.");
    }

    Map<SModuleReference, Integer> depVersions = md.getDependencyVersions();
    Map<SModuleReference, Integer> newDepVersions = collectDependencyVersions(abstractModule, depVersions);
    if (!(depVersions.equals(newDepVersions))) {
      abstractModule.setChanged();
      depVersions.clear();
      depVersions.putAll(newDepVersions);
    }

    Map<SLanguage, Integer> langVersions = md.getLanguageVersions();
    Map<SLanguage, Integer> newLangVersions = collectLanguageVersions(abstractModule, langVersions);
    if (!(langVersions.equals(newLangVersions))) {
      abstractModule.setChanged();
      langVersions.clear();
      langVersions.putAll(newLangVersions);
    }

    Set<SModuleReference> devkits = abstractModule.collectLanguagesAndDevkits().devkits;
    if (!(md.getUsedDevkits().containsAll(devkits))) {
      abstractModule.setChanged();
      // intentionally no clean(), augmentation only, just in case there's anything vital already. 
      md.getUsedDevkits().addAll(devkits);
    }
  }

  public Map<SLanguage, Integer> collectLanguageVersions(SModule module, Map<SLanguage, Integer> oldLangVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    Map<SLanguage, Integer> newLangVersions = new HashMap<SLanguage, Integer>();
    Set<SLanguage> usedLanguages = module.getUsedLanguages();
    SLanguageHierarchy languageHierarchy = new SLanguageHierarchy(LanguageRegistry.getInstance(myMpsMproject.getRepository()), usedLanguages);
    Set<SLanguage> extendingLangsClosure = languageHierarchy.getExtended();
    for (SLanguage lang : extendingLangsClosure) {
      if (oldLangVersions.containsKey(lang)) {
        newLangVersions.put(lang, oldLangVersions.get(lang));
      } else {
        newLangVersions.put(lang, lang.getLanguageVersion());
      }
    }
    return newLangVersions;
  }

  public Map<SModuleReference, Integer> collectDependencyVersions(SModule module, Map<SModuleReference, Integer> oldDepVersions) {
    module.getRepository().getModelAccess().checkReadAccess();

    Map<SModuleReference, Integer> newDepVersions = new HashMap<SModuleReference, Integer>();
    Set<SModule> visible = new LinkedHashSet<SModule>();
    visible.add(module);
    Collection<SModule> dependentModules = new GlobalModuleDependenciesManager(module).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE);
    visible.addAll(dependentModules);
    for (SModule dep : visible) {
      if (oldDepVersions.containsKey(dep.getModuleReference())) {
        newDepVersions.put(dep.getModuleReference(), oldDepVersions.get(dep.getModuleReference()));
      } else {
        newDepVersions.put(dep.getModuleReference(), ((AbstractModule) dep).getModuleVersion());
      }
    }
    return newDepVersions;
  }

  protected static Logger LOG = LogManager.getLogger(MigrationManagerImpl.class);
  public void checkModelVersionsAreValid(SModule module, Map<SLanguage, Integer> langVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    for (SModel m : module.getModels()) {
      SModelInternal modelInternal = (SModelInternal) m;
      for (SLanguage lang : CollectionSequence.fromCollection(modelInternal.importedLanguageIds())) {
        int currentVersion = langVersions.get(lang);
        int modelVer = modelInternal.getLanguageImportVersion(lang);
        if (modelVer != -1) {
          if (modelVer != currentVersion) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Migration assistant detected inconsistecy in language versions. Module " + module + " uses language " + lang + " with version " + currentVersion + " while its model " + m.getName() + " uses this language with version " + modelVer);
            }
          }
        }
      }
    }
  }

  public List<ScriptApplied.ScriptAppliedReference> getModuleMigrationsToApply(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ScriptApplied.ScriptAppliedReference>() {
      public Iterable<ScriptApplied.ScriptAppliedReference> translate(SModule module) {
        return MigrationsUtil.getAllSteps(module);
      }
    }).toListSequence();
  }

  public List<ScriptApplied.ScriptAppliedReference> getMissingMigrations() {
    final Wrappers._T<List<ScriptApplied.ScriptAppliedReference>> result = new Wrappers._T<List<ScriptApplied.ScriptAppliedReference>>(ListSequence.fromList(new ArrayList<ScriptApplied.ScriptAppliedReference>()));
    myMpsMproject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result.value = ListSequence.fromList(getModuleMigrationsToApply(MigrationsUtil.getMigrateableModulesFromProject(myMpsMproject))).where(new IWhereFilter<ScriptApplied.ScriptAppliedReference>() {
          public boolean accept(ScriptApplied.ScriptAppliedReference it) {
            return it.resolve(myMigrationComponent, false) == null;
          }
        }).toListSequence();
      }
    });
    return result.value;
  }

  public int projectStepsCount(boolean isCleanup) {
    List<ProjectMigration> migrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    int cleanupSize = ListSequence.fromList(migrations).ofType(CleanupProjectMigration.class).count();
    return (isCleanup ? cleanupSize : ListSequence.fromList(migrations).count() - cleanupSize);
  }

  public MigrationManager.MigrationStep nextProjectStep(Map<ProjectMigrationWithOptions.Option, Object> options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(myMpsMproject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    final ProjectMigration cc = current;
    return new MigrationManager.MigrationStep() {
      public String getDescription() {
        return cc.getDescription();
      }
      public boolean execute() {
        try {
          myMpsMproject.getRepository().getModelAccess().executeCommand(new Runnable() {
            public void run() {
              cc.execute(myMpsMproject);
            }
          });
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }

      public void forceExecutionNextTime() {
        if (!((cc instanceof CleanupProjectMigration))) {
          throw new UnsupportedOperationException("only supported for cleanup project migrations");
        }
        ((CleanupProjectMigration) cc).forceExecutionNextTime(myMpsMproject);
      }
    };
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        // this is xor, which is absent in bl 
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      // was: cleanup, now: not cleanup 
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }

  public int moduleStepsCount() {
    final Wrappers._int result = new Wrappers._int();
    myMpsMproject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result.value = ListSequence.fromList(getModuleMigrationsToApply(MigrationsUtil.getMigrateableModulesFromProject(myMpsMproject))).count();
      }
    });
    return result.value;
  }

  public MigrationManager.MigrationStep nextModuleStep() {
    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);
    myMpsMproject.getRepository().getModelAccess().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<MigrationManager.MigrationStep>() {
      public MigrationManager.MigrationStep invoke() {
        return result.value = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject))).translate(new ITranslator2<SModule, ScriptApplied.ScriptAppliedReference>() {
          public Iterable<ScriptApplied.ScriptAppliedReference> translate(SModule module) {
            return MigrationsUtil.getAllSteps(module);
          }
        }).select(new ISelector<ScriptApplied.ScriptAppliedReference, ScriptApplied>() {
          public ScriptApplied select(ScriptApplied.ScriptAppliedReference it) {
            return it.resolve(myMigrationComponent, false);
          }
        }).where(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return it != null && Sequence.fromIterable(it.getDependencies()).where(new IWhereFilter<ScriptApplied.ScriptAppliedReference>() {
              public boolean accept(ScriptApplied.ScriptAppliedReference it) {
                return !(it.isAlreadyDone());
              }
            }).isEmpty();
          }
        }).select(new ISelector<ScriptApplied, MigrationManager.MigrationStep>() {
          public MigrationManager.MigrationStep select(final ScriptApplied it) {
            return new MigrationManager.MigrationStep() {
              public String getDescription() {
                return it.getDescription();
              }
              public boolean execute() {
                final Wrappers._boolean res = new Wrappers._boolean();
                myMpsMproject.getRepository().getModelAccess().executeCommand(new Runnable() {
                  public void run() {
                    res.value = it.execute(myMigrationComponent);
                  }
                });
                return res.value;
              }
              public void forceExecutionNextTime() {
                throw new UnsupportedOperationException("not supported for module migrations");
              }
            };
          }
        }).first();
      }
    }));
    return result.value;
  }

}
