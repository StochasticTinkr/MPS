package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.project.Project;
import jetbrains.mps.migration.global.ProjectMigration;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.ArrayList;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Map;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import org.apache.log4j.Level;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class MigrationManagerImpl extends AbstractProjectComponent implements MigrationManager {
  private Project myMpsMproject;
  private ProjectMigration lastProjectMigration = null;
  private MigrationComponent myMigrationComponent;

  public MigrationManagerImpl(com.intellij.openapi.project.Project project, Project mpsProject, MigrationComponent migrationComponent) {
    super(project);
    myMpsMproject = mpsProject;
    myMigrationComponent = migrationComponent;
  }

  public MigrationComponent getMigrationComponent() {
    return myMigrationComponent;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    myMpsMproject.getRepository().getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(myMpsMproject);
        result.value = isMigrationRequired(myMpsMproject, modules);
      }
    });
    return result.value;
  }

  public static boolean isMigrationRequired(final Project p, Iterable<SModule> modules) {
    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
    boolean projectMig = ListSequence.fromList(pMig).any(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(p);
      }
    });
    boolean moduleMig = isModuleMigrationRequired(modules);
    return projectMig || moduleMig;
  }

  public Iterable<ProjectMigration> getProjectMigrationsToApply() {
    List<ProjectMigration> allProjectMigrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    return ListSequence.fromList(allProjectMigrations).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(myMpsMproject);
      }
    }).toListSequence();
  }



  public List<ScriptApplied.ScriptAppliedReference> getModuleMigrationsToApply(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ScriptApplied.ScriptAppliedReference>() {
      public Iterable<ScriptApplied.ScriptAppliedReference> translate(SModule module) {
        return MigrationsUtil.getAllSteps(module);
      }
    }).toListSequence();
  }

  public List<ScriptApplied.ScriptAppliedReference> getMissingMigrations() {
    final Wrappers._T<List<ScriptApplied.ScriptAppliedReference>> result = new Wrappers._T<List<ScriptApplied.ScriptAppliedReference>>(ListSequence.fromList(new ArrayList<ScriptApplied.ScriptAppliedReference>()));
    myMpsMproject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result.value = ListSequence.fromList(getModuleMigrationsToApply(MigrationsUtil.getMigrateableModulesFromProject(myMpsMproject))).where(new IWhereFilter<ScriptApplied.ScriptAppliedReference>() {
          public boolean accept(ScriptApplied.ScriptAppliedReference it) {
            return it.resolve(myMigrationComponent, false) == null;
          }
        }).toListSequence();
      }
    });
    return result.value;
  }

  public static boolean isModuleMigrationRequired(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).any(new IWhereFilter<SModule>() {
      public boolean accept(SModule module) {
        return Sequence.fromIterable(MigrationsUtil.getAllSteps(module)).isNotEmpty();
      }
    });
  }

  public int projectStepsCount(boolean isCleanup) {
    List<ProjectMigration> migrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    int cleanupSize = ListSequence.fromList(migrations).ofType(CleanupProjectMigration.class).count();
    return (isCleanup ? cleanupSize : ListSequence.fromList(migrations).count() - cleanupSize);
  }

  protected static Logger LOG = LogManager.getLogger(MigrationManagerImpl.class);
  public MigrationManager.MigrationStep nextProjectStep(Map<ProjectMigrationWithOptions.Option, Object> options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(myMpsMproject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    final ProjectMigration cc = current;
    return new MigrationManager.MigrationStep() {
      public String getDescription() {
        return cc.getDescription();
      }
      @Override
      public String getCommonDescription() {
        return cc.getDescription();
      }
      @Override
      public String getMergeId() {
        return null;
      }
      public boolean execute() {
        try {
          cc.execute(myMpsMproject);
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }

      public void forceExecutionNextTime() {
        if (!((cc instanceof CleanupProjectMigration))) {
          throw new UnsupportedOperationException("only supported for cleanup project migrations");
        }
        ((CleanupProjectMigration) cc).forceExecutionNextTime(myMpsMproject);
      }
    };
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        // this is xor, which is absent in bl 
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      // was: cleanup, now: not cleanup 
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }

  public int moduleStepsCount() {
    final Wrappers._int result = new Wrappers._int();
    myMpsMproject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result.value = ListSequence.fromList(getModuleMigrationsToApply(MigrationsUtil.getMigrateableModulesFromProject(myMpsMproject))).count();
      }
    });
    return result.value;
  }

  public MigrationManager.MigrationStep nextModuleStep(@Nullable final String preferredId) {
    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);
    myMpsMproject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<ScriptApplied> toApply = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject))).translate(new ITranslator2<SModule, ScriptApplied.ScriptAppliedReference>() {
          public Iterable<ScriptApplied.ScriptAppliedReference> translate(SModule module) {
            return MigrationsUtil.getAllSteps(module);
          }
        }).select(new ISelector<ScriptApplied.ScriptAppliedReference, ScriptApplied>() {
          public ScriptApplied select(ScriptApplied.ScriptAppliedReference it) {
            return it.resolve(myMigrationComponent, false);
          }
        }).where(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return it != null && Sequence.fromIterable(it.getDependencies()).where(new IWhereFilter<ScriptApplied.ScriptAppliedReference>() {
              public boolean accept(ScriptApplied.ScriptAppliedReference it) {
                return !(it.isAlreadyDone());
              }
            }).isEmpty();
          }
        });

        // try find preferred, otherwise any 
        Iterable<ScriptApplied> preferred = (preferredId == null ? toApply : Sequence.fromIterable(toApply).where(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return preferredId == null || preferredId.equals(it.getId());
          }
        }));
        if (Sequence.fromIterable(preferred).isEmpty()) {
          preferred = toApply;
        }
        if (Sequence.fromIterable(preferred).isEmpty()) {
          return;
        }

        ScriptApplied applied = Sequence.fromIterable(preferred).first();
        result.value = new MigrationManager.MigrationStep() {
          public String getDescription() {
            return applied.getDescription() + ": " + applied.getModule().getModuleName();
          }
          @Override
          public String getCommonDescription() {
            return applied.getDescription();
          }
          @Override
          public String getMergeId() {
            return applied.getId();
          }
          public boolean execute() {
            return applied.execute(myMigrationComponent);
          }
          public void forceExecutionNextTime() {
            throw new UnsupportedOperationException("not supported for module migrations");
          }
        };
      }
    });
    return result.value;
  }

}
