package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.components.StoragePathMacros;
import com.intellij.openapi.components.AbstractProjectComponent;
import com.intellij.openapi.components.PersistentStateComponent;
import jetbrains.mps.ide.migration.wizard.MigrationErrorContainer;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.migration.global.ProjectMigrationProperties;
import jetbrains.mps.ide.migration.wizard.MigrationErrorDescriptor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.ide.MPSCoreComponents;
import java.util.concurrent.atomic.AtomicInteger;
import jetbrains.mps.RuntimeFlags;
import com.intellij.openapi.startup.StartupManager;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import com.intellij.openapi.vfs.VirtualFileManager;
import jetbrains.mps.ide.platform.watching.ReloadManager;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import com.intellij.openapi.project.ex.ProjectManagerEx;
import jetbrains.mps.ide.migration.wizard.MigrationErrorWizardStep;
import jetbrains.mps.ide.migration.check.MigrationOutputUtil;
import com.intellij.openapi.application.ModalityState;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.ide.GeneralSettings;
import jetbrains.mps.smodel.RepoListenerRegistrar;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.Language;
import java.util.List;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.module.SRepositoryContentAdapter;
import jetbrains.mps.classloading.MPSClassesListenerAdapter;
import jetbrains.mps.module.ReloadableModuleBase;
import org.jetbrains.annotations.Nullable;

/**
 * At the first startup, migration is not required
 * The need for migration is determined after startup by checking all modules once and then watching the repo
 * Whether some change requires migration to be executed, the user is notified about that and the project is reloaded
 * with myState.migrationRequired set to true.
 * In this case, the migration is executed and no watchers are added (as they could try to run the migration once again)
 * After the migration is completed, myState.migrationRequired is set to false again and the project is reloaded
 * 
 * Reasons to reload project after migration:
 * 1. The reload cycle with migration wizard happens w/o adding repo listeners
 * 2. Models should be unloaded after migration
 */
@State(name = "MigrationTrigger", storages = @Storage(value = StoragePathMacros.WORKSPACE_FILE)
, reloadable = true)
public class MigrationTrigger extends AbstractProjectComponent implements PersistentStateComponent<MigrationTrigger.MyState>, IStartupMigrationExecutor, MigrationErrorContainer {
  private final ClassLoaderManager myClassLoaderManager;

  private MPSProject myMpsProject;
  private final MigrationManager myMigrationManager;
  private MigrationTrigger.MyState myState = new MigrationTrigger.MyState();

  private boolean myMigrationQueued = false;

  private ProjectMigrationProperties myProperties;

  private MigrationTrigger.MyRepoListener myRepoListener = new MigrationTrigger.MyRepoListener();
  private MigrationTrigger.MyClassesListener myClassesListener = new MigrationTrigger.MyClassesListener();
  private MigrationTrigger.MyPropertiesListener myPropertiesListener = new MigrationTrigger.MyPropertiesListener();
  private boolean myListenersAdded = false;

  private MigrationErrorDescriptor myErrors = null;

  public MigrationTrigger(Project ideaProject, MPSProject p, MigrationManager migrationManager, ProjectMigrationProperties props) {
    super(ideaProject);
    myMpsProject = p;
    myMigrationManager = migrationManager;
    myProperties = props;
    myClassLoaderManager = ApplicationManager.getApplication().getComponent(MPSCoreComponents.class).getClassLoaderManager();
  }

  private final AtomicInteger myBlocked = new AtomicInteger(0);

  public void blockMigrationsCheck() {
    myBlocked.incrementAndGet();
  }

  public void unblockMigrationsCheck() {
    int locks = myBlocked.decrementAndGet();
    assert locks >= 0 : "Non-paired block-unblock method usage";
    if (locks == 0) {
      checkMigrationNeeded();
    }
  }

  public void projectOpened() {
    // this is a hack for migration task purposes 
    if (RuntimeFlags.getTestMode().isInsideTestEnvironment()) {
      return;
    }

    if (!(myState.migrationRequired)) {
      addListeners();
      checkMigrationNeeded();
    } else {
      saveAndSetTipsState();
      StartupManager.getInstance(myProject).registerPostStartupActivity(new Runnable() {
        public void run() {
          ApplicationManager.getApplication().runWriteAction(new Runnable() {
            public void run() {
              VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir());
              VirtualFileManager.getInstance().syncRefresh();
              ReloadManager.getInstance().flush();
            }
          });
          ApplicationManager.getApplication().invokeLater(new Runnable() {
            public void run() {
              myState.migrationRequired = false;

              myMpsProject.getRepository().getModelAccess().runWriteAction(new Runnable() {
                public void run() {
                  updateUsedLanguagesVersions(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject));
                }
              });

              final MigrationAssistantWizard wizard = new MigrationAssistantWizard(myProject, myMigrationManager, MigrationTrigger.this);
              // final reload is needed to cleanup memory (unload models) and do possible switches (e.g. to a new persistence) 
              boolean finished = wizard.showAndGet();
              restoreTipsState();
              if (!(finished)) {
                return;
              }

              if (myErrors == null) {
                ApplicationManager.getApplication().runWriteAction(new Runnable() {
                  public void run() {
                    ProjectManagerEx.getInstance().reloadProject(myProject);
                  }
                });
              } else {
                MigrationErrorWizardStep lastStep = as_feb5zp_a0a0a0k0a0a0a0b0a0a0a0b0a3a52(wizard.getCurrentStepObject(), MigrationErrorWizardStep.class);
                if (lastStep == null) {
                  return;
                }

                StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {
                  public void run() {
                    ApplicationManager.getApplication().invokeLater(new Runnable() {
                      public void run() {
                        myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
                          public void run() {
                            // FIXME is there real need to obtain model access? For project and problems??? 
                            MigrationOutputUtil.showProblems(myProject, myErrors.getProblems());
                          }
                        });
                      }
                    }, ModalityState.NON_MODAL);
                  }
                });
              }
            }
          });
        }
      });
    }
  }

  public static void updateUsedLanguagesVersions(Iterable<SModule> modules) {
    Sequence.fromIterable(modules).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        it.validateLanguageVersions();
        it.validateDependencyVersions();
      }
    });
  }

  public void projectClosed() {
    removeListeners();
  }

  private void saveAndSetTipsState() {
    if (myState.tips == null) {
      myState.tips = GeneralSettings.getInstance().isShowTipsOnStartup();
    }
    GeneralSettings.getInstance().setShowTipsOnStartup(false);
  }

  private void restoreTipsState() {
    if (myState.tips == null) {
      return;
    }
    GeneralSettings.getInstance().setShowTipsOnStartup(myState.tips);
    myState.tips = null;
  }

  private void addListeners() {
    myListenersAdded = true;
    new RepoListenerRegistrar(myMpsProject.getRepository(), myRepoListener).attach();
    myClassLoaderManager.addClassesHandler(this.myClassesListener);
    myProperties.addListener(myPropertiesListener);
  }

  private boolean removeListeners() {
    if (!(myListenersAdded)) {
      return true;
    }
    myProperties.removeListener(myPropertiesListener);
    myClassLoaderManager.removeClassesHandler(myClassesListener);
    new RepoListenerRegistrar(myMpsProject.getRepository(), myRepoListener).detach();
    return false;
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "MigrationTrigger";
  }

  public synchronized void resetMigrationQueuedFlag() {
    myMigrationQueued = false;
  }

  /*package*/ void checkMigrationNeeded() {
    myMpsProject.getRepository().getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        postponeMigrationIfNeededOnModuleChange(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject));
      }
    });
  }

  private synchronized void postponeMigrationIfNeededOnModuleChange(Iterable<SModule> modules) {
    if (myMigrationQueued) {
      return;
    }

    // this is because of validateLanguageVersions, to fail ASAP 
    myMpsProject.getModelAccess().checkWriteAccess();

    updateUsedLanguagesVersions(modules);
    Set<SModule> modules2Check = SetSequence.fromSetWithValues(new HashSet<SModule>(), modules);
    if (!(MigrationManagerImpl.isMigrationRequired(myMpsProject, modules2Check))) {
      return;
    }

    postponeMigration();
  }

  private synchronized void postponeMigrationIfNeededOnLanguageReload(Iterable<Language> languages) {
    if (myMigrationQueued) {
      return;
    }

    // this is because of validateLanguageVersions, to fail ASAP 
    myMpsProject.getModelAccess().checkWriteAccess();

    // if a new language is added to a repo, all modules in project using it  
    // should be checked for whether their migration is needed  
    final Set<SModule> modules2Check = SetSequence.fromSet(new HashSet<SModule>());
    final List<SLanguage> addedLanguages = Sequence.fromIterable(languages).select(new ISelector<Language, SLanguage>() {
      public SLanguage select(Language it) {
        return MetaAdapterFactory.getLanguage(it.getModuleReference());
      }
    }).toListSequence();
    Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        Set<SLanguage> used = new HashSet<SLanguage>(it.getUsedLanguages());
        used.retainAll(addedLanguages);
        if (!(used.isEmpty())) {
          SetSequence.fromSet(modules2Check).addElement(it);
        }
      }
    });
    updateUsedLanguagesVersions(modules2Check);
    if (!(MigrationManagerImpl.isModuleMigrationRequired(modules2Check))) {
      return;
    }

    postponeMigration();
  }

  public synchronized void postponeMigration() {
    if (myBlocked.get() != 0) {
      return;
    }

    final Project ideaProject = myProject;
    final Iterable<SModule> allModules = MigrationsUtil.getMigrateableModulesFromProject(myMpsProject);
    saveAndSetTipsState();

    // wait until project is fully loaded (if not yet) 
    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {
      public void run() {
        // as we use ui, postpone to EDT 
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            myMpsProject.getRepository().getModelAccess().runWriteAction(new Runnable() {
              public void run() {
                updateUsedLanguagesVersions(allModules);
              }
            });
            boolean migrate = MigrationDialogUtil.showMigrationConfirmation(myMpsProject, allModules, myMigrationManager);
            restoreTipsState();

            // set flag to execute migration after startup 
            // NOTE we need to set it here as in invokeLater it can  
            // be executed when save session already passed, see MPS-22045 
            myState.migrationRequired = migrate;

            if (!(migrate)) {
              return;
            }

            VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir());
            VirtualFileManager.getInstance().asyncRefresh(new Runnable() {
              public void run() {
                ApplicationManager.getApplication().invokeLater(new Runnable() {
                  public void run() {
                    ReloadManager.getInstance().flush();
                    // reload project and start migration assist 
                    ProjectManagerEx.getInstance().reloadProject(ideaProject);
                  }
                });
              }
            });
          }
        });
      }
    });

    myMigrationQueued = true;
  }

  private class MyRepoListener extends SRepositoryContentAdapter {
    public MyRepoListener() {
    }
    @Override
    public void moduleAdded(@NotNull SModule module) {
      super.moduleAdded(module);
      if (!(myMpsProject.isProjectModule(module))) {
        return;
      }
      if (!(MigrationsUtil.isModuleMigrateable(module))) {
        return;
      }
      postponeMigrationIfNeededOnModuleChange(Sequence.<SModule>singleton(module));
    }

    @Override
    public void moduleChanged(SModule module) {
      super.moduleChanged(module);
      if (!(myMpsProject.isProjectModule(module))) {
        return;
      }
      if (!(MigrationsUtil.isModuleMigrateable(module))) {
        return;
      }
      postponeMigrationIfNeededOnModuleChange(Sequence.<SModule>singleton(module));
    }
  }

  private class MyClassesListener extends MPSClassesListenerAdapter {
    public MyClassesListener() {
    }
    @Override
    public void afterClassesLoaded(Set<? extends ReloadableModuleBase> modules) {
      postponeMigrationIfNeededOnLanguageReload(SetSequence.fromSet(modules).ofType(Language.class));
    }
  }

  private class MyPropertiesListener implements ProjectMigrationProperties.MigrationPropertiesReloadListener {
    @Override
    public void onReload() {
      checkMigrationNeeded();
    }
  }

  public MigrationErrorDescriptor getErrorDescriptor() {
    return myErrors;
  }

  public void setErrorDescriptor(MigrationErrorDescriptor errors) {
    myErrors = errors;
  }

  @Nullable
  @Override
  public MigrationTrigger.MyState getState() {
    return myState;
  }

  @Override
  public void loadState(MigrationTrigger.MyState state) {
    myState = state;
  }

  public static class MyState {
    public boolean migrationRequired = false;
    public Boolean tips;
  }
  private static <T> T as_feb5zp_a0a0a0k0a0a0a0b0a0a0a0b0a3a52(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
