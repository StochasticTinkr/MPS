package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.components.StoragePathMacros;
import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.migration.global.MigrationOptions;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.ide.platform.watching.ReloadManager;
import jetbrains.mps.migration.global.ProjectMigrationProperties;
import com.intellij.openapi.project.Project;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.ide.platform.watching.ReloadManagerComponent;
import java.util.concurrent.atomic.AtomicInteger;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.smodel.RepoListenerRegistrar;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.migration.runtime.base.MigrationModuleUtil;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.smodel.Language;
import java.util.List;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.openapi.startup.StartupManager;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.progress.ProgressIndicator;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.util.WaitForProgressToShow;
import jetbrains.mps.ide.migration.wizard.MigrationWizard;
import jetbrains.mps.ide.migration.wizard.MigrationError;
import com.intellij.openapi.project.ex.ProjectManagerEx;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import jetbrains.mps.ide.migration.check.MigrationOutputUtil;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.application.Application;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.ide.platform.watching.ReloadListener;
import org.jetbrains.mps.openapi.module.SRepositoryContentAdapter;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.event.SModelEventVisitor;
import jetbrains.mps.smodel.event.SModelEventVisitorAdapter;
import jetbrains.mps.smodel.event.SModelLanguageEvent;
import jetbrains.mps.smodel.event.SModelDevKitEvent;
import jetbrains.mps.smodel.ModelsEventsCollector;
import jetbrains.mps.smodel.event.SModelEvent;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.classloading.MPSClassesListenerAdapter;
import jetbrains.mps.module.ReloadableModuleBase;
import jetbrains.mps.ide.migration.wizard.MigrationSession;

/**
 * At the first startup, migration is not required
 * The need for migration is determined after startup by checking all modules once and then watching the repo
 * Whether some change requires migration to be executed, the user is notified about that and the project is reloaded
 * with myState.migrationRequired set to true.
 * In this case, the migration is executed and no watchers are added (as they could try to run the migration once again)
 * After the migration is completed, myState.migrationRequired is set to false again and the project is reloaded
 * 
 * Reasons to reload project after migration:
 * 1. The reload cycle with migration wizard happens w/o adding repo listeners
 * 2. Models should be unloaded after migration
 */
@State(name = "MigrationTrigger", storages = @Storage(value = StoragePathMacros.WORKSPACE_FILE)
)
public class MigrationTrigger extends AbstractProjectComponent implements IStartupMigrationExecutor {
  private final ClassLoaderManager myClassLoaderManager;
  private MigrationOptions myOptions = new MigrationOptions();

  private final MPSProject myMpsProject;
  private final MigrationRegistry myMigrationManager;
  private final ReloadManager myReloadManager;

  private boolean myMigrationQueued = false;

  private ProjectMigrationProperties myProperties;

  private MigrationTrigger.MyRepoListener myRepoListener = new MigrationTrigger.MyRepoListener();
  private MigrationTrigger.MyReloadListener myReloadListener = new MigrationTrigger.MyReloadListener();
  private MigrationTrigger.MyClassesListener myClassesListener = new MigrationTrigger.MyClassesListener();
  private MigrationTrigger.MyPropertiesListener myPropertiesListener = new MigrationTrigger.MyPropertiesListener();
  private boolean myListenersAdded = false;

  public MigrationTrigger(Project ideaProject, MPSProject p, MigrationRegistry migrationManager, ProjectMigrationProperties props, MPSCoreComponents mpsCore, ReloadManagerComponent reloadManager) {
    super(ideaProject);
    myMpsProject = p;
    myMigrationManager = migrationManager;
    myProperties = props;
    myClassLoaderManager = mpsCore.getClassLoaderManager();
    myReloadManager = reloadManager;
  }

  private final AtomicInteger myBlocked = new AtomicInteger(0);

  public void blockMigrationsCheck() {
    myBlocked.incrementAndGet();
  }

  public void unblockMigrationsCheck() {
    int locks = myBlocked.decrementAndGet();
    assert locks >= 0 : "Non-paired block-unblock method usage";
    if (locks == 0) {
      checkMigrationNeeded();
    }
  }

  public void projectOpened() {
    // this is a hack for migration task purposes 
    if (RuntimeFlags.getTestMode().isInsideTestEnvironment()) {
      return;
    }

    addListeners();
    checkMigrationNeeded();
  }

  public void projectClosed() {
    removeListeners();
  }

  private void addListeners() {
    myListenersAdded = true;
    new RepoListenerRegistrar(myMpsProject.getRepository(), myRepoListener).attach();
    myClassLoaderManager.addClassesHandler(this.myClassesListener);
    myProperties.addListener(myPropertiesListener);
    myReloadManager.addReloadListener(myReloadListener);
  }

  private boolean removeListeners() {
    if (!(myListenersAdded)) {
      return true;
    }
    myProperties.removeListener(myPropertiesListener);
    myClassLoaderManager.removeClassesHandler(myClassesListener);
    new RepoListenerRegistrar(myMpsProject.getRepository(), myRepoListener).detach();
    myReloadManager.removeReloadListener(myReloadListener);
    return false;
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "MigrationTrigger";
  }

  public synchronized void resetMigrationQueuedFlag() {
    myMigrationQueued = false;
  }

  /*package*/ void checkMigrationNeeded() {
    myMpsProject.getRepository().getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        checkMigrationNeededOnModuleChange(MigrationModuleUtil.getMigrateableModulesFromProject(myMpsProject));
      }
    });
  }

  private synchronized void checkMigrationNeededOnModuleChange(Iterable<SModule> modules) {
    if (myMigrationQueued) {
      return;
    }
    Set<SModule> modules2Check = SetSequence.fromSetWithValues(new HashSet<SModule>(), modules);
    if (!((myMigrationManager.importVersionsUpdateRequired(modules2Check) || CollectionSequence.fromCollection(myMigrationManager.getModuleMigrations(modules2Check)).isNotEmpty())) || CollectionSequence.fromCollection(myMigrationManager.getProjectMigrations()).isNotEmpty()) {
      return;
    }

    postponeMigration();
  }

  private synchronized void checkMigrationNeededOnLanguageReload(Iterable<Language> languages) {
    if (myMigrationQueued) {
      return;
    }

    // if a new language is added to a repo, all modules in project using it  
    // should be checked for whether their migration is needed  
    final Set<SModule> modules2Check = SetSequence.fromSet(new HashSet<SModule>());
    final List<SLanguage> addedLanguages = Sequence.fromIterable(languages).select(new ISelector<Language, SLanguage>() {
      public SLanguage select(Language it) {
        return MetaAdapterFactory.getLanguage(it.getModuleReference());
      }
    }).toListSequence();
    Sequence.fromIterable(MigrationModuleUtil.getMigrateableModulesFromProject(myMpsProject)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        Set<SLanguage> used = new HashSet<SLanguage>(it.getUsedLanguages());
        used.retainAll(addedLanguages);
        if (!(used.isEmpty())) {
          SetSequence.fromSet(modules2Check).addElement(it);
        }
      }
    });
    if (myMigrationManager.importVersionsUpdateRequired(modules2Check) || CollectionSequence.fromCollection(myMigrationManager.getModuleMigrations(modules2Check)).isNotEmpty()) {
      postponeMigration();
    }
  }

  public synchronized void postponeMigration() {
    if (myBlocked.get() != 0) {
      return;
    }

    final Project ideaProject = myProject;
    myMigrationQueued = true;

    // wait until project is fully loaded (if not yet) 
    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {
      public void run() {
        // as we use ui, postpone to EDT 
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            final Wrappers._boolean importVersionsUpdateRequired = new Wrappers._boolean();
            final Wrappers._boolean migrationRequired = new Wrappers._boolean();

            myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
              public void run() {
                importVersionsUpdateRequired.value = myMigrationManager.importVersionsUpdateRequired(MigrationModuleUtil.getMigrateableModulesFromProject(myMpsProject));
                migrationRequired.value = myMigrationManager.isMigrationRequired();
              }
            });

            boolean resave;
            boolean migrate;
            if (migrationRequired.value) {
              migrate = MigrationDialogUtil.showMigrationConfirmation(myMpsProject, myMigrationManager);
              resave = importVersionsUpdateRequired.value && migrate;
            } else {
              migrate = false;
              resave = MigrationDialogUtil.showResaveConfirmation(myMpsProject);
            }

            if (resave || migrate) {
              ProgressManager.getInstance().run(new Task.Modal(ideaProject, "Synchronizing Files...", false) {
                public void run(@NotNull ProgressIndicator pi) {
                  pi.setIndeterminate(true);
                  myReloadManager.flush();
                  syncRefresh();
                }
              });
            }

            if (resave) {
              ProgressManager.getInstance().run(new Task.Modal(ideaProject, "Resaving Module Descriptors", false) {
                public void run(@NotNull ProgressIndicator pi) {
                  ProgressMonitor pm = new ProgressMonitorAdapter(pi);
                  final Wrappers._T<List<SModule>> allModules = new Wrappers._T<List<SModule>>();
                  myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
                    public void run() {
                      allModules.value = Sequence.fromIterable(MigrationModuleUtil.getMigrateableModulesFromProject(myMpsProject)).toListSequence();
                    }
                  });
                  pm.start("Saving...", ListSequence.fromList(allModules.value).count());
                  for (final SModule module : ListSequence.fromList(allModules.value)) {
                    pm.advance(1);
                    WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {
                      public void run() {
                        myMpsProject.getRepository().getModelAccess().runWriteAction(new Runnable() {
                          public void run() {
                            myMigrationManager.doUpdateImportVersions(module);
                          }
                        });
                      }
                    });
                  }
                }
              });
            }

            if (migrate) {
              startMigration();
            } else if (resave) {
              resetMigrationQueuedFlag();
            }
          }
        });
      }
    });
  }

  private boolean startMigration() {
    MigrationTrigger.MyMigrationSession session = new MigrationTrigger.MyMigrationSession();
    final MigrationWizard wizard = new MigrationWizard(myProject, session);
    // final reload is needed to cleanup memory (unload models) and do possible switches (e.g. to a new persistence) 
    boolean finished = wizard.showAndGet();
    final MigrationError errors = session.getError();
    if (!(finished) && errors == null) {
      return true;
    }

    if (errors == null) {
      ApplicationManager.getApplication().runWriteAction(new Runnable() {
        public void run() {
          ProjectManagerEx.getInstance().reloadProject(myProject);
        }
      });
    } else {
      StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {
        public void run() {
          final Wrappers._T<List<Problem>> problems = new Wrappers._T<List<Problem>>();
          ProgressManager.getInstance().run(new Task.Modal(myProject, "Collecting Errors", false) {
            public void run(@NotNull final ProgressIndicator progressIndicator) {
              myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
                public void run() {
                  problems.value = Sequence.fromIterable(errors.getProblems(progressIndicator)).toListSequence();
                }
              });
            }
          });
          ApplicationManager.getApplication().invokeLater(new Runnable() {
            public void run() {
              myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
                public void run() {
                  MigrationOutputUtil.showProblems(myProject, problems.value);
                }
              });
            }
          }, ModalityState.NON_MODAL);
        }
      });
    }
    return false;
  }

  private void syncRefresh() {
    final Application application = ApplicationManager.getApplication();
    WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {
      public void run() {
        application.saveAll();
      }
    });
    VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir(), new EmptyProgressMonitor());
    WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {
      public void run() {
        myReloadManager.flush();
      }
    });
  }

  private class MyReloadListener implements ReloadListener {
    private boolean myUnderReload = false;
    @Override
    public void reloadStarted() {
      myUnderReload = true;
    }
    @Override
    public void reloadFinished() {
      myUnderReload = false;
    }
    public boolean isIsUnderReload() {
      return myUnderReload;
    }
  }

  private boolean isProjectMigrateableModule(@NotNull SModule module) {
    return myMpsProject.getProjectModulesWithGenerators().contains(module) && MigrationModuleUtil.isModuleMigrateable(module);
  }

  private class MyRepoListener extends SRepositoryContentAdapter {
    private class ModuleBatchUpdater implements Runnable {
      public Set<SModule> modulesTouched = SetSequence.fromSet(new HashSet<SModule>());
      private boolean touchedUnderReload = false;
      public void run() {
        myTask = null;
        List<SModule> toUpdate = SetSequence.fromSet(modulesTouched).distinct().where(new IWhereFilter<SModule>() {
          public boolean accept(SModule it) {
            return isProjectMigrateableModule(it);
          }
        }).toListSequence();
        if (!(touchedUnderReload)) {
          for (SModule m : ListSequence.fromList(toUpdate)) {
            updateSingleModuleDescriptorSilently(m);
          }
        }
        checkMigrationNeededOnModuleChange(toUpdate);
      }
    }
    private MigrationTrigger.MyRepoListener.ModuleBatchUpdater myTask = null;

    private void updateSingleModuleDescriptorSilently(SModule module) {
      if (!(isProjectMigrateableModule(module))) {
        return;
      }
      myMigrationManager.doUpdateImportVersions(module);
    }
    private void triggerOnModuleChanged(SModule module) {
      if (myTask == null) {
        myTask = new MigrationTrigger.MyRepoListener.ModuleBatchUpdater();
        myMpsProject.getModelAccess().executeCommandInEDT(myTask);
      }
      SetSequence.fromSet(myTask.modulesTouched).addElement(module);
      if (myReloadListener.isIsUnderReload()) {
        myTask.touchedUnderReload = true;
      }
    }
    private SModelEventVisitor myVisitor = new SModelEventVisitorAdapter() {
      @Override
      public void visitLanguageEvent(SModelLanguageEvent event) {
        updateSingleModuleDescriptorSilently(event.getModel().getModule());
      }
      @Override
      public void visitDevKitEvent(SModelDevKitEvent event) {
        updateSingleModuleDescriptorSilently(event.getModel().getModule());
      }
    };
    private ModelsEventsCollector myModelListener = new ModelsEventsCollector() {
      @Override
      protected void eventsHappened(List<SModelEvent> events) {
        ListSequence.fromList(events).visitAll(new IVisitor<SModelEvent>() {
          public void visit(SModelEvent it) {
            it.accept(myVisitor);
          }
        });
      }
    };
    @Override
    public void moduleAdded(@NotNull SModule module) {
      super.moduleAdded(module);
      if (isProjectMigrateableModule(module)) {
        triggerOnModuleChanged(module);
      }
    }

    @Override
    public void moduleChanged(@NotNull SModule module) {
      super.moduleChanged(module);
      if (isProjectMigrateableModule(module)) {
        triggerOnModuleChanged(module);
      }
    }
    @Override
    protected void startListening(SModel model) {
      super.startListening(model);
      if (isProjectMigrateableModule(model.getModule())) {
        myModelListener.startListeningToModel(model);
      }
    }
    @Override
    protected void stopListening(SModel model) {
      super.stopListening(model);
      if (isProjectMigrateableModule(model.getModule())) {
        myModelListener.stopListeningToModel(model);
      }
    }
  }

  private class MyClassesListener extends MPSClassesListenerAdapter {
    @Override
    public void afterClassesLoaded(Set<? extends ReloadableModuleBase> modules) {
      // do not hold set of modules from notification, make a local copy 
      final List<Language> list = SetSequence.fromSet(modules).ofType(Language.class).toListSequence();
      if (ListSequence.fromList(list).isEmpty()) {
        return;
      }
      myMpsProject.getModelAccess().runWriteInEDT(new Runnable() {
        public void run() {
          checkMigrationNeededOnLanguageReload(list);
        }
      });
    }
  }

  private class MyPropertiesListener implements ProjectMigrationProperties.MigrationPropertiesReloadListener {
    @Override
    public void onReload() {
      checkMigrationNeeded();
    }
  }

  private class MyMigrationSession extends MigrationSession.MigrationSessionBase {
    private MigrationCheckerImpl myChecker;
    private MigrationExecutorImpl myExecutor;
    public MyMigrationSession() {
      this.myChecker = new MigrationCheckerImpl(myMpsProject, getMigrationRegistry());
      this.myExecutor = new MigrationExecutorImpl(myMpsProject);
    }
    @Override
    public jetbrains.mps.project.Project getProject() {
      return myMpsProject;
    }
    @Override
    public MigrationRegistry getMigrationRegistry() {
      return myMigrationManager;
    }
    @Override
    public MigrationOptions getOptions() {
      return myOptions;
    }
    @Override
    public MigrationChecker getChecker() {
      return this.myChecker;
    }
    @Override
    public MigrationExecutor getExecutor() {
      return this.myExecutor;
    }
  }
}
