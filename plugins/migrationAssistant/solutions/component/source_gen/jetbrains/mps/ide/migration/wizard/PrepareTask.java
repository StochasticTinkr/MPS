package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import jetbrains.mps.progress.ProgressMonitorAdapter;
import java.util.List;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.ide.migration.MigrationManager;
import java.util.HashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.ide.migration.check.MigrationCheckUtil;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;

public class PrepareTask extends StepTask {
  public PrepareTask(MigrationSession session) {
    super(session, "PreCheck");
  }

  protected void doRun(ProgressMonitorAdapter progress) {
    progress.start("Checking...", 100);

    if (!((runCleanupMigrations(progress.subTask(20))))) {
      result(progress, new MigrationExceptionError(), "Error while running cleanup migration.");
      return;
    }

    List<ScriptApplied.ScriptAppliedReference> missingMigrations = findMissingMigrations(progress.subTask(10));
    if (ListSequence.fromList(missingMigrations).isNotEmpty()) {
      result(progress, new MigrationsMissingError(missingMigrations), "Some migrations are missing.");
      return;
    }

    Map<SModule, SModule> errsToShow = checkMigratedLibs(progress.subTask(10));
    if (MapSequence.fromMap(errsToShow).isNotEmpty()) {
      result(progress, new NotMigratedLibsError(errsToShow), "Some dependent modules are not migrated.");
      return;
    }

    // null - no error, true - must stop, false - can ignore 
    Boolean mustStop = checkModels(progress.subTask(60));
    if (mustStop != null) {
      result(progress, new PreCheckError(mySession.getProject(), mustStop), "Errors were found in models");
      return;
    }

    result(progress, null, "Done! Ready to migrate");
  }

  private boolean runCleanupMigrations(ProgressMonitor m) {
    int cleanupStepsCount = mySession.getMigrationManager().projectStepsCount(true);
    m.start("Cleaning...", cleanupStepsCount);
    boolean success = true;
    if (cleanupStepsCount != 0) {
      LongBaseStep.addGlobalLabel(mySession.getProject(), "Cleanup started");

      while (true) {
        MigrationManager.MigrationStep step = mySession.getMigrationManager().nextProjectStep(mySession.getOptions(), true);
        if (step == null) {
          break;
        }

        m.step(((MigrationManager.MigrationStep) step).getDescription());
        if (!(executeSingleStep(step, null))) {
          success = false;
          step.forceExecutionNextTime();
          break;
        }

        m.advance(1);
      }

      LongBaseStep.addGlobalLabel(mySession.getProject(), "Cleanup finished");
    }
    m.done();
    return success;
  }

  private List<ScriptApplied.ScriptAppliedReference> findMissingMigrations(ProgressMonitor m) {
    m.start("Checking migrations consistency...", 1);
    try {
      return mySession.getMigrationManager().getMissingMigrations();
    } finally {
      m.done();
    }
  }

  private Map<SModule, SModule> checkMigratedLibs(ProgressMonitor m) {
    m.start("Checking dependencies...", 1);
    final Map<SModule, SModule> errsToShow = MapSequence.fromMap(new HashMap<SModule, SModule>());
    final Project mpsProject = mySession.getProject();
    mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        final List<SModule> projectModules = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).toListSequence();
        Set<SModule> depModules = SetSequence.fromSetWithValues(new HashSet<SModule>(), new GlobalModuleDependenciesManager(projectModules).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE));
        SetSequence.fromSet(depModules).removeSequence(Sequence.fromIterable(((Iterable<SModule>) mpsProject.getModulesWithGenerators())));
        List<ScriptApplied.ScriptAppliedReference> depMigrationsToRun = mySession.getMigrationManager().getModuleMigrationsToApply(depModules);
        Iterable<SModule> notMigratedModules = ListSequence.fromList(depMigrationsToRun).select(new ISelector<ScriptApplied.ScriptAppliedReference, SModule>() {
          public SModule select(ScriptApplied.ScriptAppliedReference it) {
            return it.getModule();
          }
        }).distinct();
        Sequence.fromIterable(notMigratedModules).visitAll(new IVisitor<SModule>() {
          public void visit(final SModule notMigrated) {
            MapSequence.fromMap(errsToShow).put(notMigrated, ListSequence.fromList(projectModules).findFirst(new IWhereFilter<SModule>() {
              public boolean accept(SModule depCandidate) {
                return new GlobalModuleDependenciesManager(depCandidate).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE).contains(notMigrated);
              }
            }));
          }
        });
      }
    });
    m.done();
    return errsToShow;
  }

  private Boolean checkModels(final ProgressMonitor m) {
    final Wrappers._T<Boolean> mustStop = new Wrappers._T<Boolean>(null);
    final Project mpsProject = mySession.getProject();
    mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        List<SModule> modules = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).toListSequence();
        int count = ListSequence.fromList(modules).count();
        m.start("Checking models...", count);
        mustStop.value = MigrationCheckUtil.haveProblems(modules, StepTask.frac2inc(count, new _FunctionTypes._void_P1_E0<Integer>() {
          public void invoke(Integer processed) {
            m.advance(processed);
          }
        }));
        m.done();
      }
    });
    return mustStop.value;
  }


}
