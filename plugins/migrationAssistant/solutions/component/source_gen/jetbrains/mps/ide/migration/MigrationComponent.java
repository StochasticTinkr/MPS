package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.migration.component.util.MigrationDataUtil;
import jetbrains.mps.lang.migration.runtime.base.MigrationAspectDescriptor;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.language.LanguageRegistry;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.apache.log4j.Level;
import jetbrains.mps.lang.migration.runtime.base.RefactoringPart;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import java.util.List;
import jetbrains.mps.refactoring.participant.RefactoringSession;
import jetbrains.mps.ide.platform.actions.core.RefactoringProcessor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.ide.findusages.model.scopes.ModulesScope;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchTask;
import jetbrains.mps.lang.migration.runtime.base.RefactoringLog;
import jetbrains.mps.lang.migration.runtime.base.RefactoringLogReference;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModuleOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.lang.migration.runtime.base.MigrationModuleUtil;
import jetbrains.mps.refactoring.participant.RefactoringSessionImpl;

public class MigrationComponent extends AbstractProjectComponent {
  private Project myMpsProject;
  private SModule dataModule;
  private TempModuleOptions dataModuleOptions;

  private DataCollector myDataCollector = new DataCollector() {
    public Map<SModule, SNode> collectData(SModule myModule, final MigrationScriptReference scriptReference) {
      final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
      SetSequence.fromSet(MigrationsUtil.getModuleDependencies(myModule)).visitAll(new IVisitor<SModule>() {
        public void visit(SModule it) {
          SNode dataString = MigrationDataUtil.readData(it, scriptReference);
          if (dataString != null) {
            MapSequence.fromMap(requiredData).put(it, dataString);
          }
        }
      });
      return requiredData;
    }
  };

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.myMpsProject = mpsProject;
  }

  @Override
  public void initComponent() {
    myMpsProject.getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        dataModuleOptions = TempModuleOptions.forDefaultModule();
        dataModule = dataModuleOptions.createModule();
      }
    });
  }

  @Override
  public void disposeComponent() {
    myMpsProject.getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        dataModuleOptions.disposeModule();
      }
    });
  }

  private MigrationAspectDescriptor getMigrationDescriptor(Language module) {
    return LanguageRegistry.getInstance(module.getRepository()).getLanguage(module).getAspect(MigrationAspectDescriptor.class);
  }
  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);
  public MigrationScript fetchMigrationScript(MigrationScriptReference scriptReference, boolean silently) {
    SLanguage depLanguage = scriptReference.getLanguage();
    int current = scriptReference.getFromVersion();
    MigrationAspectDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());
    if (md == null && !(silently)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration descriptor for language " + depLanguage + ".");
      }
    }
    MigrationScript script = check_gd1mrb_a0e0n(md, current);
    if (script == null && !(silently)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration script for language " + depLanguage + ", version " + current + ".");
      }
      return null;
    }
    return script;
  }

  public class RefactoringPartImpl implements RefactoringPart {
    private RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?> myParticipant;
    private List<SNode> myParts;
    private SNode mySelectedOptionsSerialized;
    public RefactoringPartImpl(SNode selectedOptionsSerialized, List<SNode> parts, RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?> participant) {
      myParticipant = participant;
      mySelectedOptionsSerialized = selectedOptionsSerialized;
      myParts = parts;
    }
    public void execute(SModule module, RefactoringSession refactoringSession) {
      performDeserializingRefactoring(module, myParticipant, refactoringSession);
    }
    public <IP, FP> void performDeserializingRefactoring(final SModule module, RefactoringParticipant.PersistentRefactoringParticipant<?, ?, IP, FP> participant, RefactoringSession refactoringSession) {

      RefactoringProcessor.RefactoringUI ui = new MigrationComponent.MigrationRefactoringUI((mySelectedOptionsSerialized == null ? null : ListSequence.fromList(SLinkOperations.getChildren(mySelectedOptionsSerialized, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x31ee543051f23340L, 0x31ee543051f23346L, "options"))).select(new ISelector<SNode, RefactoringParticipant.Option>() {
        public RefactoringParticipant.Option select(SNode it) {
          return new RefactoringParticipant.Option(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x31ee543051f23343L, 0x31ee543051f23344L, "optionId")), SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x31ee543051f23343L, 0x31ee543051f30774L, "description")));
        }
      }).toListSequence()));

      final Map<SNode, SNode> initialToFinal = MapSequence.fromMap(new HashMap<SNode, SNode>());
      for (SNode part : ListSequence.fromList(myParts)) {
        MapSequence.fromMap(initialToFinal).put(SLinkOperations.getTarget(part, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x2b3f57492c163158L, 0x325b97b223b9e3acL, "initialState")), SLinkOperations.getTarget(part, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x2b3f57492c163158L, 0x325b97b223b9e3aeL, "finalState")));
      }
      _FunctionTypes._return_P1_E0<? extends Map<SNode, SNode>, ? super Iterable<RefactoringParticipant.ParticipantApplied<?, ?, IP, FP, SNode, SNode>>> doRefactorFunction = new _FunctionTypes._return_P1_E0<Map<SNode, SNode>, Iterable<RefactoringParticipant.ParticipantApplied<?, ?, IP, FP, SNode, SNode>>>() {
        public Map<SNode, SNode> invoke(Iterable<RefactoringParticipant.ParticipantApplied<?, ?, IP, FP, SNode, SNode>> changes) {
          return initialToFinal;
        }
      };

      RefactoringProcessor.<IP,FP,SNode,SNode>performRefactoring(new RefactoringParticipant.DeserializingParticipantStateFactory<IP, FP>(), ui, refactoringSession, module.getRepository(), new ModulesScope(module), null, ((Iterable<? extends RefactoringParticipant<?, ?, IP, FP>>) Sequence.<RefactoringParticipant<?, ?, IP, FP>>singleton(participant)), Sequence.fromIterable(SLinkOperations.collect(myParts, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x2b3f57492c163158L, 0x325b97b223b9e3acL, "initialState"))).toListSequence(), doRefactorFunction, null);
    }
  }

  private static class RefactoringSessionTaskQueue {
    private static final String myId = "refactoringSession.migrationAssistant.taskQueue";
    private List<Runnable> myTasks = ListSequence.fromList(new ArrayList<Runnable>());
    public static MigrationComponent.RefactoringSessionTaskQueue getInstance(RefactoringSession session) {
      MigrationComponent.RefactoringSessionTaskQueue result = ((MigrationComponent.RefactoringSessionTaskQueue) session.getObject(myId));
      if (result == null) {
        result = new MigrationComponent.RefactoringSessionTaskQueue();
        session.putObject(myId, result);
      }
      return result;
    }
    public void putTask(Runnable task) {
      ListSequence.fromList(myTasks).addElement(task);
    }
    public void runAll() {
      for (Runnable task : ListSequence.fromList(myTasks)) {
        task.run();
      }
    }
  }

  private static class MigrationRefactoringUI implements RefactoringProcessor.RefactoringUI {
    private List<RefactoringParticipant.Option> mySelectedOptions;
    private MigrationRefactoringUI(List<RefactoringParticipant.Option> selectedOptions) {
      mySelectedOptions = selectedOptions;
    }
    public void prepare(Runnable task) {
      task.run();
    }
    public void runSearch(final _FunctionTypes._void_P1_E0<? super ProgressMonitor> task) {
      task.invoke(new EmptyProgressMonitor());
    }
    public List<RefactoringParticipant.Option> selectParticipants(List<RefactoringParticipant.Option> availableOptions) {
      return (mySelectedOptions == null ? availableOptions : mySelectedOptions);
    }
    public void showRefactoringView(final Runnable task, String refactoringName, SearchResults searchResults, SearchTask searchTask, RefactoringSession refactoringSession) {
      MigrationComponent.RefactoringSessionTaskQueue.getInstance(refactoringSession).putTask(task);
    }
  }

  public RefactoringLog fetchRefactoringLog(RefactoringLogReference scriptReference, boolean silently) {
    Language depModule = (Language) scriptReference.getModule();
    final int current = scriptReference.getFromVersion();
    SModel migrationModel = SModuleOperations.getAspect(depModule, "migration");
    final SNode log = ListSequence.fromList(SModelOperations.roots(migrationModel, MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, "jetbrains.mps.lang.migration.structure.RefactoringLog"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getInteger(it, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, 0x1bf9eb43276b6d91L, "fromVersion")) == current;
      }
    }).first();
    if (log == null && !(silently)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load refactoring log for module " + depModule + ", version " + current + ".");
      }
      return null;
    }
    Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>> participants = Sequence.fromIterable(new ExtensionPoint<Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>>>("jetbrains.mps.refactoring.participant.PersistentRefactoringParticipantsEP").getObjects()).translate(new ITranslator2<Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>>, RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>>() {
      public Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>> translate(Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>> it) {
        return it;
      }
    });
    List<RefactoringLogReference> executeAfter = Sequence.fromIterable(SLinkOperations.collect(SLinkOperations.getChildren(log, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, 0x1bf9eb43276b6d90L, "executeAfter")), MetaAdapterFactory.getReferenceLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d9dL, 0x1bf9eb43276b6d9eL, "refactoring"))).select(new ISelector<SNode, RefactoringLogReference>() {
      public RefactoringLogReference select(SNode it) {
        return ((RefactoringLogReference) (RefactoringLogReference) BHReflection.invoke(it, SMethodTrimmedId.create("getDescriptor", MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, "jetbrains.mps.lang.migration.structure.RefactoringLog"), "4uVwhQyPQ_Z")));
      }
    }).toListSequence();
    List<RefactoringPart> parts = Sequence.fromIterable(participants).select(new ISelector<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>, RefactoringPart>() {
      public RefactoringPart select(final RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?> participant) {
        List<SNode> participantParts = ListSequence.fromList(SLinkOperations.getChildren(log, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, 0x1bf9eb43276b6d92L, "part"))).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return eq_gd1mrb_a0a0a0a0a0a0a0a0a0a0a0h0w(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x2b3f57492c163158L, 0x325b97b223b9e3aaL, "participant")), participant.getId());
          }
        }).toListSequence();
        return ((RefactoringPart) new MigrationComponent.RefactoringPartImpl(SLinkOperations.getTarget(log, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, 0x31ee543051f2333cL, "options")), participantParts, participant));
      }
    }).toListSequence();
    RefactoringLog implementation = new RefactoringStepImpl(SPropertyOperations.getString(log, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), ((RefactoringLogReference) BHReflection.invoke(log, SMethodTrimmedId.create("getDescriptor", MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, "jetbrains.mps.lang.migration.structure.RefactoringLog"), "4uVwhQyPQ_Z"))), executeAfter, parts);
    return implementation;
  }

  public boolean executeMigrationScript(MigrationScriptApplied sa) {
    MigrationScript script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage fromLanguage = script.getDescriptor().getLanguage();
    Integer usedVersion = module.getModuleDescriptor().getLanguageVersions().get(fromLanguage);
    usedVersion = Math.max(usedVersion, 0);
    assert usedVersion == script.getDescriptor().getFromVersion();
    try {
      script.setDataCollector(myDataCollector);
      SNode data = script.execute(module);
      if (data != null) {
        MigrationDataUtil.addData(module, dataModule, script.getDescriptor(), data);
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    module.getModuleDescriptor().getLanguageVersions().put(fromLanguage, toVersion);
    module.setChanged();

    for (SModel model : ListSequence.fromList(module.getModels())) {
      if (model.isReadOnly()) {
        continue;
      }
      if (!((model instanceof SModelInternal))) {
        continue;
      }
      if (!(((SModelInternal) model).importedLanguageIds().contains(fromLanguage))) {
        continue;
      }

      ((SModelInternal) model).setLanguageImportVersion(fromLanguage, toVersion);
    }

    return true;
  }

  public boolean executeRefactoringLog(RefactoringLogApplied logApplied) {
    RefactoringLog rLog = logApplied.getRefactoringLog();
    AbstractModule module = ((AbstractModule) logApplied.getModule());
    SModule fromModule = rLog.getDescriptor().getModule();
    int importedVersion = MigrationModuleUtil.getDependencyVersion(module, fromModule);
    importedVersion = Math.max(importedVersion, 0);
    assert importedVersion == rLog.getDescriptor().getFromVersion();
    try {
      RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();
      rLog.execute(module, refactoringSession);
      MigrationComponent.RefactoringSessionTaskQueue.getInstance(refactoringSession).runAll();
      refactoringSession.performAllRegistered();
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = rLog.getDescriptor().getFromVersion() + 1;
    MigrationModuleUtil.setDepVersion(module, fromModule.getModuleReference(), toVersion);

    // todo: versions in models 
    return true;
  }

  private static MigrationScript check_gd1mrb_a0e0n(MigrationAspectDescriptor checkedDotOperand, Integer current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
  private static boolean eq_gd1mrb_a0a0a0a0a0a0a0a0a0a0a0h0w(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
