package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.lang.migration.runtime.base.MigrationDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.migration.component.util.MigrationDataUtil;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.apache.log4j.Level;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.ide.platform.actions.core.RefactoringParticipant;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.ide.platform.actions.core.RefactoringSession;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.lang.migration.runtime.base.RefactoringLog;
import jetbrains.mps.lang.migration.runtime.base.RefactoringLogReference;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.migration.runtime.base.RefactoringStepImpl;
import jetbrains.mps.lang.migration.runtime.base.RefactoringPart;
import jetbrains.mps.ide.platform.actions.core.RefactoringSessionImpl;
import jetbrains.mps.ide.findusages.model.scopes.ModulesScope;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.smodel.SModelInternal;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project myMpsProject;
  private SModule dataModule;
  private TempModuleOptions dataModuleOptions;

  private DataCollector myDataCollector = new DataCollector() {
    public Map<SModule, SNode> collectData(SModule myModule, final MigrationScriptReference scriptReference) {
      final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
      SetSequence.fromSet(MigrationsUtil.getModuleDependencies(myModule)).visitAll(new IVisitor<SModule>() {
        public void visit(SModule it) {
          SNode dataString = MigrationDataUtil.readData(it, scriptReference);
          if (dataString != null) {
            MapSequence.fromMap(requiredData).put(it, dataString);
          }
        }
      });
      return requiredData;
    }
  };

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.myMpsProject = mpsProject;
  }

  @Override
  public void initComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        dataModuleOptions = TempModuleOptions.forDefaultModule();
        myMpsProject.getRepository().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            dataModule = dataModuleOptions.createModule();
          }
        });
      }
    });
  }

  @Override
  public void disposeComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        myMpsProject.getRepository().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            dataModuleOptions.disposeModule();
          }
        });
      }
    });
  }

  private MigrationDescriptor loadMigrationDescriptor(final Language module) {
    final Wrappers._T<String> name = new Wrappers._T<String>();
    myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        name.value = getDescriptorFQName(module);
      }
    });
    try {
      Class descriptorClass = module.getClass(name.value);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception on migration descriptor instantiation", e);
      }
      return null;
    }
  }

  private String getDescriptorFQName(SModule module) {
    return module.getModuleName() + "." + LanguageAspect.MIGRATION.getName() + "." + ((String) BHReflection.invoke(SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, "jetbrains.mps.lang.migration.structure.MigrationScript")), SMethodTrimmedId.create("getGeneratedClassName", MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, "jetbrains.mps.lang.migration.structure.MigrationScript"), "7w5LXrJJkLe")));
  }

  private MigrationDescriptor getMigrationDescriptor(Language module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }
  public MigrationScript fetchMigrationScript(MigrationScriptReference scriptReference, boolean silently) {
    SLanguage depLanguage = scriptReference.getLanguage();
    int current = scriptReference.getFromVersion();
    MigrationDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());
    if (md == null && !(silently)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration descriptor for language " + depLanguage + ".");
      }
    }
    MigrationScript script = check_gd1mrb_a0e0s(md, current);
    if (script == null && !(silently)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration script for language " + depLanguage + ", version " + current + ".");
      }
      return null;
    }
    return script;
  }

  public static <I, F> void executeRefactoringLog(RefactoringParticipant.PersistentRefactoringParticipant<I, F, ?, ?> participant, SNode initialStateSerialized, SNode finalStateSerialized, SNode selectedOptionsSerialized, final SRepository repository, SearchScope searchScope, final RefactoringSession session) {
    I initialState = participant.deserializeInitialState(initialStateSerialized);
    final F finalState = participant.deserializeFinalState(finalStateSerialized);
    List<RefactoringParticipant.Option> availableOptions = participant.getAvailableOptions(initialState, repository);
    List<RefactoringParticipant.Option> selectedOptions;
    if (selectedOptionsSerialized == null) {
      selectedOptions = availableOptions;
    } else {
      selectedOptions = ListSequence.fromList(SLinkOperations.getChildren(selectedOptionsSerialized, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x31ee543051f23340L, 0x31ee543051f23346L, "options"))).select(new ISelector<SNode, RefactoringParticipant.Option>() {
        public RefactoringParticipant.Option select(SNode it) {
          return new RefactoringParticipant.Option(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x31ee543051f23343L, 0x31ee543051f23344L, "optionId")), SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x31ee543051f23343L, 0x31ee543051f30774L, "description")));
        }
      }).toListSequence();
    }
    ListSequence.fromList(participant.getChanges(initialState, repository, selectedOptions, searchScope, new EmptyProgressMonitor())).visitAll(new IVisitor<RefactoringParticipant.Change<I, F>>() {
      public void visit(RefactoringParticipant.Change<I, F> it) {
        it.confirm(finalState, repository, session);
      }
    });
  }

  public RefactoringLog fetchRefactoringLog(RefactoringLogReference scriptReference, boolean silently) {
    Language depModule = (Language) scriptReference.getModule();
    final int current = scriptReference.getFromVersion();
    SModel migrationModel = LanguageAspect.MIGRATION.get(depModule);
    final SNode log = ListSequence.fromList(SModelOperations.roots(migrationModel, MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, "jetbrains.mps.lang.migration.structure.RefactoringLog"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getInteger(it, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, 0x1bf9eb43276b6d91L, "fromVersion")) == current;
      }
    }).first();
    if (log == null && !(silently)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load refactoring log for module " + depModule + ", version " + current + ".");
      }
      return null;
    }
    final Map<String, RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>> participants = MapSequence.fromMap(new HashMap<String, RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>>());
    for (RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?> participant : Sequence.fromIterable(new ExtensionPoint<Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>>>("jetbrains.mps.ide.platform.PersistentRefactoringParticipantsEP").getObjects()).translate(new ITranslator2<Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>>, RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>>() {
      public Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>> translate(Iterable<RefactoringParticipant.PersistentRefactoringParticipant<?, ?, ?, ?>> it) {
        return it;
      }
    })) {
      MapSequence.fromMap(participants).put(participant.getId(), participant);
    }
    RefactoringLog implementation = new RefactoringStepImpl(SPropertyOperations.getString(log, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), ((RefactoringLogReference) BHReflection.invoke(log, SMethodTrimmedId.create("getDescriptor", MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, "jetbrains.mps.lang.migration.structure.RefactoringLog"), "4uVwhQyPQ_Z"))), ListSequence.fromList(SLinkOperations.getChildren(log, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, 0x1bf9eb43276b6d90L, "executeAfter"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d9dL, 0x1bf9eb43276b6d9eL, "refactoring")) != null);
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d9dL, 0x1bf9eb43276b6d9eL, "refactoring"));
      }
    }).select(new ISelector<SNode, RefactoringLogReference>() {
      public RefactoringLogReference select(SNode it) {
        return ((RefactoringLogReference) (RefactoringLogReference) BHReflection.invoke(it, SMethodTrimmedId.create("getDescriptor", MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, "jetbrains.mps.lang.migration.structure.RefactoringLog"), "4uVwhQyPQ_Z")));
      }
    }), ListSequence.fromList(SLinkOperations.getChildren(log, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, 0x1bf9eb43276b6d92L, "part"))).select(new ISelector<SNode, RefactoringPart>() {
      public RefactoringPart select(final SNode refactoringPartNode) {
        return new RefactoringPart() {
          public void execute(SModule module) {
            RefactoringSessionImpl session = new RefactoringSessionImpl();
            executeRefactoringLog(MapSequence.fromMap(participants).get(SPropertyOperations.getString(refactoringPartNode, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x2b3f57492c163158L, 0x325b97b223b9e3aaL, "participant"))), SLinkOperations.getTarget(refactoringPartNode, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x2b3f57492c163158L, 0x325b97b223b9e3acL, "initialState")), SLinkOperations.getTarget(refactoringPartNode, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x2b3f57492c163158L, 0x325b97b223b9e3aeL, "finalState")), SLinkOperations.getTarget(log, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x1bf9eb43276b6d8fL, 0x31ee543051f2333cL, "options")), myMpsProject.getRepository(), new ModulesScope(module), session);
            session.commit();
          }
        };
      }
    }));
    return implementation;
  }

  public boolean executeMigrationScript(MigrationScriptApplied sa) {
    MigrationScript script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage fromLanguage = script.getDescriptor().getLanguage();
    Integer usedVersion = module.getModuleDescriptor().getLanguageVersions().get(fromLanguage);
    usedVersion = Math.max(usedVersion, 0);
    assert usedVersion == script.getDescriptor().getFromVersion();
    try {
      script.setDataCollector(myDataCollector);
      SNode data = script.execute(module);
      if (data != null) {
        MigrationDataUtil.addData(module, dataModule, script.getDescriptor(), data);
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    module.getModuleDescriptor().getLanguageVersions().put(fromLanguage, toVersion);
    module.setChanged();

    for (SModel model : ListSequence.fromList(module.getModels())) {
      if (model.isReadOnly()) {
        continue;
      }
      if (!((model instanceof SModelInternal))) {
        continue;
      }
      if (!(((SModelInternal) model).importedLanguageIds().contains(fromLanguage))) {
        continue;
      }

      ((SModelInternal) model).setLanguageImportVersion(fromLanguage, toVersion);
    }

    return true;
  }

  public boolean executeRefactoringLog(RefactoringLogApplied sa) {
    RefactoringLog script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SModule fromModule = script.getDescriptor().getModule();
    Integer importedVersion = module.getModuleDescriptor().getDependencyVersions().get(fromModule.getModuleReference());
    importedVersion = Math.max(importedVersion, 0);
    assert importedVersion == script.getDescriptor().getFromVersion();
    try {
      script.execute(module);
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    module.getModuleDescriptor().getDependencyVersions().put(fromModule.getModuleReference(), toVersion);
    module.setChanged();

    // todo: versions in models 
    return true;
  }

  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);
  private static MigrationScript check_gd1mrb_a0e0s(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
}
