package jetbrains.mps.execution.impl.configurations;

/*Generated by MPS */

import com.intellij.openapi.components.ProjectComponent;
import jetbrains.mps.plugins.PluginReloadingListener;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import com.intellij.openapi.project.Project;
import jetbrains.mps.plugins.projectplugins.ProjectPluginManager;
import java.util.List;
import jetbrains.mps.plugins.PluginContributor;
import com.intellij.execution.ui.RunContentDescriptor;
import com.intellij.openapi.application.ApplicationManager;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.ui.content.Content;
import org.apache.log4j.Level;
import com.intellij.openapi.application.ModalityState;
import com.intellij.execution.ExecutionManager;
import com.intellij.execution.ui.RunContentManagerImpl;
import com.intellij.execution.configurations.RunConfiguration;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.classloading.ModuleClassLoader;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.ArrayList;
import com.intellij.execution.impl.RunManagerImpl;
import com.intellij.execution.RunManagerEx;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import com.intellij.execution.configurations.ConfigurationType;
import java.lang.reflect.Field;
import com.intellij.openapi.options.SchemeManager;

/**
 * This component allows to create reloadable (!) run configurations within MPS.
 * It listens to the project plugins manager because we use custom project plugins to register custom 'before' tasks (like 'make' etc.)
 * It saves all run configurations at the plugin unload and then restores them at the plugin load event
 * Currently before tasks are saved but not loaded (they are loaded from template configurations) due to change in IDEA api
 * FIX need to try creating a special proxy class which wraps the MPS-owned classes and turns them to IDEA while delegating all the method invocations
 * to the right class.
 * Another possibility is to create some kind of extension point in IDEA to make the configurations reloadable.
 * However I see the first scenario as a much better choice (if it works)
 */
public class RunConfigurationsStateManager implements ProjectComponent, PluginReloadingListener {
  private static final Logger LOG = LogManager.getLogger(RunConfigurationsStateManager.class);
  private final Project myProject;
  private final ProjectPluginManager myProjectPluginManager;
  private final RunConfigurationsStateManager.RunConfigurationsState myState = new RunConfigurationsStateManager.RunConfigurationsState();

  public RunConfigurationsStateManager(Project project, ProjectPluginManager pluginManager) {
    myProject = project;
    myProjectPluginManager = pluginManager;
  }

  @Override
  public void afterPluginsLoaded(List<PluginContributor> contributors) {
    initRunConfigurations();
  }

  @Override
  public void beforePluginsUnloaded(List<PluginContributor> contributors) {
    disposeRunConfigurations();
  }

  @Override
  public void initComponent() {
  }

  @Override
  public void disposeComponent() {
  }

  @Override
  public void projectOpened() {
    myProjectPluginManager.addReloadingListener(RunConfigurationsStateManager.this);
  }

  @Override
  public void projectClosed() {
    myProjectPluginManager.removeReloadingListener(this);
  }

  public void initRunConfigurations() {
    if (myProject.isDisposed()) {
      return;
    }
    myState.restoreState();
  }

  public void disposeRunConfigurations() {
    assert !(myProject.isDisposed());
    disposeRunContentDescriptors();
  }

  private void disposeRunContentDescriptors() {
    final List<RunContentDescriptor> descriptors = collectDescriptorsToDispose();

    ApplicationManager.getApplication().invokeLater(new Runnable() {
      @Override
      public void run() {
        {
          Iterator<RunContentDescriptor> descriptor_it = ListSequence.fromList(descriptors).iterator();
          RunContentDescriptor descriptor_var;
          while (descriptor_it.hasNext()) {
            descriptor_var = descriptor_it.next();
            Content attachedContent = descriptor_var.getAttachedContent();
            if (attachedContent == null) {
              if (LOG.isEnabledFor(Level.WARN)) {
                LOG.warn("Attached content of descriptor " + descriptor_var.getDisplayName() + " is null.");
              }
            } else
            if (attachedContent.getManager() == null) {
              if (LOG.isEnabledFor(Level.WARN)) {
                LOG.warn("Manager of attached content of descriptor " + descriptor_var.getDisplayName() + " is null.");
              }
            } else {
              attachedContent.getManager().removeAllContents(true);
            }
          }
        }
      }
    }, ModalityState.NON_MODAL);
  }

  private void clearAllRunConfigurations() {
    getRunManager().clearAll();
  }

  private List<RunContentDescriptor> collectDescriptorsToDispose() {
    ExecutionManager executionManager = ExecutionManager.getInstance(myProject);
    final RunContentManagerImpl contentManager = (RunContentManagerImpl) executionManager.getContentManager();

    Iterable<RunConfiguration> allConfigurationsList = getRunManager().getAllConfigurationsList();
    final List<String> reloadableConfigurationNames = Sequence.fromIterable(allConfigurationsList).where(new IWhereFilter<RunConfiguration>() {
      public boolean accept(RunConfiguration it) {
        return it.getClass().getClassLoader() instanceof ModuleClassLoader;
      }
    }).select(new ISelector<RunConfiguration, String>() {
      public String select(RunConfiguration it) {
        return it.getName();
      }
    }).toListSequence();
    final List<RunContentDescriptor> descriptors = ListSequence.fromList(new ArrayList<RunContentDescriptor>());
    {
      Iterator<RunContentDescriptor> descriptor_it = ListSequence.fromList(contentManager.getAllDescriptors()).iterator();
      RunContentDescriptor descriptor_var;
      while (descriptor_it.hasNext()) {
        descriptor_var = descriptor_it.next();
        if (ListSequence.fromList(reloadableConfigurationNames).contains(descriptor_var.getDisplayName())) {
          ListSequence.fromList(descriptors).addElement(descriptor_var);
        }
      }
    }
    return descriptors;
  }

  private RunManagerImpl getRunManager() {
    return (RunManagerImpl) RunManagerEx.getInstanceEx(myProject);
  }

  @NonNls
  @NotNull
  @Override
  public String getComponentName() {
    return "MPS Run Configs Manager";
  }

  public static RunConfigurationsStateManager getInstance(Project project) {
    return project.getComponent(RunConfigurationsStateManager.class);
  }

  private class RunConfigurationsState {
    public RunConfigurationsState() {
    }

    public void restoreState() {
      clearAllRunConfigurations();
      getRunManager().initializeConfigurationTypes(ConfigurationType.CONFIGURATION_TYPE_EP.getExtensions());
      RunManagerImpl runManager = getRunManager();
      Class<RunManagerImpl> runManagerClass = RunManagerImpl.class;
      try {
        for (Field f : runManagerClass.getDeclaredFields()) {
          if (f.getName().endsWith("SchemeManager")) {
            f.setAccessible(true);
            Object schemeManager = f.get(runManager);
            assert schemeManager instanceof SchemeManager;
            ((SchemeManager) schemeManager).reload();
          }
        }
      } catch (IllegalAccessException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Unable to access schemeManagers via reflection", e);
        }
      }
    }
  }
}
