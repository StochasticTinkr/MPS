package jetbrains.mps.ide.mpsmigration.v_2017_2;

/*Generated by MPS */

import jetbrains.mps.migration.global.BaseProjectMigration;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Set;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModelReference;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.model.SModelName;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.ModelDependencyScanner;
import jetbrains.mps.project.AbstractModule;

public class JUnitLibsRepackaging extends BaseProjectMigration {

  public JUnitLibsRepackaging() {
    super("jetbrains.mps.ide.mpsmigration.v172." + JUnitLibsRepackaging.class.getSimpleName());
  }

  @Override
  public boolean doExecute(Project project) {
    SModule junitModule = PersistenceFacade.getInstance().createModuleReference("49808fad-9d41-4b96-83fa-9231640f6b2b(JUnit)").resolve(project.getRepository());
    if (junitModule == null) {
      return false;
    }

    SModule hamcrestModule = PersistenceFacade.getInstance().createModuleReference("1fd846c3-c5f9-4b9e-9ecc-e716f7149f86(Hamcrest)").resolve(project.getRepository());
    if (hamcrestModule == null) {
      return false;
    }

    Map<String, SModel> junitModels = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel nextModel : Sequence.fromIterable(junitModule.getModels())) {
      MapSequence.fromMap(junitModels).put(nextModel.getName().getLongName(), nextModel);
    }

    Map<String, SModel> hamcrestModels = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel nextModel : Sequence.fromIterable(hamcrestModule.getModels())) {
      MapSequence.fromMap(hamcrestModels).put(nextModel.getName().getLongName(), nextModel);
    }

    for (SModule projectModule : ListSequence.fromList(project.getProjectModules())) {
      if (projectModule == junitModule || projectModule == hamcrestModule || projectModule == PersistenceFacade.getInstance().createModuleReference("83f155ff-422c-4b5a-a2f2-b459302dd215(jetbrains.mps.baseLanguage.unitTest.libs)").resolve(project.getRepository())) {
        continue;
      }

      Set<SModuleReference> modulesToImport = SetSequence.fromSet(new HashSet<SModuleReference>());
      for (SModel projectSModel : Sequence.fromIterable(projectModule.getModels())) {
        SModel projectModel = projectSModel;

        List<SModelReference> modelsToImport = ListSequence.fromList(new ArrayList<SModelReference>());
        Set<SModelReference> modelsToOptimize = SetSequence.fromSet(new HashSet<SModelReference>());
        for (SNode node : ListSequence.fromList(SModelOperations.nodes(projectModel, null))) {
          List<SReference> allNodeRefs = ListSequence.fromList(new ArrayList<SReference>());
          for (SReference ref : Sequence.fromIterable(node.getReferences())) {
            ListSequence.fromList(allNodeRefs).addElement(ref);
          }

          for (SReference existingRef : ListSequence.fromList(allNodeRefs)) {
            SNodeId targetNodeId = existingRef.getTargetNodeId();
            if (targetNodeId == null) {
              continue;
            }
            SModelReference targetSModelReference = existingRef.getTargetSModelReference();
            if (targetSModelReference == null) {
              continue;
            }
            String targetModelName = new SModelName(targetSModelReference.getModelName()).getLongName();

            if (MapSequence.fromMap(junitModels).containsKey(targetModelName)) {
              SNode newTarget = MapSequence.fromMap(junitModels).get(targetModelName).getNode(targetNodeId);
              if (newTarget != null) {
                SetSequence.fromSet(modelsToOptimize).addElement(targetSModelReference);
                node.setReferenceTarget(existingRef.getLink(), newTarget);
                ListSequence.fromList(modelsToImport).addElement(MapSequence.fromMap(junitModels).get(targetModelName).getReference());
                SetSequence.fromSet(modulesToImport).addElement(PersistenceFacade.getInstance().createModuleReference("49808fad-9d41-4b96-83fa-9231640f6b2b(JUnit)"));
              }
            } else if (MapSequence.fromMap(hamcrestModels).containsKey(targetModelName)) {
              SNode newTarget = MapSequence.fromMap(hamcrestModels).get(targetModelName).getNode(targetNodeId);
              if (newTarget != null) {
                SetSequence.fromSet(modelsToOptimize).addElement(targetSModelReference);
                node.setReferenceTarget(existingRef.getLink(), newTarget);
                ListSequence.fromList(modelsToImport).addElement(MapSequence.fromMap(hamcrestModels).get(targetModelName).getReference());
                SetSequence.fromSet(modulesToImport).addElement(PersistenceFacade.getInstance().createModuleReference("1fd846c3-c5f9-4b9e-9ecc-e716f7149f86(Hamcrest)"));
              }
            }
          }
        }
        for (SModelReference newImport : ListSequence.fromList(modelsToImport)) {
          ((SModelInternal) projectSModel).addModelImport(newImport);
        }
        if (SetSequence.fromSet(modelsToOptimize).isNotEmpty()) {
          Set<SModelReference> crossModelReferences = new ModelDependencyScanner().crossModelReferences(true).walk(projectSModel).getCrossModelReferences();
          for (SModelReference modelToOptimize : SetSequence.fromSet(modelsToOptimize)) {
            if (!(crossModelReferences.contains(modelToOptimize))) {
              ((SModelInternal) projectSModel).deleteModelImport(modelToOptimize);
            }
          }
        }
      }

      for (SModuleReference module : SetSequence.fromSet(modulesToImport)) {
        ((AbstractModule) projectModule).addDependency(module, false);
      }
    }
    return true;
  }
  @Override
  public String getDescription() {
    return "Updating all usages of JUnit/Hamcrest classes in order to use newly created stub solutions";
  }
}
