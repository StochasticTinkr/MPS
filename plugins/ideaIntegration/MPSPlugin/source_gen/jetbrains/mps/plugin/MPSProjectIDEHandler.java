package jetbrains.mps.plugin;

/*Generated by MPS */

import java.rmi.server.UnicastRemoteObject;
import com.intellij.openapi.components.ProjectComponent;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import com.intellij.openapi.project.Project;
import java.rmi.RemoteException;
import jetbrains.mps.RuntimeFlags;
import java.rmi.NoSuchObjectException;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.ide.project.ProjectHelper;
import java.io.File;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.lang.smodel.query.runtime.CommandUtil;
import jetbrains.mps.lang.smodel.query.runtime.QueryExecutionContext;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.textgen.trace.DebugInfo;
import jetbrains.mps.textgen.trace.TraceInfo;
import org.apache.log4j.Level;
import jetbrains.mps.smodel.SNodePointer;
import com.intellij.openapi.wm.IdeFrame;
import com.intellij.openapi.wm.WindowManager;
import com.intellij.openapi.wm.ex.StatusBarEx;
import com.intellij.openapi.ui.MessageType;
import jetbrains.mps.openapi.navigation.NavigationSupport;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.intellij.ide.impl.ProjectUtil;
import jetbrains.mps.util.Pair;
import jetbrains.mps.textgen.trace.TraceablePositionInfo;
import jetbrains.mps.textgen.trace.DebugInfoRoot;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import jetbrains.mps.ide.findusages.findalgorithm.finders.specific.AspectMethodsFinder;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.ide.findusages.view.UsageToolOptions;
import jetbrains.mps.ide.findusages.view.UsagesViewTool;
import jetbrains.mps.ide.findusages.view.FindUtils;
import jetbrains.mps.ide.findusages.findalgorithm.finders.IFinder;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.ide.findusages.model.IResultProvider;
import jetbrains.mps.util.NameUtil;

public class MPSProjectIDEHandler extends UnicastRemoteObject implements IMPSIDEHandler, ProjectComponent {
  private static final Logger LOG_1373119566 = LogManager.getLogger(MPSProjectIDEHandler.class);
  private static final Logger LOG = LogManager.getLogger(MPSProjectIDEHandler.class);
  private Project myProject;
  public MPSProjectIDEHandler(Project project) throws RemoteException {
    myProject = project;
  }
  @Override
  public void projectOpened() {
    if (RuntimeFlags.isTestMode()) {
      return;
    }
    new Thread() {
      @Override
      public void run() {
        try {
          IProjectHandler handler = MPSPlugin.getInstance().getProjectHandler(myProject.getBasePath());
          if (handler == null) {
            return;
          }
          handler.addIdeHandler(MPSProjectIDEHandler.this);
        } catch (RemoteException e) {
          e.printStackTrace();
        }
      }
    }.start();
  }
  @Override
  public void projectClosed() {
    if (RuntimeFlags.isTestMode()) {
      return;
    }
    new Thread() {
      @Override
      public void run() {
        IProjectHandler handler = MPSPlugin.getInstance().getProjectHandler(myProject.getBasePath());
        if (handler != null) {
          try {
            handler.removeIdeHandler(MPSProjectIDEHandler.this);
          } catch (RemoteException e) {
            MPSProjectIDEHandler.LOG.error(null, e);
          }
        }
        try {
          UnicastRemoteObject.unexportObject(MPSProjectIDEHandler.this, true);
        } catch (NoSuchObjectException e) {
          throw new RuntimeException(e);
        }
      }
    }.start();
  }
  @NonNls
  @NotNull
  @Override
  public String getComponentName() {
    return "MPS Project IDE Handler";
  }
  @Override
  public void initComponent() {
  }
  @Override
  public void disposeComponent() {
  }
  @Override
  public void showSource(final String filePath, final String modelHint, final int line, int column) throws RemoteException {
    final jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);
    mpsProject.getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        String fileName = new File(filePath).getName();

        List<SModel> modelsByName = ListSequence.fromList(new ArrayList<SModel>());

        {
          final SearchScope scope = CommandUtil.createScope(ProjectHelper.fromIdeaProject(myProject));
          QueryExecutionContext context = new QueryExecutionContext() {
            public SearchScope getDefaultSearchScope() {
              return scope;
            }
          };
          // we first look up in models with the given name (better chance to succeed), then in all other models 
          ListSequence.fromList(modelsByName).addSequence(Sequence.fromIterable(CommandUtil.models(CommandUtil.selectScope(null, context))).where(new IWhereFilter<SModel>() {
            public boolean accept(SModel it) {
              return Objects.equals(SModelOperations.getModelName(it), modelHint);
            }
          }));
          ListSequence.fromList(modelsByName).addSequence(Sequence.fromIterable(CommandUtil.models(CommandUtil.selectScope(null, context))).where(new IWhereFilter<SModel>() {
            public boolean accept(SModel it) {
              return !(Objects.equals(SModelOperations.getModelName(it), modelHint));
            }
          }));
        }

        SNode bestNode = null;
        for (SModel model : ListSequence.fromList(modelsByName)) {
          DebugInfo di = new TraceInfo().getDebugInfo(model);
          if (di == null) {
            if (LOG_1373119566.isEnabledFor(Level.WARN)) {
              LOG_1373119566.warn("Debug info not found for model " + SModelOperations.getModelName(model));
            }
            continue;
          }
          // IMPORTANT: line+1 because the line parameter means "line, starting with 0", while in debug info it starts from 1 
          SNodePointer np = getBestNodeForPosition(di, fileName, line + 1);
          bestNode = np.resolve(mpsProject.getRepository());
          if (bestNode != null) {
            break;
          }
        }

        if ((bestNode == null)) {
          final IdeFrame ideFrame = WindowManager.getInstance().getIdeFrame(myProject);
          if (ideFrame != null) {
            StatusBarEx statusBar = (StatusBarEx) ideFrame.getStatusBar();
            statusBar.notifyProgressByBalloon(MessageType.WARNING, "No source found for " + fileName + ":" + line, null, null);
          }
        } else {
          NavigationSupport.getInstance().openNode(mpsProject, bestNode, true, (SNodeOperations.getParent(bestNode) != null));
        }
        ProjectUtil.focusProjectWindow(myProject, true);
      }
    });
  }

  @NotNull
  private SNodePointer getBestNodeForPosition(DebugInfo debugInfo, @NotNull final String fileName, final int line) {
    List<Pair<TraceablePositionInfo, DebugInfoRoot>> nicePositions = ListSequence.fromList(new ArrayList<Pair<TraceablePositionInfo, DebugInfoRoot>>());
    Iterable<DebugInfoRoot> roots = debugInfo.getRoots();
    for (DebugInfoRoot root : Sequence.fromIterable(roots).where(new IWhereFilter<DebugInfoRoot>() {
      public boolean accept(DebugInfoRoot it) {
        return it.getFileNames().contains(fileName);
      }
    })) {
      Collection<TraceablePositionInfo> positions = root.getPositions();
      // for each root we get the nearest position that contains the given line 
      TraceablePositionInfo info = CollectionSequence.fromCollection(positions).where(new IWhereFilter<TraceablePositionInfo>() {
        public boolean accept(TraceablePositionInfo it) {
          return it.contains(fileName, line);
        }
      }).sort(new ISelector<TraceablePositionInfo, Integer>() {
        public Integer select(TraceablePositionInfo it) {
          return it.getStartLine();
        }
      }, true).findLast(new IWhereFilter<TraceablePositionInfo>() {
        public boolean accept(TraceablePositionInfo it) {
          return it.getStartLine() <= line;
        }
      });
      if (info != null) {
        ListSequence.fromList(nicePositions).addElement(new Pair(info, root));
      }
    }
    if (ListSequence.fromList(nicePositions).isEmpty()) {
      return new SNodePointer(null);
    }

    // now, between all those "best local" positions, we select the global best one  
    Pair<TraceablePositionInfo, DebugInfoRoot> bestPosition = ListSequence.fromList(nicePositions).sort(new ISelector<Pair<TraceablePositionInfo, DebugInfoRoot>, Integer>() {
      public Integer select(Pair<TraceablePositionInfo, DebugInfoRoot> it) {
        return it.o1.getStartLine();
      }
    }, true).findLast(new IWhereFilter<Pair<TraceablePositionInfo, DebugInfoRoot>>() {
      public boolean accept(Pair<TraceablePositionInfo, DebugInfoRoot> it) {
        return it.o1.getStartLine() <= line;
      }
    });

    return new SNodePointer(bestPosition.o2.getNodeRef().getModelReference(), PersistenceFacade.getInstance().createNodeId(bestPosition.o1.getNodeId()));
  }

  @Override
  public void showNode(final String namespace, final String id) throws RemoteException {
    final jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);
    mpsProject.getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        for (SModel descriptor : new ModuleRepositoryFacade(mpsProject).getAllModels()) {
          if (!(namespace.equals(descriptor.getModelName()))) {
            continue;
          }
          SNode node = descriptor.getNode(PersistenceFacade.getInstance().createNodeId(id));
          if (node != null) {
            NavigationSupport.getInstance().openNode(mpsProject, node, true, node.getParent() != null);
          }
        }
        ProjectUtil.focusProjectWindow(myProject, true);
      }
    });
  }
  @Override
  public void showAspectMethodUsages(final String namespace, final String name) throws RemoteException {
    SearchQuery searchQuery = new SearchQuery(new AspectMethodsFinder.AspectMethodsHolder(namespace, name), GlobalScope.getInstance());
    UsageToolOptions opt = new UsageToolOptions().allowRunAgain(false).navigateIfSingle(false).forceNewTab(false).notFoundMessage("No usages for that method");
    UsagesViewTool.showUsages(myProject, FindUtils.makeProvider(new IFinder[]{new AspectMethodsFinder()}), searchQuery, opt);
  }
  @Override
  public void showClassUsages(final String fqName) throws RemoteException {
    final jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);
    mpsProject.getModelAccess().runReadAction(new Runnable() {
      @Override
      public void run() {
        SNode cls = findClassByName(fqName);
        if (cls == null) {
          MPSProjectIDEHandler.LOG.error("Can't find a class " + fqName);
          return;
        }
        ProjectUtil.focusProjectWindow(myProject, true);
        findUsages(cls, GlobalScope.getInstance(), FindUtils.makeProvider("jetbrains.mps.baseLanguage.findUsages.ClassUsages_Finder"));
      }
    });
  }
  @Override
  public void showMethodUsages(final String classFqName, final String methodName, final int parameterCount) throws RemoteException {
    final jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);
    mpsProject.getModelAccess().runReadAction(new Runnable() {
      @Override
      public void run() {
        if (classFqName == null || methodName == null) {
          MPSProjectIDEHandler.LOG.error("Can't find a method " + classFqName + "." + methodName);
          return;

        }
        SNode cls = findClassByName(classFqName);
        if (cls == null) {
          MPSProjectIDEHandler.LOG.error("Can't find a class " + classFqName);
          return;
        }
        Iterable<SNode> allMethods = SNodeOperations.ofConcept(SNodeOperations.getChildren(cls), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"));
        SNode method = Sequence.fromIterable(allMethods).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return methodName.equals(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))) && ListSequence.fromList(SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, "parameter"))).count() == parameterCount;
          }
        });
        if (method == null) {
          MPSProjectIDEHandler.LOG.error("Can't find a method " + classFqName + "." + methodName);
          return;
        }
        ProjectUtil.focusProjectWindow(myProject, true);
        IResultProvider provider = FindUtils.makeProvider("jetbrains.mps.baseLanguage.findUsages.ConstructorUsages_Finder", "jetbrains.mps.baseLanguage.findUsages.BaseMethodUsages_Finder");
        findUsages(method, GlobalScope.getInstance(), provider);
      }
    });
  }
  private void findUsages(@NotNull final SNode node, final SearchScope scope, final IResultProvider provider) {
    UsageToolOptions opt = new UsageToolOptions().allowRunAgain(true).navigateIfSingle(false).forceNewTab(false).notFoundMessage("No usages for that node");
    UsagesViewTool.showUsages(myProject, provider, new SearchQuery(node, scope), opt);
  }
  private SNode findClassByName(String classFqName) {
    // This is slightly updated SModelUtil.findNodeByFQName, which moved here as it's the only place we use it 
    // FIXME however, it's ugly and needs rework 
    String modelName = NameUtil.namespaceFromLongName(classFqName);
    String name = NameUtil.shortNameFromLongName(classFqName);
    for (SModel m : Sequence.fromIterable(GlobalScope.getInstance().getModels())) {
      if (!(modelName.equals(NameUtil.getModelLongName(m)))) {
        continue;
      }
      SModel model = m;
      for (SNode root : ListSequence.fromList(SModelOperations.roots(model, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")))) {
        if (name.equals(SPropertyOperations.getString(root, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")))) {
          return root;
        }
      }
    }
    return null;
  }
}
