package jetbrains.mps.ide.editor.util;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import java.util.Comparator;
import jetbrains.mps.ide.navigation.NodeNavigatable;
import com.intellij.util.Function;
import jetbrains.mps.ide.editor.util.renderer.BaseRenderer;
import jetbrains.mps.util.annotation.ToRemove;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import com.intellij.ui.awt.RelativePoint;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Collections;
import javax.swing.ListCellRenderer;
import jetbrains.mps.classloading.ModuleClassLoader;
import javax.swing.JList;
import com.intellij.ui.components.JBList;
import com.intellij.openapi.ui.popup.PopupChooserBuilder;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import java.awt.event.InputEvent;
import java.awt.event.MouseEvent;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.awt.Point;
import com.intellij.openapi.ui.popup.JBPopup;
import com.intellij.ui.SortedListModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.annotations.Nullable;
import java.util.function.Consumer;
import javax.swing.ListSelectionModel;

public final class GoToContextMenuHelper {
  private final Project myProject;
  private final CaptionFunction myCaptionFun;
  private final Comparator<NodeNavigatable> myComparator;
  private final Function<NodeNavigatable, String> myNamerForFiltering;
  private final BaseRenderer myRenderer;

  /**
   * left for the mbeddr compatibility
   * 
   * @deprecated use the new method instead
   */
  @Deprecated
  @ToRemove(version = 183)
  public static void showNodeMenu(Project project, String title, List<SNodeReference> nodes, final BaseRenderer renderer, RelativePoint point) {
    if (ListSequence.fromList(nodes).isEmpty()) {
      return;
    }
    List<NodeNavigatable> navigatables = new ArrayList<NodeNavigatable>();
    for (SNodeReference node : nodes) {
      navigatables.add(new NodeNavigatable(project, node));
    }
    Collections.sort(navigatables, new Comparator<NodeNavigatable>() {
      @Override
      public int compare(NodeNavigatable o1, NodeNavigatable o2) {
        return getText(o1).compareTo(getText(o2));
      }

      private String getText(NodeNavigatable element) {
        return element.getNodePointer().toString();
      }
    });
    openTargets(point, navigatables, title, renderer);
  }

  @ToRemove(version = 183)
  @Deprecated
  private static void openTargets(RelativePoint p, List<NodeNavigatable> targets, String title, ListCellRenderer listRenderer) {
    assert !(GoToContextMenuHelper.class.getClassLoader() instanceof ModuleClassLoader) : "if this class is loaded by a reloadable classloader, this will cause memleaks. See MPS-13481";
    if (targets.isEmpty()) {
      return;
    }
    if (targets.size() == 1) {
      targets.get(0).navigate(true);
    } else {
      final JList list = new JBList(targets.toArray());
      list.setCellRenderer(listRenderer);
      new PopupChooserBuilder(list).setTitle(title).setMovable(true).setItemChoosenCallback(new Runnable() {
        @Override
        public void run() {
          int[] ids = list.getSelectedIndices();
          if (ids == null || ids.length == 0) {
            return;
          }
          Object[] selectedElements = list.getSelectedValues();
          for (Object element : selectedElements) {
            NodeNavigatable selected = (NodeNavigatable) element;
            selected.navigate(true);
          }
        }
      }).createPopup().show(p);
    }
  }

  public static RelativePoint getRelativePoint(EditorCell selectedCell, InputEvent inputEvent) {
    if (inputEvent instanceof MouseEvent) {
      return new RelativePoint(((MouseEvent) inputEvent));
    }
    return new RelativePoint((EditorComponent) selectedCell.getEditorComponent(), new Point(selectedCell.getX(), selectedCell.getY()));
  }

  private static final Comparator<SNodeReference> DEFAULT_COMPARATOR = new Comparator<SNodeReference>() {
    @Override
    public int compare(SNodeReference n1, SNodeReference n2) {
      return getText(n1).compareTo(getText(n2));
    }

    private String getText(SNodeReference ptr) {
      return ptr + "";
    }
  };

  public static final class ContextMenuComposite {
    public final JBPopup myPopup;
    public final JBList<NodeNavigatable> myJBList;
    public final SortedListModel<NodeNavigatable> myListModel;

    public ContextMenuComposite(@NotNull JBPopup popup, @NotNull JBList<NodeNavigatable> jbList, @NotNull SortedListModel<NodeNavigatable> listModel) {
      myPopup = popup;
      myJBList = jbList;
      myListModel = listModel;
    }
  }

  public GoToContextMenuHelper(@NotNull MPSProject project, @NotNull CaptionFunction captionFun, @NotNull BaseRenderer renderer, @Nullable Comparator<SNodeReference> comparator, @Nullable Function<SNodeReference, String> namer) {
    myProject = project;
    myCaptionFun = captionFun;
    myRenderer = renderer;
    if (comparator == null) {
      comparator = DEFAULT_COMPARATOR;
    }
    if (namer == null) {
      namer = NamerFactory.DEFAULT_NAMER_FACTORY.create(project.getRepository());
    }
    myComparator = adaptComparatorForNavigatable(comparator);
    myNamerForFiltering = adaptNamerForNavigatable(namer);
  }

  public GoToContextMenuHelper(@NotNull MPSProject project, @NotNull CaptionFunction captionFun, @NotNull BaseRenderer renderer) {
    this(project, captionFun, renderer, null, null);
  }

  @NotNull
  public GoToContextMenuHelper.ContextMenuComposite showMenuWithNodes(@NotNull List<SNodeReference> nodes, @NotNull RelativePoint point) {
    final SortedListModel<NodeNavigatable> model = new SortedListModel(myComparator);
    nodes.stream().distinct().map(new java.util.function.Function<SNodeReference, NodeNavigatable>() {
      @Override
      public NodeNavigatable apply(SNodeReference it) {
        return new NodeNavigatable(myProject, it);
      }
    }).forEach(new Consumer<NodeNavigatable>() {
      @Override
      public void accept(NodeNavigatable item) {
        model.add(item);
      }
    });
    GoToContextMenuHelper.ContextMenuComposite menu = buildPopup();
    menu.myJBList.setModel(model);
    menu.myPopup.show(point);
    return menu;
  }

  @NotNull
  public GoToContextMenuHelper.ContextMenuComposite buildPopup() {
    return buildPopup(Collections.<SNodeReference>emptyList());
  }

  @NotNull
  public GoToContextMenuHelper.ContextMenuComposite buildPopup(@NotNull List<SNodeReference> foundUsages) {
    checkClassLoader();
    SortedListModel<NodeNavigatable> listModel = new SortedListModel(myComparator);
    for (SNodeReference usage : ListSequence.fromList(foundUsages)) {
      listModel.add(new NodeNavigatable(myProject, usage));
    }
    final JBList<NodeNavigatable> list = new JBList(listModel);
    String startingCaption = myCaptionFun.caption(0, false);
    JBPopup popup = new PopupChooserBuilder<NodeNavigatable>(list).setTitle(startingCaption).setMovable(true).setItemChoosenCallback(new Runnable() {
      @Override
      public void run() {
        int[] ids = list.getSelectedIndices();
        if (ids == null || ids.length == 0) {
          return;
        }
        for (NodeNavigatable selected : list.getSelectedValuesList()) {
          selected.navigate(true);
        }
      }
    }).setRequestFocus(true).setRenderer(myRenderer).setSelectionMode(ListSelectionModel.SINGLE_SELECTION).setNamerForFiltering(myNamerForFiltering).setAutoselectOnMouseMove(true).createPopup();
    return new GoToContextMenuHelper.ContextMenuComposite(popup, list, listModel);
  }

  private static Function<NodeNavigatable, String> adaptNamerForNavigatable(final Function<SNodeReference, String> namer) {
    return new Function<NodeNavigatable, String>() {
      public String fun(NodeNavigatable p0) {
        SNodeReference nodePointer = p0.getNodePointer();
        return namer.fun(nodePointer);
      }
    };
  }

  private static Comparator<NodeNavigatable> adaptComparatorForNavigatable(final Comparator<SNodeReference> comparator) {
    return new Comparator<NodeNavigatable>() {
      @Override
      public int compare(NodeNavigatable n1, NodeNavigatable n2) {
        return comparator.compare(n1.getNodePointer(), n2.getNodePointer());
      }
    };
  }

  private static void checkClassLoader() {
    assert !((GoToContextMenuHelper.class.getClassLoader() instanceof ModuleClassLoader)) : "if this class is loaded by a reloadable classloader, this will cause memleaks. See MPS-13481";
  }
}
