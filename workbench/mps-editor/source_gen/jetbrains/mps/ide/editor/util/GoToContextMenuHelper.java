package jetbrains.mps.ide.editor.util;

/*Generated by MPS */

import com.intellij.openapi.ui.popup.JBPopup;
import com.intellij.openapi.ui.popup.PopupChooserBuilder;
import com.intellij.ui.SortedListModel;
import com.intellij.ui.awt.RelativePoint;
import com.intellij.ui.components.JBList;
import com.intellij.util.Function;
import jetbrains.mps.classloading.ModuleClassLoader;
import jetbrains.mps.ide.editor.util.renderer.BaseRenderer;
import jetbrains.mps.ide.navigation.NodeNavigatable;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.util.Computable;
import jetbrains.mps.util.ModelComputeRunnable;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeReference;

import javax.swing.ListSelectionModel;
import java.awt.Point;
import java.awt.event.InputEvent;
import java.awt.event.MouseEvent;
import java.util.Comparator;
import java.util.List;
import java.util.function.Consumer;

public final class GoToContextMenuHelper {
  private final jetbrains.mps.project.Project myProject;
  private final String myTitle;
  private final Comparator<NodeNavigatable> myComparator;
  private final Function<NodeNavigatable, String> myNamerForNavigatable;
  private final BaseRenderer myRenderer;

  public static final class ContextMenuComposite {
    public final JBPopup myPopup;
    public final JBList<NodeNavigatable> myJBList;
    public final SortedListModel<NodeNavigatable> myListModel;

    public ContextMenuComposite(@NotNull JBPopup popup, @NotNull JBList<NodeNavigatable> jbList, @NotNull SortedListModel<NodeNavigatable> listModel) {
      myPopup = popup;
      myJBList = jbList;
      myListModel = listModel;
    }
  }

  private static final Comparator<NodeNavigatable> DEFAULT_COMPARATOR = new Comparator<NodeNavigatable>() {
    @Override
    public int compare(NodeNavigatable o1, NodeNavigatable o2) {
      return getText(o1).compareTo(getText(o2));
    }

    private String getText(NodeNavigatable element) {
      return element.getNodePointer().toString();
    }
  };

  public GoToContextMenuHelper(@NotNull MPSProject project,
                               @NotNull String title,
                               @NotNull Comparator<NodeNavigatable> comparator,
                               @NotNull BaseRenderer renderer) {
    myProject = project;
    myTitle = title;
    myComparator = comparator;
    myRenderer = renderer;
    myNamerForNavigatable = new Function<NodeNavigatable, String>() {
      @Override
      public String fun(NodeNavigatable navigatable) {
        SNodeReference nodePointer = navigatable.getNodePointer();
        String name = new ModelComputeRunnable<>(new Computable<String>() {
          @Override
          public String compute() {
            SNode resolved = nodePointer.resolve(myProject.getRepository());
            //  invoke #getRoot#getName
            if (resolved != null) {
              return resolved.getName();
            }
            return nodePointer.toString();
          }
        }).runRead(myProject.getModelAccess());
        return name;
      }
    };
  }

  public GoToContextMenuHelper(@NotNull MPSProject project, @NotNull String title, @NotNull BaseRenderer renderer) {
    this(project, title, DEFAULT_COMPARATOR, renderer);
  }

  public static RelativePoint getRelativePoint(EditorCell selectedCell, InputEvent inputEvent) {
    if (inputEvent instanceof MouseEvent) {
      return new RelativePoint(((MouseEvent) inputEvent));
    }
    return new RelativePoint((EditorComponent) selectedCell.getEditorComponent(), new Point(selectedCell.getX(), selectedCell.getY()));
  }

  @NotNull
  public ContextMenuComposite showMenuWithNodes(@NotNull List<SNodeReference> nodes, @NotNull RelativePoint point) {
    SortedListModel<NodeNavigatable> model = new SortedListModel<>(myComparator);
    nodes.stream()
         .distinct()
         .map(new java.util.function.Function<SNodeReference, NodeNavigatable>() {
           @Override
           public NodeNavigatable apply(SNodeReference it) {
             return new NodeNavigatable(myProject, it);
           }
         })
         .forEach(new Consumer<NodeNavigatable>() {
           @Override
           public void accept(NodeNavigatable item) {
             model.add(item);
           }
         });

    ContextMenuComposite menu = buildPopup();
    menu.myJBList.setModel(model);
    menu.myPopup.show(point);
    return menu;
  }

  @NotNull
  public ContextMenuComposite buildPopup() {
    checkClassLoader();

    SortedListModel<NodeNavigatable> listModel = new SortedListModel<>(myComparator);
    final JBList<NodeNavigatable> list = new JBList<>(listModel);
    JBPopup popup = new PopupChooserBuilder<NodeNavigatable>(list).setTitle(myTitle).setMovable(true).setItemChoosenCallback(new Runnable() {
      @Override
      public void run() {
        int[] ids = list.getSelectedIndices();
        if (ids == null || ids.length == 0) {
          return;
        }
        for (NodeNavigatable selected : list.getSelectedValuesList()) {
          selected.navigate(true);
        }
      }
    }).setRenderer(myRenderer).setSelectionMode(ListSelectionModel.SINGLE_SELECTION).setNamerForFiltering(myNamerForNavigatable).createPopup();
    return new ContextMenuComposite(popup, list, listModel);
  }

  private static void checkClassLoader() {
    assert !(GoToHelper.class.getClassLoader() instanceof ModuleClassLoader) : "if this class is loaded by a reloadable classloader, this will cause memleaks. See MPS-13481";
  }
}
