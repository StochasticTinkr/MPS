package jetbrains.mps.ide.editor.util;

/*Generated by MPS */

import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.progress.PerformInBackgroundOption;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.progress.impl.BackgroundableProcessIndicator;
import com.intellij.openapi.ui.popup.JBPopup;
import com.intellij.ui.awt.RelativePoint;
import com.intellij.ui.components.JBList;
import com.intellij.util.Alarm;
import jetbrains.mps.ide.editor.util.renderer.DefaultMethodRenderer;
import jetbrains.mps.ide.findusages.findalgorithm.finders.IFinder;
import jetbrains.mps.ide.findusages.findalgorithm.finders.IFinder.FindCallback;
import jetbrains.mps.ide.findusages.findalgorithm.finders.IInterfacedFinder;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.ide.findusages.view.FindUtils;
import jetbrains.mps.ide.navigation.NodeNavigatable;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.util.Pair;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeReference;

import javax.swing.DefaultListModel;
import javax.swing.ListModel;
import javax.swing.SwingUtilities;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public final class GoToHelper {
  private GoToHelper() {
  }

  public static void executeFinders(final SNode node, final MPSProject mpsProject, final String title, final IInterfacedFinder finder, final RelativePoint relativePoint) {
    Pair<JBPopup, JBList<NodeNavigatable>> jbPopupJBListPair = GoToContextMenuUtil.showMenu(mpsProject, title,
                                                                                            Collections.emptyList(),
                                                                                            new DefaultMethodRenderer(mpsProject.getRepository()),
                                                                                            relativePoint);
    final JBPopup popup = jbPopupJBListPair.o1;
    final JBList<NodeNavigatable> list = jbPopupJBListPair.o2;
    DefaultListModel<NodeNavigatable> listModel = new DefaultListModel<>();
    list.setModel(listModel);
    Task.Backgroundable task = new Task.Backgroundable(mpsProject.getProject(), "Searching...", true, PerformInBackgroundOption.ALWAYS_BACKGROUND) {
      private final Alarm myAlarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);
      private final Object LOCK = new Object();
      private final List<NodeNavigatable> myCurrentResults = new ArrayList<>();

      public void run(@NotNull final ProgressIndicator indicator) {

        mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
          public void run() {
            // XXX I know cast to IFinder is stupid here, but it's the way to deal with checkTypeSystem test failures.
            // We desperately need a mechanism to match stub classes with their MPS origins.
            SearchQuery searchQuery = new SearchQuery(node, new GlobalScope(mpsProject.getRepository()));
            FindCallback callback = new FindCallback() {
              @Override
              public void onUsageFound(@NotNull SearchResult<?> result) {
                if (popup.isDisposed()) {
                  return;
                }
                Object object = result.getObject();
                if (object instanceof SNode) {
                  synchronized (LOCK) {
                    SNodeReference pointer = SNodeOperations.getPointer((SNode) object);
                    if (!myCurrentResults.add(new NodeNavigatable(mpsProject, pointer))) {
                      return;
                    }
                  }
                  myAlarm.addRequest(() -> {
                    myAlarm.cancelAllRequests();
                    refresh();
                  }, 100, ModalityState.stateForComponent(popup.getContent()));
                }
              }

              private void refresh() {
//                if (myCanceled) return;
                if (popup.isDisposed()) return;
                List<NodeNavigatable> newData;
                synchronized (LOCK) {
                  newData = new ArrayList<>(myCurrentResults);
                }
                for (NodeNavigatable newElement : newData) {
                  if (!listModel.contains(newElement)) {
                    listModel.addElement(newElement);
                  }
                }
                popup.pack(true, true);
              }
            };
            FindUtils.searchForResults(new ProgressMonitorAdapter(indicator),
                                                        callback,
                                                        searchQuery,
                                                        (IFinder) finder);
          }
        });
      }
    };
    ProgressManager.getInstance().run(task);
//    ProgressManager.getInstance().runProcessWithProgressAsynchronously(task, new BackgroundableProcessIndicator(task));
  }
}
