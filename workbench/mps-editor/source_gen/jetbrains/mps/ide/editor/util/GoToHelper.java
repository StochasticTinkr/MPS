package jetbrains.mps.ide.editor.util;

/*Generated by MPS */

import com.intellij.find.FindBundle;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.progress.PerformInBackgroundOption;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.progress.Task.Backgroundable;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.ui.popup.JBPopup;
import com.intellij.openapi.util.Ref;
import com.intellij.ui.SortedListModel;
import com.intellij.ui.awt.RelativePoint;
import com.intellij.ui.components.JBList;
import com.intellij.util.Alarm;
import jetbrains.mps.ide.editor.util.GoToContextMenuHelper.ContextMenuComposite;
import jetbrains.mps.ide.editor.util.renderer.DefaultMethodRenderer;
import jetbrains.mps.ide.findusages.findalgorithm.finders.Finder;
import jetbrains.mps.ide.findusages.findalgorithm.finders.IFinder;
import jetbrains.mps.ide.findusages.findalgorithm.finders.IFinder.FindCallback;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.ide.findusages.view.FindUtils;
import jetbrains.mps.ide.navigation.NodeNavigatable;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.util.Computable;
import jetbrains.mps.util.ModelComputeRunnable;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.module.ModelAccess;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public final class GoToHelper {
  private GoToHelper() {
  }

  public static abstract class BackgroundSearchTask extends Backgroundable {
    private final MPSProject myMPSProject;
    private final SearchQuery myQuery;
    private final List<Finder> myFinders;
    private volatile boolean myCancelled = false;

    BackgroundSearchTask(@NotNull MPSProject project, @NotNull SearchQuery query, @NotNull List<Finder> finders, @NotNull String title) {
      super(project.getProject(), title, true, PerformInBackgroundOption.ALWAYS_BACKGROUND);
      myMPSProject = project;
      myQuery = query;
      myFinders = finders;
    }

    @Override
    public final void onCancel() {
      myCancelled = true;
    }

    public final boolean isCancelled() {
      return myCancelled;
    }

    public abstract void onUsageFound(@NotNull SearchResult<?> result);

    @Override
    public void run(@NotNull ProgressIndicator indicator) {
      myMPSProject.getRepository().getModelAccess().runReadAction(new Runnable() {
        @Override
        public void run() {
          FindCallback callback = new FindCallback() {
            @Override
            public void onUsageFound(@NotNull SearchResult<?> result) {
              BackgroundSearchTask.this.onUsageFound(result);
            }
          };
          FindUtils.searchForResults(new ProgressMonitorAdapter(indicator),
                                     callback,
                                     myQuery,
                                     myFinders.toArray(new IFinder[0]));
        }
      });
    }
  }

  public static void showPopupAndSearchInBackground(final SearchQuery query,
                                                    final MPSProject mpsProject,
                                                    final String title,
                                                    final Finder finder,
                                                    final RelativePoint relativePoint,
                                                    final List<SNodeReference> resultsAlreadyFound) {
    if (resultsAlreadyFound.isEmpty()) {

    }
  }

  public static void showPopupAndSearchNodeInBackground(final SNode node,
                                                        final MPSProject project,
                                                        final String title,
                                                        final Finder finder,
                                                        final RelativePoint point) {


    ModelAccess modelAccess = project.getRepository().getModelAccess();
    SearchQuery query = new ModelComputeRunnable<>(new Computable<SearchQuery>() {
      @Override
      public SearchQuery compute() {
        return new SearchQuery(node, new GlobalScope(project.getRepository()));
      }
    }).runRead(modelAccess);
    showPopupAndSearchInBackground(query, project, title, finder, point);
  }

  public static void showPopupAndSearchInBackground(final SearchQuery query,
                                                    final MPSProject mpsProject,
                                                    final String title,
                                                    final Finder finder,
                                                    final RelativePoint relativePoint) {
    DefaultMethodRenderer renderer = new DefaultMethodRenderer(mpsProject.getRepository());
    ContextMenuComposite contextMenuComposite = new GoToContextMenuHelper(mpsProject, title, renderer).buildPopup();
    final JBPopup popup = contextMenuComposite.myPopup;
    final JBList<NodeNavigatable> list = contextMenuComposite.myJBList;
    list.setPaintBusy(true);
    Task.Backgroundable task = new BackgroundSearchTask(mpsProject, query, Collections.singletonList(finder), "Searching...") {
      private final Alarm myAlarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);
      private final Ref<Boolean> myShown = new Ref<>(false);
      private final Object LOCK = new Object();
      private final List<NodeNavigatable> myCurrentResults = new ArrayList<>();

      @Override
      public void onUsageFound(@NotNull SearchResult<?> result) {
        if (popup.isDisposed()) {
          return;
        }
        Object object = result.getObject();
        if (object instanceof SNode) {
          synchronized (LOCK) {
            SNodeReference pointer = SNodeOperations.getPointer((SNode) object);
            if (!myCurrentResults.add(new NodeNavigatable(mpsProject, pointer))) {
              return;
            }
          }
          myAlarm.addRequest(new Runnable() {
            @Override
            public void run() {
              myAlarm.cancelAllRequests();
              refresh();
            }
          }, 50, ModalityState.stateForComponent(popup.getContent()));
        }
      }

      private void refresh() {
        if (isCancelled()) return;
        if (popup.isDisposed()) return;
        List<NodeNavigatable> newData;
        synchronized (LOCK) {
          newData = new ArrayList<>(myCurrentResults);
        }
        for (NodeNavigatable newElement : newData) {
          SortedListModel<NodeNavigatable> listModel = contextMenuComposite.myListModel;
          if (!listModel.getItems().contains(newElement)) {
            listModel.add(newElement);
          }
        }
        popup.pack(true, true);
        if (!myShown.get()) {
          myShown.set(true);
          popup.show(relativePoint);
        }
      }

      @Override
      public void onFinished() {
        if (isCancelled()) return;
        if (popup.isDisposed()) return;
        list.setPaintBusy(false);
        if (myCurrentResults.isEmpty()) {
          Messages.showInfoMessage(relativePoint.getComponent(), FindBundle.message("find.usage.view.no.usages.text"), FindBundle.message("find.pointcut.applications.not.found.title"));
        }
        if (myCurrentResults.size() == 1) {
          popup.cancel();
          NodeNavigatable navigatable = myCurrentResults.get(0);
          navigatable.navigate(true);
        }
      }
    };
    ProgressManager.getInstance().run(task);
  }
}
