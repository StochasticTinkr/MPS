package jetbrains.mps.ide.editor.util;

/*Generated by MPS */

import com.intellij.openapi.ui.popup.JBPopup;
import com.intellij.ui.components.JBList;
import jetbrains.mps.ide.navigation.NodeNavigatable;
import com.intellij.ui.SortedListModel;
import com.intellij.util.Alarm;
import com.intellij.openapi.util.Ref;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.ide.findusages.model.SearchResult;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeReference;
import com.intellij.openapi.application.ModalityState;

public class BackgroundSearchWithPopupTask extends BackgroundSearchTask {
  private final JBPopup myPopup;
  private final PopupSettingsBuilder mySettings;
  private final JBList<NodeNavigatable> myList;
  private final SortedListModel<NodeNavigatable> myListModel;
  private final Alarm myAlarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);
  private final Ref<Boolean> myShown = new Ref<Boolean>(false);
  private final Object LOCK = new Object();
  private final List<NodeNavigatable> myCurrentResults = new ArrayList<NodeNavigatable>();
  private volatile boolean myFinished = false;

  public BackgroundSearchWithPopupTask(@NotNull PopupSettingsBuilder settings) {
    super(settings.myProject, settings.query, settings.finders, "Searching...");
    mySettings = settings;
    final GoToContextMenuHelper.ContextMenuComposite contextMenuComposite = new GoToContextMenuHelper(settings.myProject, settings.captionFun, settings.renderer, settings.comparator, settings.nameFilter).buildPopup();
    myPopup = contextMenuComposite.myPopup;
    myList = contextMenuComposite.myJBList;
    myListModel = contextMenuComposite.myListModel;
  }

  @Override
  public void run(@NotNull final ProgressIndicator indicator) {
    myList.setPaintBusy(true);
    super.run(indicator);
  }

  @Override
  public void onUsageFound(@NotNull SearchResult<?> result) {
    if (myPopup.isDisposed()) {
      return;
    }
    Object object = result.getObject();
    if (object instanceof SNode) {
      synchronized (LOCK) {
        SNodeReference pointer = ((SNode) object).getReference();
        if (!(myCurrentResults.add(new NodeNavigatable(mySettings.myProject, pointer)))) {
          return;
        }
      }
      myAlarm.addRequest(new Runnable() {
        @Override
        public void run() {
          myAlarm.cancelAllRequests();
          refresh();
        }
      }, 50, ModalityState.stateForComponent(myPopup.getContent()));
    }
  }

  private void refresh() {
    if (isCancelled()) {
      return;
    }
    if (myPopup.isDisposed()) {
      return;
    }
    final List<NodeNavigatable> newData;
    synchronized (LOCK) {
      newData = new ArrayList<NodeNavigatable>(myCurrentResults);
    }
    mySettings.myProject.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (NodeNavigatable newElement : newData) {
          SortedListModel<NodeNavigatable> listModel = myListModel;
          if (!(listModel.getItems().contains(newElement))) {
            listModel.add(newElement);
          }
        }
      }
    });
    String newCaption = mySettings.captionFun.caption(myCurrentResults.size(), myFinished);
    myPopup.setCaption(newCaption);
    myPopup.pack(true, true);
    if (!(myShown.get())) {
      myShown.set(true);
      myPopup.show(mySettings.point);
    }
  }

  @Override
  public void onFinished() {
    if (isCancelled()) {
      return;
    }
    if (myPopup.isDisposed()) {
      return;
    }
    myFinished = true;
    if (myCurrentResults.isEmpty()) {
    } else if (myCurrentResults.size() == 1) {
      myPopup.cancel();
      NodeNavigatable navigatable = myCurrentResults.get(0);
      navigatable.navigate(true);
    } else {
      refresh();
      myList.setPaintBusy(false);
    }
  }
}
