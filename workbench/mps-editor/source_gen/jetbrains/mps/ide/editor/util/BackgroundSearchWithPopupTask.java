package jetbrains.mps.ide.editor.util;

/*Generated by MPS */

import com.intellij.openapi.ui.popup.JBPopup;
import com.intellij.ui.components.JBList;
import jetbrains.mps.ide.navigation.NamedNodeNavigatable;
import jetbrains.mps.ide.navigation.NodeNavigatable;
import com.intellij.ui.SortedListModel;
import com.intellij.util.Alarm;
import com.intellij.openapi.util.Ref;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.ide.findusages.model.SearchResult;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeReference;
import com.intellij.openapi.application.ModalityState;

public class BackgroundSearchWithPopupTask extends BackgroundSearchTask {
  private final JBPopup myPopup;
  private final PopupSettingsBuilder mySettings;
  private final JBList<NodeNavigatable> myList;
  private final SortedListModel<NodeNavigatable> myListModel;
  private final Alarm myAlarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);
  private final Ref<Boolean> myShown = new Ref<Boolean>(false);
  private final Object LOCK = new Object();
  private final BlockingQueue<NamedNodeNavigatable> myResults = new LinkedBlockingQueue<>();
  private final List<NamedNodeNavigatable> myResultList = new ArrayList<>();
  private volatile boolean myFinished = false;

  public BackgroundSearchWithPopupTask(@NotNull PopupSettingsBuilder settings) {
    super(settings.myProject, settings.query, settings.finders, "Searching...");
    mySettings = settings;
    final GoToContextMenuHelper.ContextMenuComposite contextMenuComposite = new GoToContextMenuHelper(settings.myProject, settings.captionFun, settings.renderer, settings.comparator, settings.nameFilter).buildPopup();
    myPopup = contextMenuComposite.myPopup;
    myList = contextMenuComposite.myJBList;
    myListModel = contextMenuComposite.myListModel;
  }

  @Override
  public void run(@NotNull final ProgressIndicator indicator) {
    myList.setPaintBusy(true);
    super.run(indicator);
  }

  @Override
  public void onUsageFound(@NotNull SearchResult<?> result) {
    if (myPopup.isDisposed()) {
      return;
    }
    Object object = result.getObject();
    if (object instanceof SNode) {
      SNodeReference pointer = ((SNode) object).getReference();
      assert ModelAccess.instance().canRead();
      NamedNodeNavigatable newNamedNV = new NamedNodeNavigatable(mySettings.myProject, pointer, getName(pointer));
      if (!(myResults.add(newNamedNV))) {
        return;
      }
      myResultList.add(newNamedNV);
      myAlarm.addRequest(new Runnable() {
        @Override
        public void run() {
          myAlarm.cancelAllRequests();
          refresh();
        }
      }, 100, ModalityState.stateForComponent(myPopup.getContent()));
    }
  }

  @NotNull
  private String getName(SNodeReference pointer) {
    return mySettings.nameFilter.fun(pointer);
  }

  private void refresh() {
    if (isCancelled()) {
      return;
    }
    if (myPopup.isDisposed()) {
      return;
    }
    String newCaption = mySettings.captionFun.caption(myResultList.size(), myFinished);
    myPopup.setCaption(newCaption);
    myPopup.pack(true, true);
    if (!(myShown.get())) {
      myShown.set(true);
      myPopup.show(mySettings.point);
    }
    mySettings.myProject.getModelAccess().runReadAction(new Runnable() {
                                                          @Override
                                                          public void run() {
                                                            List<NodeNavigatable> items = new ArrayList<>();
                                                            myResults.drainTo(items);
                                                            myListModel.addAll(items);
                                                          }
                                                        });
  }

  @Override
  public void onFinished() {
    if (isCancelled()) {
      return;
    }
    if (myPopup.isDisposed()) {
      return;
    }
    myFinished = true;
    if (myResultList.isEmpty()) {
    } else if (myResultList.size() == 1) {
      myPopup.cancel();
      NodeNavigatable navigatable = myResultList.get(0);
      navigatable.navigate(true);
    } else {
      refresh();
      myList.setPaintBusy(false);
    }
  }
}
