package jetbrains.mps.ide.editor.actions;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.editor.runtime.cells.ReadOnlyUtil;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import java.util.Iterator;
import jetbrains.mps.nodeEditor.cells.EditorCell_Component;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.cells.APICellAdapter;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import jetbrains.mps.nodeEditor.ChildrenCollectionFinder;
import jetbrains.mps.openapi.editor.ActionHandler;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.util.SNodeOperations;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SNode;

public class EditorActionUtils {
  public EditorActionUtils() {
  }
  /*package*/ static boolean isReadonlyActionEnabled(EditorComponent editorComponent) {
    return !(editorComponent.getNodeSubstituteChooser().isVisible()) && editorComponent.getSelectionManager().getSelection() != null;
  }
  public static boolean isWriteActionEnabled(EditorComponent editorComponent, Iterable<EditorCell> changingCells) {
    if (!(isReadonlyActionEnabled(editorComponent))) {
      return false;
    }
    return !(ReadOnlyUtil.isCellsReadOnlyInEditor(editorComponent, changingCells));
  }
  /*package*/ static EditorCell getEditorCellToInsert(EditorComponent editorComponent) {
    Selection selection = editorComponent.getSelectionManager().getSelection();
    // TODO: remove this limitation 
    if (!(selection instanceof SingularSelection)) {
      return null;
    }
    Iterator<EditorCell> iterator = selection.getSelectedCells().iterator();
    if (!(iterator.hasNext())) {
      return null;
    }
    EditorCell editorCell = iterator.next();
    return (editorCell instanceof EditorCell_Component ? null : editorCell);
  }
  /**
   * Should be executed inside write action as it reads and modifies a model, 
   * and ActionHandler may want to grap command, therefore, model read won't suffice.
   */
  public static void callInsertAction(@NotNull EditorCell cell) {
    if (cell.isErrorState() && APICellAdapter.validate(cell, false, true)) {
      return;
    }
    EditorActionUtils.callAction(cell, CellActionType.INSERT, true);
  }

  /**
   * Expects model read lock
   */
  public static EditorCell getSiblingCollectionForInsert(@NotNull EditorCell cell, boolean forward) {
    // TODO FIXME rewrite without hasSingleRolesAtLeftBoundary, cleanup ChildrenCollectionFinder 
    EditorCell nextLeaf = (forward ? CellTraversalUtil.getNextLeaf(cell) : CellTraversalUtil.getPrevLeaf(cell));

    if ((cell.isBig() || GeometryUtil.isLastPositionInBigCell(cell)) && ((forward ? hasSingleRolesAtRightBoundary(cell) : hasSingleRolesAtLeftBoundary(cell))) && nextLeaf != null) {
      // Looking for the next child collection in parents 
      return new ChildrenCollectionFinder(nextLeaf, cell, forward, true).find();
    }
    return null;
  }
  /**
   * Should be executed inside write action, see {@link jetbrains.mps.ide.editor.actions.EditorActionUtils#callInsertAction(EditorCell) } for details
   */
  public static void callInsertBeforeAction(@NotNull EditorCell cell) {
    if (cell.isErrorState() && APICellAdapter.validate(cell, true, true)) {
      return;
    }
    EditorActionUtils.callAction(cell, CellActionType.INSERT_BEFORE, false);
  }


  private static void callAction(EditorCell cell, CellActionType cellAction, boolean after) {
    ActionHandler actionHandler = cell.getEditorComponent().getActionHandler();
    if (cell instanceof EditorCell_Label && !(isLinkCollection(cell))) {
      // Looking for the next child collection to the right from this cell 
      EditorCell cellWithRole = new ChildrenCollectionFinder(cell, after, false).find();
      if (cellWithRole == null) {
        // Looking for the next child collection in parents 
        cellWithRole = getSiblingCollectionForInsert(cell, after);
      }
      if (cellWithRole != null && actionHandler.executeAction(cellWithRole, cellAction)) {
        return;
      }
    }
    actionHandler.executeAction(cell, cellAction);
  }


  /**
   * Should be executed inside read action
   */
  public static void callInsertPlaceholderAction(@NotNull EditorCell cell) {
    EditorActionUtils.callAction(cell, CellActionType.INSERT_PLACEHOLDER, true);
  }
  /**
   * Should be executed inside read action
   */
  public static void callInsertPlaceholderBeforeAction(@NotNull EditorCell cell) {
    EditorActionUtils.callAction(cell, CellActionType.INSERT_PLACEHOLDER_BEFORE, false);
  }

  /**
   * We can use this method to determine if we should redispatch insert event to the corresponding
   * child collection below the cell returned from cell.getNextLeaf() or we should go on and insert
   * next child into a collection containing cell itself.
   * 
   * @return true if we should redispatch insert event to the next leaft cell
   */
  private static boolean hasSingleRolesAtRightBoundary(EditorCell cell) {
    if (!(hasSingleRole(cell))) {
      return false;
    }

    if (isOnRightBoundary(cell)) {
      EditorCell_Collection parentCell = cell.getParent();
      if (parentCell != null) {
        EditorCell nextLeaf = CellTraversalUtil.getNextLeaf(cell);
        if (nextLeaf != null && SNodeOperations.isAncestor(parentCell.getSNode(), nextLeaf.getSNode())) {
          return true;
        }
        return hasSingleRolesAtRightBoundary(parentCell);
      }
    }
    return true;
  }
  /**
   * We can use this method to determine if we should redispatch insert event to the corresponding
   * child collection below the cell returned from cell.getPrevLeaf() or we should go on and insert
   * prev. child into a collection containing cell itself
   * 
   * @return true if we should redispatch insert event to the prev. leaft cell
   */
  private static boolean hasSingleRolesAtLeftBoundary(EditorCell cell) {
    if (!(hasSingleRole(cell))) {
      return false;
    }

    if (isOnLeftBoundary(cell)) {
      EditorCell_Collection parentCell = cell.getParent();
      if (parentCell != null) {
        EditorCell prevLeaf = CellTraversalUtil.getPrevLeaf(cell);
        if (prevLeaf != null && SNodeOperations.isAncestor(parentCell.getSNode(), prevLeaf.getSNode())) {
          return true;
        }
        return hasSingleRolesAtLeftBoundary((EditorCell) parentCell);
      }
    }
    return true;
  }
  public static boolean isOnLeftBoundary(EditorCell cell) {
    EditorCell prevLeaf = CellTraversalUtil.getPrevLeaf(cell);
    return prevLeaf == null || prevLeaf.getSNode() != cell.getSNode();
  }
  public static boolean isOnRightBoundary(EditorCell cell) {
    EditorCell nextLeaf = CellTraversalUtil.getNextLeaf(cell);
    return nextLeaf == null || nextLeaf.getSNode() != cell.getSNode();
  }
  private static boolean hasSingleRole(EditorCell cell) {
    SContainmentLink l = jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.getContainingLink(((SNode) cell.getSNode()));
    return l != null && l.isValid() && !(l.isMultiple());
  }
  private static boolean isLinkCollection(EditorCell cell) {
    return cell.getRole() != null;
  }
}
