package jetbrains.mps.ide.editor.actions;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.ReflectiveHintsManager;
import jetbrains.mps.openapi.editor.EditorComponent;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Collections;
import java.util.Arrays;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.actionSystem.AnActionEvent;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import jetbrains.mps.openapi.editor.selection.Selection;

/*package*/ class ReflectiveEditorUtil {

  private static class HintsAdapter implements ReflectiveHintsManager.ReflectiveHintsProvider {

    private EditorComponent myEditorComponent;

    public HintsAdapter(EditorComponent editorComponent) {
      myEditorComponent = editorComponent;
    }

    private List<String> getExplicitEditorHintsForNode(SNode node) {
      String[] explicitEditorHintsForNode = myEditorComponent.getUpdater().getExplicitEditorHintsForNode(node.getReference());
      if (explicitEditorHintsForNode == null) {
        return Collections.emptyList();
      } else {
        return Arrays.asList(explicitEditorHintsForNode);
      }
    }

    @Nullable
    @Override
    public String getHint(@NotNull SNode node) {
      List<String> hints = getExplicitEditorHintsForNode(node);
      if (hints.contains("jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditor")) {
        return "jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditor";
      } else if (hints.contains("jetbrains.mps.lang.core.editor.BaseEditorContextHints.noReflectiveEditor")) {
        return "jetbrains.mps.lang.core.editor.BaseEditorContextHints.noReflectiveEditor";
      } else if (hints.contains("jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditorForNode")) {
        return "jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditorForNode";
      } else if (hints.contains("jetbrains.mps.lang.core.editor.BaseEditorContextHints.noReflectiveEditorForNode")) {
        return "jetbrains.mps.lang.core.editor.BaseEditorContextHints.noReflectiveEditorForNode";
      } else {
        return null;
      }
    }

    @Override
    public void setHint(@NotNull SNode node, @Nullable String string) {
      myEditorComponent.getUpdater().removeExplicitEditorHintsForNode(node.getReference(), "jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditor", "jetbrains.mps.lang.core.editor.BaseEditorContextHints.noReflectiveEditor", "jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditorForNode", "jetbrains.mps.lang.core.editor.BaseEditorContextHints.noReflectiveEditorForNode");
      if (string != null) {
        myEditorComponent.getUpdater().addExplicitEditorHintsForNode(node.getReference(), string);
      }
    }
  }

  public static boolean isApplicable(AnActionEvent event, List<SNode> selectedNodes, EditorComponent editorComponent, boolean isReflective, boolean isForManyNodes) {

    if (!(isForManyNodes) && selectedNodes.size() > 1) {
      return false;
    }

    ReflectiveHintsManager manager = new ReflectiveHintsManager(new ReflectiveEditorUtil.HintsAdapter(editorComponent));

    boolean canMake = false;
    if (isForManyNodes) {
      for (SNode node : selectedNodes) {
        if (manager.canMakeSubtree(isReflective, node)) {
          canMake = true;
          break;
        }
      }
    } else {
      canMake = manager.canMakeNode(isReflective, selectedNodes.get(0));
    }

    if (canMake) {
      String plurality = (isForManyNodes ? ("s for Subtree" + ((selectedNodes.size() > 1 ? "+" : ""))) : "");
      String caption = String.format("Show %s Editor%s", (isReflective ? "Reflective" : "Regular"), plurality);
      event.getPresentation().setText(caption);
      return true;
    }

    return false;
  }

  public static void execute(AnActionEvent event, List<SNode> selectedNodes, EditorComponent editorComponent, boolean isReflective, boolean isForManyNodes) {

    ReflectiveHintsManager manager = new ReflectiveHintsManager(new ReflectiveEditorUtil.HintsAdapter(editorComponent));
    if (isForManyNodes) {
      for (SNode node : selectedNodes) {
        if (manager.canMakeSubtree(isReflective, node)) {
          manager.makeSubtree(isReflective, node);
        }
      }
    } else {
      manager.makeNode(isReflective, selectedNodes.get(0));
    }

    editorComponent.rebuildEditorContent();
    editorComponent.getEditorContext().flushEvents();

    if (selectedNodes.size() > 1) {
      SelectionManager selectionManager = editorComponent.getEditorContext().getSelectionManager();
      Selection selection = selectionManager.createRangeSelection(selectedNodes.get(0), selectedNodes.get(selectedNodes.size() - 1));
      selectionManager.setSelection(selection);
    } else {
      editorComponent.getSelectionManager().setSelection(selectedNodes.get(0));
    }
  }

}
