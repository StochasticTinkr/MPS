package jetbrains.mps.ide.newSolutionDialog;

/*Generated by MPS */

import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.project.persistence.SolutionDescriptorPersistence;
import jetbrains.mps.util.MacrosFactory;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.library.ModulesMiner;
import jetbrains.mps.util.ReferenceUpdater;
import java.util.function.Consumer;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.project.structure.modules.LanguageDescriptor;
import jetbrains.mps.project.persistence.LanguageDescriptorPersistence;
import java.util.Iterator;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.List;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.extapi.persistence.CloneableModelRoot;
import org.apache.log4j.Level;
import jetbrains.mps.extapi.persistence.CloneCapabilities;
import jetbrains.mps.extapi.persistence.ModelRootBase;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.Collection;
import jetbrains.mps.project.structure.model.ModelRootDescriptor;
import org.jetbrains.mps.openapi.persistence.Memento;
import jetbrains.mps.persistence.MementoImpl;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.util.PathConverters;
import jetbrains.mps.project.structure.modules.GeneratorDescriptor;
import jetbrains.mps.project.structure.modules.mappingpriorities.MappingPriorityRule;
import jetbrains.mps.project.structure.modules.Dependency;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.project.structure.modules.ModuleFacetDescriptor;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.extapi.persistence.FileDataSource;

public class CloneModuleUtil {

  public static AbstractModule cloneModule(String namespace, String rootPath, Project project, final AbstractModule sourceModule, String extenstion) {
    return NewModuleUtil.createModule(extenstion, namespace, rootPath, project, new _FunctionTypes._return_P3_E0<AbstractModule, String, IFile, Project>() {
      public AbstractModule invoke(String s, IFile f, Project p) {
        return createClonedModule(s, f, p, sourceModule);
      }
    });
  }

  private static AbstractModule createClonedModule(String namespace, IFile targetDescriptorFile, MPSModuleOwner moduleOwner, AbstractModule sourceModule) {
    if (sourceModule instanceof Solution) {
      return createClonedSolution(namespace, targetDescriptorFile, moduleOwner, as_iwu1g5_a3a0a0a3(sourceModule, Solution.class));
    }
    if (sourceModule instanceof Language) {
      return createClonedLanguage(namespace, targetDescriptorFile, moduleOwner, as_iwu1g5_a3a0a1a3(sourceModule, Language.class));
    }
    throw new IllegalArgumentException("Unknown module " + sourceModule.getModuleName());
  }

  private static Solution createClonedSolution(String namespace, IFile targetDescriptorFile, MPSModuleOwner moduleOwner, final Solution sourceSolution) {
    SolutionDescriptor targetDescriptor = createClonedSolutionDescriptor(namespace, targetDescriptorFile, sourceSolution);

    SolutionDescriptorPersistence.saveSolutionDescriptor(targetDescriptorFile, targetDescriptor, MacrosFactory.forModuleFile(targetDescriptorFile));

    final Solution targetSolution = (Solution) ModuleRepositoryFacade.createModule(new ModulesMiner().loadModuleHandle(targetDescriptorFile), moduleOwner);

    cloneModels(targetSolution, sourceSolution);

    ReferenceUpdater referenceUpdater = new ReferenceUpdater();
    referenceUpdater.addModuleToAdjust(sourceSolution, targetSolution, true);
    referenceUpdater.adjust();

    targetSolution.getModels().forEach(new Consumer<SModel>() {
      public void accept(SModel it) {
        tryRenameModel(it, sourceSolution.getModuleName(), targetSolution.getModuleName());
      }
    });

    return targetSolution;
  }

  private static Language createClonedLanguage(String namespace, IFile targetDescriptorFile, MPSModuleOwner moduleOwner, Language sourceLanguage) {
    LanguageDescriptor targetDescriptor = createClonedLanguageDescriptor(namespace, targetDescriptorFile, sourceLanguage);

    LanguageDescriptorPersistence.saveLanguageDescriptor(targetDescriptorFile, targetDescriptor, MacrosFactory.forModuleFile(targetDescriptorFile));

    Language targetLanguage = (Language) ModuleRepositoryFacade.createModule(new ModulesMiner().loadModuleHandle(targetDescriptorFile), moduleOwner);

    ReferenceUpdater referenceUpdater = new ReferenceUpdater();

    cloneModels(targetLanguage, sourceLanguage);
    referenceUpdater.addModuleToAdjust(sourceLanguage, targetLanguage, true);

    Iterator<Generator> targetGenerators = targetLanguage.getGenerators().iterator();
    Iterator<Generator> sourceGenerators = sourceLanguage.getGenerators().iterator();

    while (sourceGenerators.hasNext()) {
      Generator targetGenerator = targetGenerators.next();
      Generator sourceGenerator = sourceGenerators.next();

      cloneModels(targetGenerator, sourceGenerator);
      referenceUpdater.addModuleToAdjust(sourceGenerator, targetGenerator, true);
    }
    referenceUpdater.adjust();

    for (SModel model : ListSequence.fromList(targetLanguage.getModels())) {
      tryRenameModel(model, sourceLanguage.getModuleName(), targetLanguage.getModuleName());
    }

    for (Generator generator : CollectionSequence.fromCollection(targetLanguage.getGenerators())) {
      for (SModel model : ListSequence.fromList(generator.getModels())) {
        tryRenameModel(model, sourceLanguage.getModuleName(), targetLanguage.getModuleName());
      }
    }

    return targetLanguage;
  }

  protected static Logger LOG = LogManager.getLogger(CloneModuleUtil.class);
  public static void cloneModels(AbstractModule targetModule, AbstractModule sourceModule) {
    List<ModelRoot> targetModelRoots = ListSequence.fromList(new ArrayList<ModelRoot>());

    for (ModelRoot sourceModelRoot : Sequence.fromIterable(sourceModule.getModelRoots())) {

      if (!(sourceModelRoot instanceof CloneableModelRoot)) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("model root " + sourceModelRoot + " doesn't support clonning");
        }
        continue;
      }
      CloneCapabilities capabilities = ((CloneableModelRoot) sourceModelRoot).getCloneCapabilities();
      if (!(capabilities.isCloneable())) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("model root " + sourceModelRoot + " doesn't support clonning : " + capabilities.getErrorMessage());
        }
        continue;
      }

      ModelRootBase targetModelRoot = (ModelRootBase) PersistenceFacade.getInstance().getModelRootFactory(sourceModelRoot.getType()).create();

      targetModelRoot.setModule(targetModule);
      ((CloneableModelRoot) sourceModelRoot).cloneTo(targetModelRoot);
      ListSequence.fromList(targetModelRoots).addElement(targetModelRoot);
    }

    ModuleDescriptor targetDescriptor = targetModule.getModuleDescriptor();
    Collection<ModelRootDescriptor> modelRootDescriptors = targetDescriptor.getModelRootDescriptors();
    for (ModelRoot targetModelRoot : ListSequence.fromList(targetModelRoots)) {
      Memento targetMemento = new MementoImpl();
      targetModelRoot.save(targetMemento);
      modelRootDescriptors.add(new ModelRootDescriptor(targetModelRoot.getType(), targetMemento));
    }
    targetModule.setModuleDescriptor(targetDescriptor);
  }

  private static SolutionDescriptor createClonedSolutionDescriptor(String namespace, IFile descriptorFile, Solution sourceSolution) {
    SolutionDescriptor targerDescriptor = new SolutionDescriptor();
    targerDescriptor.setNamespace(namespace);
    targerDescriptor.setId(ModuleId.regular());
    if (descriptorFile.getParent().getChildren().size() > 1) {
      throw new IllegalStateException("Trying to clone a solution to a not empty directory:" + descriptorFile.getParent());
    }

    cloneSolutionDescriptorInfo(targerDescriptor, descriptorFile, sourceSolution.getModuleDescriptor(), sourceSolution.getDescriptorFile());

    return targerDescriptor;
  }

  private static LanguageDescriptor createClonedLanguageDescriptor(String namespace, IFile descriptorFile, Language sourceLanguage) {
    LanguageDescriptor targetDescriptor = new LanguageDescriptor();
    targetDescriptor.setNamespace(namespace);
    targetDescriptor.setId(ModuleId.regular());
    if (descriptorFile.getParent().getChildren().size() > 1) {
      throw new IllegalStateException("Trying to clone a language to a not empty directory:" + descriptorFile.getParent());
    }

    cloneLanguageDescriptorInfo(targetDescriptor, descriptorFile, sourceLanguage.getModuleDescriptor(), sourceLanguage.getDescriptorFile());

    return targetDescriptor;
  }

  private static void cloneSolutionDescriptorInfo(SolutionDescriptor targetDescriptor, IFile targetDescriptorFile, SolutionDescriptor sourceDescriptor, IFile sourceDescriptorFile) {
    cloneModuleDescriptorInfo(targetDescriptor, sourceDescriptor);

    targetDescriptor.setKind(sourceDescriptor.getKind());
    targetDescriptor.setCompileInMPS(sourceDescriptor.getCompileInMPS());
    targetDescriptor.setOutputPath(PathConverters.forDescriptorFiles(targetDescriptorFile, sourceDescriptorFile).sourceToDestination(sourceDescriptor.getOutputPath()));
  }

  private static void cloneLanguageDescriptorInfo(LanguageDescriptor targetDescriptor, IFile targetDescriptorFile, LanguageDescriptor sourceDescriptor, IFile sourceDescriptorFile) {
    cloneModuleDescriptorInfo(targetDescriptor, sourceDescriptor);

    targetDescriptor.setLanguageVersion(sourceDescriptor.getLanguageVersion());
    targetDescriptor.setGenPath(PathConverters.forDescriptorFiles(targetDescriptorFile, sourceDescriptorFile).sourceToDestination(sourceDescriptor.getGenPath()));

    targetDescriptor.getAccessoryModels().clear();
    targetDescriptor.getAccessoryModels().addAll(sourceDescriptor.getAccessoryModels());

    targetDescriptor.getRuntimeModules().clear();
    targetDescriptor.getRuntimeModules().addAll(sourceDescriptor.getRuntimeModules());

    targetDescriptor.getExtendedLanguages().clear();
    targetDescriptor.getExtendedLanguages().addAll(sourceDescriptor.getExtendedLanguages());

    List<GeneratorDescriptor> targetGenerators = targetDescriptor.getGenerators();
    for (GeneratorDescriptor sourceGenerator : ListSequence.fromList(sourceDescriptor.getGenerators())) {
      GeneratorDescriptor targetGenerator = new GeneratorDescriptor();

      // similiar to Generator.generateGeneratorUID(Language) 
      String targetGeneratorUID = targetDescriptor.getNamespace() + "#" + jetbrains.mps.smodel.SModel.generateUniqueId();

      targetGenerator.setGeneratorUID(targetGeneratorUID);
      cloneGeneratorDescriptorInfo(targetGenerator, sourceGenerator);

      targetGenerators.add(targetGenerator);
    }
  }

  private static void cloneGeneratorDescriptorInfo(GeneratorDescriptor targetDescriptor, GeneratorDescriptor sourceDescriptor) {
    cloneModuleDescriptorInfo(targetDescriptor, sourceDescriptor);

    targetDescriptor.setGenerateTemplates(sourceDescriptor.isGenerateTemplates());
    targetDescriptor.setReflectiveQueries(sourceDescriptor.isReflectiveQueries());

    targetDescriptor.getDepGenerators().clear();
    targetDescriptor.getDepGenerators().addAll(sourceDescriptor.getDepGenerators());

    List<MappingPriorityRule> targetMappingPriorityRules = targetDescriptor.getPriorityRules();
    targetMappingPriorityRules.clear();
    for (MappingPriorityRule sourceMappingPriorityRule : ListSequence.fromList(sourceDescriptor.getPriorityRules())) {
      targetMappingPriorityRules.add(sourceMappingPriorityRule.getCopy());
    }
  }

  private static void cloneModuleDescriptorInfo(ModuleDescriptor targetDescriptor, ModuleDescriptor sourceDescriptor) {

    targetDescriptor.setModuleVersion(sourceDescriptor.getModuleVersion());
    targetDescriptor.setUseTransientOutput(sourceDescriptor.isUseTransientOutput());

    Collection<Dependency> sourceDependencies = sourceDescriptor.getDependencies();
    Collection<Dependency> targetDependencies = targetDescriptor.getDependencies();

    Map<SModuleReference, Integer> sourceDependencyVersions = sourceDescriptor.getDependencyVersions();
    Map<SModuleReference, Integer> targetDependencyVersions = targetDescriptor.getDependencyVersions();

    targetDependencies.clear();
    targetDependencyVersions.clear();

    for (Dependency dependency : CollectionSequence.fromCollection(sourceDependencies)) {
      SModuleReference moduleRef = dependency.getModuleRef();
      targetDependencies.add(dependency.getCopy());
      targetDependencyVersions.put(moduleRef, sourceDependencyVersions.get(moduleRef));
    }

    targetDescriptor.getLanguageVersions().clear();
    targetDescriptor.getLanguageVersions().putAll(sourceDescriptor.getLanguageVersions());

    targetDescriptor.getUsedDevkits().clear();
    targetDescriptor.getUsedDevkits().addAll(sourceDescriptor.getUsedDevkits());

    targetDescriptor.getSourcePaths().clear();
    targetDescriptor.getSourcePaths().addAll(sourceDescriptor.getSourcePaths());

    targetDescriptor.getAdditionalJavaStubPaths().clear();
    targetDescriptor.getAdditionalJavaStubPaths().addAll(sourceDescriptor.getAdditionalJavaStubPaths());

    Collection<ModuleFacetDescriptor> targetModuleFacetDescriptors = targetDescriptor.getModuleFacetDescriptors();
    targetModuleFacetDescriptors.clear();
    for (ModuleFacetDescriptor source : CollectionSequence.fromCollection(sourceDescriptor.getModuleFacetDescriptors())) {
      targetModuleFacetDescriptors.add(new ModuleFacetDescriptor(source.getType(), source.getMemento().copy()));
    }

    targetDescriptor.getModuleFacetDescriptors().addAll(sourceDescriptor.getModuleFacetDescriptors());
  }

  private static void tryRenameModel(SModel model, String oldModuleName, String newModuleName) {
    if (model instanceof EditableSModel) {
      String newName = model.getName().getValue();
      if (newName.startsWith(oldModuleName)) {
        newName = newModuleName + newName.substring(oldModuleName.length());
      }
      ((EditableSModel) model).rename(newName, model.getSource() instanceof FileDataSource);
    }
  }

  private static <T> T as_iwu1g5_a3a0a0a3(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_iwu1g5_a3a0a1a3(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
