package jetbrains.mps.ide.newSolutionDialog;

/*Generated by MPS */

import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.Project;
import java.util.Map;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.extapi.persistence.CloneType;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.project.persistence.SolutionDescriptorPersistence;
import jetbrains.mps.util.MacrosFactory;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.library.ModulesMiner;
import jetbrains.mps.util.ReferenceUpdater;
import jetbrains.mps.project.structure.model.ModelRootDescriptor;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.structure.modules.LanguageDescriptor;
import jetbrains.mps.project.persistence.LanguageDescriptorPersistence;
import java.util.List;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import java.util.Iterator;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import org.jetbrains.mps.openapi.module.SDependency;
import jetbrains.mps.project.structure.modules.Dependency;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.apache.log4j.Level;
import jetbrains.mps.extapi.persistence.ModelRootBase;
import org.jetbrains.mps.openapi.persistence.Memento;
import jetbrains.mps.persistence.MementoImpl;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.util.PathConverters;
import jetbrains.mps.project.structure.modules.GeneratorDescriptor;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.project.structure.modules.mappingpriorities.MappingPriorityRule;
import jetbrains.mps.util.PathConverter;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.project.structure.modules.ModuleFacetDescriptor;

public class CloneModuleUtil {

  public static AbstractModule cloneModule(String namespace, String rootPath, Project project, final AbstractModule sourceModule, final Map<ModelRoot, CloneType> cloneTypes, String extenstion) {
    return NewModuleUtil.createModule(extenstion, namespace, rootPath, project, new _FunctionTypes._return_P3_E0<AbstractModule, String, IFile, Project>() {
      public AbstractModule invoke(String s, IFile f, Project p) {
        return createClonedModule(s, f, p, sourceModule, cloneTypes);
      }
    });
  }

  private static AbstractModule createClonedModule(String namespace, IFile targetDescriptorFile, MPSModuleOwner moduleOwner, AbstractModule sourceModule, Map<ModelRoot, CloneType> cloneTypes) {
    if (sourceModule instanceof Solution) {
      return createClonedSolution(namespace, targetDescriptorFile, moduleOwner, as_iwu1g5_a3a0a0a3(sourceModule, Solution.class), cloneTypes);
    }
    if (sourceModule instanceof Language) {
      return createClonedLanguage(namespace, targetDescriptorFile, moduleOwner, as_iwu1g5_a3a0a1a3(sourceModule, Language.class), cloneTypes);
    }
    throw new IllegalArgumentException("Unknown module " + sourceModule.getModuleName());
  }

  private static Solution createClonedSolution(String namespace, IFile targetDescriptorFile, MPSModuleOwner moduleOwner, Solution sourceSolution, Map<ModelRoot, CloneType> cloneTypes) {
    SolutionDescriptor targetDescriptor = createClonedSolutionDescriptor(namespace, targetDescriptorFile, sourceSolution);

    SolutionDescriptorPersistence.saveSolutionDescriptor(targetDescriptorFile, targetDescriptor, MacrosFactory.forModuleFile(targetDescriptorFile));

    Solution targetSolution = (Solution) ModuleRepositoryFacade.createModule(new ModulesMiner().loadModuleHandle(targetDescriptorFile), moduleOwner);

    ReferenceUpdater referenceUpdater = new ReferenceUpdater();
    Iterable<ModelRootDescriptor> createdModelRootDescriptors = cloneModels(targetSolution, sourceSolution, cloneTypes, referenceUpdater);
    referenceUpdater.adjust();

    targetDescriptor = targetSolution.getModuleDescriptor();
    final Collection<ModelRootDescriptor> modelRootDescriptors = targetDescriptor.getModelRootDescriptors();
    Sequence.fromIterable(createdModelRootDescriptors).visitAll(new IVisitor<ModelRootDescriptor>() {
      public void visit(ModelRootDescriptor it) {
        modelRootDescriptors.add(it);
      }
    });
    targetSolution.setModuleDescriptor(targetDescriptor);

    return targetSolution;
  }

  private static Language createClonedLanguage(String namespace, IFile targetDescriptorFile, MPSModuleOwner moduleOwner, Language sourceLanguage, Map<ModelRoot, CloneType> cloneTypes) {
    Map<SModuleReference, AbstractModule> moduleMapping = MapSequence.fromMap(new HashMap<SModuleReference, AbstractModule>());

    LanguageDescriptor targetDescriptor = createClonedLanguageDescriptor(namespace, targetDescriptorFile, sourceLanguage);

    LanguageDescriptorPersistence.saveLanguageDescriptor(targetDescriptorFile, targetDescriptor, MacrosFactory.forModuleFile(targetDescriptorFile));

    Language targetLanguage = (Language) ModuleRepositoryFacade.createModule(new ModulesMiner().loadModuleHandle(targetDescriptorFile), moduleOwner);

    ReferenceUpdater referenceUpdater = new ReferenceUpdater();
    List<Tuples._2<AbstractModule, Iterable<ModelRootDescriptor>>> modelRootAddFutures = ListSequence.fromList(new ArrayList<Tuples._2<AbstractModule, Iterable<ModelRootDescriptor>>>());

    ListSequence.fromList(modelRootAddFutures).addElement(MultiTuple.<AbstractModule,Iterable<ModelRootDescriptor>>from(as_iwu1g5_a0a0a11a7(targetLanguage, AbstractModule.class), cloneModels(targetLanguage, sourceLanguage, cloneTypes, referenceUpdater)));
    MapSequence.fromMap(moduleMapping).put(sourceLanguage.getModuleReference(), targetLanguage);

    SLanguage targetSLanguage = MetaAdapterByDeclaration.getLanguage(targetLanguage);
    SLanguage sourceSLanguage = MetaAdapterByDeclaration.getLanguage(sourceLanguage);
    referenceUpdater.addUsedLanguagesMapping(sourceSLanguage, targetSLanguage);

    Iterator<Generator> targetGenerators = targetLanguage.getGenerators().iterator();
    Iterator<Generator> sourceGenerators = sourceLanguage.getGenerators().iterator();

    while (sourceGenerators.hasNext()) {
      Generator targetGenerator = targetGenerators.next();
      Generator sourceGenerator = sourceGenerators.next();

      MapSequence.fromMap(moduleMapping).put(sourceGenerator.getModuleReference(), targetGenerator);
      ListSequence.fromList(modelRootAddFutures).addElement(MultiTuple.<AbstractModule,Iterable<ModelRootDescriptor>>from(as_iwu1g5_a0a0a4a12a7(targetGenerator, AbstractModule.class), cloneModels(targetGenerator, sourceGenerator, cloneTypes, referenceUpdater)));
    }

    referenceUpdater.adjust();
    resolveDependecies(moduleMapping);

    for (Tuples._2<AbstractModule, Iterable<ModelRootDescriptor>> modelRootAddFuture : ListSequence.fromList(modelRootAddFutures)) {
      ModuleDescriptor moduleDescriptor = modelRootAddFuture._0().getModuleDescriptor();
      final Collection<ModelRootDescriptor> modelRootDescriptors = moduleDescriptor.getModelRootDescriptors();
      Sequence.fromIterable(modelRootAddFuture._1()).visitAll(new IVisitor<ModelRootDescriptor>() {
        public void visit(ModelRootDescriptor it) {
          modelRootDescriptors.add(it);
        }
      });
      modelRootAddFuture._0().setModuleDescriptor(moduleDescriptor);
    }

    return targetLanguage;
  }



  private static void resolveDependecies(Map<SModuleReference, AbstractModule> moduleMapping) {
    Iterable<AbstractModule> targetModules = MapSequence.fromMap(moduleMapping).values();
    for (AbstractModule targetModule : Sequence.fromIterable(targetModules)) {
      for (SDependency dependency : Sequence.fromIterable(targetModule.getDeclaredDependencies())) {
        SModuleReference depReference = dependency.getTargetModule();
        if (MapSequence.fromMap(moduleMapping).containsKey(depReference)) {
          targetModule.removeDependency(new Dependency(depReference, dependency.getScope(), dependency.isReexport()));
          targetModule.addDependency(MapSequence.fromMap(moduleMapping).get(depReference).getModuleReference(), dependency.isReexport());
        }
      }
    }
  }

  protected static Logger LOG = LogManager.getLogger(CloneModuleUtil.class);
  public static Iterable<ModelRootDescriptor> cloneModels(AbstractModule targetModule, AbstractModule sourceModule, Map<ModelRoot, CloneType> cloneTypes, ReferenceUpdater referenceUpdater) {
    List<ModelRoot> targetModelRoots = ListSequence.fromList(new ArrayList<ModelRoot>());

    for (ModelRoot sourceModelRoot : Sequence.fromIterable(sourceModule.getModelRoots())) {

      CloneType cloneType = MapSequence.fromMap(cloneTypes).get(sourceModelRoot);
      if (cloneType == null) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Unspesified clone type for " + sourceModelRoot);
        }
        continue;
      }

      ModelRoot result = as_iwu1g5_a0a0e0c0o(sourceModelRoot, ModelRootBase.class).cloneTo(targetModule, cloneType, referenceUpdater);

      if (result == null) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Can't clone model root " + sourceModelRoot + " to module" + targetModule + " (" + cloneType + ")");
        }
        continue;
      }

      ListSequence.fromList(targetModelRoots).addElement(result);
    }

    final List<ModelRootDescriptor> modelRootDescriptors = ListSequence.fromList(new ArrayList<ModelRootDescriptor>());

    for (ModelRoot targetModelRoot : ListSequence.fromList(targetModelRoots)) {
      Memento targetMemento = new MementoImpl();
      targetModelRoot.save(targetMemento);
      ListSequence.fromList(modelRootDescriptors).addElement(new ModelRootDescriptor(targetModelRoot.getType(), targetMemento));
      ((ModelRootBase) targetModelRoot).dispose();
    }

    return modelRootDescriptors;
  }

  private static SolutionDescriptor createClonedSolutionDescriptor(String namespace, IFile descriptorFile, Solution sourceSolution) {
    SolutionDescriptor targerDescriptor = new SolutionDescriptor();
    targerDescriptor.setNamespace(namespace);
    targerDescriptor.setId(ModuleId.regular());
    if (descriptorFile.getParent().getChildren().size() > 1) {
      throw new IllegalStateException("Trying to clone a solution to a not empty directory:" + descriptorFile.getParent());
    }

    cloneSolutionDescriptorInfo(targerDescriptor, descriptorFile, sourceSolution.getModuleDescriptor(), sourceSolution.getDescriptorFile());

    return targerDescriptor;
  }

  private static LanguageDescriptor createClonedLanguageDescriptor(String namespace, IFile descriptorFile, Language sourceLanguage) {
    LanguageDescriptor targetDescriptor = new LanguageDescriptor();
    targetDescriptor.setNamespace(namespace);
    targetDescriptor.setId(ModuleId.regular());
    if (descriptorFile.getParent().getChildren().size() > 1) {
      throw new IllegalStateException("Trying to clone a language to a not empty directory:" + descriptorFile.getParent());
    }

    cloneLanguageDescriptorInfo(targetDescriptor, descriptorFile, sourceLanguage.getModuleDescriptor(), sourceLanguage.getDescriptorFile());

    return targetDescriptor;
  }

  private static void cloneSolutionDescriptorInfo(SolutionDescriptor targetDescriptor, IFile targetDescriptorFile, SolutionDescriptor sourceDescriptor, IFile sourceDescriptorFile) {
    cloneModuleDescriptorInfo(targetDescriptor, targetDescriptorFile, sourceDescriptor, sourceDescriptorFile);

    targetDescriptor.setKind(sourceDescriptor.getKind());
    targetDescriptor.setCompileInMPS(sourceDescriptor.getCompileInMPS());
    targetDescriptor.setOutputPath(PathConverters.forDescriptorFiles(targetDescriptorFile, sourceDescriptorFile).sourceToDestination(sourceDescriptor.getOutputPath()));
  }

  private static void cloneLanguageDescriptorInfo(LanguageDescriptor targetDescriptor, IFile targetDescriptorFile, LanguageDescriptor sourceDescriptor, IFile sourceDescriptorFile) {
    cloneModuleDescriptorInfo(targetDescriptor, targetDescriptorFile, sourceDescriptor, sourceDescriptorFile);

    targetDescriptor.setLanguageVersion(sourceDescriptor.getLanguageVersion());
    targetDescriptor.setGenPath(PathConverters.forDescriptorFiles(targetDescriptorFile, sourceDescriptorFile).sourceToDestination(sourceDescriptor.getGenPath()));

    targetDescriptor.getAccessoryModels().clear();
    targetDescriptor.getAccessoryModels().addAll(sourceDescriptor.getAccessoryModels());

    targetDescriptor.getRuntimeModules().clear();
    targetDescriptor.getRuntimeModules().addAll(sourceDescriptor.getRuntimeModules());

    targetDescriptor.getExtendedLanguages().clear();
    targetDescriptor.getExtendedLanguages().addAll(sourceDescriptor.getExtendedLanguages());

    List<GeneratorDescriptor> targetGenerators = targetDescriptor.getGenerators();
    for (GeneratorDescriptor sourceGenerator : ListSequence.fromList(sourceDescriptor.getGenerators())) {
      GeneratorDescriptor targetGenerator = new GeneratorDescriptor();

      // similiar to Generator.generateGeneratorUID(Language) 
      String targetGeneratorUID = targetDescriptor.getNamespace() + "#" + SModel.generateUniqueId();

      targetGenerator.setGeneratorUID(targetGeneratorUID);
      cloneGeneratorDescriptorInfo(targetGenerator, targetDescriptorFile, sourceGenerator, sourceDescriptorFile);

      targetGenerators.add(targetGenerator);
    }
  }

  private static void cloneGeneratorDescriptorInfo(GeneratorDescriptor targetDescriptor, IFile targetDescriptorFile, GeneratorDescriptor sourceDescriptor, IFile sourceDescriptorFile) {
    cloneModuleDescriptorInfo(targetDescriptor, targetDescriptorFile, sourceDescriptor, sourceDescriptorFile);

    targetDescriptor.setGenerateTemplates(sourceDescriptor.isGenerateTemplates());
    targetDescriptor.setReflectiveQueries(sourceDescriptor.isReflectiveQueries());

    targetDescriptor.getDepGenerators().clear();
    targetDescriptor.getDepGenerators().addAll(sourceDescriptor.getDepGenerators());

    List<MappingPriorityRule> targetMappingPriorityRules = targetDescriptor.getPriorityRules();
    targetMappingPriorityRules.clear();
    for (MappingPriorityRule sourceMappingPriorityRule : ListSequence.fromList(sourceDescriptor.getPriorityRules())) {
      targetMappingPriorityRules.add(sourceMappingPriorityRule.getCopy());
    }
  }

  private static void cloneModuleDescriptorInfo(ModuleDescriptor targetDescriptor, IFile targetDescriptorFile, ModuleDescriptor sourceDescriptor, IFile sourceDescriptorFile) {

    PathConverter pathConverter = PathConverters.forDescriptorFiles(targetDescriptorFile, sourceDescriptorFile);

    targetDescriptor.setModuleVersion(sourceDescriptor.getModuleVersion());
    targetDescriptor.setUseTransientOutput(sourceDescriptor.isUseTransientOutput());

    Collection<Dependency> sourceDependencies = sourceDescriptor.getDependencies();
    Collection<Dependency> targetDependencies = targetDescriptor.getDependencies();

    Map<SModuleReference, Integer> sourceDependencyVersions = sourceDescriptor.getDependencyVersions();
    Map<SModuleReference, Integer> targetDependencyVersions = targetDescriptor.getDependencyVersions();

    targetDependencies.clear();
    targetDependencyVersions.clear();

    for (Dependency dependency : CollectionSequence.fromCollection(sourceDependencies)) {
      SModuleReference moduleRef = dependency.getModuleRef();
      targetDependencies.add(dependency.getCopy());
      targetDependencyVersions.put(moduleRef, sourceDependencyVersions.get(moduleRef));
    }

    targetDescriptor.getLanguageVersions().clear();
    targetDescriptor.getLanguageVersions().putAll(sourceDescriptor.getLanguageVersions());

    targetDescriptor.getUsedDevkits().clear();
    targetDescriptor.getUsedDevkits().addAll(sourceDescriptor.getUsedDevkits());

    targetDescriptor.getSourcePaths().clear();
    targetDescriptor.getSourcePaths().addAll(sourceDescriptor.getSourcePaths());

    targetDescriptor.getAdditionalJavaStubPaths().clear();
    targetDescriptor.getAdditionalJavaStubPaths().addAll(sourceDescriptor.getAdditionalJavaStubPaths());

    Collection<ModuleFacetDescriptor> targetModuleFacetDescriptors = targetDescriptor.getModuleFacetDescriptors();
    targetModuleFacetDescriptors.clear();
    for (ModuleFacetDescriptor source : CollectionSequence.fromCollection(sourceDescriptor.getModuleFacetDescriptors())) {
      targetModuleFacetDescriptors.add(new ModuleFacetDescriptor(source.getType(), source.getMemento().copy()));
    }

    targetDescriptor.getModuleFacetDescriptors().addAll(sourceDescriptor.getModuleFacetDescriptors());
  }

  private static <T> T as_iwu1g5_a3a0a0a3(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_iwu1g5_a3a0a1a3(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_iwu1g5_a0a0a11a7(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_iwu1g5_a0a0a4a12a7(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_iwu1g5_a0a0e0c0o(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
