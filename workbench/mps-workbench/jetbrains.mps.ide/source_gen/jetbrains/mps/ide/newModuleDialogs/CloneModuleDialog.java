package jetbrains.mps.ide.newModuleDialogs;

/*Generated by MPS */

import jetbrains.mps.extapi.persistence.CopyNotSupportedException;
import jetbrains.mps.extapi.persistence.CopyableModelRoot;
import jetbrains.mps.extapi.persistence.ModelRootBase;
import jetbrains.mps.library.ModulesMiner.ModuleHandle;
import jetbrains.mps.persistence.MementoImpl;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.project.structure.model.ModelRootDescriptor;
import jetbrains.mps.project.structure.modules.DeploymentDescriptor;
import jetbrains.mps.project.structure.modules.GeneratorDescriptor;
import jetbrains.mps.project.structure.modules.LanguageDescriptor;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.util.ModulePathConverter;
import jetbrains.mps.util.PathConverters;
import jetbrains.mps.vfs.IFile;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.StandaloneMPSProject;
import jetbrains.mps.util.ReferenceUpdater;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.project.Solution;
import jetbrains.mps.ide.ui.dialogs.modules.CloneModuleSettings;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.mps.openapi.persistence.Memento;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

public class CloneModuleDialog extends AbstractModuleCreationDialog {

  private final AbstractModule myModuleOriginal;

  public CloneModuleDialog(MPSProject project, @Nullable String virtualFolder, AbstractModule moduleOrginal) {
    super(project, virtualFolder);
    setTitle("Clone Module " + moduleOrginal.getModuleName());

    myModuleOriginal = moduleOrginal;
    init();
  }

  protected static Logger LOG = LogManager.getLogger(CloneModuleDialog.class);
  @Override
  protected void runCreation() {
    ModuleDescriptor moduleDescriptor = myModuleOriginal.getModuleDescriptor();
    if (moduleDescriptor == null) {
      throw new IllegalArgumentException("The module descriptor is null for the " + myModuleOriginal);
    }
    final String moduleLocation = mySettings.getModuleLocation() + getExtension();
    IFile resultFile = myModuleOriginal.getFileSystem().getFile(moduleLocation);

    ModuleDescriptor copyDescriptor = new DescriptorCopyOrganizer(myModuleOriginal, mySettings.getModuleName(), resultFile).copyDescriptor();
    /**
     * we can exploit polymorphism by moving this code to the individual module classes
     * however I cannot think of pretty api for this case.
     * Should it be a #copy method which returns a constructor like <code>Function<SModule></code>?
     * Due to the mix-up in the SModule hierarchy API (descriptors reflect the persistence not the actual module properties)
     * I am unable to design this under such circumstances.
     * First we need to resolve module problems then we can write this code in a proper way.
     */
    myResult = (AbstractModule) ModuleRepositoryFacade.createModule(new ModuleHandle(resultFile, copyDescriptor), myProject); //
    try {
      copyModelRoots(myModuleOriginal, myResult);
      copyFacets(myModuleOriginal, myResult);
    } catch (CopyNotSupportedException e) {
      LOG.error(e);
      new ModuleRepositoryFacade(myProject).unregisterModule(myResult);
      myResult = null;
      return;
    }
    myProject.addModule(myResult);
    // FIXME RADIMIR RENAMES MODELS HERE

    ((StandaloneMPSProject) myProject).setFolderFor(myResult, myVirtualFolder);
    adjustReferences();
    myResult.renameModels(myModuleOriginal.getModuleName(), myResult.getModuleName(), true);
    myResult.save();
  }

  private void adjustReferences() {
    ReferenceUpdater referenceUpdater = new ReferenceUpdater();
    referenceUpdater.addModuleToAdjust(myModuleOriginal, myResult, true);
    referenceUpdater.adjust();
  }

  private void hackGeneratorDescriptor(ModulePathConverter module){}

  static class DescriptorCopyOrganizer {
    @NotNull
    private final AbstractModule myModuleToCopy;
    @NotNull
    private final String myNewName;
    private final ModulePathConverter myModulePathConverter;

    public DescriptorCopyOrganizer(@NotNull AbstractModule moduleToCopy, @NotNull String newName, @NotNull IFile newFile) {
      myModuleToCopy = moduleToCopy;
      myNewName = newName;
      if (moduleToCopy.getDescriptorFile() != null) {
        myModulePathConverter = PathConverters.forDescriptorFiles(moduleToCopy.getDescriptorFile(), newFile);
      } else {
        myModulePathConverter = null;
      }
      if (moduleToCopy.getModuleDescriptor() == null) {
        throw new UnsupportedOperationException("Cannot copy without descriptor so far");
      }
    }

    /**
     * here we copy descriptor but remove the model roots and module facets descriptors since
     * we need to copy them in an abstract way afterwards
     */
    @NotNull
    public ModuleDescriptor copyDescriptor() {
      ModuleDescriptor moduleDescriptor = myModuleToCopy.getModuleDescriptor();
      ModuleDescriptor copyDescriptor = moduleDescriptor.copy();
      copyDescriptor.setId(ModuleId.regular());
      copyDescriptor.setNamespace(myNewName);

      if (myModulePathConverter != null) {
        hackJavaFacetProperties(copyDescriptor);
        hackDeploymentDescriptor(copyDescriptor);
        if (copyDescriptor instanceof SolutionDescriptor) {
          hackSolutionDescriptor((SolutionDescriptor) copyDescriptor);
        } else if (copyDescriptor instanceof LanguageDescriptor) {
          hackLanguageDescriptor((LanguageDescriptor) copyDescriptor);
          ((LanguageDescriptor) copyDescriptor).getGenerators().forEach(this::hackGeneratorDescriptor);
        }
      }

      copyDescriptor.getModuleFacetDescriptors().clear(); // these are descriptors not the model roots themselves and thus we have a problem
      copyDescriptor.getModelRootDescriptors().clear(); // same problem with facets
      return copyDescriptor;
    }

    /**
     * will go away when these paths are restrained to be relative [from the module file] or absolute without regard to the module file
     * moreover these paths will move to the java module facet implementation
     */
    private void hackJavaFacetProperties(@NotNull ModuleDescriptor copyDescriptor) {
      List<String> newStubPaths = copyDescriptor.getAdditionalJavaStubPaths().stream().map(myModulePathConverter::source2Target).collect(Collectors.toList());
      copyDescriptor.getAdditionalJavaStubPaths().clear();
      copyDescriptor.getAdditionalJavaStubPaths().addAll(newStubPaths);

      List<String> newSourcePaths = copyDescriptor.getSourcePaths().stream().map(myModulePathConverter::source2Target).collect(Collectors.toList());
      copyDescriptor.getSourcePaths().clear();
      copyDescriptor.getSourcePaths().addAll(newSourcePaths);
    }

    /**
     * will go away when these paths are restrained to be relative [from the module file] or absolute without regard to the module file
     * or if these locations are not needed right in the module, just are vital for its initialization
     */
    private void hackDeploymentDescriptor(@NotNull ModuleDescriptor copyDescriptor) {
      DeploymentDescriptor deploymentDescriptor = copyDescriptor.getDeploymentDescriptor();
      if (deploymentDescriptor != null) {
        deploymentDescriptor.setSourcesJar(myModulePathConverter.source2Target(deploymentDescriptor.getSourcesJar()));
        deploymentDescriptor.setDescriptorFile(myModulePathConverter.source2Target(deploymentDescriptor.getDescriptorFile()));
      }
    }

    /**
     * will go away when these paths are restrained to be relative [from the module file] or absolute without regard to the module file
     */
    private void hackSolutionDescriptor(@NotNull SolutionDescriptor copyDescriptor) {
      final String outputPath = copyDescriptor.getOutputPath();
      if (outputPath != null) {
        copyDescriptor.setOutputPath(myModulePathConverter.source2Target(outputPath));
      }
    }

    private void hackLanguageDescriptor(@NotNull LanguageDescriptor copyDescriptor) {
      final String genPath = copyDescriptor.getGenPath();
      if (genPath != null) {
        copyDescriptor.setGenPath(myModulePathConverter.source2Target(genPath));
      }
    }

    private void hackGeneratorDescriptor(@NotNull GeneratorDescriptor copyDescriptor) {
      copyDescriptor.setGeneratorUID(copyDescriptor.getNamespace() + "#" + SModel.generateUniqueId());
    }
  }

  public static void copyModelRoots(AbstractModule source, AbstractModule target) throws CopyNotSupportedException {
    List<ModelRoot> targetModelRoots = new ArrayList<>();

    for (ModelRoot sourceModelRoot : source.getModelRoots()) {
      if (!(sourceModelRoot instanceof CopyableModelRoot)) {
        throw new IllegalArgumentException("Can't clone model root " + sourceModelRoot + " : Cloning hasn't implemented for '" + sourceModelRoot.getType() + "' model roots");
      }
      ModelRoot targetModelRoot = PersistenceFacade.getInstance().getModelRootFactory(sourceModelRoot.getType()).create();

      if (targetModelRoot instanceof ModelRootBase) {
        ((ModelRootBase) targetModelRoot).setModule(target);
      }
      ((CopyableModelRoot) sourceModelRoot).copyTo((CopyableModelRoot) targetModelRoot);
      targetModelRoots.add(targetModelRoot);
    }

    // hack to synchronize the module descriptor with new model roots
    ModuleDescriptor targetDescriptor = target.getModuleDescriptor();
    if (targetDescriptor != null) {
      Collection<ModelRootDescriptor> modelRootDescriptors = targetDescriptor.getModelRootDescriptors();
      for (ModelRoot targetModelRoot : targetModelRoots) {
        Memento targetMemento = new MementoImpl();
        targetModelRoot.save(targetMemento);
        modelRootDescriptors.add(new ModelRootDescriptor(targetModelRoot.getType(), targetMemento));
      }
      target.setModuleDescriptor(targetDescriptor);
    }
  }

  //TODO formally now facet needs to be copied in the same way model roots do. however facets are going to become independent from the module
  public static void copyFacets(AbstractModule source, AbstractModule target) throws CopyNotSupportedException {
    // nop
  }

  @Override
  protected String getExtension() {
    if (myModuleOriginal instanceof Language) {
      return MPSExtentions.DOT_LANGUAGE;
    }
    if (myModuleOriginal instanceof Solution) {
      return MPSExtentions.DOT_SOLUTION;
    }
    return null;
  }

  @Override
  protected CloneModuleSettings createSettingsInstance() {
    return new CloneModuleSettings(getProjectPath(), myModuleOriginal);
  }


  @Nullable
  @NonNls
  @Override
  protected String getDimensionServiceKey() {
    return CloneModuleDialog.class.getName();
  }
}
