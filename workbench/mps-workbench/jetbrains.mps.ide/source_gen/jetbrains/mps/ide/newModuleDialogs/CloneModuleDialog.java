package jetbrains.mps.ide.newModuleDialogs;

/*Generated by MPS */

import jetbrains.mps.extapi.persistence.CopyNotSupportedException;
import jetbrains.mps.extapi.persistence.CopyableModelRoot;
import jetbrains.mps.extapi.persistence.ModelRootBase;
import jetbrains.mps.library.ModulesMiner.ModuleHandle;
import jetbrains.mps.persistence.MementoImpl;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.project.structure.model.ModelRootDescriptor;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.util.ModulePathConverter;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.path.Path;
import org.jetbrains.annotations.Nullable;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.StandaloneMPSProject;
import jetbrains.mps.util.ReferenceUpdater;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.project.Solution;
import jetbrains.mps.ide.ui.dialogs.modules.CloneModuleSettings;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.mps.openapi.persistence.Memento;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Clone Module Action Dialog
 * @author Radimir.Sorokin, apyshkin
 */
public final class CloneModuleDialog extends AbstractModuleCreationDialog {
  private final AbstractModule myModuleOriginal;

  public CloneModuleDialog(MPSProject project, @Nullable String virtualFolder, AbstractModule moduleOrginal) {
    super(project, virtualFolder);
    setTitle("Clone Module " + moduleOrginal.getModuleName());

    myModuleOriginal = moduleOrginal;
    init();
  }

  protected static Logger LOG = LogManager.getLogger(CloneModuleDialog.class);
  @Override
  protected void runCreation() {
    ModuleDescriptor moduleDescriptor = myModuleOriginal.getModuleDescriptor();
    if (moduleDescriptor == null) {
      throw new IllegalArgumentException("The module descriptor is null for the " + myModuleOriginal);
    }
    final String moduleLocation = mySettings.getModuleLocation() + Path.SYSTEM_SEPARATOR + mySettings.getModuleName() + getExtension();
    IFile resultFile = myModuleOriginal.getFileSystem().getFile(moduleLocation);

    ModuleDescriptor copyDescriptor = new DescriptorCopyOrganizer(myModuleOriginal, mySettings.getModuleName(), resultFile).copyDescriptor();
    /**
     * we can exploit polymorphism by moving this code to the individual module [descriptor] classes
     * however I cannot think of pretty api for this case.
     * Should it be a #copy method which returns a constructor like <code>Function<IFile></code>?
     * Due to the mix-up in the SModule hierarchy API (descriptors reflect the persistence not the actual module properties)
     * I am unable to design it under the given circumstances.
     * First we need to resolve module problems then we can write this code in a proper way.
     */
    myResult = (AbstractModule) ModuleRepositoryFacade.createModule(new ModuleHandle(resultFile, copyDescriptor), myProject);
    try {
      copyModelRoots(myModuleOriginal, myResult);
      copyFacets(myModuleOriginal, myResult);
    } catch (CopyNotSupportedException e) {
      LOG.error("", e);
      new ModuleRepositoryFacade(myProject).unregisterModule(myResult);
      myResult = null;
      return;
    }
    myResult.updateModelsSet();
    myProject.addModule(myResult);
    if (myProject instanceof StandaloneMPSProject) {
      ((StandaloneMPSProject) myProject).setFolderFor(myResult, myVirtualFolder);
    }
    adjustReferences();
    myResult.renameModels(myModuleOriginal.getModuleName(), myResult.getModuleName(), true);
    myResult.save();
  }

  private void adjustReferences() {
    ReferenceUpdater referenceUpdater = new ReferenceUpdater();
    referenceUpdater.addModuleToAdjust(myModuleOriginal, myResult, true); // FIXME RADIMIR do we need this flag
    referenceUpdater.adjust();
  }

  private void hackGeneratorDescriptor(ModulePathConverter module){}

  private static void copyModelRoots(AbstractModule source, AbstractModule target) throws CopyNotSupportedException {
    List<ModelRoot> targetModelRoots = new ArrayList<>();

    for (ModelRoot sourceModelRoot : source.getModelRoots()) {
      if (!(sourceModelRoot instanceof CopyableModelRoot)) {
        throw new CopyNotSupportedException("Can't clone model root " + sourceModelRoot + " : Cloning hasn't implemented for '" + sourceModelRoot.getType() + "' model roots");
      }
      ModelRoot targetModelRoot = PersistenceFacade.getInstance().getModelRootFactory(sourceModelRoot.getType()).create();

      if (targetModelRoot instanceof ModelRootBase) {
        ((ModelRootBase) targetModelRoot).setModule(target);
      }
      //noinspection unchecked
      ((CopyableModelRoot) sourceModelRoot).copyTo((CopyableModelRoot) targetModelRoot);
      targetModelRoots.add(targetModelRoot);
    }

    // hack to synchronize the module descriptor with new model roots
    ModuleDescriptor targetDescriptor = target.getModuleDescriptor();
    if (targetDescriptor != null) {
      Collection<ModelRootDescriptor> modelRootDescriptors = targetDescriptor.getModelRootDescriptors();
      for (ModelRoot targetModelRoot : targetModelRoots) {
        Memento targetMemento = new MementoImpl();
        targetModelRoot.save(targetMemento);
        modelRootDescriptors.add(new ModelRootDescriptor(targetModelRoot.getType(), targetMemento));
      }
      target.setModuleDescriptor(targetDescriptor);
    }
  }

  //TODO formally now facet needs to be copied in the same way model roots do. however facets are going to become independent from the module
  public static void copyFacets(AbstractModule source, AbstractModule target) throws CopyNotSupportedException {
    // nop
  }

  @Override
  protected String getExtension() {
    if (myModuleOriginal instanceof Language) {
      return MPSExtentions.DOT_LANGUAGE;
    }
    if (myModuleOriginal instanceof Solution) {
      return MPSExtentions.DOT_SOLUTION;
    }
    return null;
  }

  @Override
  protected CloneModuleSettings createSettingsInstance() {
    return new CloneModuleSettings(getProjectPath(), myModuleOriginal);
  }

  @Nullable
  @NonNls
  @Override
  protected String getDimensionServiceKey() {
    return CloneModuleDialog.class.getName();
  }
}
