package jetbrains.mps.ide.dialogs.project.creation;

/*Generated by MPS */

import com.intellij.openapi.ui.DialogWrapper;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import javax.swing.JTextField;
import javax.swing.JComboBox;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.persistence.ModelFactoryType;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.project.Project;
import java.awt.HeadlessException;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.mps.openapi.model.SModelName;
import com.intellij.uiDesigner.core.GridLayoutManager;
import java.awt.Dimension;
import com.intellij.uiDesigner.core.GridConstraints;
import javax.swing.JLabel;
import javax.swing.DefaultComboBoxModel;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import javax.swing.DefaultListCellRenderer;
import java.awt.event.ItemListener;
import java.awt.event.ItemEvent;
import jetbrains.mps.persistence.DefaultModelRoot;
import java.awt.Insets;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.List;
import java.util.LinkedList;
import java.util.Arrays;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.extapi.persistence.ModelFactoryService;
import com.intellij.ui.ColoredListCellRenderer;
import javax.swing.JList;
import jetbrains.mps.persistence.ModelCannotBeCreatedException;
import com.intellij.openapi.ui.Messages;
import jetbrains.mps.util.Reference;
import jetbrains.mps.extapi.persistence.SourceRoot;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import jetbrains.mps.project.ModelsAutoImportsManager;
import jetbrains.mps.kernel.model.MissingDependenciesFixer;
import jetbrains.mps.smodel.ModelImports;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.extapi.model.GeneratableSModel;
import jetbrains.mps.extapi.persistence.SourceRootKinds;
import jetbrains.mps.extapi.persistence.DefaultSourceRoot;
import jetbrains.mps.smodel.language.LanguageAspectSupport;
import javax.lang.model.SourceVersion;
import javax.swing.JComponent;

public class NewModelDialog extends DialogWrapper {
  @NotNull
  private final MPSProject myProject;
  @NotNull
  private final AbstractModule myModule;
  @Nullable
  private final SModel myClone;
  private final boolean myPreserveIds;

  private final JPanel myContentPane = new JPanel(new BorderLayout());
  private final JTextField myModelName = new JTextField();
  private final JComboBox<String> myModelStereotype = new JComboBox<String>();
  private final JComboBox<ModelRoot> myModelRoots = new JComboBox<ModelRoot>();
  private final JComboBox<ModelFactoryType> myModelStorageFormat = new JComboBox<ModelFactoryType>();

  private EditableSModel myResult;

  public NewModelDialog(Project project, AbstractModule module, String namespace, String stereotype, boolean strict) throws HeadlessException {
    this(project, module, namespace, stereotype, strict, null, false);
  }

  public NewModelDialog(Project project, @NotNull AbstractModule module, final String namespace, String stereotype, boolean strict, @Nullable SModel clone, boolean preserveIds) throws HeadlessException {
    super(ProjectHelper.toIdeaProject(project));
    setTitle("New Model");
    myProject = (MPSProject) project;
    myPreserveIds = preserveIds;
    myClone = clone;
    myModule = module;
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        assert myModule.getModelRoots().iterator().hasNext() : "Can't create a model in solution with no model roots";
        initContentPane(namespace);
      }
    });
    if (stereotype != null) {
      myModelStereotype.setSelectedItem(stereotype);
      myModelStereotype.setEnabled(!(strict));
    }

    init();
  }

  public NewModelDialog(Project project, @NotNull SModel cloneModel) {
    this(project, (AbstractModule) cloneModel.getModule(), null, cloneModel.getName().getStereotype(), false, cloneModel, false);
    SModelName originalName = cloneModel.getName();
    setTitle(String.format("Clone Model %s", originalName.getValue()));
    myModelName.setText(new SModelName(originalName.getLongName() + "_clone").getValue());
    check();
  }

  public NewModelDialog(Project project, AbstractModule module, @NotNull SModel cloneModel) {
    this(project, module, null, cloneModel.getName().getStereotype(), false, cloneModel, true);
    SModelName originalName = cloneModel.getName();
    setTitle(String.format("Move Model %s", originalName.getValue()));
    myModelName.setText(originalName.getLongName());
    check();
  }

  public EditableSModel getResult() {
    return myResult;
  }

  private void initContentPane(String namespace) {
    JPanel mainPanel = new JPanel(new GridLayoutManager(6, 1));
    mainPanel.setPreferredSize(new Dimension(200, 50));

    GridConstraints constraints = new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_NORTHWEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null);

    mainPanel.add(new JLabel("Model root:"), constraints);

    constraints.setRow(constraints.getRow() + 1);
    mainPanel.add(myModelRoots, constraints);
    DefaultComboBoxModel<ModelRoot> model = new DefaultComboBoxModel<ModelRoot>();
    for (ModelRoot root : myModule.getModelRoots()) {
      if (root.canCreateModels()) {
        model.addElement(root);
      } else if (myModule instanceof Language && root instanceof FileBasedModelRoot) {
        // Can fix only FileBased model root (default for language) 
        model.addElement(root);
      }
    }

    if (model.getSize() == 0) {
      model.addElement(null);
    }
    myModelRoots.setRenderer(new DefaultListCellRenderer());
    myModelRoots.addItemListener(new ItemListener() {
      @Override
      public void itemStateChanged(ItemEvent e) {
        check();
        myModelStorageFormat.setVisible(myModelRoots.getSelectedItem() instanceof DefaultModelRoot);
      }
    });
    myModelRoots.setModel(model);

    myModelName.setText((namespace == null || namespace.length() == 0 ? namespace : namespace + "."));

    constraints.setRow(constraints.getRow() + 1);
    mainPanel.add(new JLabel("Model name:"), constraints);

    JPanel nameAndStereotype = new JPanel(new GridLayoutManager(1, 3, new Insets(0, 0, 0, 0), -1, -1));
    GridConstraints nameConstraints = new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_NORTHWEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null);

    nameAndStereotype.add(myModelName, nameConstraints);
    myModelName.addKeyListener(new KeyAdapter() {
      @Override
      public void keyReleased(KeyEvent event) {
        check();
      }
    });

    final JLabel atSign = new JLabel();
    nameConstraints.setColumn(nameConstraints.getColumn() + 1);
    nameConstraints.setHSizePolicy(GridConstraints.SIZEPOLICY_FIXED);
    nameAndStereotype.add(atSign, nameConstraints);

    List<String> stereotypes = new LinkedList<String>(Arrays.asList(SModelStereotype.values));
    if (!(myModule instanceof Generator)) {
      stereotypes.remove(SModelStereotype.GENERATOR);
    }
    myModelStereotype.setEditable(true);
    myModelStereotype.setModel(new DefaultComboBoxModel<String>(stereotypes.toArray(new String[stereotypes.size()])));
    myModelStereotype.addKeyListener(new KeyAdapter() {
      @Override
      public void keyReleased(KeyEvent event) {
        check();
      }
    });
    myModelStereotype.addItemListener(new ItemListener() {
      @Override
      public void itemStateChanged(ItemEvent p0) {
        check();
        atSign.setText((myModelStereotype.getSelectedItem().equals(SModelStereotype.NONE) ? "" : "@"));
      }
    });

    nameConstraints.setColumn(nameConstraints.getColumn() + 1);
    nameAndStereotype.add(myModelStereotype, nameConstraints);

    constraints.setRow(constraints.getRow() + 1);
    mainPanel.add(nameAndStereotype, constraints);

    constraints.setRow(constraints.getRow() + 1);
    mainPanel.add(new JLabel("Storage format:"), constraints);
    constraints.setRow(constraints.getRow() + 1);
    ModelFactoryService modelFactories = myProject.getComponent(ModelFactoryService.class);
    List<ModelFactoryType> factoryTypes = modelFactories.getFactoryTypes();
    myModelStorageFormat.setModel(new DefaultComboBoxModel<ModelFactoryType>(factoryTypes.toArray(new ModelFactoryType[factoryTypes.size()])));
    myModelStorageFormat.setRenderer(new ColoredListCellRenderer<ModelFactoryType>() {
      protected void customizeCellRenderer(JList<? extends ModelFactoryType> p0, ModelFactoryType factoryType, int p2, boolean p3, boolean p4) {
        append(factoryType.getFormatTitle());
      }
    });
    myModelStorageFormat.setSelectedItem(factoryTypes.get(0));
    mainPanel.add(myModelStorageFormat, constraints);
    myContentPane.add(mainPanel, BorderLayout.CENTER);
  }

  @Override
  protected void doOKAction() {
    if (!(check())) {
      return;
    }

    try {
      myResult = createModel((ModelFactoryType) myModelStorageFormat.getSelectedItem(), (ModelRoot) myModelRoots.getSelectedItem());
    } catch (ModelCannotBeCreatedException ex) {
      Messages.showErrorDialog(myProject.getProject(), "Could not create a new model because '" + ex.getMessage() + "'", "Error");
    }

    super.doOKAction();
  }

  private EditableSModel createModel(final ModelFactoryType storageFormat, final ModelRoot selectedModelRoot) throws ModelCannotBeCreatedException {
    final String fqName = getFqName();

    final Reference<SourceRoot> sourceRootOpt = new Reference<SourceRoot>(null);
    // next constant is purely for documentation purposes, just to indicate what's the intention of getOrCreateAccessortySourceRoot method 
    final boolean distinctSrcRoot4Accessory = false;
    if (myModule instanceof Language && selectedModelRoot instanceof DefaultModelRoot) {
      if (distinctSrcRoot4Accessory || !(selectedModelRoot.canCreateModel(fqName))) {
        sourceRootOpt.set(getOrCreateAccessorySourceRoot(((DefaultModelRoot) selectedModelRoot)));
      }
    }

    final Reference<ModelCannotBeCreatedException> refException = new Reference<ModelCannotBeCreatedException>();

    final EditableSModel res = new ModelAccessHelper(myProject.getModelAccess()).executeCommand(new Computable<EditableSModel>() {
      @Override
      public EditableSModel compute() {
        SModel result;
        try {
          if (selectedModelRoot instanceof DefaultModelRoot) {
            result = ((DefaultModelRoot) selectedModelRoot).createModel(new SModelName(fqName), sourceRootOpt.get(), null, storageFormat);
          } else {
            result = selectedModelRoot.createModel(fqName);
          }
          if (!(result instanceof EditableSModel)) {
            // XXX there seems to be no true need to get EditableSModel return value, please revisit 
            throw new ModelCannotBeCreatedException(String.format("Could not create EditableSModel, got %s", result));
          }
          // XXX do we need autoimports in case there's myClone we would copy from? 
          myProject.getComponent(ModelsAutoImportsManager.class).performImports(myModule, result);
          // XXX Perhaps, shall fix module dependencies only once imports of myClone has been copied? 
          new MissingDependenciesFixer(result).fixModuleDependencies();
        } catch (ModelCannotBeCreatedException e) {
          refException.set(e);
          return null;
        }
        final EditableSModel rv = ((EditableSModel) result);
        // newly created model is not marked as changed, won't get saved unless we tell it is. 
        rv.setChanged(true);
        if (myClone == null) {
          // due to threading issues and invokeLater processing, we have to do save here, in this platform write action 
          // so that dumb mode triggered from ProjectRootManagerComponent (wicked processing of a new model file created event) 
          // has a chance to get queued in EDT (see DumbServiceImpl.queueTaskOnEdt, invokeLater call) prior to our invokeLater in doOkAction(), above. 
          // DumbServiceImpl then clears dumb flag prior to model configurable dialog show up and eventually model imports popup has chances to get populated. 
          // see https://youtrack.jetbrains.com/issue/MPS-28999 
          rv.save();
          return rv;
        }
        ModelImports imports = new ModelImports(result);
        imports.copyImportedModelsFrom(myClone);
        imports.copyUsedLanguagesFrom(myClone);
        imports.copyEmployedDevKitsFrom(myClone);
        imports.copyLanguageEngagedOnGeneration(myClone);
        if (myPreserveIds) {
          CopyUtil.copyModelContentAndPreserveIds(myClone, result);
        } else {
          CopyUtil.copyModelContentAndUpdateCrossRootReferences(myClone, result);
        }
        if (myClone instanceof GeneratableSModel && result instanceof GeneratableSModel) {
          ((GeneratableSModel) result).setDoNotGenerate(((GeneratableSModel) myClone).isDoNotGenerate());
          ((GeneratableSModel) result).setGenerateIntoModelFolder(((GeneratableSModel) myClone).isGenerateIntoModelFolder());
        }
        rv.save();
        return rv;
      }
    });

    if (!(refException.isNull())) {
      throw refException.get();
    }

    return res;
  }

  private SourceRoot getOrCreateAccessorySourceRoot(final FileBasedModelRoot selectedModelRoot) {
    return new ModelAccessHelper(myProject.getModelAccess()).runWriteAction(new Computable<SourceRoot>() {
      public SourceRoot compute() {
        final String dedicatedSourceRootName = "languageAccessories";
        for (SourceRoot sr : selectedModelRoot.getSourceRoots(SourceRootKinds.SOURCES)) {
          if (sr.getPath().endsWith(dedicatedSourceRootName)) {
            return sr;
          }
        }
        DefaultSourceRoot rv = new DefaultSourceRoot(dedicatedSourceRootName, selectedModelRoot.getContentDirectory());
        selectedModelRoot.addSourceRoot(SourceRootKinds.SOURCES, rv);
        // it's up to model root impl to ensure module is marked changed on source root addition 
        return rv;
      }
    });
  }

  private String getFqName() {
    String stereo = myModelStereotype.getSelectedItem().toString().trim();
    return myModelName.getText() + ((stereo.length() > 0 ? "@" + stereo : ""));

  }

  private boolean check() {
    return new ModelAccessHelper(myProject.getModelAccess()).runReadAction(new Computable<Boolean>() {
      public Boolean compute() {
        return checkImpl();
      }
    });
  }

  private boolean checkImpl() {
    Object selected = myModelRoots.getSelectedItem();

    if (!((selected instanceof ModelRoot))) {
      setErrorText("Model root is not selected");
      return false;
    }

    ModelRoot mr = ((ModelRoot) selected);

    String modelName = myModelName.getText();
    if (modelName.length() == 0) {
      setErrorText("Empty model name isn't allowed");
      return false;
    }

    if (modelName.lastIndexOf(".") == modelName.length()) {
      setErrorText("Empty model short name isn't allowed");
      return false;
    }

    if (myModule instanceof Language) {
      if (LanguageAspectSupport.isLanguageModelNameForbidden(modelName)) {
        String shortName = modelName.substring(modelName.lastIndexOf(".") + 1);
        setErrorText("This name isn't allowed because '" + shortName + "' is language aspect name");
        return false;
      }
    }

    if (!(SourceVersion.isName(modelName))) {
      setErrorText("Model name should be valid Java package");
      return false;
    }

    if (!(mr.canCreateModel(getFqName()))) {
      boolean isLang = myModule instanceof Language;
      if (!(isLang) || !((mr instanceof FileBasedModelRoot))) {
        setErrorText("Can't create a model with this name under this model root");
        return false;
      }
    }

    setErrorText(null);
    return true;
  }

  @Nullable
  @Override
  protected JComponent createCenterPanel() {
    return myContentPane;
  }

  @Nullable
  @Override
  public JComponent getPreferredFocusedComponent() {
    return myModelName;
  }
}
