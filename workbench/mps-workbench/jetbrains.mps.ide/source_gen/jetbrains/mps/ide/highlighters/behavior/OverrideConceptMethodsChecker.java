package jetbrains.mps.ide.highlighters.behavior;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.BaseEventProcessingEditorChecker;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.checking.UpdateResult;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.util.Cancellable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.List;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.nodeEditor.EditorMessage;
import java.util.Collections;
import jetbrains.mps.ide.findusages.model.scopes.GlobalScope;

public final class OverrideConceptMethodsChecker extends BaseEventProcessingEditorChecker {
  /**
   * fixme transfer to a bundle
   */
  private static final int MAX_ITEMS_TO_SHOW = 5;

  private final MPSProject myProject;

  public OverrideConceptMethodsChecker(@NotNull MPSProject project) {
    myProject = project;
  }

  @NotNull
  @Override
  public UpdateResult update(EditorComponent component, boolean incremental, boolean applyQuickFixes, Cancellable cancellable) {
    SNode rootNode = component.getEditedNode();
    if (!(SNodeOperations.isInstanceOf(rootNode, MetaAdapterFactory.getConcept(0xaf65afd8f0dd4942L, 0x87d963a55f2a9db1L, 0x11d43447b1aL, "jetbrains.mps.lang.behavior.structure.ConceptBehavior")))) {
      return new UpdateResult.Completed(false, emptyListEditorMessage());
    }

    List<SNode> descendants = SNodeOperations.getNodeDescendants(rootNode, MetaAdapterFactory.getConcept(0xaf65afd8f0dd4942L, 0x87d963a55f2a9db1L, 0x11d4348057eL, "jetbrains.mps.lang.behavior.structure.ConceptMethodDeclaration"), false, new SAbstractConcept[]{});
    if (ListSequence.fromList(descendants).isEmpty()) {
      return new UpdateResult.Completed(false, emptyListEditorMessage());
    }
    List<EditorMessage> result = calculateEditorMessages(SNodeOperations.cast(rootNode, MetaAdapterFactory.getConcept(0xaf65afd8f0dd4942L, 0x87d963a55f2a9db1L, 0x11d43447b1aL, "jetbrains.mps.lang.behavior.structure.ConceptBehavior")), cancellable);
    if (cancellable.isCancelled()) {
      return new UpdateResult.Cancelled();
    }
    return new UpdateResult.Completed(true, result);
  }

  private static List<EditorMessage> emptyListEditorMessage() {
    return Collections.<EditorMessage>emptyList();
  }

  @NotNull
  private List<EditorMessage> calculateEditorMessages(SNode behavior, Cancellable cancellable) {
    List<EditorMessage> ancestors = new AncestorsMethodsLookup(cancellable, new GlobalScope(myProject), behavior, MAX_ITEMS_TO_SHOW).calcMessages();
    if (cancellable.isCancelled()) {
      return ancestors;
    }
    List<EditorMessage> descendants = new DescendantsMethodsLookup(cancellable, new GlobalScope(myProject), behavior, MAX_ITEMS_TO_SHOW).calcMessages();
    return ListSequence.fromList(ancestors).union(ListSequence.fromList(descendants)).toListSequence();
  }
}
