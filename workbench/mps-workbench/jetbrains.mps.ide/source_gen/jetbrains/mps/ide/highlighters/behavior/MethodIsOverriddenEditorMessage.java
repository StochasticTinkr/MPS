package jetbrains.mps.ide.highlighters.behavior;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorMessageIconRenderer;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import jetbrains.mps.openapi.editor.message.EditorMessageOwner;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import javax.swing.Icon;
import com.intellij.openapi.actionSystem.AnAction;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.openapi.actionSystem.ActionManager;

/**
 * a message for a method which is overridden by someone
 * could be overridden or implemented (different icon & text)
 */
public final class MethodIsOverriddenEditorMessage extends AbstractOverrideEditorMessage {
  private static final EditorMessageIconRenderer.IconRendererType TYPE = new EditorMessageIconRenderer.IconRendererType(1);
  private static final String INDENT = "     ";

  private static boolean isOverridden(SNode method) {
    return (SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1ffL, "body")) != null);
  }

  private final boolean myOverridden;

  public MethodIsOverriddenEditorMessage(SNode method, @Nullable List<SNode> overrides, EditorMessageOwner owner) {
    super(method, owner, tooltipText(method, overrides));
    this.myOverridden = isOverridden(method);
  }

  private static String tooltipText(SNode method, @Nullable List<SNode> overrides) {
    // fixme html reference to the concept 
    if (overrides == null) {
      return (isOverridden(method) ? "Is overridden in subclasses" : "Has implementations");
    }
    String prefix = ((isOverridden(method) ? "Is overridden" : "Is implemented")) + " in ";

    String tooltip = prefix;
    if (ListSequence.fromList(overrides).count() == 1) {
      tooltip = prefix + " " + MethodIsOverriddenEditorMessage.getTextFromOverride(ListSequence.fromList(overrides).getElement(0));
    } else {
      for (SNode override : ListSequence.fromList(overrides)) {
        tooltip += "\n" + INDENT + MethodIsOverriddenEditorMessage.getTextFromOverride(override);
      }
    }
    return tooltip;
  }

  private static String getTextFromOverride(SNode override) {
    return ((String) BHReflection.invoke0(((SNode) BHReflection.invoke0(override, MetaAdapterFactory.getConcept(0xaf65afd8f0dd4942L, 0x87d963a55f2a9db1L, 0x11d4348057eL, "jetbrains.mps.lang.behavior.structure.ConceptMethodDeclaration"), SMethodTrimmedId.create("getContainingConcept", MetaAdapterFactory.getConcept(0xaf65afd8f0dd4942L, 0x87d963a55f2a9db1L, 0x11d4348057eL, "jetbrains.mps.lang.behavior.structure.ConceptMethodDeclaration"), "i3POAMX"))), MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept"), SMethodTrimmedId.create("getFqName", null, "hEwIO9y")));
  }

  @Override
  public Icon getIcon() {
    return (this.myOverridden ? IconResourceBundle_OverrideImplements.getInstance().getResource("OVERRIDDEN") : IconResourceBundle_OverrideImplements.getInstance().getResource("IMPLEMENTED"));
  }

  @Override
  public EditorMessageIconRenderer.IconRendererType getType() {
    return TYPE;
  }

  @Override
  public AnAction getClickAction() {
    // that is right: the method is overridden (implemented) and we can navigate to the implemeting methods (descendant) 
    return ((BaseAction) ActionManager.getInstance().getAction("jetbrains.mps.ide.actions.GoToImplementationBehaviorMethod_Action"));
  }
}
