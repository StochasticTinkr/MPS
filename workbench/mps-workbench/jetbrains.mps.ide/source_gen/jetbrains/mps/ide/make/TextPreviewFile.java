package jetbrains.mps.ide.make;

/*Generated by MPS */

import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.text.TextUnit;
import org.jetbrains.annotations.NotNull;
import java.io.IOException;
import java.nio.charset.Charset;
import jetbrains.mps.util.FileUtil;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.vfs.VirtualFileSystem;
import com.intellij.openapi.fileTypes.FileType;
import com.intellij.openapi.fileTypes.FileTypeRegistry;
import com.intellij.openapi.fileTypes.UnknownFileType;
import com.intellij.openapi.fileTypes.PlainTextFileType;
import com.intellij.openapi.vfs.newvfs.NewVirtualFileSystem;
import com.intellij.openapi.util.io.FileAttributes;
import java.io.OutputStream;
import java.io.InputStream;
import com.intellij.util.ArrayUtil;

public class TextPreviewFile extends VirtualFile {
  private static TextPreviewFile.TextPreviewVirtualFileSystem FS = new TextPreviewFile.TextPreviewVirtualFileSystem();
  private static final String BINARY_CONTENT = "<binary content>";
  private final String myName;
  private final String myModelName;
  private final Object myFileContent;

  public TextPreviewFile(String name, Object fileContent, String modelName) {
    this.myName = name;
    this.myFileContent = fileContent;
    this.myModelName = modelName;
  }

  public TextPreviewFile(TextUnit textUnit, String modelName) {
    // FIXME what's in modelName, do we really care to prepend it to file name? 
    this(textUnit.getFileName(), textUnit, modelName);
  }

  @NotNull
  @Override
  public byte[] contentsToByteArray() throws IOException {
    if (myFileContent instanceof String) {
      return ((String) myFileContent).getBytes(getCharset());
    }
    if (myFileContent instanceof TextUnit) {
      return ((TextUnit) myFileContent).getBytes();
    }
    return BINARY_CONTENT.getBytes(getCharset());
  }
  @Override
  @NotNull
  public Charset getCharset() {
    if (myFileContent instanceof TextUnit) {
      return ((TextUnit) myFileContent).getEncoding();
    }
    return FileUtil.DEFAULT_CHARSET;
  }
  @NotNull
  @NonNls
  @Override
  public String getName() {
    return myName;
  }
  @Override
  public long getTimeStamp() {
    return 0L;
  }
  @Override
  public long getModificationStamp() {
    return 0L;
  }
  @Override
  @NotNull
  public String getPath() {
    return myModelName + "/" + myName;
  }
  @Nullable
  @Override
  public VirtualFile getParent() {
    return null;
  }
  @NotNull
  @Override
  public String getUrl() {
    return TextPreviewFile.TextPreviewVirtualFileSystem.PROTOCOL + getPath();
  }
  @NotNull
  @Override
  public VirtualFileSystem getFileSystem() {
    return FS;
  }
  @Override
  public boolean isDirectory() {
    return false;
  }
  @Override
  public boolean isValid() {
    return true;
  }
  @Override
  public boolean isWritable() {
    return false;
  }
  @Override
  public long getLength() {
    return (myFileContent instanceof String ? ((String) myFileContent).getBytes(getCharset()).length : 0);
  }
  @NotNull
  @Override
  public FileType getFileType() {
    FileType fileType = FileTypeRegistry.getInstance().getFileTypeByFileName(myName);
    if (fileType.equals(UnknownFileType.INSTANCE)) {
      return PlainTextFileType.INSTANCE;
    }
    return fileType;
  }

  private static class TextPreviewVirtualFileSystem extends NewVirtualFileSystem {
    private static String PROTOCOL = "preview";
    public TextPreviewVirtualFileSystem() {
    }
    @Override
    @NotNull
    public String getCanonicallyCasedName(VirtualFile file) {
      return file.getName();
    }
    @Nullable
    @Override
    public FileAttributes getAttributes(@NotNull VirtualFile file) {
      if (file instanceof TextPreviewFile) {
        return new FileAttributes(false, false, false, false, file.getLength(), file.getModificationStamp(), false);
      }
      return null;
    }
    @Override
    public boolean markNewFilesAsDirty() {
      return false;
    }
    @Override
    public boolean isReadOnly() {
      return true;
    }
    @Override
    public void refresh(boolean b) {
    }
    @Override
    public void refreshWithoutFileWatcher(boolean b) {
    }
    @Nullable
    @Override
    protected String normalize(String string) {
      return string;
    }
    @Nullable
    @Override
    public VirtualFile refreshAndFindFileByPath(@NotNull String string) {
      return null;
    }
    @Nullable
    @Override
    public VirtualFile findFileByPathIfCached(@NotNull @NonNls String string) {
      return null;
    }
    @Nullable
    @Override
    public VirtualFile findFileByPath(@NotNull @NonNls String string) {
      return null;
    }
    @Override
    @NotNull
    public String extractPresentableUrl(@NotNull String string) {
      return string;
    }
    @Override
    public void renameFile(Object object, @NotNull VirtualFile file, @NotNull String string) throws IOException {
    }
    @Override
    public void moveFile(Object object, @NotNull VirtualFile file, @NotNull VirtualFile file1) throws IOException {
    }
    @Override
    public void deleteFile(Object object, @NotNull VirtualFile file) throws IOException {
    }
    @Override
    @NotNull
    public VirtualFile createChildFile(Object object, @NotNull VirtualFile file, @NotNull String string) throws IOException {
      return null;
    }
    @NotNull
    @Override
    public VirtualFile createChildDirectory(Object object, @NotNull VirtualFile file, @NotNull String string) throws IOException {
      return null;
    }
    @Override
    @NotNull
    public VirtualFile copyFile(Object object, @NotNull VirtualFile file, @NotNull VirtualFile file1, @NotNull String string) throws IOException {
      return null;
    }
    @Override
    public int getRank() {
      return 0;
    }
    @NotNull
    @Override
    protected String extractRootPath(@NotNull String string) {
      return "/";
    }
    @Override
    public boolean isCaseSensitive() {
      return false;
    }
    @Override
    public long getLength(VirtualFile file) {
      return 0L;
    }
    @NotNull
    @Override
    public OutputStream getOutputStream(VirtualFile file, Object object, long l, long l1) throws IOException {
      return null;
    }
    @NotNull
    @Override
    public InputStream getInputStream(VirtualFile file) throws IOException {
      return null;
    }
    @NotNull
    @Override
    public byte[] contentsToByteArray(VirtualFile file) throws IOException {
      return null;
    }
    @Override
    public void setWritable(VirtualFile file, boolean b) throws IOException {
    }
    @Override
    public boolean isWritable(VirtualFile file) {
      return false;
    }
    @Override
    public void setTimeStamp(VirtualFile file, long l) throws IOException {
    }
    @Override
    public long getTimeStamp(VirtualFile file) {
      return 0L;
    }
    @Override
    public boolean isDirectory(VirtualFile file) {
      return false;
    }
    @NotNull
    @Override
    public String[] list(VirtualFile file) {
      return ArrayUtil.EMPTY_STRING_ARRAY;
    }
    @NonNls
    @NotNull
    @Override
    public String getProtocol() {
      return PROTOCOL;
    }
    @Override
    public boolean exists(VirtualFile file) {
      return false;
    }
  }
  @Override
  public void refresh(boolean b, boolean b1, @Nullable Runnable runnable) {
    // Do nothing and don't throw exception as StubVirtualFile to prevent error from TextPreviewModel_Action 
  }

  @Override
  public VirtualFile[] getChildren() {
    return new VirtualFile[0];
  }
  @NotNull
  @Override
  public OutputStream getOutputStream(Object object, long l, long l1) throws IOException {
    throw new UnsupportedOperationException();
  }
  @Override
  public InputStream getInputStream() throws IOException {
    return null;
  }
}
