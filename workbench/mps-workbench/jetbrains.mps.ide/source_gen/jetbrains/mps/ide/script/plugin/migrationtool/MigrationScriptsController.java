package jetbrains.mps.ide.script.plugin.migrationtool;

/*Generated by MPS */

import java.util.Collection;
import jetbrains.mps.ide.findusages.model.SearchResult;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.ide.ThreadUtils;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.lang.script.runtime.AbstractMigrationRefactoring;
import org.apache.log4j.Level;

public class MigrationScriptsController {
  private final MigrationScriptFinder myFinder;

  public MigrationScriptsController(MigrationScriptFinder finder) {
    myFinder = finder;
  }

  public Collection<SearchResult<SNode>> computeAliveIncludedResults(final List<SNodeReference> includedResultNodes, SRepository repo) {
    // apparently, requires model read. why does it demand EDT, is unclear 
    ThreadUtils.assertEDT();
    final List<SearchResult<SNode>> aliveIncludedResults = new ArrayList<SearchResult<SNode>>();
    final Set aliveIncludedNodes = new HashSet<SNode>();
    List<SNodeReference> includedNodes = includedResultNodes;
    for (SNodeReference includedNode : includedNodes) {
      SNode n;
      if ((n = includedNode.resolve(repo)) != null) {
        aliveIncludedNodes.add(n);
      }
    }
    List<SearchResult<SNode>> aliveResults = myFinder.getLastSearchResults().getAliveResults();
    for (SearchResult aliveResult : aliveResults) {
      if (aliveIncludedNodes.contains(aliveResult.getObject())) {
        aliveIncludedResults.add(aliveResult);
      }
    }
    return Collections.unmodifiableCollection(aliveIncludedResults);
  }

  protected static Logger LOG = LogManager.getLogger(MigrationScriptsController.class);
  public void process(final ProgressMonitor pmonitor, final Collection<SearchResult<SNode>> searchResults) {
    // requires model write 
    pmonitor.start("", searchResults.size());
    for (SearchResult<SNode> seachResult : searchResults) {
      pmonitor.advance(1);
      final SNode node = seachResult.getObject();
      if (node == null || node.getModel() == null) {
        return;
      }

      final AbstractMigrationRefactoring migrationRefactoring = myFinder.getRefactoring(seachResult);
      try {
        if (migrationRefactoring.isApplicableInstanceNode(node)) {
          migrationRefactoring.doUpdateInstanceNode(node);
        }
      } catch (Throwable th) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Script execution failed", th);
        }
      }
    }
    pmonitor.done();
  }
}
