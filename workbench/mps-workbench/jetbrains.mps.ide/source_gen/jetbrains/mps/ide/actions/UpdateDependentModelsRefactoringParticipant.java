package jetbrains.mps.ide.actions;

/*Generated by MPS */

import jetbrains.mps.refactoring.participant.RefactoringParticipantBase;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.refactoring.participant.MoveModelRefactoringParticipant;
import jetbrains.mps.smodel.structure.Extension;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import java.util.List;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.Set;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import jetbrains.mps.project.GlobalScope;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.ide.findusages.model.SearchResults;
import java.util.HashSet;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.refactoring.participant.MoveNodeRefactoringParticipant;
import jetbrains.mps.refactoring.participant.RefactoringSession;
import jetbrains.mps.smodel.SModelInternal;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SReferenceBase;

public class UpdateDependentModelsRefactoringParticipant extends RefactoringParticipantBase<SModelReference, SModelReference, SModel, SModel> implements MoveModelRefactoringParticipant<SModelReference, SModelReference> {

  public static class UpdateDependentModelsRefactoringParticipant_extension extends Extension.Default<MoveModelRefactoringParticipant<?, ?>> {
    public UpdateDependentModelsRefactoringParticipant_extension() {
      super("jetbrains.mps.refactoring.participant.MoveModelParticipantEP");
    }
    public MoveModelRefactoringParticipant<?, ?> get() {
      return new UpdateDependentModelsRefactoringParticipant();
    }
  }

  private final RefactoringParticipant.RefactoringDataCollector<SModelReference, SModelReference, SModel, SModel> myDataCollector = new RefactoringParticipant.RefactoringDataCollector<SModelReference, SModelReference, SModel, SModel>() {
    public SModelReference beforeMove(SModel modelToMove) {
      return modelToMove.getReference();
    }
    public SModelReference afterMove(SModel movedModel) {
      return movedModel.getReference();
    }
  };

  public RefactoringParticipant.RefactoringDataCollector<SModelReference, SModelReference, SModel, SModel> getDataCollector() {
    return myDataCollector;
  }

  private RefactoringParticipant.Option myOption = new RefactoringParticipant.Option("moveModel.options.updateNodeReferences", "Update node references");

  @Override
  public List<RefactoringParticipant.Option> getAvailableOptions(SModelReference initialState, SRepository repository) {
    return ListSequence.fromListAndArray(new ArrayList<RefactoringParticipant.Option>(), myOption);
  }

  @Override
  public List<RefactoringParticipant.Change<SModelReference, SModelReference>> getChanges(final SModelReference initialState, final SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, final ProgressMonitor progressMonitor) {
    if (!(ListSequence.fromList(selectedOptions).contains(myOption))) {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SModelReference, SModelReference>>());
    }

    progressMonitor.start(myOption.getDescription(), 1);
    final Wrappers._T<Set<SModel>> usages = new Wrappers._T<Set<SModel>>();
    final Wrappers._T<SModel> sourceModel = new Wrappers._T<SModel>();
    repository.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        usages.value = FindUsagesFacade.getInstance().findModelUsages(GlobalScope.getInstance(), Collections.singleton(initialState), progressMonitor.subTask(1));
        sourceModel.value = initialState.resolve(repository);
      }
    });

    return SetSequence.fromSet(usages.value).select(new ISelector<SModel, RefactoringParticipant.Change<SModelReference, SModelReference>>() {
      public RefactoringParticipant.Change<SModelReference, SModelReference> select(SModel it) {
        final SModelReference usageRef = it.getReference();
        final SearchResults searchResults = new SearchResults(SetSequence.fromSetAndArray(new HashSet<SModel>(), sourceModel.value), ListSequence.fromListAndArray(new ArrayList<SearchResult<SModel>>(), new SearchResult<SModel>(it, "dependent model")));
        RefactoringParticipant.Change<SModelReference, SModelReference> change = new MoveNodeRefactoringParticipant.ChangeBase<SModelReference, SModelReference>() {
          public SearchResults getSearchResults() {
            return searchResults;
          }
          public void confirm(final SModelReference finalState, final SRepository repository, RefactoringSession refactoringSession) {
            refactoringSession.registerChange(new Runnable() {
              public void run() {
                SModel usage = usageRef.resolve(repository);
                if (usage instanceof SModelInternal && usage instanceof EditableSModel) {
                  ((SModelInternal) usage).addModelImport(finalState);
                  updateUsages((EditableSModel) usage, initialState, finalState);
                  ((SModelInternal) usage).deleteModelImport(initialState);
                }
              }
            });
          }
        };
        return change;
      }
    }).toListSequence();
  }

  public static void updateUsages(EditableSModel usageModel, final SModelReference oldModelReference, final SModelReference newModelReference) {
    Iterable<SNode> nodes = (Iterable<SNode>) SNodeUtil.getDescendants(usageModel);
    Sequence.fromIterable(nodes).translate(new ITranslator2<SNode, SReference>() {
      public Iterable<SReference> translate(SNode it) {
        return SNodeOperations.getReferences(it);
      }
    }).where(new IWhereFilter<SReference>() {
      public boolean accept(SReference it) {
        return Objects.equals(it.getTargetSModelReference(), oldModelReference);
      }
    }).visitAll(new IVisitor<SReference>() {
      public void visit(SReference it) {
        ((SReferenceBase) (SReference) it).setTargetSModelReference(newModelReference);
      }
    });
    usageModel.setChanged(true);
  }

}
