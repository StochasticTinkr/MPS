package jetbrains.mps.ide.hierarchy;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import jetbrains.mps.icons.MPSIcons;
import jetbrains.mps.ide.ui.tree.TreeHighlighterExtension;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.project.GlobalScopeMinusTransient;
import java.util.Collections;
import jetbrains.mps.progress.EmptyProgressMonitor;

public class BaseLanguageHierarchyViewTool extends AbstractHierarchyView {
  public BaseLanguageHierarchyViewTool(Project project) {
    super(project, "Class Hierarchy", -1, MPSIcons.ToolWindows.ClassHierarchyView);
  }
  @Override
  protected AbstractHierarchyTree createHierarchyTree(boolean isParentHierarchy) {
    BaseLanguageHierarchyViewTool.BaseLanguageHierarchyTree tree = new BaseLanguageHierarchyViewTool.BaseLanguageHierarchyTree(getMPSProject().getRepository(), isParentHierarchy);
    tree.setHierarchyView(this);
    TreeHighlighterExtension.attachHighlighters(tree, getProject());
    return tree;
  }
  private static class BaseLanguageHierarchyTree extends AbstractHierarchyTree {
    private BaseLanguageHierarchyTree(SRepository repo, boolean isParentHierarchy) {
      super(repo);
      setParentHierarchy(isParentHierarchy);
    }
    @Override
    protected Set<SNode> getParents(SNode node, Set<SNode> visited) {
      HashSet<SNode> result = new HashSet<SNode>();
      if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
        SNode classConcept = SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
        SNode classifierType = SLinkOperations.getTarget(classConcept, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass"));
        if (classifierType != null) {
          SNode classifier = SLinkOperations.getTarget(classifierType, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"));
          if (SNodeOperations.isInstanceOf(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
            result.add(classifier);
          }
        }
        for (SNode interfaceType : SLinkOperations.getChildren(classConcept, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xff2ac0b419L, "implementedInterface"))) {
          SNode interfaceClassifier = SLinkOperations.getTarget(interfaceType, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"));
          if (SNodeOperations.isInstanceOf(interfaceClassifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
            result.add(interfaceClassifier);
          }
        }
      } else
      if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
        SNode anInterface = SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"));
        for (SNode interfaceType : SLinkOperations.getChildren(anInterface, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, 0x101eddadad7L, "extendedInterface"))) {
          SNode interfaceClassifier = SLinkOperations.getTarget(interfaceType, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"));
          if (SNodeOperations.isInstanceOf(interfaceClassifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
            result.add(interfaceClassifier);
          }
        }
      }
      return result;
    }
    @Override
    protected String noNodeString() {
      return "(no classifier)";
    }
    @Override
    protected SNode getParent(SNode node) {
      if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
        SNode classConcept = SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
        SNode type = SLinkOperations.getTarget(classConcept, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass"));
        if (type == null) {
          return null;
        }
        SNode classifier = SLinkOperations.getTarget(type, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"));
        if (SNodeOperations.isInstanceOf(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
          return classifier;
        }
      } else
      if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
        return null;
      }
      return null;
    }
    @Override
    protected Set<SNode> getDescendants(SNode node, Set<SNode> visited) {
      FindUsagesFacade fuFacade = FindUsagesFacade.getInstance();
      // FIXME there's ClassifierSuccessor index we can use here, although shall not use them directly 
      // but rather through FindUsagesFacade, with dedicated 'successor' query, so that there'd be single HierarchyViewTool, and finders plug through  
      // FindUsages to get accessed in a generic way. 
      Set<SReference> usages = fuFacade.findUsages(GlobalScopeMinusTransient.getInstance(), Collections.<SNode>singleton(node), new EmptyProgressMonitor());
      Set<SNode> result = new HashSet<SNode>();
      for (SReference usage : usages) {
        SNode sourceNode = usage.getSourceNode();
        if (MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier").equals(usage.getLink())) {
          if (SNodeOperations.isInstanceOf(sourceNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType"))) {
            SNode classifierType = SNodeOperations.cast(sourceNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType"));
            if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(classifierType), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")) && MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass").equals(classifierType.getContainmentLink())) {
              result.add(SNodeOperations.getParent(classifierType));
            }
            if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(classifierType), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")) && MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xff2ac0b419L, "implementedInterface").equals(classifierType.getContainmentLink())) {
              result.add(SNodeOperations.getParent(classifierType));
            }
            if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(classifierType), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface")) && MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, 0x101eddadad7L, "extendedInterface").equals(classifierType.getContainmentLink())) {
              result.add(SNodeOperations.getParent(classifierType));
            }
          }
        }
        if (MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, 0x1107e0fd2a0L, "classifier").equals(usage.getLink())) {
          if (SNodeOperations.isInstanceOf(sourceNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass"))) {
            SNode anonymousClass = SNodeOperations.cast(sourceNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass"));
            result.add(anonymousClass);
          }
        }
      }
      return result;
    }
  }
}
