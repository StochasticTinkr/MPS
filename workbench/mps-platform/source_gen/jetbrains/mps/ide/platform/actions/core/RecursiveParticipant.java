package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;

public interface RecursiveParticipant<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> extends RefactoringParticipant<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> {

  List<List<RefactoringParticipant.Change<InitialDataObject, FinalDataObject>>> getChanges(List<InitialDataObject> initialStates, SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor, Iterable<RefactoringParticipant.ParticipantApplied> parents);

  class RecursiveParticipantApplied<I, F, IP, FP> extends RefactoringParticipant.ParticipantApplied<I, F, IP, FP, IP, FP> {
    private Iterable<RefactoringParticipant.ParticipantApplied> myParents;
    public static <I, F, IP, FP> RecursiveParticipant.RecursiveParticipantApplied<I, F, IP, FP> create(RefactoringParticipant<I, F, IP, FP> participant, List<IP> oldNodes, Iterable<RefactoringParticipant.ParticipantApplied> parents) {
      return new RecursiveParticipant.RecursiveParticipantApplied<I, F, IP, FP>(participant, oldNodes, parents);
    }
    private RecursiveParticipantApplied(RefactoringParticipant<I, F, IP, FP> participant, List<IP> oldNodes, Iterable<RefactoringParticipant.ParticipantApplied> parents) {
      super(new RefactoringParticipant.CollectingParticipantStateFactory<IP, FP>(), participant, oldNodes);
      myParents = parents;
    }
    @Override
    protected List<List<RefactoringParticipant.Change<I, F>>> initChanges(final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope, final ProgressMonitor progressMonitor) {
      if (getParticipant() instanceof RecursiveParticipant) {
        if (Sequence.fromIterable(myParents).any(new IWhereFilter<RefactoringParticipant.ParticipantApplied>() {
          public boolean accept(RefactoringParticipant.ParticipantApplied parent) {
            return eq_7nv468_a0a0a0a0a0a0a0a0d3(parent.getParticipant(), RecursiveParticipantApplied.this.getParticipant()) && ListSequence.fromList(parent.getInitialStates()).containsSequence(ListSequence.fromList(RecursiveParticipantApplied.this.getInitialStates())) && ListSequence.fromList(((List<Object>) RecursiveParticipantApplied.this.getInitialStates())).containsSequence(ListSequence.fromList(parent.getInitialStates()));
          }
        })) {
          // todo: checked exception 
          throw new IllegalStateException("infinite recursion detected");
        } else {
          return mapNotNull(getInitialStates(), new _FunctionTypes._return_P1_E0<List<List<RefactoringParticipant.Change<I, F>>>, List<I>>() {
            public List<List<RefactoringParticipant.Change<I, F>>> invoke(List<I> initialStates) {
              return ((RecursiveParticipant<I, F, IP, FP>) getParticipant()).getChanges(initialStates, repository, selectedOptions, searchScope, progressMonitor, Sequence.fromIterable(myParents).concat(Sequence.fromIterable(Sequence.<RefactoringParticipant.ParticipantApplied>singleton(RecursiveParticipantApplied.this))));
            }
          });
        }
      } else {
        return super.initChanges(repository, selectedOptions, searchScope, progressMonitor);
      }
    }
    private static boolean eq_7nv468_a0a0a0a0a0a0a0a0d3(Object a, Object b) {
      return (a != null ? a.equals(b) : a == b);
    }
  }
}
