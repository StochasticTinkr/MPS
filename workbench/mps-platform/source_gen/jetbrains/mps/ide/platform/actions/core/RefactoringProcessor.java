package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.util.List;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchTask;
import jetbrains.mps.lang.migration.runtime.base.RefactoringSession;
import com.intellij.openapi.project.Project;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.ide.platform.refactoring.RefactoringAccessEx;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewAction;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewItem;
import org.apache.log4j.Level;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.module.SearchScope;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.util.SubProgressKind;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class RefactoringProcessor {

  public interface RefactoringSearchUI {
    void prepare(Runnable task);
    void runSearch(final _FunctionTypes._void_P1_E0<? super ProgressMonitor> task);
    List<RefactoringParticipant.Option> selectParticipants(List<RefactoringParticipant.Option> options);
  }

  public static interface RefactoringUI extends RefactoringProcessor.RefactoringSearchUI {
    void runRefactoring(final Runnable task, String refactoringName, SearchResults searchResults, SearchTask searchTask, RefactoringSession session);
  }

  public static class RefactoringSearchUIImpl implements RefactoringProcessor.RefactoringSearchUI {
    protected Project myProject;
    protected SRepository myRepository;
    public RefactoringSearchUIImpl(Project project, SRepository repository) {
      myRepository = repository;
      myProject = project;
    }
    public RefactoringSearchUIImpl(MPSProject mpsProject) {
      this(mpsProject.getProject(), mpsProject.getRepository());
    }
    public void prepare(Runnable task) {
      myRepository.getModelAccess().runReadAction(task);
    }
    public List<RefactoringParticipant.Option> selectParticipants(final List<RefactoringParticipant.Option> options) {
      if (ListSequence.fromList(options).isEmpty()) {
        return options;
      }
      List<Integer> selectedOptionIndices = SelectOptionsDialog.selectOptions(myProject, ListSequence.fromList(options).select(new ISelector<RefactoringParticipant.Option, String>() {
        public String select(RefactoringParticipant.Option it) {
          return it.getDescription();
        }
      }).toListSequence(), "Select Participants", "Select how to update usages:");
      if (selectedOptionIndices == null) {
        return null;
      }
      return ListSequence.fromList(selectedOptionIndices).select(new ISelector<Integer, RefactoringParticipant.Option>() {
        public RefactoringParticipant.Option select(Integer i) {
          return ListSequence.fromList(options).getElement(i);
        }
      }).toListSequence();
    }
    public void runSearch(final _FunctionTypes._void_P1_E0<? super ProgressMonitor> task) {
      ProgressManager.getInstance().run(new Task.Modal(myProject, "Refactoring", true) {
        public void run(@NotNull final ProgressIndicator progressIndicator) {
          progressIndicator.setIndeterminate(false);
          RefactoringSearchUIImpl.this.myRepository.getModelAccess().runReadAction(new Runnable() {
            public void run() {
              ProgressMonitorAdapter progressMonitor = new ProgressMonitorAdapter(progressIndicator);
              task.invoke(progressMonitor);
            }
          });
        }
      });
    }
  }

  public static class RefactoringUIImpl extends RefactoringProcessor.RefactoringSearchUIImpl implements RefactoringProcessor.RefactoringUI {
    private RefactoringSessionImpl myRefactoringSession;
    public RefactoringUIImpl(MPSProject project, RefactoringSessionImpl refactoringSession) {
      super(project);
      myRefactoringSession = refactoringSession;
    }
    public void runRefactoring(final Runnable performRefactoringTask, String refactoringName, SearchResults searchResults, final SearchTask rerunTask, RefactoringSession refactoringSession) {
      RefactoringAccessEx.getInstance().showRefactoringView(myProject, new RefactoringViewAction() {
        public void performAction(RefactoringViewItem refactoringViewItem) {
          try {
            myRepository.getModelAccess().executeCommand(new Runnable() {
              public void run() {
                performRefactoringTask.run();
                myRefactoringSession.close();
              }
            });
          } catch (RuntimeException exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Exception during refactoring: ", exception);
            }
          }
          refactoringViewItem.close();
        }
      }, searchResults, rerunTask, refactoringName);
    }
  }

  public static <IP, FP, IS, FS> Tuples._2<List<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>, List<RefactoringParticipant.Option>> askParticipantChanges(final RefactoringParticipant.ParticipantStateFactory<IP, FP, IS, FS> factory, RefactoringProcessor.RefactoringSearchUI refactoringUI, final SRepository repository, final SearchScope searchScope, final Iterable<? extends RefactoringParticipant<?, ?, IP, FP>> participants, final List<IS> nodes) {

    final List<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>> participantStates = ListSequence.fromList(new ArrayList<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>());
    final Wrappers._T<List<RefactoringParticipant.Option>> options = new Wrappers._T<List<RefactoringParticipant.Option>>();
    refactoringUI.prepare(new Runnable() {
      public void run() {
        for (RefactoringParticipant<?, ?, IP, FP> participant : Sequence.fromIterable(participants)) {
          ListSequence.fromList(participantStates).addElement(RefactoringParticipant.ParticipantState.create(factory, participant, nodes));
        }
        options.value = ListSequence.fromList(participantStates).translate(new ITranslator2<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>, RefactoringParticipant.Option>() {
          public Iterable<RefactoringParticipant.Option> translate(RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS> it) {
            return it.getAvaliableOptions(repository);
          }
        }).distinct().sort(new ISelector<RefactoringParticipant.Option, String>() {
          public String select(RefactoringParticipant.Option it) {
            return it.getDescription();
          }
        }, true).toListSequence();
      }
    });

    final List<RefactoringParticipant.Option> selectedOptions = refactoringUI.selectParticipants(options.value);
    if (selectedOptions == null) {
      return null;
    }
    final Wrappers._boolean cancelled = new Wrappers._boolean(false);
    refactoringUI.runSearch(new _FunctionTypes._void_P1_E0<ProgressMonitor>() {
      public void invoke(ProgressMonitor progressMonitor) {
        int steps = ListSequence.fromList(participantStates).count();
        progressMonitor.start("Searching for usages", steps);
        for (RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS> participantStates : ListSequence.fromList(participantStates)) {
          try {
            participantStates.findChanges(repository, selectedOptions, searchScope, progressMonitor.subTask(1, SubProgressKind.AS_COMMENT));
          } catch (RuntimeException e) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Exception during usages search", e);
            }
            cancelled.value = true;
            break;
          }
          if (progressMonitor.isCanceled()) {
            cancelled.value = true;
            break;
          }
        }
        progressMonitor.done();
      }
    });

    if (cancelled.value) {
      return null;
    }
    return MultiTuple.<List<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>,List<RefactoringParticipant.Option>>from(participantStates, selectedOptions);
  }

  public static <IP, FP> void performRefactoring(MPSProject project, String refactoringName, Iterable<? extends RefactoringParticipant<?, ?, IP, FP>> participants, final List<IP> initialStates, final _FunctionTypes._return_P2_E0<? extends _FunctionTypes._return_P1_E0<? extends FP, ? super IP>, ? super Iterable<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IP, FP>>, ? super RefactoringSession> doRefactor) {
    RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();
    performRefactoring(new RefactoringParticipant.CollectingParticipantStateFactory<IP, FP>(), new RefactoringProcessor.RefactoringUIImpl(project, refactoringSession), refactoringSession, project.getRepository(), project.getScope(), refactoringName, participants, initialStates, doRefactor);
  }

  public static <IP, FP, IS, FS> void performRefactoring(final RefactoringParticipant.ParticipantStateFactory<IP, FP, IS, FS> factory, RefactoringProcessor.RefactoringUI refactoringUI, final RefactoringSession refactoringSession, final SRepository repository, final SearchScope scope, String refactoringName, final Iterable<? extends RefactoringParticipant<?, ?, IP, FP>> participants, final List<IS> initialStates, final _FunctionTypes._return_P2_E0<? extends _FunctionTypes._return_P1_E0<? extends FS, ? super IS>, ? super Iterable<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>, ? super RefactoringSession> doRefactor) {


    final _FunctionTypes._return_P1_E0<? extends Tuples._2<Tuples._2<List<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>, List<RefactoringParticipant.Option>>, SearchResults>, ? super RefactoringProcessor.RefactoringSearchUI> searchTask = new _FunctionTypes._return_P1_E0<Tuples._2<Tuples._2<List<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>, List<RefactoringParticipant.Option>>, SearchResults>, RefactoringProcessor.RefactoringSearchUI>() {
      public Tuples._2<Tuples._2<List<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>, List<RefactoringParticipant.Option>>, SearchResults> invoke(RefactoringProcessor.RefactoringSearchUI rerunUI) {
        Tuples._2<List<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>, List<RefactoringParticipant.Option>> participantStates = askParticipantChanges(factory, rerunUI, repository, scope, participants, initialStates);
        if (participantStates == null) {
          return null;
        }

        SearchResults searchResults = new SearchResults();
        for (RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS> participantState : ListSequence.fromList(participantStates._0())) {
          List<? extends List<? extends RefactoringParticipant.Change<?, ?>>> participantChanges = participantState.getChanges();
          for (List<? extends RefactoringParticipant.Change<?, ?>> nodeChanges : ListSequence.fromList(participantChanges)) {
            for (RefactoringParticipant.Change<?, ?> change : ListSequence.fromList(nodeChanges)) {
              searchResults.addAll(change.getSearchResults());
            }
          }
        }
        return MultiTuple.<Tuples._2<List<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>, List<RefactoringParticipant.Option>>,SearchResults>from(participantStates, searchResults);
      }
    };
    final Tuples._2<Tuples._2<List<RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS>>, List<RefactoringParticipant.Option>>, SearchResults> searchResults = searchTask.invoke(refactoringUI);
    if (searchResults == null) {
      return;
    }

    refactoringUI.runRefactoring(new Runnable() {
      public void run() {
        final _FunctionTypes._return_P1_E0<? extends FS, ? super IS> getFinalObject = doRefactor.invoke(searchResults._0()._0(), refactoringSession);
        if (getFinalObject == null) {
          return;
        }
        for (RefactoringParticipant.ParticipantState<?, ?, IP, FP, IS, FS> participantState : ListSequence.fromList(searchResults._0()._0())) {
          participantState.doRefactor(ListSequence.fromList(initialStates).select(new ISelector<IS, FS>() {
            public FS select(IS it) {
              return getFinalObject.invoke(it);
            }
          }).toListSequence(), repository, refactoringSession);
        }
      }
    }, refactoringName, searchResults._1(), new SearchTask() {
      public boolean canExecute() {
        return true;
      }
      public SearchResults execute(final jetbrains.mps.project.Project project, final ProgressMonitor progressMonitor) {
        return searchTask.invoke(new RefactoringProcessor.RefactoringSearchUI() {
          public void prepare(Runnable task) {
            project.getRepository().getModelAccess().runReadAction(task);
          }
          @Override
          public List<RefactoringParticipant.Option> selectParticipants(List<RefactoringParticipant.Option> options) {
            return searchResults._0()._1();
          }
          @Override
          public void runSearch(final _FunctionTypes._void_P1_E0<? super ProgressMonitor> task) {
            project.getRepository().getModelAccess().runReadAction(new Runnable() {
              public void run() {
                task.invoke(progressMonitor);
              }
            });
          }
        })._1();
      }
    }, refactoringSession);
  }

  protected static Logger LOG = LogManager.getLogger(RefactoringProcessor.class);
}
