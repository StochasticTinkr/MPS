package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.project.MPSProject;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.ISelector;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import org.jetbrains.mps.openapi.util.SubProgressKind;
import org.apache.log4j.Level;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.platform.refactoring.RefactoringAccessEx;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewAction;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewItem;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class RefactoringProcessor {

  public static <T, S> Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> askParticipantChanges(final MPSProject project, final Iterable<? extends RefactoringParticipant<?, ?, T, S>> participants, final List<T> nodes) {
    final Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> changes = MapSequence.fromMap(new HashMap<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>>());
    final Wrappers._T<List<RefactoringParticipant.Option>> options = new Wrappers._T<List<RefactoringParticipant.Option>>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (RefactoringParticipant<?, ?, T, S> participant : Sequence.fromIterable(participants)) {
          MapSequence.fromMap(changes).put(participant, RefactoringParticipant.ParticipantState.create(participant, nodes));
        }
        options.value = MapSequence.fromMap(changes).translate(new ITranslator2<IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>>, RefactoringParticipant.Option>() {
          public Iterable<RefactoringParticipant.Option> translate(IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> it) {
            return it.value().getAvaliableOptions(project.getRepository());
          }
        }).distinct().sort(new ISelector<RefactoringParticipant.Option, String>() {
          public String select(RefactoringParticipant.Option it) {
            return it.getDescription();
          }
        }, true).toListSequence();
      }
    });

    final List<RefactoringParticipant.Option> selectedOptions = selectParticipants(project, options.value);
    if (selectedOptions == null) {
      return null;
    }
    final Wrappers._boolean cancelled = new Wrappers._boolean(false);
    ProgressManager.getInstance().run(new Task.Modal(project.getProject(), "Refactoring", true) {
      public void run(@NotNull ProgressIndicator progressIndicator) {
        final ProgressMonitorAdapter progressMonitor = new ProgressMonitorAdapter(progressIndicator);
        project.getRepository().getModelAccess().runReadAction(new Runnable() {
          public void run() {
            int steps = MapSequence.fromMap(changes).count();
            progressMonitor.start("Searching for usages", steps);
            for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> participantStates : MapSequence.fromMap(changes)) {
              try {
                participantStates.value().findChanges(project.getRepository(), selectedOptions, project.getScope(), progressMonitor.subTask(1, SubProgressKind.AS_COMMENT));
              } catch (RuntimeException e) {
                if (LOG.isEnabledFor(Level.ERROR)) {
                  LOG.error("Exception during usages search", e);
                }
                cancelled.value = true;
                break;
              }
              if (progressMonitor.isCanceled()) {
                cancelled.value = true;
                break;
              }
            }
            progressMonitor.done();
          }
        });
      }
    });

    if (cancelled.value) {
      return null;
    }
    return changes;
  }

  public static List<RefactoringParticipant.Option> selectParticipants(MPSProject project, final List<RefactoringParticipant.Option> options) {
    if (ListSequence.fromList(options).isEmpty()) {
      return options;
    }
    List<Integer> selectedOptionIndices = SelectOptionsDialog.selectOptions(project.getProject(), ListSequence.fromList(options).select(new ISelector<RefactoringParticipant.Option, String>() {
      public String select(RefactoringParticipant.Option it) {
        return it.getDescription();
      }
    }).toListSequence(), "Select Participants", "Select how to update usages:");
    if (selectedOptionIndices == null) {
      return null;
    }
    return ListSequence.fromList(selectedOptionIndices).select(new ISelector<Integer, RefactoringParticipant.Option>() {
      public RefactoringParticipant.Option select(Integer i) {
        return ListSequence.fromList(options).getElement(i);
      }
    }).toListSequence();
  }

  public static <T, S> void performRefactoring(final MPSProject project, String refactoringName, Iterable<? extends RefactoringParticipant<?, ?, T, S>> participants, final List<T> nodes, final _FunctionTypes._return_P2_E0<? extends _FunctionTypes._return_P1_E0<? extends S, ? super T>, ? super Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>>, ? super RefactoringSession> doRefactor) {
    final Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> changes = askParticipantChanges(project, participants, nodes);
    if (changes == null) {
      return;
    }

    SearchResults searchResults = new SearchResults();
    for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> participantState : MapSequence.fromMap(changes)) {
      List<? extends List<? extends RefactoringParticipant.Change<?, ?>>> partivipantChanges = participantState.value().getChanges();
      for (List<? extends RefactoringParticipant.Change<?, ?>> nodeChanges : ListSequence.fromList(partivipantChanges)) {
        for (RefactoringParticipant.Change<?, ?> change : ListSequence.fromList(nodeChanges)) {
          searchResults.addAll(change.getSearchResults());
        }
      }
    }

    RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(), new RefactoringViewAction() {
      public void performAction(RefactoringViewItem refactoringViewItem) {
        project.getRepository().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();
            final _FunctionTypes._return_P1_E0<? extends S, ? super T> getFinalObject = doRefactor.invoke(changes, refactoringSession);
            if (getFinalObject == null) {
              return;
            }
            for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> participantChanges : MapSequence.fromMap(changes)) {
              participantChanges.value().doRefactor(ListSequence.fromList(nodes).select(new ISelector<T, S>() {
                public S select(T it) {
                  return getFinalObject.invoke(it);
                }
              }).toListSequence(), project.getRepository(), refactoringSession);
            }
            try {
              refactoringSession.commit();
            } catch (RuntimeException exception) {
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Exception during refactoring: ", exception);
              }
            }
          }
        });
        refactoringViewItem.close();
      }
    }, searchResults, false, refactoringName);
  }

  protected static Logger LOG = LogManager.getLogger(RefactoringProcessor.class);
}
