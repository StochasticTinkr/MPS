package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import jetbrains.mps.ide.platform.refactoring.MoveNodesDialog;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.ISelector;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import org.jetbrains.mps.openapi.util.SubProgressKind;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.platform.refactoring.RefactoringAccessEx;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewAction;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewItem;
import org.apache.log4j.Level;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.Iterator;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MoveNodesDefault implements MoveNodesRefactoring {


  public String getName() {
    return "Move Nodes";
  }

  public static void moveNodes(List<SNode> nodes, MPSProject mpsProject) {
    MoveNodesDefault moveNodesDefault = new MoveNodesDefault();
    if (moveNodesDefault.isApplicable(mpsProject, nodes)) {
      moveNodesDefault.apply(mpsProject, nodes);
    }
  }

  public boolean isApplicable(MPSProject project, List<SNode> nodesToMove) {
    return canBeMoved(nodesToMove, project.getRepository());
  }

  public static boolean canBeMoved(final List<SNode> nodesToMove, SRepository repository) {
    if (ListSequence.fromList(nodesToMove).isEmpty()) {
      return false;
    }
    final Wrappers._boolean result = new Wrappers._boolean();
    repository.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        SNode firstNode = ListSequence.fromList(nodesToMove).first();
        final SContainmentLink containmentLink = firstNode.getContainmentLink();
        final SNode parent = firstNode.getParent();
        final SModel model = firstNode.getModel();
        result.value = ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return eq_92fyi8_a0a0a0a0a0a0a4a0a0a0a2a8(it.getContainmentLink(), containmentLink) && it.getParent() == parent && it.getModel() == model;
          }
        });
      }
    });
    return result.value;
  }

  public static class CopyMapObject {
    private static final String id = "refactoringSession.copyMap";
    private Map<SNode, SNode> copyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    public static MoveNodesDefault.CopyMapObject getCopyMap(RefactoringSession session) {
      MoveNodesDefault.CopyMapObject result = (MoveNodesDefault.CopyMapObject) session.getObject(id);
      if (result == null) {
        result = new MoveNodesDefault.CopyMapObject();
        session.putObject(id, result);
      }
      return result;
    }
    public Map<SNode, SNode> getCopyMap() {
      return copyMap;
    }
    public List<SNode> copy(List<SNode> oldNodes) {
      Map<SNode, SNode> localCopyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      List<SNode> result = CopyUtil.copyAndPreserveId(oldNodes, localCopyMap);
      MapSequence.fromMap(copyMap).putAll(localCopyMap);
      for (IMapping<SNode, SNode> mapping : MapSequence.fromMap(copyMap)) {
        CopyUtil.addReferences(mapping.key(), copyMap, false);
      }
      return result;
    }
  }

  public void apply(final MPSProject project, final List<SNode> nodesToMove) {

    final Wrappers._T<SModel> currentModel = new Wrappers._T<SModel>();
    final Wrappers._T<SContainmentLink> role = new Wrappers._T<SContainmentLink>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        currentModel.value = SNodeOperations.getModel(ListSequence.fromList(nodesToMove).first());
        role.value = ListSequence.fromList(nodesToMove).first().getContainmentLink();
      }
    });
    final SContainmentLink finalRole = role.value;
    final NodeLocation newLocation = MoveNodesDialog.getSelectedObject(project.getProject(), currentModel.value, new MoveNodesDialog.ModelFilter("Choose Node or Model") {
      @Override
      public boolean check(final NodeLocation selectedObject, SModel model) {
        if (selectedObject == null) {
          return false;
        }
        if (selectedObject instanceof NodeLocation.NodeLocationChild) {
          if (finalRole == null) {
            return false;
          }
          final Wrappers._T<Collection<SContainmentLink>> containmentLinks = new Wrappers._T<Collection<SContainmentLink>>();
          project.getRepository().getModelAccess().runReadAction(new Runnable() {
            public void run() {
              containmentLinks.value = ((NodeLocation.NodeLocationChild) selectedObject).getNode().resolve(project.getRepository()).getConcept().getContainmentLinks();
            }
          });
          return CollectionSequence.fromCollection(containmentLinks.value).contains(finalRole);
        } else {
          return true;
        }
      }
    });
    if (newLocation instanceof NodeLocation.NodeLocationChild) {
      ((NodeLocation.NodeLocationChild) newLocation).setRole(role.value);
    }
    if (newLocation == null) {
      return;
    }
    Map<SNode, MoveNodesDefault.NodeProcessor> moveMap = MapSequence.fromMap(new HashMap<SNode, MoveNodesDefault.NodeProcessor>());
    MoveNodesDefault.NodeProcessor processor = new MoveNodesDefault.CopyingNodeProcessor(newLocation, project);
    for (SNode node : ListSequence.fromList(nodesToMove)) {
      MapSequence.fromMap(moveMap).put(node, processor);
    }
    doMove(project, moveMap, null);
  }

  public static class ToMoveItem extends MultiTuple._2<List<SNode>, NodeLocation> {
    public ToMoveItem() {
      super();
    }
    public ToMoveItem(List<SNode> nodes, NodeLocation newLocation) {
      super(nodes, newLocation);
    }
    public List<SNode> nodes(List<SNode> value) {
      return super._0(value);
    }
    public NodeLocation newLocation(NodeLocation value) {
      return super._1(value);
    }
    public List<SNode> nodes() {
      return super._0();
    }
    public NodeLocation newLocation() {
      return super._1();
    }
  }

  @NotNull
  public static SNode resolveNode(SNodeReference nodeReference, Project project) {
    SNode node = nodeReference.resolve(project.getRepository());
    if (node == null) {
      throw new IllegalArgumentException("Node " + nodeReference + " doesn't exist in current project.");
    }
    return node;
  }

  public static void doMove(final MPSProject project, final List<ToMoveItem> toMove, _FunctionTypes._void_P1_E0<? super RefactoringSession> callBack) {
    Map<SNode, MoveNodesDefault.NodeProcessor> moveMap = MapSequence.fromMap(new HashMap<SNode, MoveNodesDefault.NodeProcessor>());
    for (ToMoveItem nodesToMove : ListSequence.fromList(toMove)) {
      MoveNodesDefault.NodeProcessor processor = new MoveNodesDefault.CopyingNodeProcessor(nodesToMove.newLocation(), project);
      for (SNode node : ListSequence.fromList(nodesToMove.nodes())) {
        MapSequence.fromMap(moveMap).put(node, processor);
      }
    }
    doMove(project, moveMap, callBack);
  }

  public static <T, S> Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> askParticipantChanges(final MPSProject project, final Iterable<? extends RefactoringParticipant<?, ?, T, S>> participants, final List<T> nodes) {
    final Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> changes = MapSequence.fromMap(new HashMap<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>>());
    final Wrappers._T<List<RefactoringParticipant.Option>> options = new Wrappers._T<List<RefactoringParticipant.Option>>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (RefactoringParticipant<?, ?, T, S> participant : Sequence.fromIterable(participants)) {
          MapSequence.fromMap(changes).put(participant, RefactoringParticipant.ParticipantState.create(participant, nodes));
        }
        options.value = MapSequence.fromMap(changes).translate(new ITranslator2<IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>>, RefactoringParticipant.Option>() {
          public Iterable<RefactoringParticipant.Option> translate(IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> it) {
            return it.value().getAvaliableOptions(project.getRepository());
          }
        }).distinct().sort(new ISelector<RefactoringParticipant.Option, String>() {
          public String select(RefactoringParticipant.Option it) {
            return it.getDescription();
          }
        }, true).toListSequence();
      }
    });

    final List<RefactoringParticipant.Option> selectedOptions = selectParticipants(project, options.value);

    final Wrappers._boolean cancelled = new Wrappers._boolean(false);
    ProgressManager.getInstance().run(new Task.Modal(project.getProject(), "Refactoring", true) {
      public void run(@NotNull ProgressIndicator progressIndicator) {
        final ProgressMonitorAdapter progressMonitor = new ProgressMonitorAdapter(progressIndicator);
        project.getRepository().getModelAccess().runReadAction(new Runnable() {
          public void run() {
            int steps = MapSequence.fromMap(changes).count();
            progressMonitor.start("Searching for usages", steps);
            for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> participantStates : MapSequence.fromMap(changes)) {
              participantStates.value().findChanges(project.getRepository(), selectedOptions, project.getScope(), progressMonitor.subTask(1, SubProgressKind.AS_COMMENT));
              if (progressMonitor.isCanceled()) {
                cancelled.value = true;
                break;
              }
            }
            progressMonitor.done();
          }
        });
      }
    });

    if (cancelled.value) {
      return null;
    }
    return changes;
  }

  public static List<RefactoringParticipant.Option> selectParticipants(MPSProject project, final List<RefactoringParticipant.Option> options) {
    if (ListSequence.fromList(options).isEmpty()) {
      return options;
    }
    List<Integer> selectedOptionIndices = SelectOptionsDialog.selectOptions(project.getProject(), ListSequence.fromList(options).select(new ISelector<RefactoringParticipant.Option, String>() {
      public String select(RefactoringParticipant.Option it) {
        return it.getDescription();
      }
    }).toListSequence(), "Select Participants", "Select how to update usages:");
    if (selectedOptionIndices == null) {
      return null;
    }
    return ListSequence.fromList(selectedOptionIndices).select(new ISelector<Integer, RefactoringParticipant.Option>() {
      public RefactoringParticipant.Option select(Integer i) {
        return ListSequence.fromList(options).getElement(i);
      }
    }).toListSequence();
  }

  public static <T, S> void performRefactoring(final MPSProject project, String refactoringName, Iterable<? extends RefactoringParticipant<?, ?, T, S>> participants, final List<T> nodes, final _FunctionTypes._return_P2_E0<? extends _FunctionTypes._return_P1_E0<? extends S, ? super T>, ? super Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>>, ? super RefactoringSession> doRefactor) {
    final Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> changes = askParticipantChanges(project, participants, nodes);
    if (changes == null) {
      return;
    }

    SearchResults searchResults = new SearchResults();
    for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> participantState : MapSequence.fromMap(changes)) {
      List<? extends List<? extends RefactoringParticipant.Change<?, ?>>> partivipantChanges = participantState.value().getChanges();
      for (List<? extends RefactoringParticipant.Change<?, ?>> nodeChanges : ListSequence.fromList(partivipantChanges)) {
        for (RefactoringParticipant.Change<?, ?> change : ListSequence.fromList(nodeChanges)) {
          searchResults.addAll(change.getSearchResults());
        }
      }
    }

    RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(), new RefactoringViewAction() {
      public void performAction(RefactoringViewItem refactoringViewItem) {
        project.getRepository().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();
            final _FunctionTypes._return_P1_E0<? extends S, ? super T> getFinalObject = doRefactor.invoke(changes, refactoringSession);
            for (IMapping<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, T, S>> participantChanges : MapSequence.fromMap(changes)) {
              participantChanges.value().doRefactor(ListSequence.fromList(nodes).select(new ISelector<T, S>() {
                public S select(T it) {
                  return getFinalObject.invoke(it);
                }
              }).toListSequence(), project.getRepository(), refactoringSession);
            }
            try {
              refactoringSession.commit();
            } catch (RuntimeException exception) {
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Exception during refactoring: ", exception);
              }
            }
          }
        });
        refactoringViewItem.close();
      }
    }, searchResults, false, refactoringName);
  }

  public static void doMove(final MPSProject project, final Map<SNode, MoveNodesDefault.NodeProcessor> moveMap, final _FunctionTypes._void_P1_E0<? super RefactoringSession> initRefactoringSession) {

    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (IMapping<SNode, MoveNodesDefault.NodeProcessor> moving : MapSequence.fromMap(moveMap)) {
          if (!(moving.value().isValid(moving.key()))) {
            throw new IllegalArgumentException();
          }
        }
      }
    });

    final Wrappers._T<List<SNode>> allNodes = new Wrappers._T<List<SNode>>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        allNodes.value = ListSequence.fromListWithValues(new ArrayList<SNode>(), SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet()).translate(new ITranslator2<SNode, SNode>() {
          public Iterable<SNode> translate(SNode it) {
            return SNodeOperations.getNodeDescendants(it, null, true, new SAbstractConcept[]{});
          }
        }));
      }
    });

    Iterable<? extends RefactoringParticipant<?, ?, SNode, SNode>> participants = new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects();
    performRefactoring(project, "Move nodes", participants, allNodes.value, new _FunctionTypes._return_P2_E0<_FunctionTypes._return_P1_E0<? extends SNode, ? super SNode>, Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>>, RefactoringSession>() {
      public _FunctionTypes._return_P1_E0<? extends SNode, ? super SNode> invoke(final Map<RefactoringParticipant, RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>> changes, RefactoringSession refactoringSession) {
        if (initRefactoringSession != null) {
          initRefactoringSession.invoke(refactoringSession);
        }

        final Map<MoveNodesDefault.NodeProcessor, List<SNode>> nodeProcessors = MapSequence.fromMap(new HashMap<MoveNodesDefault.NodeProcessor, List<SNode>>());
        MapSequence.fromMap(moveMap).visitAll(new IVisitor<IMapping<SNode, MoveNodesDefault.NodeProcessor>>() {
          public void visit(IMapping<SNode, MoveNodesDefault.NodeProcessor> mapping) {
            MoveNodesDefault.NodeProcessor processor = mapping.value();
            if (!(MapSequence.fromMap(nodeProcessors).containsKey(processor))) {
              MapSequence.fromMap(nodeProcessors).put(processor, ListSequence.fromList(new ArrayList<SNode>()));
            }
            ListSequence.fromList(MapSequence.fromMap(nodeProcessors).get(processor)).addElement(mapping.key());
          }
        });
        for (IMapping<MoveNodesDefault.NodeProcessor, List<SNode>> mapping : MapSequence.fromMap(nodeProcessors)) {
          mapping.key().process(mapping.value(), ListSequence.fromList(mapping.value()).where(new IWhereFilter<SNode>() {
            public boolean accept(final SNode moveRoot) {
              boolean shouldKeep = Sequence.fromIterable(MapSequence.fromMap(changes).values()).any(new IWhereFilter<RefactoringParticipant.ParticipantState<?, ?, SNode, SNode>>() {
                public boolean accept(final RefactoringParticipant.ParticipantState<?, ?, SNode, SNode> participantState) {
                  return ListSequence.fromList(SNodeOperations.getNodeDescendants(moveRoot, null, true, new SAbstractConcept[]{})).any(new IWhereFilter<SNode>() {
                    public boolean accept(SNode desc) {
                      return ListSequence.fromList(participantState.getChanges()).any(new IWhereFilter<List<? extends RefactoringParticipant.Change<?, ?>>>() {
                        public boolean accept(List<? extends RefactoringParticipant.Change<?, ?>> participantChanges) {
                          return ListSequence.fromList(participantChanges).any(new IWhereFilter<RefactoringParticipant.Change<?, ?>>() {
                            public boolean accept(RefactoringParticipant.Change<?, ?> change) {
                              return change.needsToPreserveOldNode();
                            }
                          });
                        }
                      });
                    }
                  });
                }
              });
              return !(shouldKeep);
            }
          }).toListSequence(), refactoringSession);
        }
        final Map<SNode, SNode> copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();
        return new _FunctionTypes._return_P1_E0<SNode, SNode>() {
          public SNode invoke(SNode oldNode) {
            return MapSequence.fromMap(copyMap).get(oldNode);
          }
        };
      }
    });
  }

  public static interface NodeProcessor {
    boolean isValid(List<SNode> nodesToMove);
    boolean isValid(SNode nodeToMove);
    void process(List<SNode> nodesToMove, List<SNode> whichOfThemToRemove, RefactoringSession refactoringSession);
  }

  public static class CopyingNodeProcessor implements MoveNodesDefault.NodeProcessor {
    private NodeLocation myNodeLocation;
    private Project myProject;
    public CopyingNodeProcessor(NodeLocation location, Project project) {
      myNodeLocation = location;
      myProject = project;
    }
    public boolean isValid(List<SNode> nodesToMove) {
      return ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return isValid(it);
        }
      });
    }
    public boolean isValid(SNode nodeToMove) {
      return myNodeLocation.canInsert(myProject.getRepository(), nodeToMove);
    }
    public void process(List<SNode> nodesToMove, List<SNode> whichOfThemToRemove, RefactoringSession refactoringSession) {
      MoveNodesDefault.CopyMapObject copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession);
      copyMap.copy(nodesToMove);
      {
        Iterator<SNode> oldNode_it = ListSequence.fromList(whichOfThemToRemove).iterator();
        SNode oldNode_var;
        while (oldNode_it.hasNext()) {
          oldNode_var = oldNode_it.next();
          SNodeOperations.detachNode(oldNode_var);
        }
      }
      {
        Iterator<SNode> oldNode_it = ListSequence.fromList(nodesToMove).iterator();
        SNode oldNode_var;
        while (oldNode_it.hasNext()) {
          oldNode_var = oldNode_it.next();
          myNodeLocation.insertNode(myProject.getRepository(), MapSequence.fromMap(copyMap.getCopyMap()).get(oldNode_var));
        }
      }
    }
  }

  public static class MergingNodeProcessor implements MoveNodesDefault.NodeProcessor {
    private SNodeReference myTarget;
    private Project myProject;
    public MergingNodeProcessor(SNodeReference target, Project project) {
      myTarget = target;
      myProject = project;
    }
    public boolean isValid(List<SNode> nodesToMove) {
      return ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return isValid(it);
        }
      });
    }
    public boolean isValid(SNode nodeToMove) {
      return myTarget.resolve(myProject.getRepository()) != null;
    }
    public void process(List<SNode> nodesToMove, List<SNode> whichOfThemToRemove, RefactoringSession refactoringSession) {
      if (ListSequence.fromList(nodesToMove).count() != 1) {
        throw new IllegalArgumentException();
      }
      MoveNodesDefault.CopyMapObject copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession);
      MapSequence.fromMap(copyMap.getCopyMap()).put(ListSequence.fromList(nodesToMove).first(), myTarget.resolve(myProject.getRepository()));
      {
        Iterator<SNode> oldNode_it = ListSequence.fromList(whichOfThemToRemove).iterator();
        SNode oldNode_var;
        while (oldNode_it.hasNext()) {
          oldNode_var = oldNode_it.next();
          SNodeOperations.detachNode(oldNode_var);
        }
      }
    }
  }


  protected static Logger LOG = LogManager.getLogger(MoveNodesDefault.class);
  private static boolean eq_92fyi8_a0a0a0a0a0a0a4a0a0a0a2a8(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
