package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.project.Project;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.migration.runtime.base.RefactoringSession;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Collections;
import jetbrains.mps.smodel.CopyUtil;

public class MoveNodesUtil {


  public static boolean areSiblings(final List<SNode> nodesToMove, SRepository repository) {
    if (ListSequence.fromList(nodesToMove).isEmpty()) {
      return false;
    }
    final Wrappers._boolean result = new Wrappers._boolean();
    repository.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        SNode firstNode = ListSequence.fromList(nodesToMove).first();
        final SContainmentLink containmentLink = firstNode.getContainmentLink();
        final SNode parent = firstNode.getParent();
        final SModel model = firstNode.getModel();
        result.value = ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return eq_nlglo1_a0a0a0a0a0a0a4a0a0a0a2a2(it.getContainmentLink(), containmentLink) && it.getParent() == parent && it.getModel() == model;
          }
        });
      }
    });
    return result.value;
  }

  @NotNull
  public static SNode resolveNode(SNodeReference nodeReference, Project project) {
    // todo: unused method 
    SNode node = nodeReference.resolve(project.getRepository());
    if (node == null) {
      throw new IllegalArgumentException("Node " + nodeReference + " doesn't exist in current project.");
    }
    return node;
  }

  public static class ListIndex<T> {
    private Map<T, Integer> myIndices = MapSequence.fromMap(new HashMap<T, Integer>());
    public ListIndex(List<T> patternList) {
      for (int i = 0; i < ListSequence.fromList(patternList).count(); i++) {
        MapSequence.fromMap(myIndices).put(ListSequence.fromList(patternList).getElement(i), i);
      }
    }
    public int getIndex(T object) {
      return MapSequence.fromMap(myIndices).get(object);
    }
    public <S> S getCorrespondent(List<S> list, T anchor) {
      return ListSequence.fromList(list).getElement(getIndex(anchor));
    }
  }


  public static void moveTo(final MPSProject project, String refactoringName, final Map<MoveNodesUtil.NodeProcessor, List<SNode>> processorToMoveRoots) {

    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (IMapping<MoveNodesUtil.NodeProcessor, List<SNode>> mapping : MapSequence.fromMap(processorToMoveRoots)) {
          if (!(mapping.key().isValid(mapping.value()))) {
            throw new IllegalArgumentException();
          }
        }
      }
    });

    final Map<SNodeReference, List<SNodeReference>> moveRootsToDescendants = MapSequence.fromMap(new HashMap<SNodeReference, List<SNodeReference>>());
    final List<SNode> allNodes = ListSequence.fromList(new ArrayList<SNode>());
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (IMapping<MoveNodesUtil.NodeProcessor, List<SNode>> mapping : MapSequence.fromMap(processorToMoveRoots)) {
          MoveNodesUtil.NodeProcessor processor = mapping.key();
          for (SNode moveRoot : ListSequence.fromList(mapping.value())) {
            List<SNode> nodesToSearch = processor.getNodesToSearch(moveRoot);
            MapSequence.fromMap(moveRootsToDescendants).put(moveRoot.getReference(), ListSequence.fromList(nodesToSearch).select(new ISelector<SNode, SNodeReference>() {
              public SNodeReference select(SNode it) {
                return it.getReference();
              }
            }).toListSequence());
            ListSequence.fromList(allNodes).addSequence(ListSequence.fromList(nodesToSearch));
          }
        }
      }
    });
    final MoveNodesUtil.ListIndex<SNodeReference> nodeChangesCorrespondence = new MoveNodesUtil.ListIndex<SNodeReference>(ListSequence.fromList(allNodes).select(new ISelector<SNode, SNodeReference>() {
      public SNodeReference select(SNode it) {
        return it.getReference();
      }
    }).toListSequence());

    Iterable<? extends RefactoringParticipant<?, ?, SNode, SNode>> participants = (Iterable<? extends RefactoringParticipant<?, ?, SNode, SNode>>) new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects();
    final Map<SNode, RefactoringParticipant.KeepOldNodes> removeOldRoots = MapSequence.fromMap(new HashMap<SNode, RefactoringParticipant.KeepOldNodes>());
    RefactoringProcessor.performRefactoringUserInteractive(project, refactoringName, participants, allNodes, new _FunctionTypes._return_P2_E0<Map<SNode, SNode>, Iterable<RefactoringParticipant.ParticipantApplied<?, ?, SNode, SNode, SNode, SNode>>, RefactoringSession>() {
      public Map<SNode, SNode> invoke(final Iterable<RefactoringParticipant.ParticipantApplied<?, ?, SNode, SNode, SNode, SNode>> participantStates, RefactoringSession refactoringSession) {
        for (IMapping<MoveNodesUtil.NodeProcessor, List<SNode>> mapping : MapSequence.fromMap(processorToMoveRoots)) {
          List<SNode> moveRoots = mapping.value();
          MoveNodesUtil.NodeProcessor processor = mapping.key();

          for (SNode moveRoot : ListSequence.fromList(moveRoots)) {
            MapSequence.fromMap(removeOldRoots).put(moveRoot, RefactoringParticipant.KeepOldNodes.max(ListSequence.fromList(MapSequence.fromMap(moveRootsToDescendants).get(moveRoot.getReference())).translate(new ITranslator2<SNodeReference, RefactoringParticipant.KeepOldNodes>() {
              public Iterable<RefactoringParticipant.KeepOldNodes> translate(final SNodeReference descendant) {
                return Sequence.fromIterable(participantStates).select(new ISelector<RefactoringParticipant.ParticipantApplied<?, ?, SNode, SNode, SNode, SNode>, RefactoringParticipant.KeepOldNodes>() {
                  public RefactoringParticipant.KeepOldNodes select(RefactoringParticipant.ParticipantApplied<?, ?, SNode, SNode, SNode, SNode> participantState) {
                    List<? extends RefactoringParticipant.Change<?, ?>> changes = nodeChangesCorrespondence.getCorrespondent(participantState.getChanges(), descendant);
                    return RefactoringParticipant.KeepOldNodes.max(ListSequence.fromList(changes).select(new ISelector<RefactoringParticipant.Change<?, ?>, RefactoringParticipant.KeepOldNodes>() {
                      public RefactoringParticipant.KeepOldNodes select(RefactoringParticipant.Change<?, ?> change) {
                        return ((MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>) ((RefactoringParticipant.Change) change)).needsToPreserveOldNode();
                      }
                    }));
                  }
                });
              }
            })));
          }

          processor.process(moveRoots, removeOldRoots, refactoringSession);
        }
        return MoveNodesUtil.NodeCopyTracker.get(refactoringSession).getCopyMap();
      }
    }, new _FunctionTypes._void_P1_E0<RefactoringSession>() {
      public void invoke(RefactoringSession refactoringSession) {
        for (MoveNodesUtil.NodeProcessor processor : SetSequence.fromSet(MapSequence.fromMap(processorToMoveRoots).keySet())) {
          processor.removeAfterRefactoring(removeOldRoots, refactoringSession);
        }
      }
    });
  }

  public static abstract class NodeProcessor {
    public abstract boolean isValid(List<SNode> nodesToMove);
    public abstract boolean isValid(SNode nodeToMove);
    public abstract List<SNode> getNodesToSearch(SNode nodeToMove);
    public abstract void process(List<SNode> nodesToMove, Map<SNode, RefactoringParticipant.KeepOldNodes> ifKeepOldNodes, RefactoringSession refactoringSession);
    public void removeAfterRefactoring(Map<SNode, RefactoringParticipant.KeepOldNodes> ifKeepOldNodes, RefactoringSession refactoringSession) {
      for (SNode oldNode : SetSequence.fromSet(MapSequence.fromMap(ifKeepOldNodes).keySet())) {
        if (MapSequence.fromMap(ifKeepOldNodes).get(oldNode) != RefactoringParticipant.KeepOldNodes.KEEP) {
          SNodeOperations.detachNode(oldNode);
        }
      }
    }

  }

  public static class NodeCreatingProcessor extends MoveNodesUtil.NodeProcessor {
    protected NodeLocation myNodeLocation;
    protected Project myProject;
    public NodeCreatingProcessor(NodeLocation location, Project project) {
      myNodeLocation = location;
      myProject = project;
    }
    public boolean isValid(List<SNode> nodesToMove) {
      return ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return isValid(it);
        }
      });
    }
    public boolean isValid(SNode nodeToMove) {
      return myNodeLocation.canInsert(myProject.getRepository(), nodeToMove);
    }
    public List<SNode> getNodesToSearch(SNode nodeToMove) {
      return SNodeOperations.getNodeDescendants(nodeToMove, null, true, new SAbstractConcept[]{});
    }
    public void process(List<SNode> nodeRoots, Map<SNode, RefactoringParticipant.KeepOldNodes> ifKeepOldNodes, RefactoringSession refactoringSession) {
      MoveNodesUtil.NodeCopyTracker copyMap = MoveNodesUtil.NodeCopyTracker.get(refactoringSession);
      copyMap.copyAndTrack(nodeRoots);
      for (SNode oldNode : ListSequence.fromList(nodeRoots)) {
        if (MapSequence.fromMap(ifKeepOldNodes).get(oldNode) == RefactoringParticipant.KeepOldNodes.REMOVE) {
          SNodeOperations.detachNode(oldNode);
        }
        myNodeLocation.insertNode(myProject.getRepository(), MapSequence.fromMap(copyMap.getCopyMap()).get(oldNode));
      }
    }
  }

  public static class ExistingTargetProcessor extends MoveNodesUtil.NodeProcessor {
    private SNodeReference myTarget;
    private Project myProject;
    public ExistingTargetProcessor(SNodeReference target, Project project) {
      myTarget = target;
      myProject = project;
    }
    public boolean isValid(List<SNode> nodesToMove) {
      return ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return isValid(it);
        }
      });
    }
    public boolean isValid(SNode nodeToMove) {
      return myTarget.resolve(myProject.getRepository()) != null;
    }
    public List<SNode> getNodesToSearch(SNode nodeToMove) {
      return ListSequence.fromListAndArray(new ArrayList<SNode>(), nodeToMove);
    }
    public void process(List<SNode> nodesToMove, Map<SNode, RefactoringParticipant.KeepOldNodes> ifKeepOldNodes, RefactoringSession refactoringSession) {
      if (ListSequence.fromList(nodesToMove).count() != 1) {
        throw new IllegalArgumentException();
      }
      MoveNodesUtil.NodeCopyTracker copyMap = MoveNodesUtil.NodeCopyTracker.get(refactoringSession);
      MapSequence.fromMap(copyMap.getCopyMap()).put(ListSequence.fromList(nodesToMove).first(), myTarget.resolve(myProject.getRepository()));
      for (SNode oldNode : SetSequence.fromSet(MapSequence.fromMap(ifKeepOldNodes).keySet())) {
        if (MapSequence.fromMap(ifKeepOldNodes).get(oldNode) == RefactoringParticipant.KeepOldNodes.REMOVE) {
          SNodeOperations.detachNode(oldNode);
        }
      }
    }
  }


  public static class NodeCopyTracker {
    private static final String id = "refactoringSession.nodeCopyTracker";
    private Map<SNode, SNode> copyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    public static MoveNodesUtil.NodeCopyTracker get(RefactoringSession session) {
      MoveNodesUtil.NodeCopyTracker result = (MoveNodesUtil.NodeCopyTracker) session.getObject(id);
      if (result == null) {
        result = new MoveNodesUtil.NodeCopyTracker();
        session.putObject(id, result);
      }
      return result;
    }
    public Map<SNode, SNode> getCopyMap() {
      return Collections.unmodifiableMap(copyMap);
    }
    public List<SNode> copyAndTrack(List<SNode> oldNodes) {
      Map<SNode, SNode> localCopyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      List<SNode> result = CopyUtil.copyAndPreserveId(oldNodes, localCopyMap);
      MapSequence.fromMap(copyMap).putAll(localCopyMap);
      for (IMapping<SNode, SNode> mapping : MapSequence.fromMap(copyMap)) {
        CopyUtil.addReferences(mapping.key(), copyMap, false);
      }
      return result;
    }
  }
  private static boolean eq_nlglo1_a0a0a0a0a0a0a4a0a0a0a2a2(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
