package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.ide.findusages.model.SearchResults;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public interface RefactoringParticipant<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> {

  static interface RefactoringDataCollector<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> {
    InitialDataObject beforeMove(InitialPoint nodeToMove);
    FinalDataObject afterMove(FinalPoint movedNode);
  }

  RefactoringParticipant.RefactoringDataCollector<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> getDataCollector();

  class Option {
    private String myId;
    private String myDescription;
    public Option(String id, String description) {
      myId = id;
      myDescription = description;
    }
    public String getId() {
      return myId;
    }
    public String getDescription() {
      return myDescription;
    }
    public int hashCode() {
      return myId.hashCode();
    }
    public boolean equals(Object object) {
      return object instanceof RefactoringParticipant.Option && eq_g5nieh_a0a0a6f(((RefactoringParticipant.Option) object).getId(), this.getId());
    }
    private static boolean eq_g5nieh_a0a0a6f(Object a, Object b) {
      return (a != null ? a.equals(b) : a == b);
    }
  }

  List<RefactoringParticipant.Option> getAvailableOptions(List<InitialDataObject> initialStates, SRepository repository);

  List<List<RefactoringParticipant.Change<InitialDataObject, FinalDataObject>>> getChanges(List<InitialDataObject> initialStates, SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor);

  static interface Change<InitialDataObject, FinalDataObject> {
    SearchResults getSearchResults();
    boolean needsToPreserveOldNode();
    void confirm(FinalDataObject finalState, SRepository repository, RefactoringSession refactoringSession);
  }

  static interface PersistentRefactoringParticipant<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> extends RefactoringParticipant<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> {
    String getId();
    SNode serializeInitialState(InitialDataObject initialState);
    InitialDataObject deserializeInitialState(SNode serialized);
    SNode serializeFinalState(FinalDataObject finalState);
    FinalDataObject deserializeFinalState(SNode serialized);
  }

  class ParticipantState<I, F, IP, FP> {
    private RefactoringParticipant<I, F, IP, FP> myParticipant;
    private List<I> myInitialStates;
    private List<List<RefactoringParticipant.Change<I, F>>> changes;
    public List<List<RefactoringParticipant.Change<I, F>>> getChanges() {
      return changes;
    }
    public RefactoringParticipant<I, F, IP, FP> getParticipant() {
      return myParticipant;
    }
    public List<I> getInitialStates() {
      return myInitialStates;
    }
    public static <I, F, IP, FP> RefactoringParticipant.ParticipantState<I, F, IP, FP> create(RefactoringParticipant<I, F, IP, FP> participant, List<IP> oldNode) {
      return new RefactoringParticipant.ParticipantState<I, F, IP, FP>(participant, oldNode);
    }
    public ParticipantState(RefactoringParticipant<I, F, IP, FP> participant, List<IP> oldNodes) {
      this.myParticipant = participant;
      myInitialStates = ListSequence.fromList(oldNodes).select(new ISelector<IP, I>() {
        public I select(IP oldNode) {
          return ParticipantState.this.myParticipant.getDataCollector().beforeMove(oldNode);
        }
      }).toListSequence();
    }
    public List<RefactoringParticipant.Option> getAvaliableOptions(SRepository repository) {
      return myParticipant.getAvailableOptions(myInitialStates, repository);
    }
    public List<List<RefactoringParticipant.Change<I, F>>> findChanges(SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor) {
      return changes = initChanges(repository, selectedOptions, searchScope, progressMonitor);
    }
    protected List<List<RefactoringParticipant.Change<I, F>>> initChanges(SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor) {
      return myParticipant.getChanges(myInitialStates, repository, selectedOptions, searchScope, progressMonitor);
    }
    public void doRefactor(List<FP> newNodes, final SRepository repository, final RefactoringSession session) {
      {
        Iterator<List<RefactoringParticipant.Change<I, F>>> nodeChanges_it = ListSequence.fromList(this.changes).iterator();
        Iterator<FP> newNode_it = ListSequence.fromList(newNodes).iterator();
        List<RefactoringParticipant.Change<I, F>> nodeChanges_var;
        FP newNode_var;
        while (nodeChanges_it.hasNext() && newNode_it.hasNext()) {
          nodeChanges_var = nodeChanges_it.next();
          newNode_var = newNode_it.next();
          final F finalState = this.myParticipant.getDataCollector().afterMove(newNode_var);
          ListSequence.fromList(nodeChanges_var).visitAll(new IVisitor<RefactoringParticipant.Change<I, F>>() {
            public void visit(RefactoringParticipant.Change<I, F> it) {
              it.confirm(finalState, repository, session);
            }
          });
        }
      }
    }
  }


}
