package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.migration.runtime.base.RefactoringSession;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import jetbrains.mps.ide.platform.refactoring.MoveNodesDialog;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.project.Project;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public class MoveNodesActionBase implements MoveNodesAction {


  public String getName() {
    return "Move Nodes";
  }

  public static void moveNodes(List<SNode> nodes, MPSProject mpsProject) {
    MoveNodesActionBase moveNodesDefault = new MoveNodesActionBase();
    if (moveNodesDefault.isApplicable(mpsProject, nodes)) {
      moveNodesDefault.execute(mpsProject, nodes);
    }
  }

  public boolean isApplicable(MPSProject project, List<SNode> nodesToMove) {
    return areSiblings(nodesToMove, project.getRepository());
  }

  public static boolean areSiblings(final List<SNode> nodesToMove, SRepository repository) {
    if (ListSequence.fromList(nodesToMove).isEmpty()) {
      return false;
    }
    final Wrappers._boolean result = new Wrappers._boolean();
    repository.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        SNode firstNode = ListSequence.fromList(nodesToMove).first();
        final SContainmentLink containmentLink = firstNode.getContainmentLink();
        final SNode parent = firstNode.getParent();
        final SModel model = firstNode.getModel();
        result.value = ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return eq_k1voar_a0a0a0a0a0a0a4a0a0a0a2a8(it.getContainmentLink(), containmentLink) && it.getParent() == parent && it.getModel() == model;
          }
        });
      }
    });
    return result.value;
  }

  public static class CopyMapObject {
    private static final String id = "refactoringSession.copyMap";
    private Map<SNode, SNode> copyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    public static MoveNodesActionBase.CopyMapObject getCopyMap(RefactoringSession session) {
      MoveNodesActionBase.CopyMapObject result = (MoveNodesActionBase.CopyMapObject) session.getObject(id);
      if (result == null) {
        result = new MoveNodesActionBase.CopyMapObject();
        session.putObject(id, result);
      }
      return result;
    }
    public Map<SNode, SNode> getCopyMap() {
      return copyMap;
    }
    public List<SNode> copy(List<SNode> oldNodes) {
      Map<SNode, SNode> localCopyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      List<SNode> result = CopyUtil.copyAndPreserveId(oldNodes, localCopyMap);
      MapSequence.fromMap(copyMap).putAll(localCopyMap);
      for (IMapping<SNode, SNode> mapping : MapSequence.fromMap(copyMap)) {
        CopyUtil.addReferences(mapping.key(), copyMap, false);
      }
      return result;
    }
  }

  public void execute(final MPSProject project, final List<SNode> nodesToMove) {

    final Wrappers._T<SModel> currentModel = new Wrappers._T<SModel>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        currentModel.value = SNodeOperations.getModel(ListSequence.fromList(nodesToMove).first());
      }
    });
    final NodeLocation newLocation = MoveNodesDialog.getSelectedObject(project.getProject(), currentModel.value, new MoveNodesDialog.ModelFilter() {
      public String getErrorMessage(NodeLocation selectedObject) {
        return "Choose model or node that can contain moving nodes";
      }
      public boolean tryToSetRole(final NodeLocation.NodeLocationChild selectedObject) {
        final Wrappers._T<SContainmentLink> role = new Wrappers._T<SContainmentLink>();
        final Wrappers._T<Collection<SContainmentLink>> containmentLinks = new Wrappers._T<Collection<SContainmentLink>>();
        project.getRepository().getModelAccess().runReadAction(new Runnable() {
          public void run() {
            containmentLinks.value = selectedObject.getNode().resolve(project.getRepository()).getConcept().getContainmentLinks();
            role.value = ListSequence.fromList(nodesToMove).first().getContainmentLink();
          }
        });
        if (role.value != null && CollectionSequence.fromCollection(containmentLinks.value).contains(role.value)) {
          selectedObject.setRole(role.value);
          return true;
        }
        final Wrappers._T<Iterable<SContainmentLink>> applicableLinks = new Wrappers._T<Iterable<SContainmentLink>>();
        project.getRepository().getModelAccess().runReadAction(new Runnable() {
          public void run() {
            applicableLinks.value = CollectionSequence.fromCollection(containmentLinks.value).where(new IWhereFilter<SContainmentLink>() {
              public boolean accept(final SContainmentLink link) {
                return ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
                  public boolean accept(SNode node) {
                    return SNodeOperations.getConcept(node).isSubConceptOf(link.getTargetConcept());
                  }
                });
              }
            });
          }
        });
        if (Sequence.fromIterable(applicableLinks.value).count() == 1) {
          selectedObject.setRole(Sequence.fromIterable(applicableLinks.value).first());
          return true;
        }
        return false;
      }
      @Override
      public boolean check(final NodeLocation selectedObject, SModel model) {
        if (selectedObject instanceof NodeLocation.NodeLocationChild) {
          return tryToSetRole((NodeLocation.NodeLocationChild) selectedObject);
        } else if (selectedObject instanceof NodeLocation.NodeLocationRoot) {
          return new ModelAccessHelper(project.getRepository()).runReadAction(new Computable<Boolean>() {
            public Boolean compute() {
              return ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
                public boolean accept(SNode it) {
                  return selectedObject.canInsert(project.getRepository(), it);
                }
              });
            }
          });
        } else {
          return false;
        }
      }
    });
    if (newLocation == null) {
      return;
    }

    MoveNodesActionBase.NodeProcessor processor = new MoveNodesActionBase.NodeCreatingProcessor(newLocation, project);
    doMove(project, MapSequence.<MoveNodesActionBase.NodeProcessor, List<SNode>>fromMapAndKeysArray(new HashMap<MoveNodesActionBase.NodeProcessor, List<SNode>>(), processor).withValues(nodesToMove));
  }

  @NotNull
  public static SNode resolveNode(SNodeReference nodeReference, Project project) {
    // todo: unused method 
    SNode node = nodeReference.resolve(project.getRepository());
    if (node == null) {
      throw new IllegalArgumentException("Node " + nodeReference + " doesn't exist in current project.");
    }
    return node;
  }

  public class ListIndex<T> {
    private Map<T, Integer> myIndices = MapSequence.fromMap(new HashMap<T, Integer>());
    public ListIndex(List<T> patternList) {
      for (int i = 0; i < ListSequence.fromList(patternList).count(); i++) {
        MapSequence.fromMap(myIndices).put(ListSequence.fromList(patternList).getElement(i), i);
      }
    }
    public int getIndex(T object) {
      return MapSequence.fromMap(myIndices).get(object);
    }
    public <S> S getCorrespondent(List<S> list, T anchor) {
      return ListSequence.fromList(list).getElement(getIndex(anchor));
    }
  }


  public void doMove(final MPSProject project, final Map<MoveNodesActionBase.NodeProcessor, List<SNode>> processorToMoveRoots) {

    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (IMapping<MoveNodesActionBase.NodeProcessor, List<SNode>> mapping : MapSequence.fromMap(processorToMoveRoots)) {
          if (!(mapping.key().isValid(mapping.value()))) {
            throw new IllegalArgumentException();
          }
        }
      }
    });

    final Map<SNodeReference, List<SNodeReference>> moveRootsToDescendants = MapSequence.fromMap(new HashMap<SNodeReference, List<SNodeReference>>());
    final List<SNode> allNodes = ListSequence.fromList(new ArrayList<SNode>());
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (IMapping<MoveNodesActionBase.NodeProcessor, List<SNode>> mapping : MapSequence.fromMap(processorToMoveRoots)) {
          MoveNodesActionBase.NodeProcessor processor = mapping.key();
          for (SNode moveRoot : ListSequence.fromList(mapping.value())) {
            List<SNode> nodesToSearch = processor.getNodesToSearch(moveRoot);
            MapSequence.fromMap(moveRootsToDescendants).put(moveRoot.getReference(), ListSequence.fromList(nodesToSearch).select(new ISelector<SNode, SNodeReference>() {
              public SNodeReference select(SNode it) {
                return it.getReference();
              }
            }).toListSequence());
            ListSequence.fromList(allNodes).addSequence(ListSequence.fromList(nodesToSearch));
          }
        }
      }
    });
    final MoveNodesActionBase.ListIndex<SNodeReference> allNodeIndices = new MoveNodesActionBase.ListIndex<SNodeReference>(ListSequence.fromList(allNodes).select(new ISelector<SNode, SNodeReference>() {
      public SNodeReference select(SNode it) {
        return it.getReference();
      }
    }).toListSequence());

    Iterable<? extends RefactoringParticipant<?, ?, SNode, SNode>> participants = new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects();
    RefactoringProcessor.performRefactoring(project, getName(), participants, allNodes, new _FunctionTypes._return_P2_E0<_FunctionTypes._return_P1_E0<? extends SNode, ? super SNode>, Iterable<RefactoringParticipant.ParticipantState<?, ?, SNode, SNode, SNode, SNode>>, RefactoringSession>() {
      public _FunctionTypes._return_P1_E0<? extends SNode, ? super SNode> invoke(Iterable<RefactoringParticipant.ParticipantState<?, ?, SNode, SNode, SNode, SNode>> participantStates, RefactoringSession refactoringSession) {

        return doRefactor(processorToMoveRoots, allNodeIndices, moveRootsToDescendants, participantStates, refactoringSession);
      }
    });
  }

  private _FunctionTypes._return_P1_E0<? extends SNode, ? super SNode> doRefactor(final Map<MoveNodesActionBase.NodeProcessor, List<SNode>> processorToRoots, final MoveNodesActionBase.ListIndex<SNodeReference> nodeChangesCorrespondence, Map<SNodeReference, List<SNodeReference>> moveRootsToDescendants, final Iterable<RefactoringParticipant.ParticipantState<?, ?, SNode, SNode, SNode, SNode>> participantStates, final RefactoringSession refactoringSession) {
    for (IMapping<MoveNodesActionBase.NodeProcessor, List<SNode>> mapping : MapSequence.fromMap(processorToRoots)) {
      List<SNode> moveRoots = mapping.value();
      final MoveNodesActionBase.NodeProcessor processor = mapping.key();

      final Map<SNode, RefactoringParticipant.KeepOldNodes> ifRemoveOldRoots = MapSequence.fromMap(new HashMap<SNode, RefactoringParticipant.KeepOldNodes>());
      for (SNode moveRoot : ListSequence.fromList(moveRoots)) {
        MapSequence.fromMap(ifRemoveOldRoots).put(moveRoot, RefactoringParticipant.KeepOldNodes.max(ListSequence.fromList(MapSequence.fromMap(moveRootsToDescendants).get(moveRoot.getReference())).translate(new ITranslator2<SNodeReference, RefactoringParticipant.KeepOldNodes>() {
          public Iterable<RefactoringParticipant.KeepOldNodes> translate(final SNodeReference descendant) {
            return Sequence.fromIterable(participantStates).select(new ISelector<RefactoringParticipant.ParticipantState<?, ?, SNode, SNode, SNode, SNode>, RefactoringParticipant.KeepOldNodes>() {
              public RefactoringParticipant.KeepOldNodes select(RefactoringParticipant.ParticipantState<?, ?, SNode, SNode, SNode, SNode> participantState) {
                List<? extends RefactoringParticipant.Change<?, ?>> changes = nodeChangesCorrespondence.getCorrespondent(participantState.getChanges(), descendant);
                return RefactoringParticipant.KeepOldNodes.max(ListSequence.fromList(changes).select(new ISelector<RefactoringParticipant.Change<?, ?>, RefactoringParticipant.KeepOldNodes>() {
                  public RefactoringParticipant.KeepOldNodes select(RefactoringParticipant.Change<?, ?> change) {
                    return ((MoveNodeRefactoringParticipant.MoveNodeChange<?, ?>) ((RefactoringParticipant.Change) change)).needsToPreserveOldNode();
                  }
                }));
              }
            });
          }
        })));
      }

      processor.process(moveRoots, ifRemoveOldRoots, refactoringSession);
      refactoringSession.registerLast(new Runnable() {
        public void run() {
          processor.removeAfterRefactoring(ifRemoveOldRoots, refactoringSession);
        }
      });
    }
    final Map<SNode, SNode> copyMap = MoveNodesActionBase.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();
    return new _FunctionTypes._return_P1_E0<SNode, SNode>() {
      public SNode invoke(SNode oldNode) {
        return MapSequence.fromMap(copyMap).get(oldNode);
      }
    };
  }

  public static abstract class NodeProcessor {
    public abstract boolean isValid(List<SNode> nodesToMove);
    public abstract boolean isValid(SNode nodeToMove);
    public abstract List<SNode> getNodesToSearch(SNode nodeToMove);
    public abstract void process(List<SNode> nodesToMove, Map<SNode, RefactoringParticipant.KeepOldNodes> ifKeepOldNodes, RefactoringSession refactoringSession);
    public void removeAfterRefactoring(Map<SNode, RefactoringParticipant.KeepOldNodes> ifKeepOldNodes, RefactoringSession refactoringSession) {
      for (SNode oldNode : SetSequence.fromSet(MapSequence.fromMap(ifKeepOldNodes).keySet())) {
        if (MapSequence.fromMap(ifKeepOldNodes).get(oldNode) != RefactoringParticipant.KeepOldNodes.KEEP) {
          SNodeOperations.detachNode(oldNode);
        }
      }
    }

  }

  public static class NodeCreatingProcessor extends MoveNodesActionBase.NodeProcessor {
    protected NodeLocation myNodeLocation;
    protected Project myProject;
    public NodeCreatingProcessor(NodeLocation location, Project project) {
      myNodeLocation = location;
      myProject = project;
    }
    public boolean isValid(List<SNode> nodesToMove) {
      return ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return isValid(it);
        }
      });
    }
    public boolean isValid(SNode nodeToMove) {
      return myNodeLocation.canInsert(myProject.getRepository(), nodeToMove);
    }
    public List<SNode> getNodesToSearch(SNode nodeToMove) {
      return SNodeOperations.getNodeDescendants(nodeToMove, null, true, new SAbstractConcept[]{});
    }
    public void process(List<SNode> nodeRoots, Map<SNode, RefactoringParticipant.KeepOldNodes> ifKeepOldNodes, RefactoringSession refactoringSession) {
      MoveNodesActionBase.CopyMapObject copyMap = MoveNodesActionBase.CopyMapObject.getCopyMap(refactoringSession);
      copyMap.copy(nodeRoots);
      for (SNode oldNode : ListSequence.fromList(nodeRoots)) {
        if (MapSequence.fromMap(ifKeepOldNodes).get(oldNode) == RefactoringParticipant.KeepOldNodes.REMOVE) {
          SNodeOperations.detachNode(oldNode);
        }
        myNodeLocation.insertNode(myProject.getRepository(), MapSequence.fromMap(copyMap.getCopyMap()).get(oldNode));
      }
    }
  }

  public static class ExistingTargetProcessor extends MoveNodesActionBase.NodeProcessor {
    private SNodeReference myTarget;
    private Project myProject;
    public ExistingTargetProcessor(SNodeReference target, Project project) {
      myTarget = target;
      myProject = project;
    }
    public boolean isValid(List<SNode> nodesToMove) {
      return ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return isValid(it);
        }
      });
    }
    public boolean isValid(SNode nodeToMove) {
      return myTarget.resolve(myProject.getRepository()) != null;
    }
    public List<SNode> getNodesToSearch(SNode nodeToMove) {
      return ListSequence.fromListAndArray(new ArrayList<SNode>(), nodeToMove);
    }
    public void process(List<SNode> nodesToMove, Map<SNode, RefactoringParticipant.KeepOldNodes> ifKeepOldNodes, RefactoringSession refactoringSession) {
      if (ListSequence.fromList(nodesToMove).count() != 1) {
        throw new IllegalArgumentException();
      }
      MoveNodesActionBase.CopyMapObject copyMap = MoveNodesActionBase.CopyMapObject.getCopyMap(refactoringSession);
      MapSequence.fromMap(copyMap.getCopyMap()).put(ListSequence.fromList(nodesToMove).first(), myTarget.resolve(myProject.getRepository()));
      for (SNode oldNode : SetSequence.fromSet(MapSequence.fromMap(ifKeepOldNodes).keySet())) {
        if (MapSequence.fromMap(ifKeepOldNodes).get(oldNode) == RefactoringParticipant.KeepOldNodes.REMOVE) {
          SNodeOperations.detachNode(oldNode);
        }
      }
    }
  }


  private static boolean eq_k1voar_a0a0a0a0a0a0a4a0a0a0a2a8(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
