package jetbrains.mps.ide.ui.finders;

/*Generated by MPS */

import jetbrains.mps.ide.findusages.findalgorithm.finders.BaseFinder;
import jetbrains.mps.ide.findusages.findalgorithm.finders.IFinder;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.util.Collection;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.ide.findusages.findalgorithm.finders.SearchedObjects;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.project.DevKit;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelOperations;

/**
 * Look up language uses in scope module's imports and their models. 
 * Name of the class might not be precise (yet - if we decide to split look up in imports and in models).
 * SearchResult include both modules and models.
 * 
 * Note, this finder looks up SLanguage, not a Language module uses, thus it shall not be used when
 * we care about module dependencies.
 * 
 * Unlike {@link jetbrains.mps.ide.ui.finders.LanguageModelImportFinder }, this finder focuses on modules. I'm not confident we need
 * both finders, though.
 * 
 * FIXME perhaps, shall either use LanguageUsageFinder for uses in models (i.e. build another scope from caller and pass to LUF), or
 * shall respect scope's models here (not only/in addition to models of scope modules). Note, LUF looks up nodes, while this shall stop at model's level.
 */
public class LanguageImportFinder extends BaseFinder implements IFinder {
  private static final String MODELS_WRITTEN_IN_LANGUAGE = "models written in language";
  private static final String EXPORTED_BY = "exported by";

  public LanguageImportFinder() {
  }

  @Override
  public String getDescription() {
    return "Language Imports";
  }

  @Override
  public void find(SearchQuery query, @NotNull IFinder.FindCallback callback, ProgressMonitor monitor) {
    Collection<SLanguage> languageToLookUp = LanguageUsagesFinder.getLanguageToLookUp(query);
    callback.onSearchedObjectsCalculated(new SearchedObjects(languageToLookUp));
    for (SLanguage lang : languageToLookUp) {
      SearchScope scope = query.getScope();
      for (SModule module : scope.getModules()) {
        if (monitor.isCanceled()) {
          return;
        }
        if (module instanceof Solution) {
          collectUsagesInSolution(lang, (Solution) module, callback);
        } else if (module instanceof Language) {
          collectUsagesInLanguage(lang, (Language) module, callback);
          for (Generator g : ((Language) module).getOwnedGenerators()) {
            collectUsagesInGenerator(lang, g, callback);
          }
        } else if (module instanceof DevKit) {
          collectUsagesInDevKit(lang, (DevKit) module, callback);
        }
      }
    }
  }

  private void collectUsagesInSolution(SLanguage searchLanguage, Solution solution, @NotNull IFinder.FindCallback callback) {
    if (solution.getUsedLanguages().contains(searchLanguage)) {
      callback.onUsageFound(new SearchResult<Solution>(solution, ModuleUsagesFinder.USED_BY));
      collectUsagesInModels(searchLanguage, solution, callback);
    }
  }

  private void collectUsagesInLanguage(SLanguage searchedLanguage, Language language, @NotNull IFinder.FindCallback callback) {
    if (language.getUsedLanguages().contains(searchedLanguage)) {
      callback.onUsageFound(new SearchResult<Language>(language, ModuleUsagesFinder.USED_BY));
      collectUsagesInModels(searchedLanguage, language, callback);
    }
  }

  private void collectUsagesInGenerator(SLanguage searchedLanguage, Generator generator, @NotNull IFinder.FindCallback callback) {
    if (generator.getUsedLanguages().contains(searchedLanguage)) {
      callback.onUsageFound(new SearchResult<Generator>(generator, ModuleUsagesFinder.USED_BY));
      collectUsagesInModels(searchedLanguage, generator, callback);
    }
  }

  private void collectUsagesInDevKit(SLanguage searchLanguage, DevKit devKit, @NotNull IFinder.FindCallback callback) {
    if (searchLanguage == null) {
      return;
    }
    for (Language l : devKit.getExportedLanguages()) {
      if (searchLanguage.equals(MetaAdapterByDeclaration.getLanguage(l))) {
        callback.onUsageFound(new SearchResult<DevKit>(devKit, EXPORTED_BY));
        break;
      }
    }
  }

  private void collectUsagesInModels(SLanguage searchedLanguage, SModule owner, @NotNull IFinder.FindCallback callback) {
    for (SModel model : owner.getModels()) {
      // FIXME rest of the class relies on plain (no unwraped devkits and extended languages) imports, 
      // perhaps, shall revert to SModel.getUsedLanguages() here as well? 
      if (SModelOperations.getAllLanguageImports(model).contains(searchedLanguage)) {
        callback.onUsageFound(new SearchResult<SModel>(model, MODELS_WRITTEN_IN_LANGUAGE));
      }
    }
  }
}
