package jetbrains.mps.ide.ui.dialogs.modules;

/*Generated by MPS */

import jetbrains.mps.project.AbstractModule;
import java.util.List;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.extapi.persistence.CloneCapabilities;
import jetbrains.mps.extapi.persistence.ModelRootBase;
import jetbrains.mps.extapi.persistence.CloneType;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import javax.swing.table.TableModel;
import javax.swing.JLabel;
import com.intellij.ui.table.JBTable;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.Component;
import javax.swing.JTable;
import com.intellij.ui.BooleanTableCellRenderer;
import javax.swing.table.TableColumn;
import com.intellij.ui.BooleanTableCellEditor;
import javax.swing.JScrollPane;
import java.awt.Dimension;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import javax.swing.table.AbstractTableModel;

public class CloneModuleSettings<M extends AbstractModule> extends AbstractModuleCreationSettings {

  private static final int INDEX_TYPE = 0;
  private static final int INDEX_PRESENTATION = 1;
  private static final int INDEX_CLONE_TYPE = 2;

  private static final String[] HEADERS = new String[]{"Type", "Model Root", "Reuse"};


  private final List<Tuples._2<ModelRoot, Boolean>> myRoots = ListSequence.fromList(new ArrayList<Tuples._2<ModelRoot, Boolean>>());
  private final int myEditableRootsCount;

  protected final M myModuleOriginal;

  private final String MODEL_ROOT_INFO_STYLE = "<html><body>";
  private final String MODEL_ROOT_INFO_TEXT = "Select Model Roots that should be reused: ";

  public CloneModuleSettings(String projectPath, M moduleOriginal) {
    super(projectPath, "Cloned Module name:", "Clone Module to:");

    myModuleOriginal = moduleOriginal;

    List<ModelRoot> modelRoots = ListSequence.fromListWithValues(new ArrayList<ModelRoot>(), moduleOriginal.getModelRoots());

    if (moduleOriginal instanceof Language) {
      for (Generator generator : CollectionSequence.fromCollection(as_eth6zq_a0a0a0g0q(moduleOriginal, Language.class).getGenerators())) {
        ListSequence.fromList(modelRoots).addSequence(Sequence.fromIterable(generator.getModelRoots()));
      }
    }

    // TODO : support general case when CloneType is not only CLONE & REUSE 
    List<ModelRoot> reusable = ListSequence.fromList(new ArrayList<ModelRoot>());
    List<ModelRoot> cloneable = ListSequence.fromList(new ArrayList<ModelRoot>());
    List<ModelRoot> bothTypes = ListSequence.fromList(new ArrayList<ModelRoot>());

    for (ModelRoot root : ListSequence.fromList(modelRoots)) {
      CloneCapabilities capabilities = ((ModelRootBase) root).getCloneCapabilities();
      boolean isReusable = capabilities.isCloneable(CloneType.REUSE);
      boolean isCloneable = capabilities.isCloneable(CloneType.CLONE);

      if (isReusable && !(isCloneable)) {
        ListSequence.fromList(reusable).addElement(root);
        continue;
      }
      if (!(isReusable) && isCloneable) {
        ListSequence.fromList(cloneable).addElement(root);
        continue;
      }
      if (isReusable && isCloneable) {
        ListSequence.fromList(bothTypes).addElement(root);
        continue;
      }
      if (capabilities.getAllowedCloneTypes().isEmpty()) {
        throw new IllegalArgumentException("Module " + root.getModule() + " contains non-cloneable model roots");
      } else {
        assert true : "CloneType has not-supported instance.";
      }
    }

    for (ModelRoot root : ListSequence.fromList(bothTypes)) {
      ListSequence.fromList(myRoots).addElement(MultiTuple.<ModelRoot,Boolean>from(root, false));
    }
    myEditableRootsCount = ListSequence.fromList(myRoots).count();
    for (ModelRoot root : ListSequence.fromList(cloneable)) {
      ListSequence.fromList(myRoots).addElement(MultiTuple.<ModelRoot,Boolean>from(root, false));
    }
    for (ModelRoot root : ListSequence.fromList(reusable)) {
      ListSequence.fromList(myRoots).addElement(MultiTuple.<ModelRoot,Boolean>from(root, true));
    }

    TableModel tableModel = new CloneModuleSettings.ModelRoootTabelModel();

    JLabel info = new JLabel(MODEL_ROOT_INFO_STYLE + MODEL_ROOT_INFO_TEXT);
    this.add(info, 4, 0.0);

    JBTable modelRootTable = new JBTable(tableModel);

    TableCellRenderer modelRootInfoCellRenderer = new DefaultTableCellRenderer() {
      @Override
      public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
        c.setEnabled(row < myEditableRootsCount);
        return c;
      }
    };
    TableCellRenderer reuseCheckBoxCellRenderer = new BooleanTableCellRenderer() {
      @Override
      public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
        c.setEnabled(row < myEditableRootsCount);
        return c;
      }
    };

    TableColumn column;

    column = modelRootTable.getColumnModel().getColumn(INDEX_TYPE);
    column.setMinWidth(100);
    column.setPreferredWidth(150);
    column.setMaxWidth(200);
    column.setCellRenderer(modelRootInfoCellRenderer);

    column = modelRootTable.getColumnModel().getColumn(INDEX_PRESENTATION);
    column.setPreferredWidth(300);
    column.setCellRenderer(modelRootInfoCellRenderer);

    column = modelRootTable.getColumnModel().getColumn(INDEX_CLONE_TYPE);
    column.setMinWidth(100);
    column.setPreferredWidth(150);
    column.setMaxWidth(200);
    column.setCellEditor(new BooleanTableCellEditor());
    column.setCellRenderer(reuseCheckBoxCellRenderer);

    modelRootTable.setRowHeight(50);
    modelRootTable.getTableHeader().setReorderingAllowed(false);

    JScrollPane scrollPane = new JScrollPane();
    scrollPane.setViewportView(modelRootTable);

    this.add(scrollPane, 5, 1.0);

    this.setMinimumSize(new Dimension(400, 400));
    this.setPreferredSize(new Dimension(640, 480));
    reset();
  }

  @Override
  protected String getDefaultModuleName() {
    return myModuleOriginal.getModuleName() + "_clone";
  }

  @Override
  protected String getDefaultModulePath() {
    return getModuleRootPath((myModuleOriginal instanceof Language ? "languages" : "solutions"));
  }

  public M getOriginalModule() {
    return myModuleOriginal;
  }

  public Map<ModelRoot, CloneType> getModelRootTypes() {
    Map<ModelRoot, CloneType> res = MapSequence.fromMap(new HashMap<ModelRoot, CloneType>());
    for (Tuples._2<ModelRoot, Boolean> root : ListSequence.fromList(myRoots)) {
      MapSequence.fromMap(res).put(root._0(), ((boolean) root._1() ? CloneType.REUSE : CloneType.CLONE));
    }
    return res;
  }

  private String generatorPrefix(ModelRoot modelRoot) {
    return (modelRoot.getModule() instanceof Generator ? "(generator) " : "");
  }

  private class ModelRoootTabelModel extends AbstractTableModel {

    @Override
    public String getColumnName(int columnIndex) {
      return HEADERS[columnIndex];
    }

    @Override
    public int getRowCount() {
      return ListSequence.fromList(myRoots).count();
    }
    @Override
    public int getColumnCount() {
      return HEADERS.length;
    }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
      switch (columnIndex) {
        case 0:
          return ListSequence.fromList(myRoots).getElement(rowIndex)._0().getType();
        case 1:
          return generatorPrefix(ListSequence.fromList(myRoots).getElement(rowIndex)._0()) + ListSequence.fromList(myRoots).getElement(rowIndex)._0().getPresentation();
        case 2:
          return (boolean) ListSequence.fromList(myRoots).getElement(rowIndex)._1();
        default:
          return null;
      }
    }

    @Override
    public void setValueAt(Object newValue, int rowIndex, int columnIndex) {
      if (columnIndex == 2) {
        ListSequence.fromList(myRoots).getElement(rowIndex)._1(as_eth6zq_a0a0a0a0h82(newValue, Boolean.class));
      }
    }

    @Override
    public boolean isCellEditable(int rowIndex, int columnIndex) {
      return columnIndex == 2 && rowIndex < myEditableRootsCount;
    }


  }
  private static <T> T as_eth6zq_a0a0a0g0q(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_eth6zq_a0a0a0a0h82(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
