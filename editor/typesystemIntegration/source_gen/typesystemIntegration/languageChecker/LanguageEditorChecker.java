package typesystemIntegration.languageChecker;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.BaseEditorChecker;
import java.util.Set;
import jetbrains.mps.checkers.AbstractConstraintsChecker;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Map;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.checkers.LanguageErrorsComponent;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SRepositoryContentAdapter;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.event.SModelListener;
import jetbrains.mps.smodel.SModelAdapter;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.checkers.ConstraintsChecker;
import jetbrains.mps.checkers.TargetConceptChecker;
import jetbrains.mps.smodel.RepoListenerRegistrar;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.nodeEditor.checking.EditorChecker;
import jetbrains.mps.typesystem.checking.TypesEditorChecker;
import jetbrains.mps.nodeEditor.checking.LegacyEditorCheckerAdapter;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.nodeEditor.EditorMessage;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.util.Cancellable;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.typesystem.inference.ITypechecking;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.nodeEditor.inspector.InspectorEditorComponent;
import org.apache.log4j.Level;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.errors.QuickFix_Runtime;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.checkers.ErrorReportUtil;
import jetbrains.mps.errors.MessageStatus;
import jetbrains.mps.nodeEditor.HighlighterMessage;
import jetbrains.mps.typesystem.checking.HighlightUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.errors.QuickFixProvider;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.extapi.model.TransientSModel;
import jetbrains.mps.nodeEditor.EditorSettings;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class LanguageEditorChecker extends BaseEditorChecker {
  private boolean myMessagesChanged = false;
  private boolean myForceRunQuickFixes = false;
  private Set<AbstractConstraintsChecker> myRules = SetSequence.fromSet(new HashSet<AbstractConstraintsChecker>());

  /**
   * The two maps below are accessed from EDT (by {@link typesystemIntegration.languageChecker.LanguageEditorChecker#myDisposeListener }) and from the background highlighter
   * thread. Access to the maps must be therefore guarded by this lock.
   */
  private final Object myMapsLock = new Object();
  private Map<EditorComponent, LanguageErrorsComponent> myEditorComponentToErrorMap = MapSequence.fromMap(new HashMap<EditorComponent, LanguageErrorsComponent>());
  private Map<SModel, Set<EditorComponent>> myModelToEditorComponentsMap = MapSequence.fromMap(new HashMap<SModel, Set<EditorComponent>>());

  private EditorComponent.EditorDisposeListener myDisposeListener = new EditorComponent.EditorDisposeListener() {
    @Override
    public void editorWillBeDisposed(EditorComponent editorComponent) {
      editorComponent.removeDisposeListener(myDisposeListener);
      synchronized (myMapsLock) {
        MapSequence.fromMap(myEditorComponentToErrorMap).removeKey(editorComponent).dispose();

        for (SModel model : MapSequence.fromMap(myModelToEditorComponentsMap).keySet()) {
          Set<EditorComponent> editorComponents = MapSequence.fromMap(myModelToEditorComponentsMap).get(model);
          if (SetSequence.fromSet(editorComponents).removeElement(editorComponent) != null) {
            if (SetSequence.fromSet(editorComponents).isEmpty()) {
              MapSequence.fromMap(myModelToEditorComponentsMap).removeKey(model);
              removeModelListener(model);
            }
            break;
          }
        }
      }
    }
  };

  private final SRepository myRepository;
  private final SRepositoryContentAdapter myRepositoryListener = new SRepositoryContentAdapter() {

    @Override
    protected boolean isIncluded(SModule module) {
      return !(module.isReadOnly());
    }
    @Override
    protected void stopListening(SModel model) {
      synchronized (myMapsLock) {
        if (!(MapSequence.fromMap(myModelToEditorComponentsMap).containsKey(model))) {
          return;
        }
        for (EditorComponent editorComponent : MapSequence.fromMap(myModelToEditorComponentsMap).get(model)) {
          MapSequence.fromMap(myEditorComponentToErrorMap).removeKey(editorComponent).dispose();
          editorComponent.removeDisposeListener(myDisposeListener);
        }
        MapSequence.fromMap(myModelToEditorComponentsMap).removeKey(model);
      }
      removeModelListener(model);
    }
  };

  private SModelListener myModelListener = new SModelAdapter() {
    @Override
    public void beforeModelDisposed(SModel model) {
      synchronized (myMapsLock) {
        for (EditorComponent editorComponent : MapSequence.fromMap(myModelToEditorComponentsMap).get(model)) {
          MapSequence.fromMap(myEditorComponentToErrorMap).removeKey(editorComponent).dispose();
          editorComponent.removeDisposeListener(myDisposeListener);
        }
        MapSequence.fromMap(myModelToEditorComponentsMap).removeKey(model);
      }
    }
  };

  private RefScopeCheckerInEditor myScopeChecker;
  public LanguageEditorChecker(@NotNull SRepository projectRepo) {
    myRepository = projectRepo;
    SetSequence.fromSet(myRules).addElement(new ConstraintsChecker());
    SetSequence.fromSet(myRules).addElement(myScopeChecker = new RefScopeCheckerInEditor());
    SetSequence.fromSet(myRules).addElement(new InEditorStructureChecker());
    SetSequence.fromSet(myRules).addElement(new TargetConceptChecker());
    SetSequence.fromSet(myRules).addElement(new UsedLanguagesChecker());
    new RepoListenerRegistrar(myRepository, myRepositoryListener).attach();
  }
  @Override
  protected void doDispose() {
    new RepoListenerRegistrar(myRepository, myRepositoryListener).detach();
    synchronized (myMapsLock) {
      Sequence.fromIterable(MapSequence.fromMap(myEditorComponentToErrorMap).values()).visitAll(new IVisitor<LanguageErrorsComponent>() {
        public void visit(LanguageErrorsComponent it) {
          it.dispose();
        }
      });
      SetSequence.fromSet(MapSequence.fromMap(myEditorComponentToErrorMap).keySet()).visitAll(new IVisitor<EditorComponent>() {
        public void visit(EditorComponent it) {
          it.removeDisposeListener(myDisposeListener);
        }
      });
      myEditorComponentToErrorMap = null;
      SetSequence.fromSet(MapSequence.fromMap(myModelToEditorComponentsMap).keySet()).visitAll(new IVisitor<SModel>() {
        public void visit(SModel it) {
          removeModelListener(it);
        }
      });
      myModelToEditorComponentsMap = null;
    }
    super.doDispose();
  }
  private void removeModelListener(SModel model) {
    ((SModelInternal) model).removeModelListener(myModelListener);
  }
  private void addModelListener(SModel modelDescriptor) {
    ((SModelInternal) modelDescriptor).addModelListener(myModelListener);
  }
  @Override
  protected boolean areMessagesChanged() {
    return myMessagesChanged;
  }
  @Override
  protected boolean isLaterThan(EditorChecker checker) {
    if (checker instanceof TypesEditorChecker) {
      return true;
    }
    if (checker instanceof LegacyEditorCheckerAdapter) {
      LegacyEditorCheckerAdapter legacyChecker = (LegacyEditorCheckerAdapter) checker;
      if (legacyChecker.getChecker() instanceof AutoResolver) {
        return true;
      }
    }
    return false;
  }
  @Override
  protected boolean hasDramaticalEvent(List<SModelEvent> list) {
    return true;
  }

  @Override
  protected Set<EditorMessage> createMessages(final SNode node, final List<SModelEvent> list, final boolean wasCheckedOnce, final EditorContext editorContext, final Cancellable cancellable, boolean applyQuickFixes) {
    return TypeContextManager.getInstance().runTypeCheckingComputation(((EditorComponent) editorContext.getEditorComponent()).getTypecheckingContextOwner(), node, new ITypechecking.Computation<Set<EditorMessage>>() {
      @Override
      public Set<EditorMessage> compute(TypeCheckingContext typeCheckingContext) {
        return doCreateMessages(node, wasCheckedOnce, editorContext, typeCheckingContext, cancellable);
      }
    });
  }
  @Override
  protected Set<EditorMessage> createMessages(final SNode node, final List<SModelEvent> list, final boolean wasCheckedOnce, final EditorContext editorContext) {
    throw new UnsupportedOperationException("old createMessages() API not supported");
  }
  private Set<EditorMessage> doCreateMessages(SNode node, boolean wasCheckedOnce, EditorContext editorContext, TypeCheckingContext typeCheckingContext, Cancellable cancellable) {
    EditorComponent editorComponent = (EditorComponent) editorContext.getEditorComponent();
    boolean inspector = editorComponent instanceof InspectorEditorComponent;

    myMessagesChanged = false;

    SNode editedNode = editorComponent.getEditedNode();

    if (editedNode == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("edited node is null");
      }
      return Collections.emptySet();
    }
    if (node.getModel() == null || SNodeOperations.getModel(editedNode) == null) {
      // descriptor is null for a replaced model 
      // after model is replaced but before it is disposed (this can happen asyncronously) 
      return Collections.emptySet();
    }

    LanguageErrorsComponent errorsComponent = getErrorsComponent(editorComponent);
    if (errorsComponent == null) {
      return Collections.emptySet();
    }

    if (!(wasCheckedOnce)) {
      errorsComponent.clear();
    }

    myMessagesChanged = runChecks(inspector, errorsComponent, typeCheckingContext, node, editorContext, cancellable);

    if (!(myMessagesChanged)) {
      // skipping further processing if nothing was changed 
      return Collections.emptySet();
    }

    return createMessages(editorContext, inspector, errorsComponent, editedNode);
  }

  private boolean runChecks(boolean inspector, LanguageErrorsComponent errorsComponent, TypeCheckingContext typeCheckingContext, SNode node, EditorContext editorContext, Cancellable cancellable) {
    if (inspector) {
      return errorsComponent.checkInspector();
    }

    try {
      if (typeCheckingContext != null) {
        typeCheckingContext.setIsNonTypesystemComputation();
      }
      myScopeChecker.setEditorComponent((EditorComponent) editorContext.getEditorComponent());
      return errorsComponent.check(SNodeOperations.getContainingRoot(((SNode) node)), myRules, editorContext.getRepository(), cancellable);
    } finally {
      if (typeCheckingContext != null) {
        typeCheckingContext.resetIsNonTypesystemComputation();
      }
    }
  }

  private Set<EditorMessage> createMessages(EditorContext editorContext, boolean inspector, LanguageErrorsComponent errorsComponent, SNode editedNode) {
    Set<EditorMessage> result = SetSequence.fromSet(new HashSet<EditorMessage>());
    boolean runQuickFixes = shouldRunQuickFixs(editorContext.getModel(), inspector);
    final List<Tuples._2<QuickFix_Runtime, SNode>> quickFixesToExecute = ListSequence.fromList(new ArrayList<Tuples._2<QuickFix_Runtime, SNode>>());
    for (IErrorReporter errorReporter : errorsComponent.getErrors()) {
      // todo here should be processor-based architecture, like in other checkers 
      if (!(ErrorReportUtil.shouldReportError(errorReporter.getSNode()))) {
        continue;
      }

      SNode nodeWithError = errorReporter.getSNode();
      if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(nodeWithError, null, true)).contains(editedNode))) {
        // in inspector skipping all messages for invisible nodes 
        continue;
      }
      MessageStatus status = errorReporter.getMessageStatus();
      String errorString = errorReporter.reportError();
      HighlighterMessage message = HighlightUtil.createHighlighterMessage(nodeWithError, NameUtil.capitalize(status.getPresentation()) + ": " + errorString, errorReporter, LanguageEditorChecker.this);
      List<QuickFixProvider> intentionProviders = message.getIntentionProviders();
      if (runQuickFixes && intentionProviders.size() == 1 && intentionProviders.get(0).isExecutedImmediately()) {
        QuickFix_Runtime quickFix = intentionProviders.get(0).getQuickFix();
        if (quickFix != null) {
          ListSequence.fromList(quickFixesToExecute).addElement(MultiTuple.<QuickFix_Runtime,SNode>from(quickFix, nodeWithError));
        }
      }
      SetSequence.fromSet(result).addElement(message);
    }

    if (inspector) {
      return result;
    }
    // running quick fixes in main editor only 
    final boolean wasForceRunQuickFixes = myForceRunQuickFixes;
    myForceRunQuickFixes = false;
    if (ListSequence.fromList(quickFixesToExecute).isNotEmpty()) {
      ApplicationManager.getApplication().invokeLater(new Runnable() {
        public void run() {
          ModelAccess.instance().runUndoTransparentCommand(new Runnable() {
            public void run() {
              for (Tuples._2<QuickFix_Runtime, SNode> fix : quickFixesToExecute) {
                if (SNodeOperations.getModel(fix._1()) != null) {
                  fix._0().execute(fix._1());
                  if (wasForceRunQuickFixes) {
                    // forcing to execute quickFixes for all errors reported on the modified model 
                    myForceRunQuickFixes = true;
                  }
                }
              }
            }
          });
        }
      });
    }
    return result;
  }

  /**
   * 
   * @return null if {@code editorComponent} is null, a non-null value otherwise
   */
  @Nullable
  private LanguageErrorsComponent getErrorsComponent(EditorComponent editorComponent) {
    synchronized (myMapsLock) {
      LanguageErrorsComponent errorsComponent;

      final Wrappers._T<EditorComponent> mainEditorComponent = new Wrappers._T<EditorComponent>(null);
      if (editorComponent instanceof InspectorEditorComponent) {
        List<SNode> editedNodeAncestors = SNodeOperations.getNodeAncestors(((SNode) editorComponent.getEditedNode()), null, true);
        for (EditorComponent candidate : MapSequence.fromMap(myEditorComponentToErrorMap).keySet()) {
          if (ListSequence.fromList(editedNodeAncestors).contains(candidate.getEditedNode())) {
            mainEditorComponent.value = candidate;
            break;
          }
        }
        if (mainEditorComponent.value == null) {
          return null;
        }
      } else {
        mainEditorComponent.value = editorComponent;
      }

      SModel model = editorComponent.getEditorContext().getModel();
      errorsComponent = MapSequence.fromMap(myEditorComponentToErrorMap).get(mainEditorComponent.value);
      if (errorsComponent == null) {
        errorsComponent = new LanguageErrorsComponent(model);
        MapSequence.fromMap(myEditorComponentToErrorMap).put(mainEditorComponent.value, errorsComponent);

        Set<EditorComponent> mappedEditorComponent = MapSequence.fromMap(myModelToEditorComponentsMap).get(model);
        if (mappedEditorComponent == null) {
          mappedEditorComponent = SetSequence.fromSet(new HashSet<EditorComponent>());
          MapSequence.fromMap(myModelToEditorComponentsMap).put(model, mappedEditorComponent);
          addModelListener(model);
        }
        SetSequence.fromSet(mappedEditorComponent).addElement(mainEditorComponent.value);

        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            mainEditorComponent.value.addDisposeListener(myDisposeListener);
            if (mainEditorComponent.value.isDisposed()) {
              myDisposeListener.editorWillBeDisposed(mainEditorComponent.value);
            }
          }
        });
      }
      return errorsComponent;
    }
  }
  private boolean shouldRunQuickFixs(SModel model, boolean inspector) {
    if (inspector || !(model instanceof EditableSModel) || model instanceof TransientSModel) {
      return false;
    }
    return EditorSettings.getInstance().isAutoQuickFix() || myForceRunQuickFixes;
  }
  @Override
  protected void clear(SNode node, EditorComponent component) {
    synchronized (myMapsLock) {
      MapSequence.fromMap(myEditorComponentToErrorMap).get(component).clear();
    }
  }
  @Override
  protected void resetCheckerState() {
    myForceRunQuickFixes = true;
    super.resetCheckerState();
  }
  protected static Logger LOG = LogManager.getLogger(LanguageEditorChecker.class);
}
