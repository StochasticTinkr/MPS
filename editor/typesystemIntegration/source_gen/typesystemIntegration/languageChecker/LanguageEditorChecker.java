package typesystemIntegration.languageChecker;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.BaseEditorChecker;
import java.util.Set;
import jetbrains.mps.checkers.AbstractConstraintsChecker;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Map;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.checkers.LanguageErrorsComponent;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SRepositoryContentAdapter;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.event.SModelListener;
import jetbrains.mps.smodel.SModelAdapter;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.checkers.ConstraintsChecker;
import jetbrains.mps.checkers.TargetConceptChecker;
import jetbrains.mps.smodel.RepoListenerRegistrar;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.nodeEditor.checking.EditorChecker;
import jetbrains.mps.typesystem.checking.TypesEditorChecker;
import jetbrains.mps.nodeEditor.checking.LegacyEditorCheckerAdapter;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.nodeEditor.EditorMessage;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.util.Cancellable;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.typesystem.inference.ITypechecking;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.nodeEditor.inspector.InspectorEditorComponent;
import org.apache.log4j.Level;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.errors.QuickFix_Runtime;
import java.util.ArrayList;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.checkers.ErrorReportUtil;
import jetbrains.mps.errors.MessageStatus;
import jetbrains.mps.nodeEditor.HighlighterMessage;
import jetbrains.mps.typesystem.checking.HighlightUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.errors.QuickFixProvider;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.extapi.model.TransientSModel;
import jetbrains.mps.nodeEditor.EditorSettings;
import jetbrains.mps.project.validation.ValidationUtil;
import org.jetbrains.mps.openapi.util.Processor;
import jetbrains.mps.project.validation.ValidationProblem;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.SModelOperations;
import java.util.Collections;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class LanguageEditorChecker extends BaseEditorChecker {
  private boolean myMessagesChanged = false;
  private boolean myForceRunQuickFixes = false;
  private Set<AbstractConstraintsChecker> myRules = SetSequence.fromSet(new HashSet<AbstractConstraintsChecker>());

  /**
   * The two maps below are accessed from EDT (by {@link typesystemIntegration.languageChecker.LanguageEditorChecker#myDisposeListener }) and from the background highlighter
   * thread. Access to the maps must be therefore guarded by this lock.
   */
  private final Object myMapsLock = new Object();
  private Map<EditorComponent, LanguageErrorsComponent> myEditorComponentToErrorMap = MapSequence.fromMap(new HashMap<EditorComponent, LanguageErrorsComponent>());
  private Map<SModel, Set<EditorComponent>> myModelToEditorComponentsMap = MapSequence.fromMap(new HashMap<SModel, Set<EditorComponent>>());

  private EditorComponent.EditorDisposeListener myDisposeListener = new EditorComponent.EditorDisposeListener() {
    @Override
    public void editorWillBeDisposed(EditorComponent editorComponent) {
      editorComponent.removeDisposeListener(myDisposeListener);
      synchronized (myMapsLock) {
        MapSequence.fromMap(myEditorComponentToErrorMap).removeKey(editorComponent).dispose();

        for (SModel model : MapSequence.fromMap(myModelToEditorComponentsMap).keySet()) {
          Set<EditorComponent> editorComponents = MapSequence.fromMap(myModelToEditorComponentsMap).get(model);
          if (SetSequence.fromSet(editorComponents).removeElement(editorComponent) != null) {
            if (SetSequence.fromSet(editorComponents).isEmpty()) {
              MapSequence.fromMap(myModelToEditorComponentsMap).removeKey(model);
              removeModelListener(model);
            }
            break;
          }
        }
      }
    }
  };

  private final SRepository myRepository;
  private final SRepositoryContentAdapter myRepositoryListener = new SRepositoryContentAdapter() {

    @Override
    protected boolean isIncluded(SModule module) {
      return !(module.isReadOnly());
    }
    @Override
    protected void stopListening(SModel model) {
      synchronized (myMapsLock) {
        if (!(MapSequence.fromMap(myModelToEditorComponentsMap).containsKey(model))) {
          return;
        }
        for (EditorComponent editorComponent : MapSequence.fromMap(myModelToEditorComponentsMap).get(model)) {
          MapSequence.fromMap(myEditorComponentToErrorMap).removeKey(editorComponent).dispose();
          editorComponent.removeDisposeListener(myDisposeListener);
        }
        MapSequence.fromMap(myModelToEditorComponentsMap).removeKey(model);
      }
      removeModelListener(model);
    }
  };

  private SModelListener myModelListener = new SModelAdapter() {
    @Override
    public void beforeModelDisposed(SModel model) {
      synchronized (myMapsLock) {
        for (EditorComponent editorComponent : MapSequence.fromMap(myModelToEditorComponentsMap).get(model)) {
          MapSequence.fromMap(myEditorComponentToErrorMap).removeKey(editorComponent).dispose();
          editorComponent.removeDisposeListener(myDisposeListener);
        }
        MapSequence.fromMap(myModelToEditorComponentsMap).removeKey(model);
      }
    }
  };

  private RefScopeCheckerInEditor myScopeChecker;
  public LanguageEditorChecker(@NotNull SRepository projectRepo) {
    myRepository = projectRepo;
    SetSequence.fromSet(myRules).addElement(new ConstraintsChecker());
    SetSequence.fromSet(myRules).addElement(myScopeChecker = new RefScopeCheckerInEditor());
    SetSequence.fromSet(myRules).addElement(new LanguageEditorChecker.InEditorStructureChecker());
    SetSequence.fromSet(myRules).addElement(new TargetConceptChecker());
    SetSequence.fromSet(myRules).addElement(new LanguageEditorChecker.UsedLanguagesChecker());
    new RepoListenerRegistrar(myRepository, myRepositoryListener).attach();
  }
  @Override
  protected void doDispose() {
    new RepoListenerRegistrar(myRepository, myRepositoryListener).detach();
    synchronized (myMapsLock) {
      Sequence.fromIterable(MapSequence.fromMap(myEditorComponentToErrorMap).values()).visitAll(new IVisitor<LanguageErrorsComponent>() {
        public void visit(LanguageErrorsComponent it) {
          it.dispose();
        }
      });
      SetSequence.fromSet(MapSequence.fromMap(myEditorComponentToErrorMap).keySet()).visitAll(new IVisitor<EditorComponent>() {
        public void visit(EditorComponent it) {
          it.removeDisposeListener(myDisposeListener);
        }
      });
      myEditorComponentToErrorMap = null;
      SetSequence.fromSet(MapSequence.fromMap(myModelToEditorComponentsMap).keySet()).visitAll(new IVisitor<SModel>() {
        public void visit(SModel it) {
          removeModelListener(it);
        }
      });
      myModelToEditorComponentsMap = null;
    }
    super.doDispose();
  }
  private void removeModelListener(SModel model) {
    ((SModelInternal) model).removeModelListener(myModelListener);
  }
  private void addModelListener(SModel modelDescriptor) {
    ((SModelInternal) modelDescriptor).addModelListener(myModelListener);
  }
  @Override
  protected boolean areMessagesChanged() {
    return myMessagesChanged;
  }
  @Override
  protected boolean isLaterThan(EditorChecker checker) {
    if (checker instanceof TypesEditorChecker) {
      return true;
    }
    if (checker instanceof LegacyEditorCheckerAdapter) {
      LegacyEditorCheckerAdapter legacyChecker = (LegacyEditorCheckerAdapter) checker;
      if (legacyChecker.getChecker() instanceof AutoResolver) {
        return true;
      }
    }
    return false;
  }
  @Override
  protected boolean hasDramaticalEvent(List<SModelEvent> list) {
    return true;
  }

  @Override
  protected Set<EditorMessage> createMessages(final SNode node, final List<SModelEvent> list, final boolean wasCheckedOnce, final EditorContext editorContext, final Cancellable cancellable, boolean applyQuickFixes) {
    return TypeContextManager.getInstance().runTypeCheckingComputation(((jetbrains.mps.nodeEditor.EditorComponent) editorContext.getEditorComponent()).getTypecheckingContextOwner(), node, new ITypechecking.Computation<Set<EditorMessage>>() {
      @Override
      public Set<EditorMessage> compute(TypeCheckingContext typeCheckingContext) {
        return doCreateMessages(node, list, wasCheckedOnce, editorContext, typeCheckingContext, cancellable);
      }
    });
  }
  @Override
  protected Set<EditorMessage> createMessages(final SNode node, final List<SModelEvent> list, final boolean wasCheckedOnce, final EditorContext editorContext) {
    throw new UnsupportedOperationException("old createMessages() API not supported");
  }
  private Set<EditorMessage> doCreateMessages(SNode node, List<SModelEvent> list, boolean wasCheckedOnce, EditorContext editorContext, TypeCheckingContext typeCheckingContext, Cancellable cancellable) {
    jetbrains.mps.nodeEditor.EditorComponent editorComponent = (jetbrains.mps.nodeEditor.EditorComponent) editorContext.getEditorComponent();
    SModel model = editorContext.getModel();
    boolean inspector = editorComponent instanceof InspectorEditorComponent;

    myScopeChecker.setEditorComponent(editorComponent);

    myMessagesChanged = false;

    Set<EditorMessage> result = SetSequence.fromSet(new HashSet<EditorMessage>());
    SNode editedNode = editorComponent.getEditedNode();

    if (editedNode == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("edited node is null");
      }
      return result;
    }
    if (node.getModel() == null || SNodeOperations.getModel(editedNode) == null) {
      // descriptor is null for a replaced model 
      // after model is replaced but before it is disposed (this can happen asyncronously) 
      return result;
    }

    LanguageErrorsComponent errorsComponent;

    synchronized (myMapsLock) {
      final Wrappers._T<EditorComponent> mainEditorComponent = new Wrappers._T<EditorComponent>(null);
      if (inspector) {
        List<SNode> editedNodeAncestors = SNodeOperations.getNodeAncestors(editedNode, null, true);
        for (EditorComponent candidate : MapSequence.fromMap(myEditorComponentToErrorMap).keySet()) {
          if (ListSequence.fromList(editedNodeAncestors).contains(candidate.getEditedNode())) {
            mainEditorComponent.value = candidate;
            break;
          }
        }
        if (mainEditorComponent.value == null) {
          return result;
        }
      } else {
        mainEditorComponent.value = editorComponent;
      }

      errorsComponent = MapSequence.fromMap(myEditorComponentToErrorMap).get(mainEditorComponent.value);
      if (errorsComponent == null) {
        errorsComponent = new LanguageErrorsComponent(model);
        MapSequence.fromMap(myEditorComponentToErrorMap).put(mainEditorComponent.value, errorsComponent);

        Set<EditorComponent> mappedEditorComponent = MapSequence.fromMap(myModelToEditorComponentsMap).get(model);
        if (mappedEditorComponent == null) {
          mappedEditorComponent = SetSequence.fromSet(new HashSet<EditorComponent>());
          MapSequence.fromMap(myModelToEditorComponentsMap).put(model, mappedEditorComponent);
          addModelListener(model);
        }
        SetSequence.fromSet(mappedEditorComponent).addElement(mainEditorComponent.value);

        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            mainEditorComponent.value.addDisposeListener(myDisposeListener);
            if (mainEditorComponent.value.isDisposed()) {
              myDisposeListener.editorWillBeDisposed(mainEditorComponent.value);
            }
          }
        });
      }
    }

    if (!(wasCheckedOnce)) {
      errorsComponent.clear();
    }

    if (inspector) {
      myMessagesChanged = errorsComponent.checkInspector();
    } else {
      boolean changed = false;
      try {
        if (typeCheckingContext != null) {
          typeCheckingContext.setIsNonTypesystemComputation();
        }
        changed = errorsComponent.check(SNodeOperations.getContainingRoot(((SNode) node)), myRules, editorContext.getRepository(), cancellable);
      } finally {
        if (typeCheckingContext != null) {
          typeCheckingContext.resetIsNonTypesystemComputation();
        }
      }
      myMessagesChanged = changed;
    }

    if (!(myMessagesChanged)) {
      // skipping quickfix processing if othing was changed 
      return result;
    }

    boolean runQuickFixes = shouldRunQuickFixs(model, inspector);
    final List<Tuples._2<QuickFix_Runtime, SNode>> quickFixesToExecute = ListSequence.fromList(new ArrayList<Tuples._2<QuickFix_Runtime, SNode>>());
    for (IErrorReporter errorReporter : errorsComponent.getErrors()) {
      // todo here should be processor-based architecture, like in other checkers 
      if (!(ErrorReportUtil.shouldReportError(errorReporter.getSNode()))) {
        continue;
      }

      SNode nodeWithError = errorReporter.getSNode();
      if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(nodeWithError, null, true)).contains(editedNode))) {
        // in inspector skipping all messages for invisible nodes 
        continue;
      }
      MessageStatus status = errorReporter.getMessageStatus();
      String errorString = errorReporter.reportError();
      HighlighterMessage message = HighlightUtil.createHighlighterMessage(nodeWithError, NameUtil.capitalize(status.getPresentation()) + ": " + errorString, errorReporter, LanguageEditorChecker.this, editorContext);
      List<QuickFixProvider> intentionProviders = message.getIntentionProviders();
      if (runQuickFixes && intentionProviders.size() == 1 && intentionProviders.get(0).isExecutedImmediately()) {
        QuickFix_Runtime quickFix = intentionProviders.get(0).getQuickFix();
        if (quickFix != null) {
          ListSequence.fromList(quickFixesToExecute).addElement(MultiTuple.<QuickFix_Runtime,SNode>from(quickFix, nodeWithError));
        }
      }
      SetSequence.fromSet(result).addElement(message);
    }

    if (inspector) {
      return result;
    }
    // running quick fixes in main editor only 
    final boolean wasForceRunQuickFixes = myForceRunQuickFixes;
    myForceRunQuickFixes = false;
    if (ListSequence.fromList(quickFixesToExecute).isNotEmpty()) {
      ApplicationManager.getApplication().invokeLater(new Runnable() {
        public void run() {
          ModelAccess.instance().runUndoTransparentCommand(new Runnable() {
            public void run() {
              for (Tuples._2<QuickFix_Runtime, SNode> fix : quickFixesToExecute) {
                if (SNodeOperations.getModel(fix._1()) != null) {
                  fix._0().execute(fix._1());
                  if (wasForceRunQuickFixes) {
                    // forcing to execute quickFixes for all errors reported on the modified model 
                    myForceRunQuickFixes = true;
                  }
                }
              }
            }
          });
        }
      });
    }
    return result;
  }
  private boolean shouldRunQuickFixs(SModel model, boolean inspector) {
    if (inspector || !(model instanceof EditableSModel) || model instanceof TransientSModel) {
      return false;
    }
    return EditorSettings.getInstance().isAutoQuickFix() || myForceRunQuickFixes;
  }
  @Override
  protected void clear(SNode node, jetbrains.mps.nodeEditor.EditorComponent component) {
    synchronized (myMapsLock) {
      MapSequence.fromMap(myEditorComponentToErrorMap).get(component).clear();
    }
  }
  @Override
  protected void resetCheckerState() {
    myForceRunQuickFixes = true;
    super.resetCheckerState();
  }
  private class InEditorStructureChecker extends AbstractConstraintsChecker {
    public InEditorStructureChecker() {
    }
    public void checkNode(final SNode node, final LanguageErrorsComponent component, SRepository repository) {
      ValidationUtil.validateSingleNode(node, new Processor<ValidationProblem>() {
        public boolean process(ValidationProblem vp) {
          if (vp.getSeverity() != ValidationProblem.Severity.ERROR) {
            return true;
          }
          component.addError(node, vp.getMessage(), null);
          return true;
        }
      });
    }
  }
  private class UsedLanguagesChecker extends AbstractConstraintsChecker {
    private final SConcept C = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0xad0053c7ae9194dL, "jetbrains.mps.lang.core.structure.SideTransformInfo");
    private final SContainmentLink L = MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute");

    public UsedLanguagesChecker() {
    }
    public void checkNode(SNode node, LanguageErrorsComponent component, SRepository repository) {
      if (SNodeOperations.getParent(node) != null) {
        return;
      }

      final Set<SLanguage> importedLanguages = new HashSet<SLanguage>();
      importedLanguages.addAll(new SLanguageHierarchy(SModelOperations.getAllLanguageImports(SNodeOperations.getModel(node))).getExtended());

      // need to recurse the tree, to report missing language once per sub-tree  
      // (starting from the first node with missing language encountered) 
      // Iterative alternative would be more complicated, and there are no utility  
      // methods in the rules nor we support inner classes, hence the trick with Runnable 
      findMissing(component, Collections.singleton(node), Collections.<SLanguage>emptySet(), importedLanguages);
    }

    public void findMissing(LanguageErrorsComponent component, Iterable<? extends SNode> level, Set<SLanguage> parentReported, Set<SLanguage> imported) {
      boolean parentReportedSetChanged = false;
      for (SNode node : Sequence.fromIterable(level)) {
        HashSet<SLanguage> reported = new HashSet<SLanguage>(parentReported);
        SConcept concept = node.getConcept();
        if (concept.equals(C) && L.equals(node.getContainmentLink())) {
          continue;
        }

        SLanguage language = concept.getLanguage();
        boolean notYetReported = reported.add(language);
        parentReportedSetChanged |= notYetReported;
        if (!(imported.contains(language)) && notYetReported) {
          component.addError(node, language.getQualifiedName() + " is not imported", null, new NodeMessageTarget(), new LanguageEditorChecker.UsedLanguagesChecker.LangImportQFixProvider());
        }
        findMissing(component, node.getChildren(), (parentReportedSetChanged ? reported : parentReported), imported);
      }
    }

    private class LangImportQFixProvider implements QuickFixProvider {
      public LangImportQFixProvider() {
      }
      public QuickFix_Runtime getQuickFix() {
        return new QuickFix_Runtime() {
          @Override
          public String getDescription(SNode node) {
            return "Import " + node.getConcept().getLanguage().getQualifiedName() + " language";
          }
          public void execute(SNode node) {
            SLanguage language = node.getConcept().getLanguage();
            ((SModelInternal) node.getModel()).addLanguage(language);
          }
        };
      }
      public boolean isExecutedImmediately() {
        return false;
      }
      public void setIsError(boolean val) {
      }
      public boolean isError() {
        return true;
      }
    }
  }
  protected static Logger LOG = LogManager.getLogger(LanguageEditorChecker.class);
}
