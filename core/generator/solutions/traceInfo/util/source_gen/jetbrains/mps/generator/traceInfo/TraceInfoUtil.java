package jetbrains.mps.generator.traceInfo;

/*Generated by MPS */

import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.textgen.trace.DebugInfo;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.textgen.trace.TraceInfoCache;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.textgen.trace.PositionInfo;
import java.util.Map;
import jetbrains.mps.textgen.trace.DebugInfoRoot;
import jetbrains.mps.textgen.trace.TraceablePositionInfo;
import java.util.Set;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.MPSModuleRepository;

/**
 * 
 * @deprecated Do not use this class, full of statics. Instead, utilize instance methods of DebugInfo. To get DebugInfo, you may find {@link jetbrains.mps.textgen.trace.DefaultTraceInfoProvider } handy
 */
@Deprecated
@ToRemove(version = 3.4)
public final class TraceInfoUtil {
  @Deprecated
  private TraceInfoUtil() {
  }

  /**
   * 
   * @deprecated use {@link jetbrains.mps.textgen.trace.DebugInfo } and {@link jetbrains.mps.textgen.trace.DebugInfo#getTracedNodesForPosition(String, int) } instead, and resolve SNode as appropriate
   */
  @Nullable
  @Deprecated
  public static SNode getNode(@NonNls String className, final String file, final int position) {
    // in use by mbeddr (2 uses) 
    return ListSequence.fromList(TraceInfoUtil.getAllNodes(className, file, position)).first();
  }
  /**
   * 
   * @deprecated Use {@link jetbrains.mps.textgen.trace.DebugInfo#getTracedNodesForPosition(String, int) } instead.
   */
  @Nullable
  @Deprecated
  @ToRemove(version = 3.4)
  public static List<SNode> getAllTraceableNodes(@NotNull String className, final String file, final int position) {
    // in use by mbeddr (3 uses) 
    return TraceInfoUtil.getAllNodes(className, file, position);
  }

  private static String modelFqNameFromUnitName(String unitName) {
    int lastDot = unitName.lastIndexOf(".");
    return ((lastDot == -1 ? "" : unitName.substring(0, lastDot)));
  }
  @Nullable
  private static <T> T findInTraceInfo(@NonNls String unitName, _FunctionTypes._return_P2_E0<? extends T, ? super DebugInfo, ? super SModel> getter) {
    for (SModel descriptor : Sequence.fromIterable(getCandidateModels(unitName))) {
      final DebugInfo info = TraceInfoCache.getInstance().get(descriptor);
      if (info == null) {
        continue;
      }
      T result = getter.invoke(info, descriptor);
      if (result != null) {
        return result;
      }
    }
    return null;
  }
  private static Iterable<SModel> getCandidateModels(String unitName) {
    final String modelFqName = modelFqNameFromUnitName(unitName);
    return Sequence.fromIterable(Sequence.fromArray(SModelStereotype.values)).where(new IWhereFilter<String>() {
      public boolean accept(String it) {
        return !(SModelStereotype.isStubModelStereotype(it));
      }
    }).select(new ISelector<String, SModel>() {
      public SModel select(String stereotype) {
        return SModelRepository.getInstance().getModelDescriptor(SModelStereotype.withStereotype(modelFqName, stereotype));
      }
    }).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel it) {
        return it != null;
      }
    });
  }

  private static <T extends PositionInfo> List<SNode> getAllNodes(@NonNls String unitName, final String file, final int lineNumber) {
    return findInTraceInfo(unitName, new _FunctionTypes._return_P2_E0<List<SNode>, DebugInfo, SModel>() {
      public List<SNode> invoke(DebugInfo debugInfo, SModel descriptor) {
        Map<DebugInfoRoot, List<TraceablePositionInfo>> infoForPosition = debugInfo.getRootToInfoForPosition(file, lineNumber, new _FunctionTypes._return_P1_E0<Set<TraceablePositionInfo>, DebugInfoRoot>() {
          public Set<TraceablePositionInfo> invoke(DebugInfoRoot root) {
            return root.getPositions();
          }
        });
        List<SNode> nodes = ListSequence.fromList(new ArrayList<SNode>());
        if (MapSequence.fromMap(infoForPosition).isEmpty()) {
          return null;
        }
        for (IMapping<DebugInfoRoot, List<TraceablePositionInfo>> rootToInfo : MapSequence.fromMap(infoForPosition)) {
          final String model = rootToInfo.key().getNodeRef().getModelReference().toString();
          for (TraceablePositionInfo info : ListSequence.fromList(rootToInfo.value())) {
            SNode node = new SNodePointer(model, info.getNodeId()).resolve(MPSModuleRepository.getInstance());
            if (node != null) {
              nodes.add(node);
            }
          }
        }
        if (ListSequence.fromList(nodes).isEmpty()) {
          return null;
        }
        return nodes;
      }
    });
  }
}
