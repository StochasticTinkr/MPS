package jetbrains.mps.generator.traceInfo;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.textgen.trace.DebugInfo;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Map;
import jetbrains.mps.textgen.trace.DebugInfoRoot;
import java.util.List;
import jetbrains.mps.textgen.trace.TraceablePositionInfo;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.textgen.trace.PositionInfo;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.textgen.trace.TraceInfoCache;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.SModelRepository;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IMapping;

public final class TraceInfoUtil {
  private TraceInfoUtil() {
  }

  @Nullable
  public static SNode getNode(@NonNls String className, final String file, final int position) {
    // in use by mbeddr (2 uses) 
    return check_4iwlxm_a1a2(getAllTraceableNodes(className, file, position));
  }
  /**
   * Java-specific method for finding the most suitable node from position in java code.
   * 
   * @param unitName name of a java class
   * @param fileName name of a source file
   * @param lineNumber line number
   * @return node
   */
  @Nullable
  public static SNode getJavaNode(@NonNls String unitName, final String fileName, final int lineNumber) {
    return findInTraceInfo(unitName, new _FunctionTypes._return_P2_E0<SNode, DebugInfo, SModel>() {
      public SNode invoke(DebugInfo info, SModel modelDescriptor) {
        Map<DebugInfoRoot, List<TraceablePositionInfo>> resultList = info.getRootToInfoForPosition(fileName, lineNumber, new _FunctionTypes._return_P1_E0<Set<TraceablePositionInfo>, DebugInfoRoot>() {
          public Set<TraceablePositionInfo> invoke(DebugInfoRoot root) {
            return root.getPositions();
          }
        });
        if (resultList == null || MapSequence.fromMap(resultList).isEmpty()) {
          return null;
        }
        // todo impossible to read 
        for (DebugInfoRoot root : SetSequence.fromSet(MapSequence.fromMap(resultList).keySet())) {
          Iterable<TraceablePositionInfo> sorted = ListSequence.fromList(MapSequence.fromMap(resultList).get(root)).sort(new ISelector<TraceablePositionInfo, TraceablePositionInfo>() {
            public TraceablePositionInfo select(TraceablePositionInfo it) {
              return it;
            }
          }, true);
          final TraceablePositionInfo firstPositionInfo = Sequence.fromIterable(sorted).first();
          PositionInfo result = firstPositionInfo;
          // here we do some magic to fix the following bug: 
          // each node in base language owns a '\n' symbol in a previous line 
          // in the following code we will never get 'for' node quering line 1: 
          // 1.  for (...) { 
          // 2.    some statement 
          // 3.  } 
          // since 'some statement' takes lines 1-2 instead of just line 2 
          if (Sequence.fromIterable(sorted).count() > 1 && firstPositionInfo.getStartLine() == lineNumber && firstPositionInfo.getLineDistance() > 0) {
            result = ListSequence.fromList(Sequence.fromIterable(sorted).toListSequence()).getElement(1);
          }
          // FIXME ugly code follows. Whole TraceInfo story needs re-write to accomodate SRepository 
          final String model = root.getNodeRef().getModelReference().toString();
          // here we have another example of how not to write code 
          // this is a hack fixing MPS-8644 
          // the problem is with the BlockStatement which sometimes generates to nothing, but is still present in .debug 
          // so in the code like this: 
          // 1. { 
          // 2. statement 
          // 3. } 
          // block statement occupy the same place as "statement" because this code generates into: 
          // 1. statement 
          // the solution is simple: 
          // among all node with same position we select the deepest 
          if (Sequence.fromIterable(sorted).count() > 1) {
            Iterable<TraceablePositionInfo> sameSpacePositions = Sequence.fromIterable(sorted).where(new IWhereFilter<TraceablePositionInfo>() {
              public boolean accept(TraceablePositionInfo it) {
                return firstPositionInfo.isOccupyTheSameSpace(it);
              }
            });
            if (Sequence.fromIterable(sameSpacePositions).count() > 1) {
              SNode currentNode = new SNodePointer(model, firstPositionInfo.getNodeId()).resolve(MPSModuleRepository.getInstance());
              boolean finished = false;
              while (!(finished)) {
                finished = true;
                for (TraceablePositionInfo otherPos : Sequence.fromIterable(sameSpacePositions)) {
                  SNode otherNode = new SNodePointer(model, otherPos.getNodeId()).resolve(MPSModuleRepository.getInstance());
                  if ((otherNode != null) && ListSequence.fromList(SNodeOperations.getNodeAncestors(otherNode, null, false)).contains(currentNode)) {
                    currentNode = otherNode;
                    finished = false;
                    break;
                  }
                }
              }
              return currentNode;
            }
          }
          return new SNodePointer(model, result.getNodeId()).resolve(MPSModuleRepository.getInstance());
        }
        return null;
      }
    });
  }
  @Nullable
  public static List<SNode> getAllTraceableNodes(@NotNull String className, final String file, final int position) {
    // in use by mbeddr (3 uses) 
    return TraceInfoUtil.getAllNodes(className, file, position, new _FunctionTypes._return_P1_E0<Set<TraceablePositionInfo>, DebugInfoRoot>() {
      public Set<TraceablePositionInfo> invoke(DebugInfoRoot key) {
        return key.getPositions();
      }
    });
  }

  private static String modelFqNameFromUnitName(String unitName) {
    int lastDot = unitName.lastIndexOf(".");
    return ((lastDot == -1 ? "" : unitName.substring(0, lastDot)));
  }
  @Nullable
  private static <T> T findInTraceInfo(@NonNls String unitName, _FunctionTypes._return_P2_E0<? extends T, ? super DebugInfo, ? super SModel> getter) {
    for (SModel descriptor : Sequence.fromIterable(getCandidateModels(unitName))) {
      final DebugInfo info = TraceInfoCache.getInstance().get(descriptor);
      if (info == null) {
        continue;
      }
      T result = getter.invoke(info, descriptor);
      if (result != null) {
        return result;
      }
    }
    return null;
  }
  private static Iterable<SModel> getCandidateModels(String unitName) {
    final String modelFqName = modelFqNameFromUnitName(unitName);
    return Sequence.fromIterable(Sequence.fromArray(SModelStereotype.values)).where(new IWhereFilter<String>() {
      public boolean accept(String it) {
        return !(SModelStereotype.isStubModelStereotype(it));
      }
    }).select(new ISelector<String, SModel>() {
      public SModel select(String stereotype) {
        return SModelRepository.getInstance().getModelDescriptor(SModelStereotype.withStereotype(modelFqName, stereotype));
      }
    }).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel it) {
        return it != null;
      }
    });
  }
  private static <T extends PositionInfo> List<SNode> getAllNodes(@NonNls String unitName, final String file, final int lineNumber, final _FunctionTypes._return_P1_E0<? extends Set<T>, ? super DebugInfoRoot> positionsGetter) {
    return findInTraceInfo(unitName, new _FunctionTypes._return_P2_E0<List<SNode>, DebugInfo, SModel>() {
      public List<SNode> invoke(DebugInfo debugInfo, SModel descriptor) {
        Map<DebugInfoRoot, List<T>> infoForPosition = debugInfo.getRootToInfoForPosition(file, lineNumber, new _FunctionTypes._return_P1_E0<Set<T>, DebugInfoRoot>() {
          public Set<T> invoke(DebugInfoRoot root) {
            return positionsGetter.invoke(root);
          }
        });
        List<SNode> nodes = ListSequence.fromList(new ArrayList<SNode>());
        if (MapSequence.fromMap(infoForPosition).isEmpty()) {
          return null;
        }
        for (IMapping<DebugInfoRoot, List<T>> rootToInfo : MapSequence.fromMap(infoForPosition)) {
          final String model = rootToInfo.key().getNodeRef().getModelReference().toString();
          for (T info : ListSequence.fromList(rootToInfo.value())) {
            SNode node = new SNodePointer(model, info.getNodeId()).resolve(MPSModuleRepository.getInstance());
            if (node != null) {
              nodes.add(node);
            }
          }
        }
        if (ListSequence.fromList(nodes).isEmpty()) {
          return null;
        }
        return nodes;
      }
    });
  }
  private static SNode check_4iwlxm_a1a2(List<SNode> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return ListSequence.fromList(checkedDotOperand).first();
    }
    return null;
  }
}
