package jetbrains.mps.generator.impl;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.generator.impl.plan.PlanIdentity;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.generator.GenerationPlanBuilder;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.generator.impl.plan.CheckpointIdentity;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.smodel.Generator;

/**
 * Mediator between a model with Plan node and {@link jetbrains.mps.generator.ModelGenerationPlan } run-time presentation.
 * Translates sequence of plan steps from model into sequence of {@link jetbrains.mps.generator.GenerationPlanBuilder } calls.
 * I use {@link jetbrains.mps.generator.GenerationPlanBuilder } although it seems like an excessive mediator to hide implementation details and to facilitate
 * plan creation not from a model-backed description.
 */
public class GenPlanTranslator {
  private final SNode myPlanDeclaration;
  private final PlanIdentity myPlanIdentity;

  public GenPlanTranslator(@NotNull SNode planDeclaration) {
    myPlanDeclaration = planDeclaration;
    myPlanIdentity = new PlanIdentity(SPropertyOperations.getString(myPlanDeclaration, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
  }

  public PlanIdentity getPlanIdentity() {
    return myPlanIdentity;
  }

  /**
   * Doesn't wrap the planBuilder, it's up to caller.
   * 
   * @return {@code this} for convenience
   */
  public GenPlanTranslator feed(@NotNull GenerationPlanBuilder planBuilder) {
    ArrayList<SLanguage> langueges = new ArrayList<SLanguage>();
    ArrayList<SModule> generators = new ArrayList<SModule>();

    for (SNode stepNode : SLinkOperations.getChildren(myPlanDeclaration, MetaAdapterFactory.getContainmentLink(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x19443180a20717fbL, 0x19443180a2071807L, "steps"))) {
      if (SNodeOperations.isInstanceOf(stepNode, MetaAdapterFactory.getConcept(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x19443180a2071801L, "jetbrains.mps.lang.generator.plan.structure.Checkpoint"))) {
        planBuilder.recordCheckpoint(new CheckpointIdentity(myPlanIdentity, SPropertyOperations.getString(SNodeOperations.as(stepNode, MetaAdapterFactory.getConcept(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x19443180a2071801L, "jetbrains.mps.lang.generator.plan.structure.Checkpoint")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))));
      } else if (SNodeOperations.isInstanceOf(stepNode, MetaAdapterFactory.getConcept(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x19443180a2071802L, "jetbrains.mps.lang.generator.plan.structure.Transform"))) {
        for (SNode lid : SLinkOperations.getChildren(SNodeOperations.as(stepNode, MetaAdapterFactory.getConcept(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x19443180a2071802L, "jetbrains.mps.lang.generator.plan.structure.Transform")), MetaAdapterFactory.getContainmentLink(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x19443180a2071802L, 0x28dd6d5a7549fa8dL, "languages"))) {
          langueges.add(((SLanguage) BHReflection.invoke(lid, SMethodTrimmedId.create("getLanguage", null, "34EJa6aIcyj"))));
        }
        planBuilder.transformLanguage(langueges.toArray(new SLanguage[langueges.size()]));
        langueges.clear();
      } else if (SNodeOperations.isInstanceOf(stepNode, MetaAdapterFactory.getConcept(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x73246de9adeca171L, "jetbrains.mps.lang.generator.plan.structure.ApplyGenerators"))) {
        SRepository repository = SNodeOperations.getModel(myPlanDeclaration).getRepository();
        SNode applyGeneratorsStep = SNodeOperations.as(stepNode, MetaAdapterFactory.getConcept(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x73246de9adeca171L, "jetbrains.mps.lang.generator.plan.structure.ApplyGenerators"));
        final boolean withExtended = SPropertyOperations.getBoolean(applyGeneratorsStep, MetaAdapterFactory.getProperty(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x73246de9adeca171L, 0xc11e5088a799353L, "withExtended"));
        for (SNode generator : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(applyGeneratorsStep, MetaAdapterFactory.getContainmentLink(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x73246de9adeca171L, 0x73246de9adf5a45cL, "generator")), MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x73246de9adecb80dL, "jetbrains.mps.lang.smodel.structure.GeneratorModulePointer")))) {
          SModuleReference mr = ((SModuleReference) BHReflection.invoke(SLinkOperations.getTarget(generator, MetaAdapterFactory.getContainmentLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x73246de9adecb80dL, 0x73246de9adecb874L, "module")), SMethodTrimmedId.create("getModuleReference", null, "nJmxU5cSSU")));
          SModule module = (mr == null ? null : mr.resolve(repository));
          if (!(module instanceof Generator)) {
            continue;
          }
          if (withExtended) {
            // FIXME need applyGeneratorWithExtended that takes multiple modules 
            planBuilder.applyGeneratorWithExtended(module);
          } else {
            generators.add(module);
          }
        }
        if (!(withExtended)) {
          planBuilder.applyGenerator(generators.toArray(new SModule[generators.size()]));
          generators.clear();
        }
      } else if (SNodeOperations.isInstanceOf(stepNode, MetaAdapterFactory.getConcept(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0xc11e5088a794d07L, "jetbrains.mps.lang.generator.plan.structure.CheckpointSynchronization"))) {
        SNode cpSynch = SLinkOperations.getTarget(SNodeOperations.as(stepNode, MetaAdapterFactory.getConcept(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0xc11e5088a794d07L, "jetbrains.mps.lang.generator.plan.structure.CheckpointSynchronization")), MetaAdapterFactory.getReferenceLink(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0xc11e5088a794d07L, 0xc11e5088a794d08L, "checkpoint"));
        planBuilder.synchronizeWithCheckpoint(new CheckpointIdentity(new PlanIdentity(SPropertyOperations.getString(SNodeOperations.as(SNodeOperations.getParent(cpSynch), MetaAdapterFactory.getConcept(0x7ab1a6fa0a114b95L, 0x9e4875f363d6cb00L, 0x19443180a20717fbL, "jetbrains.mps.lang.generator.plan.structure.Plan")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))), SPropertyOperations.getString(cpSynch, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))));
      }
    }
    return this;
  }
}
