package jetbrains.mps.refactoring.framework;

/*Generated by MPS */

import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.findUsages.UsagesList;
import java.util.Set;
import java.util.HashSet;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.Collection;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.smodel.ModelDependencyUpdate;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;

public class RefactoringContext {
  private IRefactoring myRefactoring;
  private Map<String, Object> myParametersMap = new HashMap<String, Object>();
  private UsagesList myUsages;
  private Set<String> myTransientParameters = new HashSet<String>();
  private SModel mySelectedModel;
  private SNode mySelectedNode;
  private List<SNode> mySelectedNodes = new ArrayList<SNode>();
  private SearchScope myCurrentScope;
  private final Project myProject;
  private SModule mySelectedModule;
  private List<SModel> mySelectedModels;
  private List<SModule> mySelectedModules;

  public RefactoringContext(@NotNull Project project, IRefactoring refactoring) {
    myProject = project;
    setRefactoring(refactoring);
  }
  public SRepository getRepository() {
    return myProject.getRepository();
  }
  public void addAdditionalParameters(Map<String, Object> parameters) {
    myParametersMap.putAll(parameters);
  }
  public Map<String, Object> getAdditionalParameters() {
    return new HashMap<String, Object>(myParametersMap);
  }
  public void markTransient(String parameterName) {
    myTransientParameters.add(parameterName);
  }
  public void markTransient(Collection<String> parameterNames) {
    myTransientParameters.addAll(parameterNames);
  }
  public boolean isTransient(String parameterName) {
    return myTransientParameters.contains(parameterName);
  }
  public Object getParameter(String parameterName) {
    return myParametersMap.get(parameterName);
  }
  public void setParameter(String parameterName, Object parameter) {
    myParametersMap.put(parameterName, parameter);
  }
  public void setParameters(List<Object> names, List<Object> parameters) {
    {
      Iterator<Object> name_it = ListSequence.fromList(names).iterator();
      Iterator<Object> param_it = ListSequence.fromList(parameters).iterator();
      Object name_var;
      Object param_var;
      while (name_it.hasNext() && param_it.hasNext()) {
        name_var = name_it.next();
        param_var = param_it.next();
        setParameter((String) name_var, param_var);
      }
    }
  }
  public void clearParameters() {
    myParametersMap.clear();
  }
  @Nullable
  public UsagesList getUsages() {
    return myUsages;
  }
  public void setUsages(UsagesList usages) {
    myUsages = usages;
  }
  public List<SModel> getModelsFromUsages(SModel firstModel) {
    List<SModel> result = new ArrayList<SModel>();
    if (firstModel != null) {
      result.add(firstModel);
    }
    if (myUsages != null) {
      for (SModel m : myUsages.getAffectedModels()) {
        if (m != firstModel) {
          result.add(m);
        }
      }
    }
    return result;
  }
  public SNode moveNodeToNode(SNode sourceNode, String role, SNode targetNode) {
    List<SNode> nodes = new ArrayList<SNode>();
    nodes.add(sourceNode);
    List<SNode> result = moveNodesToNode(nodes, role, targetNode);
    return result.get(0);
  }
  public List<SNode> moveNodesToNode(List<SNode> sourceNodes, String role, SNode targetNode) {
    HashMap<SNode, SNode> mapping = new HashMap<SNode, SNode>();
    List<SNode> targetNodes = CopyUtil.copy(sourceNodes, mapping);
    for (SNode node : targetNodes) {
      targetNode.addChild(role, node);
    }
    SNode oldParent = null;
    for (SNode node : sourceNodes) {
      if (oldParent == null) {
        oldParent = node.getParent();
      } else {
        assert node.getParent() == oldParent;
      }
    }
    for (SNode node : sourceNodes) {
      node.delete();
    }
    return targetNodes;
  }
  public SNode moveNodeToModel(SNode sourceNode, SModel targetModel) {
    List<SNode> nodes = new ArrayList<SNode>();
    nodes.add(sourceNode);
    List<SNode> result = moveNodesToModel(nodes, targetModel);
    return result.get(0);
  }
  public List<SNode> moveNodesToModel(List<SNode> sourceNodes, SModel targetModel) {
    if (sourceNodes.isEmpty()) {
      return new ArrayList<SNode>();
    }
    HashMap<SNode, SNode> mapping = new HashMap<SNode, SNode>();
    List<SNode> targetNodes = CopyUtil.copy(sourceNodes, mapping);
    for (SNode node : targetNodes) {
      targetModel.addRootNode(node);
    }
    for (SNode node : sourceNodes) {
      node.delete();
    }
    ModelDependencyUpdate mdu = new ModelDependencyUpdate(targetModel);
    SRepository repo = targetModel.getRepository();
    mdu.updateUsedLanguages().updateImportedModels(repo);
    if (targetModel.getModule() != null && repo != null) {
      mdu.updateModuleDependencies(repo);
    }
    return targetNodes;
  }
  public void setRefactoring(IRefactoring refactoring) {
    myRefactoring = refactoring;
  }
  public IRefactoring getRefactoring() {
    return myRefactoring;
  }
  public SNode getSelectedNode() {
    return mySelectedNode;
  }
  public void setSelectedNode(SNode selectedNode) {
    mySelectedNode = selectedNode;
  }
  public List<SNode> getSelectedNodes() {
    return new ArrayList<SNode>(mySelectedNodes);
  }
  public void setSelectedNodes(List<SNode> selectedNodes) {
    mySelectedNodes = selectedNodes;
  }
  public SModel getSelectedModel() {
    return mySelectedModel;
  }
  public void setSelectedModel(SModel selectedModel) {
    mySelectedModel = selectedModel;
  }
  public List<SModel> getSelectedModels() {
    return mySelectedModels;
  }
  public void setSelectedModels(List<SModel> selectedModels) {
    mySelectedModels = selectedModels;
  }
  public SModule getSelectedModule() {
    return mySelectedModule;
  }
  public void setSelectedModule(SModule selectedModule) {
    mySelectedModule = selectedModule;
  }
  public List<SModule> getSelectedModules() {
    return mySelectedModules;
  }
  public void setSelectedModules(List<SModule> modules) {
    mySelectedModules = modules;
  }
  public void setCurrentScope(SearchScope currentScope) {
    myCurrentScope = currentScope;
  }
  public Project getSelectedProject() {
    return myProject;
  }
  public SearchScope getCurrentScope() {
    return myCurrentScope;
  }

  /**
   * 
   * @deprecated fix reduce_OperationContextOperation and delete
   * @return always null
   */
  @Deprecated
  public Object getCurrentOperationContext() {
    return null;
  }
  private void setTarget(final Object target) {
    final IRefactoringTarget refTarget = myRefactoring.getRefactoringTarget();
    getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        if (!(refTarget.allowMultipleTargets())) {
          switch (myRefactoring.getRefactoringTarget().getTarget()) {
            case NODE:
              SNode node = ((SNode) target);
              setSelectedNode(node);
              setSelectedModel(node.getModel());
              setSelectedModule(node.getModel().getModule());

              break;
            case MODEL:
              SModel descriptor = ((SModel) target);
              setSelectedModel(descriptor);
              setSelectedModule(descriptor.getModule());
              break;
            case MODULE:
              setSelectedModule((AbstractModule) target);
              break;
            default:
              throw new IllegalArgumentException("Wrong refactoring type " + refTarget.getTarget().getClass().getName());
          }
        } else {
          switch (myRefactoring.getRefactoringTarget().getTarget()) {
            case NODE:
              setSelectedNodes((List) target);
              break;
            case MODEL:
              setSelectedModels((List) target);
              break;
            case MODULE:
              setSelectedModules((List) target);
              break;
            default:
              throw new IllegalArgumentException("Wrong refactoring type " + refTarget.getTarget().getClass().getName());
          }
        }
      }
    });
  }
  public static RefactoringContext createRefactoringContext(IRefactoring refactoring, List names, List parameters, Object target, Project project) {

    RefactoringContext result = new RefactoringContext(project, refactoring);
    result.setTarget(target);
    result.setParameters(names, parameters);
    result.setCurrentScope(project.getScope());
    return result;
  }
  public static RefactoringContext createRefactoringContextByName(final String refName, List names, List parameters, Object target, Project project) {
    final Wrappers._T<IRefactoring> refactoring = new Wrappers._T<IRefactoring>();
    project.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        refactoring.value = RefactoringUtil.getRefactoringByClassName(refName);
      }
    });
    return createRefactoringContext(refactoring.value, names, parameters, target, project);
  }
}
