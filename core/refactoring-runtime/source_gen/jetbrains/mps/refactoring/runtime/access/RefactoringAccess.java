package jetbrains.mps.refactoring.runtime.access;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import jetbrains.mps.refactoring.framework.IRefactoring;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.refactoring.framework.IRefactoringTarget;
import java.util.List;
import java.util.Arrays;
import jetbrains.mps.refactoring.framework.RefactoringUtil;
import java.util.Collection;

public abstract class RefactoringAccess {
  protected static RefactoringAccess ourInstance;

  protected RefactoringAccess() {
  }

  public abstract RefactoringFacade getRefactoringFacade();

  @Nullable
  public IRefactoring getRefactoringByClassName(String className) {
    for (IRefactoring r : getAllRefactorings()) {
      Class refClass = r.getClass();
      if (refClass.getName().equals(className)) {
        return r;
      }
    }
    return null;
  }

  /**
   * NPE-safe shorthand for {@code isApplicable(getRefactoringByClassName(refactoringClassName), target)}
   */
  public boolean isApplicable(@NotNull String refactoringClassName, Object target) {
    IRefactoring r = getRefactoringByClassName(refactoringClassName);
    if (r == null) {
      return false;
    }
    return isApplicable(r, target);
  }

  public boolean isApplicable(@NotNull IRefactoring refactoring, Object target) {
    IRefactoringTarget refTarget = refactoring.getRefactoringTarget();
    boolean oneEntity = !(refTarget.allowMultipleTargets());
    List targetList;
    if (!(oneEntity)) {
      // FIXME ORLY?! cast of an argument? CCE in case caller made a mistake? 
      targetList = (List) target;
    } else {
      targetList = Arrays.asList(target);
    }

    boolean disabled = (targetList.isEmpty() || RefactoringUtil.getApplicability(refactoring, targetList).lessThan(RefactoringUtil.Applicability.APPLICABLE));
    return !(disabled);
  }

  /**
   * IMPORTANT: DON'T USE THIS METHOD, ITS VISIBILITY WILL CHANGE TO protected.
   * IT'S PROVISIONALLY PUBLIC FOR MIGRATION PURPOSES ONLY. Once RefactoringUtil is history (past 2018.2), we expect no clients 
   * to access collection of all available refactorings. If this is wrong, please file an issue.
   */
  public abstract Collection<IRefactoring> getAllRefactorings();

  public static RefactoringAccess getInstance() {
    return ourInstance;
  }

  protected static void setInstance(RefactoringAccess instance) {
    ourInstance = instance;
  }
}
