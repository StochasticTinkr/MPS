package jetbrains.mps.refactoring.participant;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import java.util.Objects;
import java.util.List;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IRightCombinator;
import jetbrains.mps.ide.findusages.model.SearchResults;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.ArrayList;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public interface RefactoringParticipant<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> {

  interface RefactoringDataCollector<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> {
    /**
     * 
     * @return null => participant ignores the node
     */
    @Nullable
    InitialDataObject beforeMove(InitialPoint nodeToMove);
    /**
     * 
     * @return null if there is no data to save
     */
    @Nullable
    FinalDataObject afterMove(FinalPoint movedNode);
  }

  RefactoringParticipant.RefactoringDataCollector<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> getDataCollector();

  class Option {
    private String myId;
    private String myDescription;
    public Option(String id, String description) {
      myId = id;
      myDescription = description;
    }
    public String getId() {
      return myId;
    }
    public String getDescription() {
      return myDescription;
    }
    public int hashCode() {
      return myId.hashCode();
    }
    public boolean equals(Object object) {
      return object instanceof RefactoringParticipant.Option && Objects.equals(((RefactoringParticipant.Option) object).getId(), this.getId());
    }
  }

  List<RefactoringParticipant.Option> getAvailableOptions(List<InitialDataObject> initialStates, SRepository repository);

  List<List<RefactoringParticipant.Change<InitialDataObject, FinalDataObject>>> getChanges(@NonNls List<InitialDataObject> initialStates, SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor);

  /**
   * POSTPONE_REMOVE is a hack used only in idea plugin
   */
  enum KeepOldNodes implements Comparable<RefactoringParticipant.KeepOldNodes> {
    REMOVE(),
    POSTPONE_REMOVE(),
    KEEP();

    public static RefactoringParticipant.KeepOldNodes max(Iterable<RefactoringParticipant.KeepOldNodes> values) {
      return Sequence.fromIterable(values).foldRight(RefactoringParticipant.KeepOldNodes.REMOVE, new IRightCombinator<RefactoringParticipant.KeepOldNodes, RefactoringParticipant.KeepOldNodes>() {
        public RefactoringParticipant.KeepOldNodes combine(RefactoringParticipant.KeepOldNodes it, RefactoringParticipant.KeepOldNodes s) {
          return (((Comparable<RefactoringParticipant.KeepOldNodes>) s).compareTo(it) > 0 ? s : it);
        }
      });
    }
  }

  interface Change<InitialDataObject, FinalDataObject> {
    SearchResults getSearchResults();
    void confirm(FinalDataObject finalState, SRepository repository, RefactoringSession refactoringSession);
  }

  interface PersistentRefactoringParticipant<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> extends RefactoringParticipant<InitialDataObject, FinalDataObject, InitialPoint, FinalPoint> {
    String getId();
    SNode serializeInitialState(InitialDataObject initialState);
    InitialDataObject deserializeInitialState(SNode serialized);
    SNode serializeFinalState(FinalDataObject finalState);
    FinalDataObject deserializeFinalState(SNode serialized);
  }

  abstract class ParticipantStateFactory<IP, FP, IS, FS> {
    public abstract <I, F> I getInitial(RefactoringParticipant<I, F, IP, FP> participant, IS oldNode);
    public abstract <I, F> F getFinal(RefactoringParticipant<I, F, IP, FP> participant, FS newNode);
  }

  class CollectingParticipantStateFactory<IP, FP> extends RefactoringParticipant.ParticipantStateFactory<IP, FP, IP, FP> {
    public <I, F> I getInitial(RefactoringParticipant<I, F, IP, FP> participant, IP oldNode) {
      return participant.getDataCollector().beforeMove(oldNode);
    }
    public <I, F> F getFinal(RefactoringParticipant<I, F, IP, FP> participant, FP oldNode) {
      return participant.getDataCollector().afterMove(oldNode);
    }
  }

  class DeserializingParticipantStateFactory<IP, FP> extends RefactoringParticipant.ParticipantStateFactory<IP, FP, SNode, SNode> {
    public <I, F> I getInitial(RefactoringParticipant<I, F, IP, FP> participant, SNode serializedInitial) {
      return ((RefactoringParticipant.PersistentRefactoringParticipant<I, F, IP, FP>) participant).deserializeInitialState(serializedInitial);
    }
    public <I, F> F getFinal(RefactoringParticipant<I, F, IP, FP> participant, SNode serializedFinal) {
      return ((RefactoringParticipant.PersistentRefactoringParticipant<I, F, IP, FP>) participant).deserializeFinalState(serializedFinal);
    }
  }

  class ParticipantApplied<I, F, IP, FP, IS, FS> {
    private RefactoringParticipant<I, F, IP, FP> myParticipant;
    private List<I> myInitialStates;
    private List<List<RefactoringParticipant.Change<I, F>>> changes;
    public List<List<RefactoringParticipant.Change<I, F>>> getChanges() {
      return changes;
    }
    public RefactoringParticipant<I, F, IP, FP> getParticipant() {
      return myParticipant;
    }
    public List<I> getInitialStates() {
      return myInitialStates;
    }
    public static <I, F, IP, FP, IS, FS> RefactoringParticipant.ParticipantApplied<I, F, IP, FP, IS, FS> create(RefactoringParticipant.ParticipantStateFactory<IP, FP, IS, FS> factory, RefactoringParticipant<I, F, IP, FP> participant, List<IS> oldNodes) {
      return new RefactoringParticipant.ParticipantApplied<I, F, IP, FP, IS, FS>(factory, participant, oldNodes);
    }
    public ParticipantApplied(final RefactoringParticipant.ParticipantStateFactory<IP, FP, IS, FS> factory, final RefactoringParticipant<I, F, IP, FP> participant, List<IS> oldNodes) {
      this.myParticipant = participant;
      myInitialStates = ListSequence.fromList(oldNodes).select(new ISelector<IS, I>() {
        public I select(IS it) {
          return factory.getInitial(participant, it);
        }
      }).toListSequence();
    }
    public List<RefactoringParticipant.Option> getAvaliableOptions(SRepository repository) {
      return myParticipant.getAvailableOptions(ListSequence.fromList(myInitialStates).where(new IWhereFilter<I>() {
        public boolean accept(I it) {
          return it != null;
        }
      }).toListSequence(), repository);
    }
    public List<List<RefactoringParticipant.Change<I, F>>> findChanges(SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor) {
      return changes = initChanges(repository, selectedOptions, searchScope, progressMonitor);
    }
    protected <T, S> List<S> mapNotNull(List<T> arguments, _FunctionTypes._return_P1_E0<? extends List<S>, ? super List<T>> notNullMapFunc) {
      List<S> filteredResult = notNullMapFunc.invoke(ListSequence.fromList(arguments).where(new IWhereFilter<T>() {
        public boolean accept(T it) {
          return it != null;
        }
      }).toListSequence());
      List<S> result = ListSequence.fromList(new ArrayList<S>(ListSequence.fromList(arguments).count()));
      int j = 0;
      for (T v : arguments) {
        ListSequence.fromList(result).addElement((v == null ? null : ListSequence.fromList(filteredResult).getElement(j++)));
      }
      return result;
    }
    protected List<List<RefactoringParticipant.Change<I, F>>> initChanges(final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope, final ProgressMonitor progressMonitor) {
      return mapNotNull(myInitialStates, new _FunctionTypes._return_P1_E0<List<List<RefactoringParticipant.Change<I, F>>>, List<I>>() {
        public List<List<RefactoringParticipant.Change<I, F>>> invoke(List<I> initialStates) {
          return myParticipant.getChanges(initialStates, repository, selectedOptions, searchScope, progressMonitor);
        }
      });
    }
    public void doRefactor(List<FS> newNodes, final SRepository repository, final RefactoringSession session, RefactoringParticipant.ParticipantStateFactory<IP, FP, IS, FS> factory) {
      {
        Iterator<List<RefactoringParticipant.Change<I, F>>> nodeChanges_it = ListSequence.fromList(this.changes).iterator();
        Iterator<FS> newNode_it = ListSequence.fromList(newNodes).iterator();
        List<RefactoringParticipant.Change<I, F>> nodeChanges_var;
        FS newNode_var;
        while (nodeChanges_it.hasNext() && newNode_it.hasNext()) {
          nodeChanges_var = nodeChanges_it.next();
          newNode_var = newNode_it.next();
          final F finalState = factory.getFinal(myParticipant, newNode_var);
          ListSequence.fromList(nodeChanges_var).visitAll(new IVisitor<RefactoringParticipant.Change<I, F>>() {
            public void visit(RefactoringParticipant.Change<I, F> it) {
              it.confirm(finalState, repository, session);
            }
          });
        }
      }
    }
  }


}
