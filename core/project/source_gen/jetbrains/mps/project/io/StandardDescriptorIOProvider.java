package jetbrains.mps.project.io;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.util.MacroHelper;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.project.structure.modules.LanguageDescriptor;
import jetbrains.mps.project.structure.modules.DevkitDescriptor;
import jetbrains.mps.vfs.IFile;
import org.jdom.Document;
import jetbrains.mps.util.JDOMUtil;
import org.jdom.Element;
import jetbrains.mps.project.persistence.SolutionDescriptorPersistence;
import jetbrains.mps.project.persistence.ModuleReadException;
import jetbrains.mps.project.persistence.ModuleDescriptorPersistence;
import org.apache.log4j.Level;
import jetbrains.mps.project.persistence.LanguageDescriptorPersistence;
import jetbrains.mps.project.structure.modules.GeneratorDescriptor;
import java.io.IOException;
import jetbrains.mps.project.persistence.DevkitDescriptorPersistence;

/*package*/ class StandardDescriptorIOProvider implements DescriptorIOProvider {
  private static final Logger LOG = LogManager.getLogger(StandardDescriptorIOProvider.class);
  private final MacroHelper.Source myMacroHelperSource;
  private final MacroHelper myMacroHelperSingleton;

  /*package*/ StandardDescriptorIOProvider(MacroHelper.Source macroHelperSource) {
    myMacroHelperSource = macroHelperSource;
    myMacroHelperSingleton = null;
  }

  /*package*/ StandardDescriptorIOProvider(MacroHelper macroHelperSingleton) {
    myMacroHelperSource = null;
    myMacroHelperSingleton = macroHelperSingleton;
  }

  @Override
  public DescriptorIO<SolutionDescriptor> solutionDescriptorIO() {
    return new StandardDescriptorIOProvider.SolutionDescriptorIO();
  }
  @Override
  public DescriptorIO<LanguageDescriptor> languageDescriptorIO() {
    return new StandardDescriptorIOProvider.LanguageDescriptorIO();
  }
  @Override
  public DescriptorIO<DevkitDescriptor> devkitDescriptorIO() {
    return new StandardDescriptorIOProvider.DevkitDescriptorIO();
  }

  /*package*/ MacroHelper forModuleFile(IFile file) {
    return (myMacroHelperSingleton != null ? myMacroHelperSingleton : myMacroHelperSource.moduleFile(file));
  }

  /*package*/ class SolutionDescriptorIO implements DescriptorIO<SolutionDescriptor> {
    public SolutionDescriptorIO() {
    }
    @Override
    public SolutionDescriptor readFromFile(IFile file) throws DescriptorIOException {
      SolutionDescriptor descriptor;
      try {
        MacroHelper macroHelper = forModuleFile(file);
        Document document = JDOMUtil.loadDocument(file);
        Element rootElement = document.getRootElement();
        descriptor = new SolutionDescriptorPersistence(macroHelper).load(rootElement);
      } catch (Exception ex) {
        descriptor = new SolutionDescriptor();
        ModuleReadException mre = (ex instanceof ModuleReadException ? ((ModuleReadException) ex) : new ModuleReadException(ex));
        ModuleDescriptorPersistence.loadBrokenModule(descriptor, file, mre);
      }
      ModuleDescriptorPersistence.setTimestamp(descriptor, file);
      return descriptor;
    }

    @Override
    public void writeToFile(SolutionDescriptor sd, IFile file) {
      if (file.isReadOnly()) {
        // XXX why on earth do we check for read-only here? why not in a caller code, where one could have reacted reasonably? 
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Can't save " + file.getPath());
        }
        return;
      }

      try {
        MacroHelper macroHelper = forModuleFile(file);
        Element result = new SolutionDescriptorPersistence(macroHelper).save(sd);
        JDOMUtil.writeDocument(new Document(result), file);
      } catch (Exception e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Failed to serialize solution descriptor", e);
        }
      }

      ModuleDescriptorPersistence.setTimestamp(sd, file);
    }
    @Override
    public void writeToXml(SolutionDescriptor sd, Element element, IFile anchorFile) {
      throw new UnsupportedOperationException();
    }
    @Override
    public SolutionDescriptor readFromXml(Element element, IFile anchorFile) {
      throw new UnsupportedOperationException();
    }
  }

  /*package*/ class LanguageDescriptorIO implements DescriptorIO<LanguageDescriptor> {
    public LanguageDescriptorIO() {
    }
    @Override
    public LanguageDescriptor readFromFile(IFile file) throws DescriptorIOException {
      LanguageDescriptor descriptor;

      try {
        MacroHelper macroHelper = forModuleFile(file);
        Document document = JDOMUtil.loadDocument(file);
        Element languageElement = document.getRootElement();
        descriptor = new LanguageDescriptorPersistence(macroHelper).load(languageElement);
      } catch (Exception ex) {
        descriptor = new LanguageDescriptor();
        ModuleReadException mre = (ex instanceof ModuleReadException ? ((ModuleReadException) ex) : new ModuleReadException(ex));
        ModuleDescriptorPersistence.loadBrokenModule(descriptor, file, mre);
      }

      ModuleDescriptorPersistence.setTimestamp(descriptor, file);
      for (GeneratorDescriptor gd : descriptor.getGenerators()) {
        ModuleDescriptorPersistence.setTimestamp(gd, file);
      }

      return descriptor;
    }

    @Override
    public void writeToFile(LanguageDescriptor ld, IFile file) {
      if (file.isReadOnly()) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Cant't save " + file.getPath());
        }
        return;
      }
      try {
        MacroHelper macroHelper = forModuleFile(file);
        Element element = new LanguageDescriptorPersistence(macroHelper).save(ld);
        Document doc = new Document(element);
        JDOMUtil.writeDocument(doc, file);
        // XXX is it always a need to refresh timestamp in the descriptor? What if serialize it into a copy file 
        ModuleDescriptorPersistence.setTimestamp(ld, file);
      } catch (IOException ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Failed to serialize language descriptor", ex);
        }
      }
    }

    @Override
    public void writeToXml(LanguageDescriptor ld, Element element, IFile anchorFile) {
      throw new UnsupportedOperationException();
    }
    @Override
    public LanguageDescriptor readFromXml(Element element, IFile anchorFile) {
      throw new UnsupportedOperationException();
    }
  }

  /*package*/ class DevkitDescriptorIO implements DescriptorIO<DevkitDescriptor> {
    public DevkitDescriptorIO() {
    }
    @Override
    public DevkitDescriptor readFromFile(IFile file) throws DescriptorIOException {
      DevkitDescriptor descriptor;
      try {
        Document document = JDOMUtil.loadDocument(file);
        descriptor = new DevkitDescriptorPersistence().load(document.getRootElement());
      } catch (Exception ex) {
        descriptor = new DevkitDescriptor();
        ModuleReadException mre = (ex instanceof ModuleReadException ? ((ModuleReadException) ex) : new ModuleReadException(ex));
        ModuleDescriptorPersistence.loadBrokenModule(descriptor, file, mre);
      }

      ModuleDescriptorPersistence.setTimestamp(descriptor, file);
      return descriptor;
    }

    @Override
    public void writeToFile(DevkitDescriptor dd, IFile file) {
      try {
        Element root = new DevkitDescriptorPersistence().save(dd);
        JDOMUtil.writeDocument(new Document(root), file);
      } catch (Exception e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Failed to serialize devkit descriptor", e);
        }
      }
      ModuleDescriptorPersistence.setTimestamp(dd, file);

    }

    @Override
    public DevkitDescriptor readFromXml(Element element, IFile anchorFile) {
      throw new UnsupportedOperationException();
    }
    @Override
    public void writeToXml(DevkitDescriptor t, Element element, IFile anchorFile) {
      throw new UnsupportedOperationException();
    }
  }
}
