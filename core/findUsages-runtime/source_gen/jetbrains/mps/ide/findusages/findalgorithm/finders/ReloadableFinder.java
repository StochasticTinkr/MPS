package jetbrains.mps.ide.findusages.findalgorithm.finders;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.ide.findusages.FindersManager;
import jetbrains.mps.ide.findusages.model.SearchResults;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import org.jetbrains.mps.openapi.util.ProgressMonitor;

/**
 * Clients need to persist informations about finders active at some point back in time (e.g. Usages View).
 * To accomplish that, we identify finders with a string (finder implementation class fqn, in fact, although we don't load
 * classes using it. It's very important to understand the difference). This class knows how to get back to genertated finder from
 * this identity string and is a finder proxy, per se.
 */
public final class ReloadableFinder extends BaseFinder {
  private final String myFinderIdentity;

  public ReloadableFinder(@NotNull String finderClass) {
    myFinderIdentity = finderClass;
  }

  public ReloadableFinder(GeneratedFinder finder) {
    myFinderIdentity = finder.getClass().getName();
  }

  @NotNull
  public String getPersistenceIdentity() {
    return myFinderIdentity;
  }

  private IInterfacedFinder getFinder() {
    return FindersManager.getInstance().getFinder(myFinderIdentity);
  }
  @Override
  public String getDescription() {
    IInterfacedFinder finder = getFinder();
    return (finder == null ? super.getDescription() : finder.getDescription());
  }

  @Override
  public SearchResults<SNode> find(SearchQuery query, ProgressMonitor monitor) {
    IInterfacedFinder finder = getFinder();
    if (finder == null) {
      return new SearchResults();
    }
    return finder.find(query, monitor);
  }
}
