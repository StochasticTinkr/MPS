package jetbrains.mps.ide.findusages.model;

/*Generated by MPS */

import jetbrains.mps.findUsages.UsagesList;
import java.util.Set;
import java.util.List;
import java.util.HashSet;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.LinkedHashSet;
import org.jetbrains.mps.openapi.model.SNode;

public class SearchResults<T> implements UsagesList {
  private final Set<Object> mySearchedNodes;
  private List<SearchResult<T>> mySearchResults;

  public SearchResults() {
    mySearchedNodes = new HashSet<Object>();
    mySearchResults = new ArrayList<SearchResult<T>>();
  }

  public SearchResults(Set<?> searchedNodes, List<SearchResult<T>> searchResults) {
    mySearchedNodes = new HashSet<Object>(searchedNodes);
    mySearchResults = searchResults;
  }

  public Set<Object> getSearchedNodes() {
    // mySearchNodes lists elements we looked for; elements our results 'derived' from. They are not necessarily of the same 
    // kind as our results, hence we use <?>, not <T> (I don't feel there's reason introduce <E> as it 
    // (a) limits where we can look; (b) complicates the code 
    return mySearchedNodes;
  }

  public List<SearchResult<T>> getSearchResults() {
    return mySearchResults;
  }

  public Set<T> getResultObjects() {
    Set<T> resultObjects = new HashSet<T>();
    for (SearchResult<T> searchResult : mySearchResults) {
      resultObjects.add(searchResult.getObject());
    }
    return resultObjects;
  }

  public void add(SearchResult<T> r) {
    mySearchResults.add(r);
  }

  public void addAll(SearchResults<T> sr) {
    mySearchedNodes.addAll(sr.mySearchedNodes);
    mySearchResults.addAll(sr.mySearchResults);
  }

  @Override
  public Set<SModel> getAffectedModels() {
    LinkedHashSet<SModel> result = new LinkedHashSet<SModel>();
    for (SearchResult searchResult : mySearchResults) {
      Object resultObject = searchResult.getObject();
      if (resultObject instanceof SNode) {
        SModel model = ((SNode) resultObject).getModel();
        if (model != null) {
          result.add(model);
        }
      } else
      if (resultObject instanceof SModel && resultObject != null) {
        result.add((SModel) resultObject);
      }
    }
    return result;
  }

  public void remove(T node) {
    for (SearchResult result : new ArrayList<SearchResult>(mySearchResults)) {
      if (result.getObject() == node) {
        mySearchResults.remove(result);
      }
    }
  }

  public void remove(SearchResult<T> searchResult) {
    mySearchResults.remove(searchResult);
  }

  public List<SearchResult<T>> getAliveResults() {
    List<SearchResult<T>> alive = new ArrayList<SearchResult<T>>();
    for (SearchResult result : mySearchResults) {
      if (result.getObject() != null) {
        alive.add(result);
      }
    }
    return alive;
  }

  public Set<?> getAliveNodes() {
    Set<Object> alive = new HashSet<Object>();
    for (Object node : mySearchedNodes) {
      if (node != null) {
        alive.add(node);
      }
    }
    return alive;
  }

  public void removeDuplicates() {
    mySearchResults = new ArrayList<SearchResult<T>>(new LinkedHashSet<SearchResult<T>>(mySearchResults));
  }
}
