package jetbrains.mps.smodel.persistence.def;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModelReference;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SModel;
import org.apache.log4j.Level;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.runtime.ConceptKind;
import jetbrains.mps.smodel.runtime.StaticScope;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class ReadHelper {
  private static final Logger LOG = LogManager.getLogger(ReadHelper.class);
  private static final char MODEL_SEPARATOR_CHAR = '.';
  private static final String DYNAMIC_REFERENCE_ID = "^";

  private SModelReference myModelRef;
  private Map<String, SModelReference> myModelByIx;
  private int myMaxImportIndex = 0;
  public ReadHelper(SModelReference modelRef) {
    myModelByIx = MapSequence.fromMap(new HashMap<String, SModelReference>());
    myModelRef = modelRef;
  }
  public void addModelRef(String index, SModelReference modelRef) {
    MapSequence.fromMap(myModelByIx).put(index, modelRef);
  }
  public void addImportToModel(SModel model, String index, String modelUID, int version, boolean implicit) {
    if (modelUID == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Error loading import element for index " + index + " in " + myModelRef);
      }
      return;
    }
    SModelReference modelRef = PersistenceFacade.getInstance().createModelReference(modelUID);
    SModel.ImportElement elem = new SModel.ImportElement(modelRef, ++myMaxImportIndex, version);
    if (implicit) {
      model.getImplicitImportsSupport().addAdditionalModelVersion(elem);
    } else {
      model.addModelImport(elem);
    }
    addModelRef(index, modelRef);
  }
  public SModelReference getSModelReference(@NotNull String ix) {
    return ((ix == null || ix.length() == 0) ? myModelRef : MapSequence.fromMap(myModelByIx).get(ix));
  }
  @NotNull
  public Pair<Boolean, SNodeReference> readLink_internal(String src) {
    // returns <true, xxx> - if src is Dynamic Reference 
    // [modelID.]nodeID | [modelID.]^ 
    Pair<Boolean, SNodeReference> result = new Pair<Boolean, SNodeReference>(false, null);
    if (src == null) {
      return result;
    }
    int dotIndex = src.indexOf(MODEL_SEPARATOR_CHAR);
    String text = decode(src.substring(dotIndex + 1, src.length()));
    result.o1 = DYNAMIC_REFERENCE_ID.equals(text);
    SModelReference modelRef = getSModelReference((dotIndex < 0 ? "" : src.substring(0, dotIndex)));
    SNodeId nodeId = (result.o1 ? null : jetbrains.mps.smodel.SNodeId.fromString(text));
    result.o2 = new SNodePointer(modelRef, nodeId);
    return result;
  }
  public SNodeReference readLinkId(String src) {
    // [modelID.]nodeID[:version] | [modelID.]^[:version] 
    return readLink_internal(src).o2;
  }
  public boolean isInterfaceNode(String nodeInfo) {
    return nodeInfo.startsWith("i");
  }
  public boolean isImplementationNode(String nodeInfo) {
    return nodeInfo != null && (nodeInfo.startsWith("l") || nodeInfo.startsWith("s"));
  }
  public boolean isImplementationWithStubNode(String nodeInfo) {
    return nodeInfo != null && nodeInfo.startsWith("s");
  }
  public String getStubConceptQualifiedName(String type) {
    String originalConcept = readType(type);
    int lastDot = originalConcept.lastIndexOf('.');
    if (lastDot == -1) {
      return null;
    }
    return originalConcept.substring(0, lastDot + 1) + "Stub" + originalConcept.substring(lastDot + 1);
  }
  public Tuples._3<ConceptKind, StaticScope, Boolean> readNodeInfo(String s) {
    ConceptKind kind;
    StaticScope scope;
    if (s.length() != 3 && s.length() != 2) {
      return null;
    }
    switch (s.charAt(0)) {
      case 'n':
        kind = ConceptKind.NORMAL;
        break;
      case 'i':
        kind = ConceptKind.INTERFACE;
        break;
      case 'l':
        kind = ConceptKind.IMPLEMENTATION;
        break;
      case 's':
        kind = ConceptKind.IMPLEMENTATION_WITH_STUB;
        break;
      default:
        return null;
    }
    switch (s.charAt(1)) {
      case 'g':
        scope = StaticScope.GLOBAL;
        break;
      case 'r':
        scope = StaticScope.ROOT;
        break;
      case 'n':
        scope = StaticScope.NONE;
        break;
      default:
        return null;
    }
    boolean unordered = false;
    if (s.length() == 3) {
      if (s.charAt(2) == 'u') {
        unordered = true;
      } else {
        return null;
      }
    }
    return MultiTuple.<ConceptKind,StaticScope,Boolean>from(kind, scope, unordered);
  }
  public String readType(String s) {
    int ix = s.indexOf(MODEL_SEPARATOR_CHAR);
    if (ix <= 0) {
      // no model ID - fqName is here 
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Broken reference to type=" + s + " in model " + myModelRef);
      }
      return s.substring(ix + 1);
    }
    SModelReference modelRef = getSModelReference(s.substring(0, ix));
    if (modelRef == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("couldn't create node '" + s.substring(ix + 1) + "' : import for index [" + s.substring(0, ix) + "] not found");
      }
      return s.substring(ix + 1);
    } else {
      return modelRef.getName().getLongName() + '.' + s.substring(ix + 1);
    }
  }
  public String readRole(String s) {
    return s;
  }
  public String readName(String s) {
    return s;
  }
  public static String decode(String s) {
    return s.replace("%d", ".").replace("%c", ":").replace("%p", "%");
  }
}
