package jetbrains.mps.tool.common;

/*Generated by MPS */

import java.nio.charset.Charset;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jdom.Document;
import java.io.File;
import org.jdom.JDOMException;
import java.io.IOException;
import org.jdom.input.SAXBuilder;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import java.io.CharArrayReader;
import java.io.OutputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import org.jdom.output.XMLOutputter;
import org.jdom.output.Format;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class JDOMUtil {
  public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
  private static final Logger LOG = LogManager.getLogger(JDOMUtil.class);
  public JDOMUtil() {
  }
  public static Document loadDocument(File file) throws JDOMException, IOException {
    SAXBuilder saxBuilder = createBuilder();
    FileInputStream in = new FileInputStream(file);
    try {
      return saxBuilder.build(new InputStreamReader(in, DEFAULT_CHARSET));
    } catch (JDOMException e) {
      LOG.error("FAILED TO LOAD FILE : " + file.getAbsolutePath());
      throw e;
    } catch (IOException e) {
      LOG.error("FAILED TO LOAD FILE : " + file.getAbsolutePath());
      throw e;
    } finally {
      in.close();
    }
  }
  public static SAXBuilder createBuilder() {
    final SAXBuilder saxBuilder = new SAXBuilder();
    saxBuilder.setEntityResolver(new EntityResolver() {
      @Override
      public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
        return new InputSource(new CharArrayReader(new char[0]));
      }
    });
    return saxBuilder;
  }
  public static void writeDocument(Document document, File file) throws IOException {
    if (!(file.getParentFile().exists())) {
      file.getParentFile().mkdirs();
    }
    if (!(file.exists())) {
      file.createNewFile();
    }
    OutputStream stream = new BufferedOutputStream(new FileOutputStream(file));
    try {
      writeDocument(document, stream);
    } finally {
      stream.close();
    }
  }
  public static void writeDocument(Document document, OutputStream stream) throws IOException {
    writeDocument(document, new OutputStreamWriter(stream, DEFAULT_CHARSET));
  }
  public static void writeDocument(Document document, Writer writer) throws IOException {
    XMLOutputter xmlOutputter = createOutputter();
    if (xmlOutputter == null) {
      LOG.error("Could not create XMLOutputter");
    } else
    if (document == null) {
      LOG.error("Document is null");
    } else
    if (writer == null) {
      LOG.error("Writer is null");
      return;
    } else {
      xmlOutputter.output(document, writer);
    }
    writer.close();
  }
  public static XMLOutputter createOutputter() {
    XMLOutputter xmlOutputter = new JDOMUtil.MyXMLOutputter();
    xmlOutputter.setFormat(Format.getPrettyFormat().setLineSeparator(System.getProperty("line.separator")));
    return xmlOutputter;
  }
  public static class MyXMLOutputter extends XMLOutputter {
    public MyXMLOutputter() {
    }
    @Override
    public String escapeAttributeEntities(String str) {
      return escapeText(str, false, true);
    }
    @Override
    public String escapeElementEntities(String str) {
      return escapeText(str, false, false);
    }
  }
  @NotNull
  public static String escapeText(String text, boolean escapeSpaces, boolean escapeLineEnds) {
    return escapeText(text, false, escapeSpaces, escapeLineEnds);
  }
  @NotNull
  public static String escapeText(String text, boolean escapeApostrophes, boolean escapeSpaces, boolean escapeLineEnds) {
    StringBuilder buffer = null;
    for (int i = 0; i < text.length(); i++) {
      final char ch = text.charAt(i);
      final String quotation = escapeChar(ch, escapeApostrophes, escapeSpaces, escapeLineEnds);
      if (buffer == null) {
        if (quotation != null) {
          //  An quotation occurred, so we'll have to use StringBuilder 
          //  (allocate room for it plus a few more entities). 
          buffer = new StringBuilder(text.length() + 20);
          //  Copy previous skipped characters and fall through 
          //  to pickup current character 
          buffer.append(text.substring(0, i));
          buffer.append(quotation);
        }
      } else {
        if (quotation == null) {
          buffer.append(ch);
        } else {
          buffer.append(quotation);
        }
      }
    }
    //  If there were any entities, return the escaped characters 
    //  that we put in the StringBuilder. Otherwise, just return 
    //  the unmodified input string. 
    return (buffer == null ? text : buffer.toString());
  }
  /**
   * * Returns null if no escapement necessary.
   */
  @Nullable
  private static String escapeChar(char c, boolean escapeApostrophes, boolean escapeSpaces, boolean escapeLineEnds) {
    switch (c) {
      case '\n':
        return (escapeLineEnds ? "&#10;" : null);
      case '\r':
        return (escapeLineEnds ? "&#13;" : null);
      case '\t':
        return (escapeLineEnds ? "&#9;" : null);
      case ' ':
        return (escapeSpaces ? "&#20" : null);
      case '<':
        return "&lt;";
      case '>':
        return "&gt;";
      case '\"':
        return "&quot;";
      case '\'':
        return (escapeApostrophes ? "&apos;" : null);
      case '&':
        return "&amp;";
      default:
    }
    return null;
  }
  public static String unescapeText(@NotNull String text) {
    StringBuilder buffer = null;
    for (int i = 0; i < text.length(); i++) {
      final char ch = text.charAt(i);
      String quotation = null;
      int start = i;
      if (ch == '&') {
        int semicolon = text.indexOf(';', start + 1);
        if (semicolon > 0) {
          String val = text.substring(start + 1, semicolon);
          if (val.startsWith("#")) {
            try {
              int value;
              if (val.length() > 2 && (val.charAt(1) == 'x' || val.charAt(1) == 'X')) {
                value = Integer.parseInt(val.substring(2), 16);
              } else {
                value = Integer.parseInt(val.substring(1), 10);
              }
              if (value >= 0 && value < 65535) {
                quotation = Character.toString((char) value);
              }
            } catch (NumberFormatException ex) {
              //  ignore, skip  
            }
          } else {
            if (val.length() == 2) {
              if ("lt".equals(val)) {
                quotation = "<";
              } else
              if ("gt".equals(val)) {
                quotation = ">";
              }
            } else
            if ("amp".equals(val)) {
              quotation = "&";
            } else
            if ("apos".equals(val)) {
              quotation = "'";
            } else
            if ("quot".equals(val)) {
              quotation = "\"";
            }
          }
          if (quotation != null) {
            i = semicolon;
          }
        }
      }
      if (buffer == null) {
        if (quotation != null) {
          buffer = new StringBuilder(text.length());
          //  Copy previous skipped characters and fall through 
          //  to pickup current character 
          buffer.append(text.substring(0, start));
          buffer.append(quotation);
        }
      } else {
        if (quotation == null) {
          buffer.append(ch);
        } else {
          buffer.append(quotation);
        }
      }
    }
    //  If there were any entities, return the escaped characters 
    //  that we put in the StringBuilder. Otherwise, just return 
    //  the unmodified input string. 
    return (buffer == null ? text : buffer.toString());
  }
}
