package jetbrains.mps.build.ant;

/*Generated by MPS */

import java.util.Collection;
import java.io.File;
import org.apache.tools.ant.Project;
import java.util.List;
import java.util.Collections;
import org.apache.tools.ant.BuildException;
import java.util.Set;
import java.util.LinkedHashSet;
import org.jetbrains.annotations.NotNull;
import java.net.URL;
import java.net.URLDecoder;
import java.net.MalformedURLException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;

public class MPSClasspathUtil {
  private static final String FILE = "file";
  private static final String JAR = "jar";
  private static final String JAR_DELIMITER = "!";
  private static final String PROTOCOL_DELIMITER = ":";

  /**
   * 
   * @deprecated there are no uses I'm aware of, nevertheless, gonna keep for another release (to be removed once 2019.1 is out)
   */
  @Deprecated
  public static Collection<File> buildClasspath(Project antProject, File mpsHomeArg, boolean fork) {
    antProject.log("MPSClasspathUtil.buildClasspath() is deprecated and about to cease existence, stop using it!", new Throwable(), Project.MSG_ERR);
    // XXX copy of what is in MpsLoadTask, just in (highly unlikely) case there's code that uses this method  
    List<File> classPathRoots;
    if (mpsHomeArg != null) {
      // if 
      classPathRoots = Collections.singletonList(new File(mpsHomeArg, "lib/"));
    } else {
      classPathRoots = MPSClasspathUtil.getClassPathRootsFromDependencies(antProject);
    }
    if (classPathRoots.isEmpty()) {
      throw new BuildException("Dependency on MPS build scripts is required to generate MPS modules.");

    }
    Set<File> classPath = new LinkedHashSet<File>();
    for (File file : classPathRoots) {
      MPSClasspathUtil.gatherAllClassesAndJarsUnder(file, classPath);
    }
    return classPath;
  }

  /**
   * 
   * @deprecated shall become instance method of an mps classpath utility class
   */
  @Deprecated
  public static File resolveMPSHome(Project antProject, boolean failOtherwise) {
    String mpsHomePath = antProject.getProperty("mps.home");
    if ((mpsHomePath == null || mpsHomePath.length() == 0)) {
      mpsHomePath = antProject.getProperty("mps_home");
    }
    if (mpsHomePath == null || !(antProject.resolveFile(mpsHomePath).exists())) {
      if (failOtherwise) {
        throw new BuildException("Path to mps home expected. Specify mps.home property or mpsHome attribute.");
      } else {
        return null;
      }
    }
    return antProject.resolveFile(mpsHomePath);
  }

  private static File getAntJARRelativeHome() {
    String containingJar = getAntMPSJar();
    if (!(containingJar.toLowerCase().endsWith(".jar"))) {
      throw new BuildException("cannot detect jar location: got `" + containingJar + "'");
    }
    File current = new File(containingJar);
    for (int i = 0; i < 3; i++) {
      current = current.getParentFile();
      if (current == null) {
        throw new BuildException("cannot detect jar location, no parent: got `" + containingJar + "'");
      }
      if (new File(current, "mps-core.jar").isFile()) {
        return current;
      }
    }
    throw new BuildException("cannot detect jar location, no mps-core.jar `" + containingJar + "'");
  }
  @NotNull
  private static String getAntMPSJar() {
    Class aClass = MPSClasspathUtil.class;
    return getResourceRoot(aClass, "/" + aClass.getName().replace('.', '/') + ".class");
  }
  /**
   * Attempts to detect classpath entry which contains given resource
   */
  @NotNull
  private static String getResourceRoot(Class context, String path) {
    URL url = context.getResource(path);
    if (url == null) {
      url = ClassLoader.getSystemResource(path.substring(1));
    }
    if (url == null) {
      throw new BuildException("cannot detect jar location; no resource `" + path + "'");
    }
    // try to decode non-latin characters in url (MPS-20091) 
    try {
      url = new URL(url.getProtocol(), url.getHost(), url.getPort(), URLDecoder.decode(url.getFile(), "UTF-8"));
    } catch (MalformedURLException e) {
    } catch (UnsupportedEncodingException e) {
    }
    return extractRoot(url, path);
  }
  /**
   * Attempts to extract classpath entry part from passed URL.
   */
  @NotNull
  private static String extractRoot(@NotNull URL resourceURL, String resourcePath) {
    if (!((resourcePath.startsWith("/") || resourcePath.startsWith("\\")))) {
      throw new BuildException("cannot detect jar location: precondition failed for" + resourcePath);
    }
    String protocol = resourceURL.getProtocol();
    String resultPath = null;

    if (MPSClasspathUtil.FILE.equals(protocol)) {
      String path = resourceURL.getFile();
      String testPath = path.replace('\\', '/').toLowerCase();
      String testResourcePath = resourcePath.replace('\\', '/').toLowerCase();
      if (testPath.endsWith(testResourcePath)) {
        resultPath = path.substring(0, path.length() - resourcePath.length());
      }
    } else
    if (MPSClasspathUtil.JAR.equals(protocol)) {
      String fullPath = resourceURL.getFile();
      int delimiter = fullPath.indexOf(MPSClasspathUtil.JAR_DELIMITER);
      if (delimiter >= 0) {
        String archivePath = fullPath.substring(0, delimiter);
        if (archivePath.startsWith(MPSClasspathUtil.FILE + MPSClasspathUtil.PROTOCOL_DELIMITER)) {
          resultPath = archivePath.substring(MPSClasspathUtil.FILE.length() + MPSClasspathUtil.PROTOCOL_DELIMITER.length());
        }
      }
    }
    if (resultPath == null) {
      throw new BuildException("cannot detect jar location: url=`" + resourceURL.toString() + "'");
    }

    if (resultPath.endsWith(File.separator)) {
      resultPath = resultPath.substring(0, resultPath.length() - 1);
    }

    return replace(resultPath, "%20", " ");
  }
  @NotNull
  private static String replace(@NotNull String text, @NotNull String from, @NotNull String to) {
    final StringBuilder result = new StringBuilder(text.length());
    final int len = from.length();
    for (int i = 0; i < text.length(); i++) {
      if (text.regionMatches(i, from, 0, len)) {
        result.append(to);
        i += len - 1;
        continue;
      }
      result.append(text.charAt(i));
    }
    return result.toString();
  }

  public static List<File> getClassPathRootsFromDependencies(Project project) {
    List<File> roots = new ArrayList<File>();

    String mpsHome = project.getProperty("artifacts.mps");
    String pluginHome = project.getProperty("artifacts.mpsPlugin");
    String ideaHome = project.getProperty("artifacts.IDEA");
    String mpsCoreHome = project.getProperty("artifacts.mpsBootstrapCore");
    String mpsWorkbenchHome = project.getProperty("artifacts.mpsWorkbench");

    if ((mpsHome != null && mpsHome.length() > 0)) {
      // we've got regular MPS installation and everything we need is under its "lib/" folder, both IDEA platform and MPS stuff (including lib/ext) 
      roots.add(new File(project.resolveFile(mpsHome).getPath(), "lib"));
    } else if ((pluginHome != null && pluginHome.length() > 0) && (ideaHome != null && ideaHome.length() > 0)) {
      // buildPlugin + IDEA 
      // XXX not sure if it's possible to build with an MPS-generated script having just an MPS-IDEA plugin, but anyway... 
      roots.add(new File(project.resolveFile(ideaHome).getPath(), "lib"));
      roots.add(new File(project.resolveFile(pluginHome).getPath(), "mps-core/lib"));
    } else if ((mpsCoreHome != null && mpsCoreHome.length() > 0) && (ideaHome != null && ideaHome.length() > 0)) {
      // we are building something with dependency to mpsBootstrapCore, likely part of MPS itself. 
      // There's IDEA installation we use, and we shall reference MPS-built artifacts 
      roots.add(new File(project.resolveFile(mpsCoreHome).getPath(), "lib"));
      roots.add(new File(project.resolveFile(ideaHome).getPath(), "lib"));
      if ((mpsWorkbenchHome != null && mpsWorkbenchHome.length() > 0)) {
        roots.add(new File(project.resolveFile(mpsWorkbenchHome).getPath(), "lib"));
      }
    } else if ((ideaHome != null && ideaHome.length() > 0) && "mpsBootstrapCore".equals(project.getName())) {
      // bootstrap hack. mpsBootstrapCore uses ant tasks defines in the jars it is about to compile/assemble. 
      // In particular, it's copyModels in <assemble> task that needs to start MPS in-process at PERSISTENCE level. 
      roots.add(new File(project.resolveFile(ideaHome).getPath(), "lib"));
      // FIXME here, we assume weave_Tasks jars respective core classes under antTasks/ as it used to do. However, 
      // FIXME I intend to change this so that there's no need to have custom handling both in mpsBootstrapCore.xml and here 
      roots.add(getAntJARRelativeHome());
    }

    return roots;
  }


  /**
   * 
   * @deprecated about to reduce visibility to package or to become an instance method of an mps classpath utility class
   */
  @Deprecated
  public static void gatherAllClassesAndJarsUnder(File dir, Set<File> result) {
    if (dir.getName().equals("classes") || dir.getName().equals("classes_gen") || dir.getName().equals("apiclasses")) {
      result.add(dir);
      return;
    }
    File[] children = dir.listFiles();
    //  we do not want trove different from ours in $mps.home$/lib 
    String troveJar = "trove" + File.separator + "lib" + File.separator + "trove";
    //  to provide right order of class loading, 
    //  files go first 
    for (File f : children) {
      if (!(f.isDirectory())) {
        if (f.getName().endsWith(".jar") && !(f.getName().contains("ant.jar")) && !(f.getPath().contains(troveJar))) {
          result.add(f);
        }
      }
    }
    for (File f : children) {
      if (f.isDirectory()) {
        // FIXME why on earth this if is here and is different from the one at the start of the method?! 
        if (f.getName().equals("classes") || f.getName().equals("classes_gen")) {
          result.add(f);
        } else {
          gatherAllClassesAndJarsUnder(f, result);
        }
      }
    }
  }
}
