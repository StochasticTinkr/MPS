package jetbrains.mps.build.ant;

/*Generated by MPS */

import org.apache.tools.ant.Task;
import java.io.File;
import jetbrains.mps.tool.common.Script;
import java.util.List;
import java.util.ArrayList;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import java.util.Set;
import java.util.Hashtable;
import org.apache.tools.ant.util.JavaEnvUtils;
import java.util.HashSet;
import java.io.IOException;
import org.apache.tools.ant.taskdefs.Execute;
import java.net.URL;
import java.net.MalformedURLException;
import java.net.URLClassLoader;
import java.lang.reflect.Method;
import org.jetbrains.annotations.NotNull;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Constructor;
import org.apache.tools.ant.ProjectComponent;
import java.util.Collections;
import java.io.FileInputStream;
import java.util.LinkedHashSet;
import java.io.InputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.log4j.Level;
import java.util.Scanner;

/**
 * Ant task that is capable to execute an MPS-aware 'worker' class.
 * Generally, MPS Ant tasks have very limited classpath (j.m.tool.common and j.m.tool.ant, respectively [ant-mps] and [ant-mps-common])
 * while actual 'worker' class likely to employ full power of MPS (either with MpsEnvironment or IdeaEnvironment).
 * Hence, the idea of the task is to get worker's classpath ready to use whatever MPS functionality needed.
 */
public class MpsLoadTask extends Task {
  public static final String CONFIGURATION_NAME = "configuration.name";
  public static final String BUILD_NUMBER = "build.number";
  private File myMpsHome;
  protected final Script myWhatToDo = new Script();
  private boolean myUsePropertiesAsMacro = false;
  private boolean myFork = true;
  private String myWorkerClass;
  private final List<String> myJvmArgs = new ArrayList<String>();

  public MpsLoadTask() {
  }

  public MpsLoadTask(String workerClass) {
    myWorkerClass = workerClass;
  }

  public void setMpsHome(File mpsHome) {
    myMpsHome = mpsHome;
  }

  public File getMpsHome() {
    return myMpsHome;
  }

  public void setFailOnError(boolean failOnError) {
    myWhatToDo.updateFailOnError(failOnError);
  }

  public void setLogLevel(MpsLoadTask.LogLevelAttribute logLevel) {
    myWhatToDo.updateLogLevel(logLevel.getLevel());
  }

  public void setFork(boolean fork) {
    myFork = fork;
  }

  public void addConfiguredRepository(RepositoryDataType repo) {
    myWhatToDo.setRepoDescriptor(repo.getDescriptor());
  }

  public void addConfiguredExclude(ExcludeNested excludeInner) {
    for (File file : excludeInner.getExcludedFromDiffFiles()) {
      myWhatToDo.excludeFileFromDiff(file);
    }
  }

  public void addConfiguredMacro(Macro macro) {
    myWhatToDo.addMacro(macro.getName(), macro.getPath().getAbsolutePath());
  }

  public boolean getUsePropertiesAsMacro() {
    return myUsePropertiesAsMacro;
  }

  public void setUsePropertiesAsMacro(boolean usePropertiesAsMacro) {
    myUsePropertiesAsMacro = usePropertiesAsMacro;
  }

  public void addConfiguredJvmArg(Arg jvmArg) {
    if (!(myFork)) {
      throw new BuildException("Nested jvmarg is only allowed in fork mode.");
    }
    log("Nested jvmarg is deprecated. Use jvmargs instead.", Project.MSG_WARN);
    myJvmArgs.add(jvmArg.getValue());
  }

  public void addConfiguredJvmArgs(JvmArgs jvmArg) {
    if (!(myFork)) {
      throw new BuildException("Nested jvmargs is only allowed in fork mode.");
    }
    myJvmArgs.addAll(jvmArg.getArgs());
  }

  public final void setWorker(String workerClass) {
    myWorkerClass = workerClass;
  }

  public final String getWorker() {
    return myWorkerClass;
  }

  @Override
  public void execute() throws BuildException {
    // XXX classpath contains MPS jars, which is odd in 'fork' scenario where AntBootstrap class adds 
    // relevant MPS jars again (it also re-uses urls of the calculated classpath). Is there's any reason to do that? 
    Set<File> classPaths = calculateClassPath(myFork);
    if (myUsePropertiesAsMacro) {
      Hashtable properties = getProject().getProperties();
      for (Object name : properties.keySet()) {
        Object value = properties.get(name);
        myWhatToDo.addMacro((String) name, (String) value);
      }
    }
    if (myFork) {
      String currentClassPathString = System.getProperty("java.class.path");
      List<String> commandLine = new ArrayList<String>();
      commandLine.add(JavaEnvUtils.getJreExecutable("java"));
      if (myJvmArgs.isEmpty()) {
        commandLine.addAll(new JvmArgs().getArgs());
      } else {
        commandLine.addAll(myJvmArgs);
      }
      String javaHome = JavaEnvUtils.getJavaHome();
      StringBuilder sb = new StringBuilder();
      Set<String> entries = new HashSet<String>();
      String pathSeparator = "";
      for (String entry : currentClassPathString.split(File.pathSeparator)) {
        if (!(entries.contains(entry)) && !(startsWith(entry, javaHome))) {
          entries.add(entry);
          sb.append(pathSeparator);
          sb.append(entry);
          pathSeparator = File.pathSeparator;
        }
      }
      for (File cp : classPaths) {
        String entry = cp.getAbsolutePath();
        if (!(entries.contains(entry))) {
          entries.add(entry);
          sb.append(pathSeparator);
          sb.append(entry);
          pathSeparator = File.pathSeparator;
        }
      }
      commandLine.add("-classpath");
      commandLine.add(sb.toString());
      // AntBootstrap comes from this module, and this module is part of currentClassPathString, hence AntBootstrap would be available 
      commandLine.add(AntBootstrap.class.getName());
      commandLine.add(getWorkerClass());
      dumpPropertiesToWhatToDo();
      try {
        commandLine.add(myWhatToDo.dumpToTmpFile().getAbsolutePath());
      } catch (IOException e) {
        throw new BuildException(e);
      }
      for (String s : getAdditionalArgs()) {
        commandLine.add(s);
      }
      Execute exe = new Execute(new MyExecuteStreamHandler(this));
      exe.setAntRun(this.getProject());
      exe.setWorkingDirectory(this.getProject().getBaseDir());
      exe.setCommandline(commandLine.toArray(new String[commandLine.size()]));
      try {
        int i = exe.execute();
        if (i != 0) {
          processNonZeroExitCode(i);
        }
      } catch (IOException e) {
        throw new BuildException(e);
      }
    } else {
      List<URL> classPathUrls = new ArrayList<URL>();
      for (File path : classPaths) {
        try {
          classPathUrls.add(new URL("file:///" + path + ((path.isDirectory() ? "/" : ""))));
        } catch (MalformedURLException e) {
          throw new BuildException(e);
        }
      }
      URLClassLoader classLoader = new URLClassLoader(classPathUrls.toArray(new URL[classPathUrls.size()]), getClass().getClassLoader());
      Thread.currentThread().setContextClassLoader(classLoader);
      try {
        Class<?> workerClass = classLoader.loadClass(getWorkerClass());
        Object worker = instantiateInProcessWorker(workerClass);
        Method method = workerClass.getMethod("work");
        method.invoke(worker);
      } catch (Throwable t) {
        throw new BuildException(t.getMessage() + "\n" + "Used class path: " + classPathUrls.toString());
      }
    }
  }

  protected Object instantiateInProcessWorker(@NotNull Class<?> workerClass) throws IllegalAccessException, InvocationTargetException, InstantiationException {
    // First, check if there's a desire to get ProjectComponent, i.e. a worker that is Ant-aware 
    for (Constructor<?> constructor : workerClass.getConstructors()) {
      if (constructor.getParameterCount() != 2) {
        continue;
      }
      Class<?>[] parameterTypes = constructor.getParameterTypes();
      if (parameterTypes[0].isAssignableFrom(Script.class) && parameterTypes[1].isAssignableFrom(ProjectComponent.class)) {
        return constructor.newInstance(myWhatToDo, this);
      }
    }
    // Then, resort to a worker that doesn't depend from Ant  
    for (Constructor<?> constructor : workerClass.getConstructors()) {
      if (constructor.getParameterCount() != 1) {
        continue;
      }
      Class<?>[] parameterTypes = constructor.getParameterTypes();
      if (parameterTypes[0].isAssignableFrom(Script.class)) {
        return constructor.newInstance(myWhatToDo);
      }
    }
    // Last, respect the case worker doesn't need anything 
    return workerClass.newInstance();
  }

  @NotNull
  protected List<String> getAdditionalArgs() {
    return Collections.emptyList();
  }

  private void outputBuildNumber() {
    String antTaskBuildNumber;
    URL resource = getClass().getResource("/build.number");
    if (resource == null) {
      log("Can't determine version of ant task.", Project.MSG_DEBUG);
      return;
    }
    try {
      antTaskBuildNumber = MpsLoadTask.readBuildNumber(resource.openStream());
      if (antTaskBuildNumber == null || antTaskBuildNumber.isEmpty()) {
        log("Can't determine version of ant task.", Project.MSG_DEBUG);
        return;
      }
    } catch (IOException ignore) {
      log("Can't determine version of ant task.", Project.MSG_DEBUG);
      return;
    }
    String mpsBuildNumber;
    try {
      mpsBuildNumber = MpsLoadTask.readBuildNumber(new FileInputStream(new File(myMpsHome.getAbsolutePath() + File.separator + "build.number")));
      if (mpsBuildNumber == null || mpsBuildNumber.isEmpty()) {
        log("Can't determine version of MPS.", Project.MSG_DEBUG);
        return;
      }
    } catch (IOException ignore) {
      log("Can't determine version of MPS.", Project.MSG_DEBUG);
      return;
    }
    if (mpsBuildNumber.equals(antTaskBuildNumber)) {
      log("Build number " + mpsBuildNumber, Project.MSG_INFO);
    } else {
      log("MPS build number is " + mpsBuildNumber + ", while ant task build number is " + antTaskBuildNumber + ".\n" + "This may cause errors.", Project.MSG_WARN);
    }
  }

  private void processNonZeroExitCode(int i) {
    throw new BuildException("Process exited with code " + i + ".");
  }

  private void dumpPropertiesToWhatToDo() {
    Hashtable properties = getProject().getProperties();
    for (Object key : properties.keySet()) {
      myWhatToDo.putProperty((String) key, (String) properties.get(key));
    }
  }

  protected void checkMpsHome() {
    if (myMpsHome == null) {
      // FIXME myMpsHome shall serve as an indicator whether user set its location explicitly (hence, with desire to force its own and ignore default home lookup logic 
      //       presently in MPSClasspathUtil, see #calculateClassPath(boolean)). Either use separate fields for user-supplied home and deduced one, or drop assignment altogether 
      myMpsHome = MPSClasspathUtil.resolveMPSHome(getProject(), true);
    }

    // the following code checks mps home is specified correctly 
    assert myMpsHome != null : "MPS home folder must be specified. Use either mpshome task attribute or mps_home or mps.home Ant property to specify home folder.";
    boolean containsBuildTxt = false;
    for (File child : myMpsHome.listFiles()) {
      if (child.getPath().equals("build.txt")) {
        containsBuildTxt = true;
        break;
      }
    }
    assert containsBuildTxt : "MPS home folder is the folder where build.txt file is located. Please correct mpshome attribute, mps_home/mps.home property, depending on which was set";

    outputBuildNumber();
  }

  private boolean startsWith(String path, String prefix) {
    return path.startsWith(prefix) && (path.length() == prefix.length() || prefix.endsWith(File.separator) || path.charAt(prefix.length()) == File.separatorChar);
  }

  protected Set<File> calculateClassPath(boolean fork) {
    List<File> classPathRoots;
    if (myMpsHome != null) {
      // if user set mps home location explicitly, assume he knows what he's doing and wishes to force it 
      classPathRoots = Collections.singletonList(new File(myMpsHome, "lib/"));
    } else {
      classPathRoots = MPSClasspathUtil.getClassPathRootsFromDependencies(getProject());
    }
    if (classPathRoots.isEmpty()) {
      throw new BuildException("Dependency on MPS build scripts is required to generate MPS modules.");

    }
    Set<File> classPath = new LinkedHashSet<File>();
    for (File file : classPathRoots) {
      MPSClasspathUtil.gatherAllClassesAndJarsUnder(file, classPath);
    }
    return classPath;
  }

  /**
   * 
   * @deprecated pass worker class name as cons argument or using #setWorker
   */
  @Deprecated
  protected String getWorkerClass() {
    // I'd like to keep getWorkerClass(), but can't make it public to satisfy Ant and not break binary code compatibility. 
    // Left for compatibility, just in case there are other subclasses of MpsLoadTask that override the method 
    String rv = getWorker();
    if (rv == null) {
      throw new IllegalStateException("Please specify 'worker' class to execute");
    }
    return rv;
  }

  public static String readBuildNumber(InputStream stream) {
    BufferedReader bufferedReader = null;
    try {
      bufferedReader = new BufferedReader(new InputStreamReader(stream));
      String buildNumber = null;
      String configurationName = null;
      while (true) {
        String line = bufferedReader.readLine();
        if (line == null) {
          break;
        }
        if (line.startsWith(CONFIGURATION_NAME)) {
          String tmp = line.substring(CONFIGURATION_NAME.length());
          configurationName = tmp.replaceAll("(\\s*)=(\\s*)(.*)", "$3");
        } else
        if (line.startsWith(BUILD_NUMBER)) {
          String tmp = line.substring(BUILD_NUMBER.length());
          buildNumber = tmp.replaceAll("(\\s*)=(\\s*)(.*)", "$3");
        }
      }
      if (buildNumber != null && configurationName != null) {
        return configurationName + "." + buildNumber;
      }
    } catch (IOException ignore) {
    } finally {
      if (bufferedReader != null) {
        try {
          bufferedReader.close();
        } catch (IOException ignore) {
        }
      }
    }
    return null;
  }

  public static class LogLevelAttribute extends EnumeratedAttribute {
    public LogLevelAttribute() {
    }
    @Override
    public String[] getValues() {
      return new String[]{"error", "warn", "warning", "info", "debug"};
    }
    public Level getLevel() {
      String val = getValue();
      if ("warning".equalsIgnoreCase(val)) {
        val = "warn";
      }
      return Level.toLevel(val);
    }
  }

  public static abstract class AbstractOutputReader extends Thread {
    private InputStream myInputStream;
    public AbstractOutputReader(InputStream inputStream) {
      this.myInputStream = inputStream;
    }
    @Override
    public void run() {
      Scanner s = new Scanner(this.myInputStream);
      try {
        while (!((this.isInterrupted())) && s.hasNextLine()) {
          this.addMessage(s.nextLine());
        }
      } catch (Exception e) {
      }
    }
    protected abstract void addMessage(String message);
  }
}
