package jetbrains.mps.build.ant;

/*Generated by MPS */

import java.io.File;
import org.apache.tools.ant.BuildException;
import java.util.Properties;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Objects;
import jetbrains.mps.tool.common.RepositoryDescriptor;
import java.util.Set;
import java.util.LinkedHashSet;

public class MigrationTask extends MpsLoadTask {
  /**
   * Coupled with string constant in AntTaskExecutionUtil.OUT_FILE_NAME
   */
  private static final String OUT_FILE_NAME = "migration_result.properties";
  /**
   * Coupled with string constant in AntTaskExecutionUtil.ERR_CODE_KEY
   */
  private static final String ERR_CODE_KEY = "mps.migration.errcode";

  public MigrationTask() {
    super("jetbrains.mps.build.migration.MigrationWorker");
    setFailOnError(true);
  }

  public void setProject(String project) {
    myWhatToDo.addProjectFile(new File(project));
  }

  @Override
  public void execute() throws BuildException {
    // this line is here until we generate migration task and the list of needed modules for it 
    addMpsModules();

    super.execute();
    Properties p = new Properties();
    try {
      String path = getProject().getBaseDir().getAbsolutePath() + File.separator + OUT_FILE_NAME;
      File file = new File(path);
      FileInputStream fis = new FileInputStream(file);
      p.load(fis);
      fis.close();
      file.delete();
    } catch (IOException e) {
      throw new BuildException("can't read task output from " + OUT_FILE_NAME, e);
    }
    if (!(Objects.equals(p.getProperty(ERR_CODE_KEY), "0"))) {
      throw new BuildException("Migration was not executed. See log for details.");
    }
  }

  private void addMpsModules() {
    RepositoryDescriptor repoDesc = myWhatToDo.getRepoDescriptor();
    if (repoDesc == null) {
      repoDesc = new RepositoryDescriptor();
      myWhatToDo.setRepoDescriptor(repoDesc);
    }
    repoDesc.folders.add(getMpsHomePath());
  }

  @Override
  protected Set<File> calculateClassPath(boolean fork) {
    Set<File> classPath = new LinkedHashSet<File>(super.calculateClassPath(fork));

    // FIXME checkMpsHome initializes myMpsHome if not set, while super.calculateClassPath() uses its value 
    //       to figure out if mps home location has been explicitly set or not. Shall avoid these implicit assumptions 
    checkMpsHome();
    File mpsHome = getMpsHome();

    // j.m.build.migration.jar hosts MigrationWorker 
    addClassPath(classPath, mpsHome, "/plugins/mps-build/languages/build/jetbrains.mps.build.migration.jar");
    addClassPath(classPath, mpsHome, "/plugins/modelchecker/lib/modelchecker.jar");
    addClassPath(classPath, mpsHome, "/plugins/migration/lib/migration.jar");
    addClassPath(classPath, mpsHome, "/plugins/migration/lib/migration-platform.jar");

    return classPath;
  }

  private String getMpsHomePath() {
    checkMpsHome();
    File mpsHome = getMpsHome();
    assert mpsHome != null : "MPSLoadTask.getMpsHome() == null. MPS home folder was not specified.";
    return mpsHome.getAbsolutePath();
  }

  private void addClassPath(Set<File> classPath, File mpsHome, String relativePath) {
    File cp = new File(mpsHome, relativePath);
    assert cp.exists() : "requested file does not exist: " + cp.getAbsolutePath();
    classPath.add(cp);
  }
}
