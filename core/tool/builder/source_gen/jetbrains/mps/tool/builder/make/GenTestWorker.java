package jetbrains.mps.tool.builder.make;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.tool.builder.MpsWorker;
import java.io.File;
import java.io.IOException;
import jetbrains.mps.project.Project;
import java.util.Set;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import java.util.Collection;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.make.facet.IFacet;
import java.util.ArrayList;
import jetbrains.mps.make.script.PropertyPoolInitializer;
import jetbrains.mps.internal.make.cfg.MakeFacetInitializer;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.make.script.IPropertiesPool;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.make.facet.ITarget;
import jetbrains.mps.internal.make.cfg.JavaCompileFacetInitializer;
import jetbrains.mps.make.script.IScriptController;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import java.util.concurrent.ExecutionException;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.make.ModuleMaker;
import jetbrains.mps.progress.EmptyProgressMonitor;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.AbstractModule;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import java.util.LinkedList;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.tool.common.ScriptProperties;
import jetbrains.mps.messages.IMessageHandler;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.tool.builder.unittest.ITestReporter;
import jetbrains.mps.tool.builder.unittest.XmlTestReporter;
import jetbrains.mps.tool.builder.unittest.ConsoleTestReporter;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;

public class GenTestWorker extends BaseGeneratorWorker {
  private final GenTestWorker.MyMessageHandler myMessageHandler = new GenTestWorker.MyMessageHandler();
  private boolean myTestFailed = false;
  private Map<String, String> path2tmp = MapSequence.fromMap(new HashMap<String, String>());
  private String tmpPath;
  private GenTestWorker.MyReporter myReporter = new GenTestWorker.MyReporter();

  public GenTestWorker(Script whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
    File tmpDir;
    try {
      tmpDir = File.createTempFile("gentest_", "tmp");
      tmpDir.delete();
      tmpDir.mkdir();
    } catch (IOException ex) {
      throw new RuntimeException(ex);
    }
    this.tmpPath = tmpDir.getAbsolutePath();
  }

  @Override
  public void work() {
    myReporter.init();
    setGenerationProperties();
    final Project project = createDummyProject();

    Set<SModule> modules = new ModelAccessHelper(project.getModelAccess()).runWriteAction(new Computable<Set<SModule>>() {
      public Set<SModule> compute() {
        return collectFromModuleFiles(project.getRepository());
      }
    });

    if (!(modules.isEmpty())) {
      loadAndMake(project, modules);
      generate(project, modules);
    } else {
      error("Could not find anything to test.");
    }

    myReporter.finishRun();
    showStatistic();
  }


  @Override
  protected void dispose() {
    cleanUp();
    super.dispose();
  }

  @Override
  protected void generate(Project project, Collection<SModule> modules) {
    StringBuffer s = new StringBuffer("Generating:");
    for (SModule m : modules) {
      s.append("\n    ");
      s.append(m);
    }
    info(s.toString());

    final MakeSession ms = new MakeSession(project, myMessageHandler, true) {
      @Override
      public IScript toScript(ScriptBuilder scriptBuilder) {
        if (isShowDiff()) {
          scriptBuilder.withFacetName(new IFacet.Name("jetbrains.mps.tool.gentest.Diff"));
        }
        return scriptBuilder.toScript();
      }
    };
    ArrayList<PropertyPoolInitializer> ppi = new ArrayList<PropertyPoolInitializer>();
    ppi.add(new MakeFacetInitializer().setPathToFile(new _FunctionTypes._return_P1_E0<IFile, String>() {
      public IFile invoke(String path) {
        return tmpFile(path);
      }
    }));
    if (isShowDiff()) {
      PropertyPoolInitializer diffFacetInit = new PropertyPoolInitializer() {
        public void populate(IPropertiesPool ppool) {
          Tuples._2<_FunctionTypes._return_P1_E0<? extends String, ? super IFile>, Set<File>> dparams = (Tuples._2<_FunctionTypes._return_P1_E0<? extends String, ? super IFile>, Set<File>>) ppool.properties(new ITarget.Name("jetbrains.mps.tool.gentest.Diff.diff"), Object.class);
          if (dparams != null) {
            dparams._0(new _FunctionTypes._return_P1_E0<String, IFile>() {
              public String invoke(IFile f) {
                return pathOfTmpFile(f);
              }
            });
            dparams._1(myWhatToDo.getExcludedFromDiffFiles());
          }
        }
      };
      ppi.add(diffFacetInit);
    }
    ppi.add(new JavaCompileFacetInitializer().setJavaCompileOptions(myJavaCompilerOptions));

    IScriptController ctl = new IScriptController.Stub2(ms, ppi.toArray(new PropertyPoolInitializer[ppi.size()]));
    try {
      BuildMakeService bms = new BuildMakeService();
      // FIXME I've got a solid feeling that without Test make facet, myReporter makes no sense, as well as both ITestReporter implementations 
      //       Though they do not bother me at the moment, hence left alive. 
      myReporter.finishRun();
      myReporter.startRun(myWhatToDo.getProperty("ant.project.name"));
      Future<IResult> result = bms.make(ms, collectResources(project, modules), null, ctl);
      if (!(result.get().isSucessful())) {
        myErrors.add("Make was not successful " + result.get().output());
      }
    } catch (InterruptedException e) {
      myErrors.add(e.toString());
    } catch (ExecutionException e) {
      myErrors.add(e.toString());
    }
  }

  private void loadAndMake(final Project project, final Collection<SModule> modules) {
    ModelAccess access = project.getRepository().getModelAccess();
    access.runReadAction(new Runnable() {
      public void run() {
        new ModuleMaker().make(modules, new EmptyProgressMonitor() {
          @Override
          public void step(String text) {
            // silently 
          }
          @Override
          public void start(@NotNull String taskName, int work) {
            // silently 
          }
        }, myJavaCompilerOptions);
      }
    });
    access.runWriteAction(new Runnable() {
      public void run() {
        // the following updates stub models that could change due to the compilation happened (webr, 3.0 migration case) 
        for (SModule m : project.getRepository().getModules()) {
          if (!((m instanceof AbstractModule))) {
            continue;
          }
          ((AbstractModule) m).updateModelsSet();
        }
      }
    });
  }

  private void cleanUp() {
    for (Queue<File> dirs = QueueSequence.fromQueueAndArray(new LinkedList<File>(), new File(tmpPath)); QueueSequence.fromQueue(dirs).isNotEmpty();) {
      File dir = QueueSequence.fromQueue(dirs).removeFirstElement();
      dir.deleteOnExit();
      for (File f : dir.listFiles()) {
        if (f.isDirectory()) {
          QueueSequence.fromQueue(dirs).addLastElement(f);
        } else {
          f.deleteOnExit();
        }
      }
    }
    this.tmpPath = null;
    MapSequence.fromMap(path2tmp).clear();
  }

  private IFile tmpFile(String path) {
    if (MapSequence.fromMap(path2tmp).containsKey(path)) {
      return FileSystem.getInstance().getFile(MapSequence.fromMap(path2tmp).get(path));
    }
    int idx = path.indexOf("/");
    if (idx > 0) {
      throw new IllegalArgumentException("not an absolute path '" + path + "'");
    }
    idx = (idx < 0 ? path.indexOf(File.separator) : idx);
    if (idx > "C:\\".length() && path.indexOf(":") < 0) {
      throw new IllegalArgumentException("not an absolute path '" + path + "'");
    }
    String tmp = tmpPath + "/" + ((idx != 0 ? path.replace(":", "_w_") : path.substring(1)));
    MapSequence.fromMap(path2tmp).put(path, tmp);
    return FileSystem.getInstance().getFile(tmp);
  }

  private String pathOfTmpFile(IFile file) {
    String p = file.getPath();
    if (!(p.startsWith(tmpPath))) {
      throw new IllegalArgumentException("unknown tmp path '" + file.getParent() + "'");
    }
    p = p.substring(tmpPath.length() + 1);
    if (p.contains("_w_")) {
      return FileSystem.getInstance().getFile(p.replace("_w_", ":")).getPath();
    }
    String prefix = (File.separatorChar == '/' ? "/" : "\\\\");
    return FileSystem.getInstance().getFile(prefix + p).getPath();
  }

  private boolean isRunningOnTeamCity() {
    return myWhatToDo.getProperty("teamcity.version") != null;
  }

  private boolean isShowDiff() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.SHOW_DIFF));
  }

  @Override
  protected void showStatistic() {
    super.showStatistic();
    if (myTestFailed) {
      throw new RuntimeException("Tests Failed");
    }
  }

  public static void main(String[] args) {
    GenTestWorker generator = new GenTestWorker(Script.fromDumpInFile(new File(args[0])), new MpsWorker.SystemOutLogger());
    generator.workFromMain();
  }

  private class MyMessageHandler implements IMessageHandler {
    public MyMessageHandler() {
    }
    @Override
    public void handle(@NotNull IMessage msg) {
      switch (msg.getKind()) {
        case ERROR:
          GenTestWorker.this.error(msg.getText());
          myReporter.errorLine("[ERROR] " + msg.getText());
          break;
        case WARNING:
          GenTestWorker.this.warning(msg.getText());
          myReporter.outputLine("[WARNING]" + msg.getText());
          break;
        case INFORMATION:
          GenTestWorker.this.info(msg.getText());
          myReporter.outputLine("[INFO]" + msg.getText());
          break;
        default:
      }
    }
  }

  private class MyReporter {
    private ITestReporter testReporter;
    private File gentestdir;
    private MyReporter() {
    }
    private void init() {
      if (gentestdir != null) {
        return;
      }
      if (isRunningOnTeamCity()) {
        String wd = myWhatToDo.getProperty("mps.gentest.reportsDir");
        wd = (wd == null ? System.getProperty("user.dir") : wd);
        gentestdir = new File(wd, ".gentest");
        if (!(gentestdir.exists())) {
          if (!(gentestdir.mkdirs())) {
            File tmpDir;
            try {
              tmpDir = File.createTempFile("gentest", "reports");
              tmpDir.delete();
              tmpDir.mkdir();
            } catch (IOException ex) {
              throw new RuntimeException(ex);
            }
            gentestdir = tmpDir;
          }
        } else if (gentestdir.isDirectory()) {
          for (File f : gentestdir.listFiles()) {
            f.delete();
          }
        }
      }
    }
    private void startRun(String name) {
      this.testReporter = (isRunningOnTeamCity() ? new XmlTestReporter(name) : new ConsoleTestReporter());
    }
    private void finishRun() {
      if (testReporter == null) {
        return;
      }
      testReporter.runFinished();
      if (isRunningOnTeamCity()) {
        BufferedOutputStream os = null;
        try {
          File reportFile = File.createTempFile("gentest_report-", ".xml", gentestdir);
          os = new BufferedOutputStream(new FileOutputStream(reportFile));
          ((XmlTestReporter) testReporter).dump(os);
          System.out.println("##teamcity[importData type='junit' path='" + reportFile.getAbsolutePath() + "']");
        } catch (IOException ex) {
        } finally {
          if (os != null) {
            try {
              os.close();
            } catch (IOException ignore) {
            }
          }
        }
      }
      this.testReporter = null;
    }

    private void outputLine(String out) {
      if (testReporter != null) {
        testReporter.outputLine(out);
      } else {
        System.out.println(out);
      }
    }
    private void errorLine(String err) {
      if (testReporter != null) {
        testReporter.errorLine(err);
      } else {
        System.err.println(err);
      }
    }
  }
}
