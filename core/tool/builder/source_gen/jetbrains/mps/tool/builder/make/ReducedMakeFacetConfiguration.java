package jetbrains.mps.tool.builder.make;

/*Generated by MPS */

import jetbrains.mps.tool.builder.paths.IRedirects;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Collections;
import jetbrains.mps.make.script.IScriptController;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.generator.IModifiableGenerationSettings;
import jetbrains.mps.generator.GenerationSettingsProvider;
import jetbrains.mps.generator.GenerationOptions;
import jetbrains.mps.make.script.IPropertiesPool;
import jetbrains.mps.make.facet.ITarget;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.internal.make.cfg.GenerateFacetInitializer;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.make.cfg.JavaCompileFacetInitializer;
import jetbrains.mps.internal.make.cfg.MakeFacetInitializer;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vfs.IFile;

public class ReducedMakeFacetConfiguration {
  private boolean rebuild;
  private IRedirects outputPathRedirects;
  private Map<String, String> fileHashes = MapSequence.fromMap(new HashMap<String, String>());
  private List<String> writtenFiles = ListSequence.fromList(new ArrayList<String>());
  private List<String> deletedFiles = ListSequence.fromList(new ArrayList<String>());
  private List<String> keptFiles = ListSequence.fromList(new ArrayList<String>());
  private Map<String, SModel> sources = MapSequence.fromMap(new HashMap<String, SModel>());
  public ReducedMakeFacetConfiguration(IRedirects pathRedirects) {
    this.outputPathRedirects = pathRedirects;
  }
  public ReducedMakeFacetConfiguration(IRedirects pathRedirects, boolean rebuild) {
    this.outputPathRedirects = pathRedirects;
    this.rebuild = rebuild;
  }
  public Map<String, String> getFileHashes() {
    return Collections.unmodifiableMap(fileHashes);
  }
  public List<String> getWrittenFiles() {
    return ListSequence.fromList(writtenFiles).asUnmodifiable();
  }
  public List<String> getKeptFiles() {
    return ListSequence.fromList(keptFiles).asUnmodifiable();
  }
  public List<String> getDeletedFiles() {
    return ListSequence.fromList(deletedFiles).asUnmodifiable();
  }
  public SModel getSource(String filePath) {
    return MapSequence.fromMap(sources).get(filePath);
  }
  public IScriptController configureFacets(final MakeSession makeSession) {
    IModifiableGenerationSettings settings = GenerationSettingsProvider.getInstance().getGenerationSettings();
    settings.setIncremental(true);
    settings.setIncrementalUseCache(false);
    final GenerationOptions.OptionsBuilder optBuilder = GenerationOptions.fromSettings(settings);

    return new IScriptController.Stub2(makeSession) {
      @Override
      public void setup(IPropertiesPool pp, Iterable<ITarget> toExecute, Iterable<? extends IResource> input) {
        // FIXME rebuild is actually part of MakeSession, not of this RMFC class. For unknown reason, however, idea plugin 
        // uses distinct values for session's and generation's clean flag 
        new GenerateFacetInitializer().cleanMake(rebuild).setGenerationOptions(optBuilder).populate(pp);

        Tuples._1<Boolean> skipCopyTraceinfo = (Tuples._1<Boolean>) pp.properties(new ITarget.Name("jetbrains.mps.lang.traceable.CopyTraceInfo.copyTraceInfo"), Object.class);
        if (skipCopyTraceinfo != null) {
          skipCopyTraceinfo._0(true);
        }

        new JavaCompileFacetInitializer().skipCompilation(true).populate(pp);

        Tuples._4<List<String>, List<String>, List<String>, Map<String, SModel>> report = (Tuples._4<List<String>, List<String>, List<String>, Map<String, SModel>>) pp.properties(new ITarget.Name("jetbrains.mps.make.reduced.ReportFiles.report"), Object.class);
        report._0(writtenFiles);
        report._1(deletedFiles);
        report._2(keptFiles);
        report._3(sources);

        Tuples._1<Map<String, String>> hashes = (Tuples._1<Map<String, String>>) pp.properties(new ITarget.Name("jetbrains.mps.make.reduced.CollectHashes.collect"), Object.class);
        hashes._0(fileHashes);

        MakeFacetInitializer makeFacetInit = new MakeFacetInitializer();
        makeFacetInit.skipReconcile(true);
        // override solution's output path 
        makeFacetInit.setPathToFile(new _FunctionTypes._return_P1_E0<IFile, String>() {
          public IFile invoke(String path) {
            return outputPathRedirects.getRedirect(path);
          }
        });
        makeFacetInit.populate(pp);
      }
    };
  }

}
