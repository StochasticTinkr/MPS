package jetbrains.mps.tool.builder;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.compiler.JavaCompilerOptions;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import jetbrains.mps.tool.common.JavaCompilerProperties;
import jetbrains.mps.compiler.JavaCompilerOptionsComponent;
import jetbrains.mps.tool.environment.MpsEnvironment;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import jetbrains.mps.tool.common.RepositoryDescriptor;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.tool.common.ScriptProperties;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.make.MPSCompilationResult;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import jetbrains.mps.make.ModuleMaker;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.classloading.ClassLoaderManager;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.generator.GenerationFacade;
import java.util.Collection;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.LinkedHashSet;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.io.DescriptorIOFacade;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.library.ModulesMiner;
import org.apache.log4j.Level;
import java.io.StringWriter;
import java.io.PrintWriter;
import jetbrains.mps.util.annotation.ToRemove;

public abstract class MpsWorker {
  private static final Logger LOG = LogManager.getLogger(MpsWorker.class);
  protected final List<String> myErrors = new ArrayList<String>();
  protected final List<String> myWarnings = new ArrayList<String>();
  protected final Script myWhatToDo;
  protected final JavaCompilerOptions myJavaCompilerOptions;
  protected final boolean mySkipCompilation;
  private final MpsWorker.AntLogger myLogger;
  protected Environment myEnvironment;
  private final BaseMPSModuleOwner myOwner = new BaseMPSModuleOwner();


  public MpsWorker(Script whatToDo, MpsWorker.AntLogger logger) {
    myWhatToDo = whatToDo;
    myLogger = logger;

    JavaCompilerProperties javaProperties = new JavaCompilerProperties(myWhatToDo);
    myJavaCompilerOptions = getJavaCompilerOptions(javaProperties);
    mySkipCompilation = javaProperties.isSkipCompilation();
  }

  private static JavaCompilerOptions getJavaCompilerOptions(JavaCompilerProperties javaProperties) {
    JavaCompilerOptionsComponent.JavaVersion parsedJavaVersion = JavaCompilerOptionsComponent.JavaVersion.parse(javaProperties.getTargetJavaVersion());
    if (parsedJavaVersion == null) {
      return JavaCompilerOptionsComponent.DEFAULT_JAVA_COMPILER_OPTIONS;
    }

    return new JavaCompilerOptions(parsedJavaVersion);
  }

  protected Environment createEnvironment() {
    return MpsEnvironment.getOrCreate(createEnvironmentConfig(myWhatToDo));
  }

  public EnvironmentConfig createEnvironmentConfig(Script whatToDo) {
    EnvironmentConfig config = EnvironmentConfig.emptyConfig().withDefaultSamples().withDefaultPlugins();
    RepositoryDescriptor repo = whatToDo.getRepoDescriptor();
    if (repo != null) {
      config = config.withBootstrapLibraries().withWorkbenchPath();
      // todo make this code more typed 
      for (String folder : repo.folders) {
        if (!(new File(folder).exists())) {
          warning("Modules folder does not exist: " + folder);
        }
        config = config.addLib(folder);
      }
      for (String file : repo.files) {
        if (!(new File(file).exists())) {
          warning("Module file does not exist: " + file);
        }
        config = config.addLib(file);
      }
    } else {
      config = config.withBootstrapLibraries().withWorkbenchPath();
    }
    for (IMapping<String, String> macro : MapSequence.fromMap(whatToDo.getMacro())) {
      config = config.addMacro(macro.key(), new File(macro.value()));
    }
    for (IMapping<String, File> lib : MapSequence.fromMap(whatToDo.getLibraries())) {
      config = config.addLib(lib.value().getAbsolutePath());
    }
    for (String jar : whatToDo.getLibraryJars()) {
      File jarFile = new File(jar);
      if (!(jarFile.exists())) {
        warning("Library " + jar + " does not exist.");
      }
      config = config.addLib(jar);
    }

    // todo make it a leagl part of the whatToDo if possible 
    String pluginsPath = whatToDo.getProperty(ScriptProperties.PLUGIN_PATHS);
    if (pluginsPath != null) {
      for (String cp : pluginsPath.split(File.pathSeparator)) {
        config.addPluginClassPath(cp);
      }
    }

    return config;
  }

  public void workFromMain() {
    try {
      Logger.getRootLogger().setLevel(myWhatToDo.getLogLevel());
      myEnvironment = createEnvironment();
      make();

      work();
      System.exit(0);
    } catch (Throwable e) {
      log(e);
      System.exit(1);
    }
  }

  public abstract void work();

  protected Project createDummyProject() {
    return myEnvironment.createEmptyProject();
  }

  protected void dispose() {
    if (myEnvironment != null) {
      myEnvironment.dispose();
      myEnvironment = null;
    }
  }

  protected void make() {
    // FIXME why do I care to make these modules? 
    final MPSModuleRepository repo = myEnvironment.getPlatform().findComponent(MPSModuleRepository.class);
    MPSCompilationResult mpsCompilationResult = new ModelAccessHelper(repo).runReadAction(new Computable<MPSCompilationResult>() {
      public MPSCompilationResult compute() {
        ModuleMaker maker = new ModuleMaker();
        return maker.make(IterableUtil.asCollection(repo.getModules()), new EmptyProgressMonitor(), myJavaCompilerOptions);
      }
    });
    reload(mpsCompilationResult);
  }
  protected void reload(final MPSCompilationResult mpsCompilationResult) {
    if (mpsCompilationResult.isReloadingNeeded()) {
      myEnvironment.getPlatform().findComponent(MPSModuleRepository.class).getModelAccess().runWriteAction(new Runnable() {
        public void run() {
          ClassLoaderManager.getInstance().reloadModules(mpsCompilationResult.getChangedModules());
        }
      });
    }
  }
  protected abstract void showStatistic();
  protected StringBuffer formatErrorsReport(String taskName) {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < 100; i++) {
      sb.append('*');
    }
    sb.append("\n");
    sb.append(myErrors.size());
    sb.append(" errors during " + taskName + ":\n");
    for (String error : myErrors) {
      sb.append(error);
      sb.append("\n");
    }
    for (int i = 0; i < 100; i++) {
      sb.append('*');
    }
    return sb;
  }
  protected void failBuild(String name) {
    if (!(myErrors.isEmpty()) && myWhatToDo.getFailOnError()) {
      throw new RuntimeException(this.formatErrorsReport(name).toString());
    }
  }

  protected void extractModels(Set<SModel> result, Project project) {
    for (SModule module : project.getProjectModulesWithGenerators()) {
      for (SModel model : module.getModels()) {
        if (includeModel(model)) {
          result.add(model);
        }
      }
    }
  }
  private boolean includeModel(SModel model) {
    return SModelStereotype.isUserModel(model) && GenerationFacade.canGenerate(model);
  }
  protected void extractModels(Collection<SModel> modelsList, SModule m) {
    for (SModel d : m.getModels()) {
      if (includeModel(d)) {
        modelsList.add(d);
      }
    }
  }
  /**
   * XXX Perhaps, would be better to pass Project here so that we populate Project explicitly, rather
   * than collect some modules (under Project's MA lock!), but process them independently using ObjectsToProcess
   */
  protected Set<SModule> collectFromModuleFiles(SRepository repo) {
    // XXX don't want to have ordering here but used to be that way in GenTestWorker and might be helpful 
    // to reproduce errors/get predictable behavior. 
    Set<SModule> modules = new LinkedHashSet<SModule>();
    // FIXME GenTestWorker/GenTestTask still use module files as configuration argument (from Java code perspective, need to check actual tasks in scripts and generator thereof) 
    for (File moduleFile : myWhatToDo.getModules()) {
      processModuleFile(repo, moduleFile, modules);
    }
    return modules;
  }
  /**
   * Discovers module(s) from specified location of a module descriptor, loads and registers them in
   * global (JUST FOR NOW) repository with custom owner.
   * 
   * The method used to filter out read-only module and DevKit which is odd provided we have no idea what's the reason to load the module in the first place.
   * Now it's caller responsibility to deal with loaded modules and ignore those undesired as appropriate.
   * 
   * @param moduleSourceDescriptorFile not null
   * @param modules collection to populate, not null.
   */
  protected void processModuleFile(SRepository repo, final File moduleSourceDescriptorFile, final Set<SModule> modules) {
    // XXX need a way to figure which FS to use here. Techically, it should come from a project as we are going to 
    // use these modules as part of the project. 
    final FileSystem fs = FileSystem.getInstance();
    IFile descriptorFile = fs.getFile(moduleSourceDescriptorFile.getPath());
    if (DescriptorIOFacade.getInstance().fromFileType(descriptorFile) == null) {
      info(String.format("File %s doesn't point to module descriptor, ignored", moduleSourceDescriptorFile));
      return;
    }
    ModuleRepositoryFacade mrf = new ModuleRepositoryFacade(repo);
    for (ModulesMiner.ModuleHandle moduleHandle : new ModulesMiner().collectModules(descriptorFile).getCollectedModules()) {
      //  seems reasonable just to instantiate a module here and leave its registration to caller 
      SModule module = mrf.instantiateModule(moduleHandle, myOwner);
      info("Loaded module " + module);
      modules.add(module);
    }
  }

  private void log(String text, Level level) {
    if (!(level.isGreaterOrEqual(myWhatToDo.getLogLevel()))) {
      return;
    }

    myLogger.log(text, level);
  }
  public void info(String text) {
    log(text, Level.INFO);
  }
  public void warning(String text) {
    log(text, Level.WARN);
    myWarnings.add(text);
  }
  public void debug(String text) {
    log(text, Level.DEBUG);
  }
  public void error(String text) {
    log(text, Level.ERROR);
    myErrors.add(text);
  }
  public void log(Throwable e) {
    StringBuffer sb = MpsWorker.extractStackTrace(e);
    error(sb.toString());
  }
  public void log(String text, Throwable e) {
    StringBuffer sb = MpsWorker.extractStackTrace(e);
    error(text + "\n" + sb.toString());
  }
  public static StringBuffer extractStackTrace(Throwable e) {
    StringWriter writer = new StringWriter();
    e.printStackTrace(new PrintWriter(writer));
    return writer.getBuffer();
  }
  public interface AntLogger {
    void log(String text, Level level);
  }
  public static class SystemOutLogger implements MpsWorker.AntLogger {
    public SystemOutLogger() {
    }
    @Override
    public void log(String text, Level level) {
      if (level == Level.ERROR) {
        System.err.println(text);
      } else {
        System.out.println(text);
      }
    }
  }
  public static class LogLogger implements MpsWorker.AntLogger {
    public LogLogger() {
    }
    @Override
    public void log(String text, Level level) {
      switch (level.toInt()) {
        case Level.ERROR_INT:
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error(text);
          }
          break;
        case Level.WARN_INT:
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn(text);
          }
          break;
        case Level.INFO_INT:
          if (LOG.isInfoEnabled()) {
            LOG.info(text);
          }
          break;
        case Level.DEBUG_INT:
          if (LOG.isDebugEnabled()) {
            LOG.debug(text);
          }
          break;
        default:
          if (LOG.isEnabledFor(Level.FATAL)) {
            LOG.fatal("[unknown level " + level + "] " + text);
          }
          break;
      }
    }
  }
  /**
   * 
   * @deprecated There's no need to wrap set of modules into this class, and there's no added value whatsoever.
   */
  @Deprecated
  @ToRemove(version = 2018.1)
  protected class ObjectsToProcess {
    private final Set<Project> myProjects = new LinkedHashSet<Project>();
    private final Set<SModule> myModules = new LinkedHashSet<SModule>();

    @Deprecated
    public ObjectsToProcess() {
    }
    @Deprecated
    public ObjectsToProcess(Set<? extends Project> mpsProjects, Set<SModule> modules) {
      myProjects.addAll(mpsProjects);
      myModules.addAll(modules);
    }
    public Set<Project> getProjects() {
      return myProjects;
    }
    public Set<SModule> getModules() {
      return myModules;
    }
    public boolean hasAnythingToGenerate() {
      return !(myProjects.isEmpty()) || !(myModules.isEmpty());
    }
  }
}
