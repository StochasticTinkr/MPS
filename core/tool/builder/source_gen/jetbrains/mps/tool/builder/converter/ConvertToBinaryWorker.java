package jetbrains.mps.tool.builder.converter;

/*Generated by MPS */

import java.util.Map;
import java.io.File;
import java.util.HashMap;
import jetbrains.mps.core.platform.Platform;
import jetbrains.mps.core.platform.PlatformFactory;
import jetbrains.mps.core.platform.PlatformOptionsBuilder;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.persistence.DefaultModelPersistence;
import jetbrains.mps.persistence.MetaModelInfoProvider;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.persistence.ModelFactory;
import jetbrains.mps.util.FileUtil;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.project.MPSExtentions;
import java.io.IOException;
import org.jetbrains.mps.openapi.persistence.ModelSaveException;
import jetbrains.mps.extapi.persistence.DataSourceBase;
import org.jetbrains.mps.openapi.persistence.StreamDataSource;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.OutputStream;
import java.io.FileOutputStream;
import org.jetbrains.annotations.NotNull;

public final class ConvertToBinaryWorker {
  private final Map<File, File> myMap;
  private final Boolean myStripImplementation;
  private HashMap<String, String> options;


  public ConvertToBinaryWorker(final Map<File, File> map, final Boolean stripImplementation) {
    myMap = map;
    myStripImplementation = stripImplementation;
  }

  public void work() {
    final Platform platform = PlatformFactory.initPlatform(PlatformOptionsBuilder.PERSISTENCE);
    RuntimeFlags.setMergeDriverMode(true);
    try {
      options = new HashMap<String, String>();
      options.put(DefaultModelPersistence.OPTION_STRIP_IMPLEMENTATION, Boolean.toString(myStripImplementation));
      options.put(MetaModelInfoProvider.OPTION_KEEP_READ_METAINFO, Boolean.TRUE.toString());

      for (Map.Entry<File, File> entry : myMap.entrySet()) {
        convertModelToBinary(entry.getKey(), entry.getValue());
      }
    } finally {
      platform.dispose();
    }
  }

  private void convertModelToBinary(File sourceFile, File destFile) {
    final PersistenceFacade pf = PersistenceFacade.getInstance();
    ModelFactory modelFactory = pf.getModelFactory(FileUtil.getExtension(sourceFile.getName()));
    if (modelFactory == null) {
      // assuming user knows what he's doing and supplied us with a model file, try default factory. 
      modelFactory = pf.getDefaultModelFactory();
    }
    try {
      SModel model = modelFactory.load(new ConvertToBinaryWorker.FileDataSource(sourceFile), options);
      pf.getModelFactory(MPSExtentions.MODEL_BINARY).save(model, new ConvertToBinaryWorker.FileDataSource(destFile));
    } catch (RuntimeException ex) {
      System.out.printf("Conversion of %s\n", sourceFile);
      ex.printStackTrace();
      throw ex;
    } catch (IOException ex) {
      throw new RuntimeException(String.format("Failed to read model from file %s", sourceFile), ex);
    } catch (ModelSaveException e) {
      throw new RuntimeException(String.format("Failed to write model in binary format to file %s", destFile), e);
    }
  }

  private static class FileDataSource extends DataSourceBase implements StreamDataSource {
    private final File myFile;

    /*package*/ FileDataSource(File file) {
      myFile = file;
    }

    @Override
    public InputStream openInputStream() throws IOException {
      return new FileInputStream(myFile);
    }

    @Override
    public OutputStream openOutputStream() throws IOException {
      myFile.getParentFile().mkdirs();
      myFile.createNewFile();
      return new FileOutputStream(myFile);
    }


    @Override
    public boolean isReadOnly() {
      // we are not going to write into sourceFile anyway, and have to write into destFile, therefore no reason to bother with actual state 
      return false;
    }

    @NotNull
    @Override
    public String getLocation() {
      return myFile.getPath();
    }
  }
}
