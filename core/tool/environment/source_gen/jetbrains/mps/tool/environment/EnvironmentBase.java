package jetbrains.mps.tool.environment;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.PathMacrosProvider;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.TestMode;
import java.util.Map;
import java.util.HashMap;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.project.PathMacros;
import jetbrains.mps.core.tool.environment.util.MapPathMacrosProvider;
import jetbrains.mps.core.tool.environment.util.CanonicalPath;
import jetbrains.mps.library.LibraryInitializer;
import java.util.List;
import jetbrains.mps.library.contributor.LibraryContributor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.annotations.Nullable;
import java.net.URL;
import java.net.MalformedURLException;
import org.apache.log4j.Level;
import jetbrains.mps.util.PathManager;
import jetbrains.mps.core.tool.environment.classloading.UrlClassLoader;
import jetbrains.mps.project.Project;
import java.util.Set;

/**
 * Base class for all environments, represents a caching environment.
 * The contract: only one environment must be alive,
 * it is being stored in the special EnvironmentContainer class.
 * 
 * @see jetbrains.mps.tool.environment.EnvironmentContainer 
 */
public abstract class EnvironmentBase implements Environment {
  private static final Logger LOG = LogManager.getLogger(EnvironmentBase.class);
  private static final String PLUGINS_PATH = "plugin.path";

  protected final EnvironmentConfig myConfig;
  private boolean myInitialized;
  private int myRefCount;
  private PathMacrosProvider myMacrosProvider;
  private final ProjectContainer myContainer = new ProjectContainer();
  private ClassLoader myRootClassLoader = null;

  public static void initializeLog4j() {
    new Log4jInitializer().init();
    LogManager.getLogger(EnvironmentBase.class).info("Initializing environment");
  }

  public EnvironmentBase(@NotNull EnvironmentConfig config) {
    if (!(RuntimeFlags.isTestMode())) {
      RuntimeFlags.setTestMode(TestMode.USUAL);
    }
    myConfig = config;
  }

  public void init() {
    if (myInitialized) {
      throw new IllegalStateException("Double initialization " + this);
    }
    initMacros();
    myRootClassLoader = createRootClassLoader();
    retain();
    myInitialized = true;
  }

  private PathMacrosProvider initMacros() {
    Map<String, String> macros = new HashMap<String, String>();
    Map<String, File> macrosConfig = myConfig.getMacros();
    for (String name : MapSequence.fromMap(macrosConfig).keySet()) {
      MapSequence.fromMap(macros).put(name, MapSequence.fromMap(macrosConfig).get(name).getAbsolutePath());
    }
    myMacrosProvider = createMapMacrosProvider(macros);
    PathMacros.getInstance().addMacrosProvider(myMacrosProvider);
    return myMacrosProvider;
  }

  private static MapPathMacrosProvider createMapMacrosProvider(Map<String, String> macros) {
    Map<String, String> realMacros = new HashMap<String, String>();
    for (String macroName : macros.keySet()) {
      String macroValue = MapSequence.fromMap(macros).get(macroName);
      CanonicalPath path = new CanonicalPath(macroValue);
      if (path.isValidDirectory()) {
        realMacros.put(macroName, path.getValue());
      }
    }
    return new MapPathMacrosProvider(realMacros);
  }

  protected void initLibraries(@NotNull LibraryInitializer libInitializer) {
    if (LOG.isInfoEnabled()) {
      LOG.info("Initializing libraries");
    }
    final List<LibraryContributor> libContribs = ListSequence.fromList(new ArrayList<LibraryContributor>());
    LibraryContributorHelper helper = new LibraryContributorHelper(myConfig, myRootClassLoader);
    if (SetSequence.fromSet(myConfig.getLibs()).isNotEmpty()) {
      ListSequence.fromList(libContribs).addElement(helper.createLibContributorForLibs());
    }
    // todo this hould go away. Instead, a regular contributor for plugins should perform 
    if (myConfig.getPlugins() != null && SetSequence.fromSet(myConfig.getPlugins()).isNotEmpty()) {
      ListSequence.fromList(libContribs).addElement(helper.createLibContributorForPlugins());
    }
    libInitializer.load(libContribs);
  }

  /**
   * Root class loader:
   * 1. As a root class loader for libraries in LibraryInitializer
   * 2. As a root class loader for dumb idea plugin facet
   */
  @Nullable
  protected final ClassLoader getRootClassLoader() {
    return myRootClassLoader;
  }

  @Nullable
  protected ClassLoader createRootClassLoader() {
    List<URL> classpath = ListSequence.fromList(new ArrayList<URL>());
    for (String cp : myConfig.getPluginClassPath()) {
      File libJar = new File(cp);
      if (!(libJar.exists())) {
        continue;
      }

      if (libJar.isFile()) {
        try {
          ListSequence.fromList(classpath).addElement(libJar.toURI().toURL());
        } catch (MalformedURLException e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("", e);
          }
        }
      } else {
        File lib = new File(cp + File.separator + "lib");
        if (!(lib.exists()) || !(lib.isDirectory())) {
          continue;
        }

        for (File f : lib.listFiles(PathManager.JAR_FILE_FILTER)) {
          try {
            ListSequence.fromList(classpath).addElement(f.toURI().toURL());
          } catch (MalformedURLException e) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("", e);
            }
          }
        }
      }
    }

    return new UrlClassLoader(classpath, LibraryInitializer.class.getClassLoader());
  }

  @Override
  public synchronized void retain() {
    ++myRefCount;
  }

  @Override
  public void release() {
    if (myRefCount == 0) {
      throw new IllegalStateException("Reference counter is set to zero -- cannot release!");
    }
    --myRefCount;
    if (myRefCount == 0) {
      doDispose();
      EnvironmentContainer.clear();
    }
  }

  @Override
  @NotNull
  public Project createProject(@NotNull ProjectStrategy strategy) {
    checkInitialized();
    return strategy.create(this);
  }

  /**
   * Contract:
   * Returns null if there is no opened project with such File
   */
  @Nullable
  public final Project getOpenedProject(@NotNull File projectFile) {
    checkInitialized();
    return myContainer.getProject(projectFile);
  }

  @Override
  @NotNull
  public Project openProject(@NotNull File projectFile) {
    checkInitialized();
    Project lastUsedProject = getOpenedProject(projectFile);
    if (lastUsedProject != null) {
      if (LOG.isInfoEnabled()) {
        LOG.info("Using the last created project");
      }
      return lastUsedProject;
    } else {
      if (LOG.isInfoEnabled()) {
        LOG.info("Opening a new project");
      }
      Project project = doOpenProject(projectFile);
      flushAllEvents();
      return project;
    }
  }


  @Override
  public void closeProject(@NotNull Project project) {
    checkInitialized();
    project.dispose();
  }

  protected abstract void doDispose();

  protected abstract Project doOpenProject(@NotNull File projectFile);

  @Override
  public final synchronized void dispose() {
    checkInitialized();
    if (LOG.isDebugEnabled()) {
      LOG.debug("Disposing environment");
    }
    myRefCount = 0;
    doDispose();
    if (EnvironmentContainer.get() == this) {
      // FIXME it's not responsibility of EnvironmentBase to clear EnvironmentContainer. 
      // In fact, we don't need EC at all. 
      EnvironmentContainer.clear();
    }
  }

  protected static void setIdeaPluginsToLoad(EnvironmentConfig config) {
    // [MM]: looks like a hack, should we regenerate it to a regular plugin specification?  
    // Probably, with plugin-set-ref to ensure the same plugin set is used 

    // typically, this property is set by generated ant scripts before running tests 
    if (isNotEmptyString(System.getProperty(PLUGINS_PATH))) {
      return;
    }

    // otherwise, we set it from config 
    setPluginPathProperty();
    setPluginIdsPropertyFromConfig(config);
  }

  private static void setPluginIdsPropertyFromConfig(EnvironmentConfig config) {
    StringBuilder result = new StringBuilder();
    Set<PluginDescriptor> plugins = config.getPlugins();
    if (plugins == null) {
      return;
    }
    for (PluginDescriptor plugin : SetSequence.fromSet(plugins)) {
      result.append(plugin.getId());
      result.append(",");
    }
    System.setProperty("idea.load.plugins.id", result.toString());
  }

  protected static void setPluginPathProperty() {
    // [MM]: why do we set ids from config, while path is not config-related? 

    StringBuilder pluginPath = new StringBuilder();
    File pluginDir = new File(PathManager.getPreInstalledPluginsPath());
    if (pluginDir.exists()) {
      for (File pluginFolder : pluginDir.listFiles()) {
        if (pluginPath.length() > 0) {
          pluginPath.append(File.pathSeparator);
        }
        pluginPath.append(pluginFolder.getPath());
      }
      System.setProperty(PLUGINS_PATH, pluginPath.toString());
    }
  }

  protected final void checkInitialized() {
    if (!(myInitialized)) {
      throw new EnvironmentBase.EnvironmentNotInitializedException();
    }
  }

  private static class EnvironmentNotInitializedException extends IllegalStateException {
    public EnvironmentNotInitializedException() {
      super("#init() method must be called before using an environment");
    }
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }
}
