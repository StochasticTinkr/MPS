package jetbrains.mps.lang.migration.runtime.base;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import java.util.Collections;
import jetbrains.mps.util.containers.EmptyIterable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModuleOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.util.Computable;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Map;

public abstract class MigrationScriptBase implements MigrationScript {
  private DataCollector myDC = new MigrationScriptBase.EmptyDataCollector();

  public String getCaption() {
    return "";
  }

  public void setDataCollector(DataCollector dataCollector) {
    myDC = dataCollector;
  }

  protected DataCollector getDataCollector() {
    return myDC;
  }

  public boolean isRerunnable() {
    return false;
  }

  public Iterable<Problem> check(SModule module) {
    return Collections.emptyList();
  }

  public Iterable<MigrationScriptReference> requiresData() {
    return new EmptyIterable<MigrationScriptReference>();
  }

  public Iterable<MigrationScriptReference> executeAfter() {
    return new EmptyIterable<MigrationScriptReference>();
  }

  @Override
  public String toString() {
    return getCaption();
  }

  protected void adjustMigratedIds(SNode node, SNode migrated) {
    if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, false)).contains(migrated))) {
      ((jetbrains.mps.smodel.SNode) migrated).setId(node.getNodeId());
    }
  }

  private static interface SNodePlacePointer {
    boolean isNodeInPlace();
    void insertOrReplace(SNode newNode);
    void remove();
    class ChildPointer implements MigrationScriptBase.SNodePlacePointer {
      private SNode node;
      private SNode parent;
      private SContainmentLink link;
      private SNode nextSibling;
      /*package*/ ChildPointer(SNode node) {
        this.node = node;
        parent = node.getParent();
        link = node.getContainmentLink();
        nextSibling = node.getNextSibling();
      }
      public boolean isNodeInPlace() {
        return node.getParent() == parent;
      }
      public void insertOrReplace(SNode newNode) {
        if (isNodeInPlace()) {
          SNodeUtil.replaceWithAnother(node, newNode);
        } else {
          parent.insertChildBefore(link, newNode, nextSibling);
        }
      }
      public void remove() {
        if (!(isNodeInPlace())) {
          parent.removeChild(node);
        }
      }
    }
    class RootPointer implements MigrationScriptBase.SNodePlacePointer {
      private SNode node;
      private SModel model;
      /*package*/ RootPointer(SNode node) {
        this.node = node;
        model = node.getModel();
      }
      public boolean isNodeInPlace() {
        return node.getParent() == null && node.getModel() == model;
      }
      public void insertOrReplace(SNode newNode) {
        if (isNodeInPlace()) {
          SNodeUtil.replaceWithAnother(node, newNode);
        } else {
          model.addRootNode(newNode);
        }
      }
      public void remove() {
        if (!(isNodeInPlace())) {
          model.removeRootNode(node);
        }
      }
    }
  }
  private static MigrationScriptBase.SNodePlacePointer createSNodePlacePointer(SNode node) {
    if (node.getParent() != null) {
      return new MigrationScriptBase.SNodePlacePointer.ChildPointer(node);
    } else {
      return new MigrationScriptBase.SNodePlacePointer.RootPointer(node);
    }
  }

  public static SNode detachNodePatternVariable(SNode node) {
    return SNodeOperations.detachNode(node);
  }
  public static List<SNode> detachListPatternVariable(List<SNode> nodes) {
    for (SNode node : ListSequence.fromList(nodes)) {
      SNodeOperations.detachNode(node);
    }
    return nodes;
  }

  public boolean isInTransformPattern(SNode node) {
    if (!(SModuleOperations.isAspect(SNodeOperations.getModel(node), "migration"))) {
      return false;
    }
    SNode enclosingPattern = SNodeOperations.getNodeAncestor(node, MetaAdapterFactory.getConcept(0xd4615e3bd6714ba9L, 0xaf012b78369b0ba7L, 0x108a9cb4791L, "jetbrains.mps.lang.pattern.structure.PatternExpression"), false, false);
    return (enclosingPattern != null) && SNodeOperations.hasRole(enclosingPattern, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x4e382b39b6529ec9L, 0x4e382b39b6529eeeL, "pattern"));
  }

  protected void applyTransormMigration(SNode origin, Computable<SNode> migration, _FunctionTypes._void_P2_E0<? super SNode, ? super SNode> postprocess) {
    MigrationScriptBase.SNodePlacePointer pointer = createSNodePlacePointer(origin);
    List<SNode> descendants = SNodeOperations.getNodeDescendants(origin, null, true, new SAbstractConcept[]{});

    SNode migrated = migration.compute();

    if (postprocess != null) {
      postprocess.invoke(origin, migrated);
    }

    if (migrated == null) {
      // origin should be removed 
      pointer.remove();
    } else {
      if (!(ListSequence.fromList(descendants).contains(migrated)) && migrated instanceof jetbrains.mps.smodel.SNode) {
        // returned value is new created node 
        if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(origin, null, false)).contains(migrated))) {
          // origin is not keeped 
          ((jetbrains.mps.smodel.SNode) migrated).setId(origin.getNodeId());
        }
      }
      pointer.insertOrReplace(migrated);
    }
  }

  private class EmptyDataCollector implements DataCollector {
    public EmptyDataCollector() {
    }
    public Map<SModule, SNode> collectData(SModule myModule, MigrationScriptReference scriptReference) {
      return Collections.<SModule,SNode>emptyMap();
    }
  }
}
