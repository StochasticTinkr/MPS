package jetbrains.mps.lang.migration.runtime.base;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.language.LanguageRegistry;
import java.util.LinkedHashSet;
import java.util.Collection;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.apache.log4j.Level;

public class VersionFixer {
  private static final Logger LOG = LogManager.getLogger(VersionFixer.class);
  private SRepository myRepo;
  private SModule myModule;

  public VersionFixer(SRepository repo, SModule module) {
    myRepo = repo;
    myModule = module;
  }

  public boolean importVersionsUpdateRequired() {
    myRepo.getModelAccess().checkReadAccess();

    AbstractModule abstractModule = (AbstractModule) myModule;
    ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + myModule + " has no module descriptor.");
    }

    Map<SModuleReference, Integer> oldDepVersions = Collections.unmodifiableMap(md.getDependencyVersions());
    Map<SModuleReference, Integer> newDepVersions = collectDependencyVersions(abstractModule, oldDepVersions);
    if (!(oldDepVersions.keySet().equals(newDepVersions.keySet()))) {
      return true;
    }

    Map<SLanguage, Integer> oldLangVersions = Collections.unmodifiableMap(md.getLanguageVersions());
    Map<SLanguage, Integer> newLangVersions = collectLanguageVersions(abstractModule, oldLangVersions);
    checkModelVersionsAreValid(myModule, newLangVersions);
    if (!(oldLangVersions.equals(newLangVersions))) {
      return true;
    }

    return false;
  }

  public void updateImportVersions() {
    myRepo.getModelAccess().checkWriteAccess();

    AbstractModule abstractModule = (AbstractModule) myModule;
    ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + myModule + " has not module descriptor.");
    }

    Map<SModuleReference, Integer> depVersions = md.getDependencyVersions();
    Map<SModuleReference, Integer> newDepVersions = collectDependencyVersions(abstractModule, depVersions);
    if (!(depVersions.equals(newDepVersions))) {
      abstractModule.setChanged();
      depVersions.clear();
      depVersions.putAll(newDepVersions);
    }

    Map<SLanguage, Integer> langVersions = md.getLanguageVersions();
    Map<SLanguage, Integer> newLangVersions = collectLanguageVersions(abstractModule, langVersions);
    if (!(langVersions.equals(newLangVersions))) {
      abstractModule.setChanged();
      langVersions.clear();
      langVersions.putAll(newLangVersions);
    }
  }

  private Map<SLanguage, Integer> collectLanguageVersions(SModule module, Map<SLanguage, Integer> oldLangVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    Map<SLanguage, Integer> newLangVersions = new HashMap<SLanguage, Integer>();
    Set<SLanguage> usedLanguages = module.getUsedLanguages();
    SLanguageHierarchy languageHierarchy = new SLanguageHierarchy(LanguageRegistry.getInstance(myRepo), usedLanguages);
    Set<SLanguage> extendingLangsClosure = languageHierarchy.getExtended();
    for (SLanguage lang : extendingLangsClosure) {
      if (oldLangVersions.containsKey(lang)) {
        newLangVersions.put(lang, oldLangVersions.get(lang));
      } else {
        newLangVersions.put(lang, lang.getLanguageVersion());
      }
    }
    return newLangVersions;
  }

  private Map<SModuleReference, Integer> collectDependencyVersions(SModule module, Map<SModuleReference, Integer> oldDepVersions) {
    module.getRepository().getModelAccess().checkReadAccess();

    Map<SModuleReference, Integer> newDepVersions = new HashMap<SModuleReference, Integer>();
    Set<SModule> visible = new LinkedHashSet<SModule>();
    visible.add(module);
    Collection<SModule> dependentModules = new GlobalModuleDependenciesManager(module).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE);
    visible.addAll(dependentModules);
    for (SModule dep : visible) {
      if (oldDepVersions.containsKey(dep.getModuleReference())) {
        newDepVersions.put(dep.getModuleReference(), oldDepVersions.get(dep.getModuleReference()));
      } else {
        newDepVersions.put(dep.getModuleReference(), ((AbstractModule) dep).getModuleVersion());
      }
    }
    return newDepVersions;
  }

  private void checkModelVersionsAreValid(SModule module, Map<SLanguage, Integer> langVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    for (SModel m : module.getModels()) {
      SModelInternal modelInternal = (SModelInternal) m;
      for (SLanguage lang : CollectionSequence.fromCollection(modelInternal.importedLanguageIds())) {
        int currentVersion = langVersions.get(lang);
        int modelVer = modelInternal.getLanguageImportVersion(lang);
        if (modelVer != -1 && modelVer != currentVersion) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Migration assistant detected inconsistency in language versions. Module " + module + " uses language " + lang + " with version " + currentVersion + " while its model " + m.getName() + " uses this language with version " + modelVer);
          }
        }
      }
    }
  }
}
