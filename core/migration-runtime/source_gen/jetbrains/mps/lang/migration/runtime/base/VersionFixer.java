package jetbrains.mps.lang.migration.runtime.base;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.module.SDependency;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.language.LanguageRegistry;
import java.util.LinkedHashSet;
import java.util.Collection;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.apache.log4j.Level;

public class VersionFixer {
  private static final Logger LOG = LogManager.getLogger(VersionFixer.class);
  private Project myProject;
  private SModule myModule;
  private boolean myRemoveOddImports;

  public VersionFixer(Project p, SModule module, boolean removeOddImports) {
    myProject = p;
    myModule = module;
    myRemoveOddImports = removeOddImports;
  }

  public boolean importVersionsUpdateRequired() {
    myProject.getModelAccess().checkReadAccess();
    return doUpdateImportVersions(true);
  }

  public void updateImportVersions() {
    myProject.getModelAccess().checkWriteAccess();
    doUpdateImportVersions(false);
  }

  /**
   * 
   * @param dryRun true means the changes shouldn't be committed to the module
   * @return true if the module differs from updated one
   */
  private boolean doUpdateImportVersions(final boolean dryRun) {
    AbstractModule abstractModule = (AbstractModule) myModule;
    final ModuleDescriptor md = abstractModule.getModuleDescriptor();

    assert md != null : "Module descriptor is null for module " + myModule.getModuleName();
    assert md.getLoadException() == null : "Asked to update import versions in module " + myModule.getModuleName() + " with load exceptions";

    if (myRemoveOddImports) {
      // myRemoveOddImports is used on language+sandbox_solution creation since laguage is not valid yet 
      // in other cases, we do not allow to update import versions (since broken deps may lead to incorrectly optimization) 
      assert areDepsSatisfied(myModule) : "Not all dependencies of module " + myModule.getModuleName() + " are satisfied";
    }

    Map<SModuleReference, Integer> oldDepsFiltered = filterValidDependencyVersions(md.getDependencyVersions());
    Map<SLanguage, Integer> langVersions = filterValidLanguageVersions(md.getLanguageVersions());

    final Wrappers._boolean changed = new Wrappers._boolean(false);

    Map<SModuleReference, Integer> newDepVersions = collectActualDependencyVersions(abstractModule, oldDepsFiltered);
    if (!(oldDepsFiltered.equals(newDepVersions))) {
      if (myRemoveOddImports) {
        Iterable<SModuleReference> keysToRemove = oldDepsFiltered.keySet();
        changed.value = changed.value || Sequence.fromIterable(keysToRemove).isNotEmpty();
        if (!(dryRun)) {
          Sequence.fromIterable(keysToRemove).visitAll(new IVisitor<SModuleReference>() {
            public void visit(SModuleReference it) {
              md.getDependencyVersions().remove(it);
            }
          });
        }
      }
      MapSequence.fromMap(newDepVersions).visitAll(new IVisitor<IMapping<SModuleReference, Integer>>() {
        public void visit(IMapping<SModuleReference, Integer> it) {
          boolean willBeChanged = !(Objects.equals(md.getDependencyVersions().get(it.key()), it.value()));
          changed.value = changed.value || willBeChanged;
          if (willBeChanged && !(dryRun)) {
            md.getDependencyVersions().put(it.key(), it.value());
          }
        }
      });
    }

    Map<SLanguage, Integer> newLangVersions = collectActualLanguageVersions(abstractModule, langVersions);
    if (!(langVersions.equals(newLangVersions))) {
      if (myRemoveOddImports) {
        Iterable<SLanguage> keysToRemove = SetSequence.fromSet(((Set<SLanguage>) langVersions.keySet())).where(new IWhereFilter<SLanguage>() {
          public boolean accept(SLanguage it) {
            return it.isValid();
          }
        });
        changed.value = changed.value || Sequence.fromIterable(keysToRemove).isNotEmpty();
        if (!(dryRun)) {
          Sequence.fromIterable(keysToRemove).visitAll(new IVisitor<SLanguage>() {
            public void visit(SLanguage it) {
              md.getLanguageVersions().remove(it);
            }
          });
        }
      }
      MapSequence.fromMap(newLangVersions).visitAll(new IVisitor<IMapping<SLanguage, Integer>>() {
        public void visit(IMapping<SLanguage, Integer> it) {
          boolean willBeChanged = !(Objects.equals(md.getLanguageVersions().get(it.key()), it.value()));
          changed.value = changed.value || willBeChanged;
          if (willBeChanged && !(dryRun)) {
            md.getLanguageVersions().put(it.key(), it.value());
          }
        }
      });
    }

    // TODO move this check somewhere else 
    checkModelVersionsAreValid(myModule, newLangVersions);

    if (changed.value && !(dryRun)) {
      abstractModule.setChanged();
    }
    return changed.value;
  }

  public boolean areDepsSatisfied() {
    return areDepsSatisfied(myModule);
  }

  private boolean areDepsSatisfied(SModule module) {
    // [MM] beter to move this logic to AbstractModule and its inheritors 
    Set<SLanguage> usedLanguages = module.getUsedLanguages();
    if (SetSequence.fromSet(usedLanguages).any(new IWhereFilter<SLanguage>() {
      public boolean accept(SLanguage it) {
        return !(it.isValid());
      }
    })) {
      return false;
    }

    Iterable<SDependency> deps = module.getDeclaredDependencies();
    if (Sequence.fromIterable(deps).any(new IWhereFilter<SDependency>() {
      public boolean accept(SDependency it) {
        return it.getTarget() == null;
      }
    })) {
      return false;
    }

    if (module instanceof AbstractModule) {
      // todo this should be removed when there's API for accessing devkit "references" 
      Set<SModuleReference> devkits = ((AbstractModule) module).collectLanguagesAndDevkits().devkits;
      if (SetSequence.fromSet(devkits).any(new IWhereFilter<SModuleReference>() {
        public boolean accept(SModuleReference it) {
          return it.resolve(myProject.getRepository()) == null;
        }
      })) {
        return false;
      }
    }

    return true;
  }

  public void addJustCreatedLanguageVersion(SLanguage language, Integer version) {
    myProject.getModelAccess().checkWriteAccess();

    AbstractModule abstractModule = (AbstractModule) myModule;
    ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + myModule + " has not module descriptor.");
    }

    if (md.getLanguageVersions().containsKey(language)) {
      throw new IllegalArgumentException("Module " + myModule + " already contains version for language " + language);
    }

    md.getLanguageVersions().put(language, version);
  }

  private Map<SLanguage, Integer> filterValidLanguageVersions(Map<SLanguage, Integer> langVersions) {
    final Map<SLanguage, Integer> versions = new HashMap<SLanguage, Integer>(langVersions);
    List<SLanguage> missed = SetSequence.fromSet(MapSequence.fromMap(versions).keySet()).where(new IWhereFilter<SLanguage>() {
      public boolean accept(SLanguage it) {
        return !(it.isValid());
      }
    }).toListSequence();
    ListSequence.fromList(missed).visitAll(new IVisitor<SLanguage>() {
      public void visit(SLanguage it) {
        MapSequence.fromMap(versions).removeKey(it);
      }
    });
    return versions;
  }

  private Map<SLanguage, Integer> collectActualLanguageVersions(SModule module, Map<SLanguage, Integer> oldLangVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    Map<SLanguage, Integer> newLangVersions = new HashMap<SLanguage, Integer>();
    Set<SLanguage> usedLanguages = module.getUsedLanguages();
    SLanguageHierarchy languageHierarchy = new SLanguageHierarchy(myProject.getComponent(LanguageRegistry.class), usedLanguages);
    Set<SLanguage> extendingLangsClosure = languageHierarchy.getExtended();
    for (SLanguage lang : extendingLangsClosure) {
      if (!(lang.isValid())) {
        continue;
      }
      if (oldLangVersions.containsKey(lang)) {
        newLangVersions.put(lang, oldLangVersions.get(lang));
      } else {
        newLangVersions.put(lang, lang.getLanguageVersion());
      }
    }
    return newLangVersions;
  }

  private Map<SModuleReference, Integer> filterValidDependencyVersions(Map<SModuleReference, Integer> dependencyVersions) {
    final Map<SModuleReference, Integer> versions = new HashMap<SModuleReference, Integer>(dependencyVersions);
    List<SModuleReference> missed = SetSequence.fromSet(MapSequence.fromMap(versions).keySet()).where(new IWhereFilter<SModuleReference>() {
      public boolean accept(SModuleReference it) {
        return it.resolve(myProject.getRepository()) == null;
      }
    }).toListSequence();
    ListSequence.fromList(missed).visitAll(new IVisitor<SModuleReference>() {
      public void visit(SModuleReference it) {
        MapSequence.fromMap(versions).removeKey(it);
      }
    });
    return versions;
  }

  private Map<SModuleReference, Integer> collectActualDependencyVersions(SModule module, Map<SModuleReference, Integer> oldDepVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    Map<SModuleReference, Integer> newDepVersions = new HashMap<SModuleReference, Integer>();
    Set<SModule> visible = new LinkedHashSet<SModule>();
    visible.add(module);
    Collection<SModule> dependentModules = new GlobalModuleDependenciesManager(module).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE);
    visible.addAll(dependentModules);
    for (SModule dep : visible) {
      if (oldDepVersions.containsKey(dep.getModuleReference())) {
        newDepVersions.put(dep.getModuleReference(), oldDepVersions.get(dep.getModuleReference()));
      } else {
        newDepVersions.put(dep.getModuleReference(), ((AbstractModule) dep).getModuleVersion());
      }
    }
    return newDepVersions;
  }

  private void checkModelVersionsAreValid(SModule myModule, Map<SLanguage, Integer> langVersions) {
    // TODO [MM] get rid of this method, check on model load etc.  
    myModule.getRepository().getModelAccess().checkReadAccess();
    for (SModel m : myModule.getModels()) {
      SModelInternal modelInternal = (SModelInternal) m;
      for (SLanguage lang : CollectionSequence.fromCollection(modelInternal.importedLanguageIds())) {
        Integer currentVersion = langVersions.get(lang);
        if (currentVersion == null) {
          continue;
        }
        int modelVer = modelInternal.getLanguageImportVersion(lang);
        if (modelVer != -1 && modelVer != currentVersion) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Migration assistant detected inconsistency in language versions. Module " + myModule + " uses language " + lang + " with version " + currentVersion + " while its model " + m.getName() + " uses this language with version " + modelVer);
          }
        }
      }
    }
  }
}
