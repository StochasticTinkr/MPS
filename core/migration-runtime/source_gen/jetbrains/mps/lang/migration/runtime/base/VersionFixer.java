package jetbrains.mps.lang.migration.runtime.base;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.language.LanguageRegistry;
import java.util.LinkedHashSet;
import java.util.Collection;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.apache.log4j.Level;

public class VersionFixer {
  private static final Logger LOG = LogManager.getLogger(VersionFixer.class);
  private SRepository myRepo;
  private SModule myModule;

  public VersionFixer(SRepository repo, SModule module) {
    myRepo = repo;
    myModule = module;
  }

  public boolean importVersionsUpdateRequired() {
    myRepo.getModelAccess().checkReadAccess();

    AbstractModule abstractModule = (AbstractModule) myModule;
    ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + myModule + " has no module descriptor.");
    }

    Map<SModuleReference, Integer> oldDepVersions = filterValidDependencyVersions(md);
    Map<SModuleReference, Integer> newDepVersions = collectActualDependencyVersions(abstractModule, oldDepVersions);
    if (!(oldDepVersions.keySet().equals(newDepVersions.keySet()))) {
      return true;
    }

    Map<SLanguage, Integer> oldLangVersions = filterValidLanguageVersions(md);
    Map<SLanguage, Integer> newLangVersions = collectActualLanguageVersions(abstractModule, oldLangVersions);
    checkModelVersionsAreValid(myModule, newLangVersions);
    if (!(oldLangVersions.equals(newLangVersions))) {
      return true;
    }

    return false;
  }

  public void updateImportVersions() {
    myRepo.getModelAccess().checkWriteAccess();

    AbstractModule abstractModule = (AbstractModule) myModule;
    final ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + myModule + " has not module descriptor.");
    }

    Map<SModuleReference, Integer> oldDepsFiltered = filterValidDependencyVersions(md);
    Map<SModuleReference, Integer> newDepVersions = collectActualDependencyVersions(abstractModule, oldDepsFiltered);
    if (!(oldDepsFiltered.equals(newDepVersions))) {
      abstractModule.setChanged();
      Iterable<SModuleReference> keysToRemove = oldDepsFiltered.keySet();
      Sequence.fromIterable(keysToRemove).visitAll(new IVisitor<SModuleReference>() {
        public void visit(SModuleReference it) {
          md.getDependencyVersions().remove(it);
        }
      });
      md.getDependencyVersions().putAll(newDepVersions);
    }

    Map<SLanguage, Integer> langVersions = filterValidLanguageVersions(md);
    Map<SLanguage, Integer> newLangVersions = collectActualLanguageVersions(abstractModule, langVersions);
    if (!(langVersions.equals(newLangVersions))) {
      abstractModule.setChanged();
      Iterable<SLanguage> keysToRemove = SetSequence.fromSet(((Set<SLanguage>) langVersions.keySet())).where(new IWhereFilter<SLanguage>() {
        public boolean accept(SLanguage it) {
          return it.isValid();
        }
      });
      Sequence.fromIterable(keysToRemove).visitAll(new IVisitor<SLanguage>() {
        public void visit(SLanguage it) {
          md.getLanguageVersions().remove(it);
        }
      });
      md.getLanguageVersions().putAll(newLangVersions);
    }
  }

  public void addNewLanguage(SLanguage language, Integer version) {
    myRepo.getModelAccess().checkWriteAccess();

    AbstractModule abstractModule = (AbstractModule) myModule;
    ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + myModule + " has not module descriptor.");
    }

    if (md.getLanguageVersions().containsKey(language)) {
      throw new IllegalArgumentException("Module " + myModule + " already contains version for language " + language);
    }

    md.getLanguageVersions().put(language, version);
  }

  private Map<SLanguage, Integer> filterValidLanguageVersions(ModuleDescriptor md) {
    final Map<SLanguage, Integer> versions = new HashMap<SLanguage, Integer>(md.getLanguageVersions());
    List<SLanguage> missed = SetSequence.fromSet(MapSequence.fromMap(versions).keySet()).where(new IWhereFilter<SLanguage>() {
      public boolean accept(SLanguage it) {
        return !(it.isValid());
      }
    }).toListSequence();
    ListSequence.fromList(missed).visitAll(new IVisitor<SLanguage>() {
      public void visit(SLanguage it) {
        MapSequence.fromMap(versions).removeKey(it);
      }
    });
    return versions;
  }

  private Map<SLanguage, Integer> collectActualLanguageVersions(SModule module, Map<SLanguage, Integer> oldLangVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    Map<SLanguage, Integer> newLangVersions = new HashMap<SLanguage, Integer>();
    Set<SLanguage> usedLanguages = module.getUsedLanguages();
    SLanguageHierarchy languageHierarchy = new SLanguageHierarchy(LanguageRegistry.getInstance(myRepo), usedLanguages);
    Set<SLanguage> extendingLangsClosure = languageHierarchy.getExtended();
    for (SLanguage lang : extendingLangsClosure) {
      if (!(lang.isValid())) {
        continue;
      }
      if (oldLangVersions.containsKey(lang)) {
        newLangVersions.put(lang, oldLangVersions.get(lang));
      } else {
        newLangVersions.put(lang, lang.getLanguageVersion());
      }
    }
    return newLangVersions;
  }

  private Map<SModuleReference, Integer> filterValidDependencyVersions(ModuleDescriptor md) {
    final Map<SModuleReference, Integer> versions = new HashMap<SModuleReference, Integer>(md.getDependencyVersions());
    List<SModuleReference> missed = SetSequence.fromSet(MapSequence.fromMap(versions).keySet()).where(new IWhereFilter<SModuleReference>() {
      public boolean accept(SModuleReference it) {
        return it.resolve(myRepo) == null;
      }
    }).toListSequence();
    ListSequence.fromList(missed).visitAll(new IVisitor<SModuleReference>() {
      public void visit(SModuleReference it) {
        MapSequence.fromMap(versions).removeKey(it);
      }
    });
    return versions;
  }

  private Map<SModuleReference, Integer> collectActualDependencyVersions(SModule module, Map<SModuleReference, Integer> oldDepVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    Map<SModuleReference, Integer> newDepVersions = new HashMap<SModuleReference, Integer>();
    Set<SModule> visible = new LinkedHashSet<SModule>();
    visible.add(module);
    Collection<SModule> dependentModules = new GlobalModuleDependenciesManager(module).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE);
    visible.addAll(dependentModules);
    for (SModule dep : visible) {
      if (oldDepVersions.containsKey(dep.getModuleReference())) {
        newDepVersions.put(dep.getModuleReference(), oldDepVersions.get(dep.getModuleReference()));
      } else {
        newDepVersions.put(dep.getModuleReference(), ((AbstractModule) dep).getModuleVersion());
      }
    }
    return newDepVersions;
  }

  private void checkModelVersionsAreValid(SModule module, Map<SLanguage, Integer> langVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    for (SModel m : module.getModels()) {
      SModelInternal modelInternal = (SModelInternal) m;
      for (SLanguage lang : CollectionSequence.fromCollection(modelInternal.importedLanguageIds())) {
        int currentVersion = langVersions.get(lang);
        int modelVer = modelInternal.getLanguageImportVersion(lang);
        if (modelVer != -1 && modelVer != currentVersion) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Migration assistant detected inconsistency in language versions. Module " + module + " uses language " + lang + " with version " + currentVersion + " while its model " + m.getName() + " uses this language with version " + modelVer);
          }
        }
      }
    }
  }
}
