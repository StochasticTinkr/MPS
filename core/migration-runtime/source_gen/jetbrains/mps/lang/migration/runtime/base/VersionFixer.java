package jetbrains.mps.lang.migration.runtime.base;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.language.LanguageRegistry;
import java.util.LinkedHashSet;
import java.util.Collection;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.apache.log4j.Level;

public class VersionFixer {
  private static final Logger LOG = LogManager.getLogger(VersionFixer.class);
  private SRepository myRepo;
  private SModule myModule;

  public VersionFixer(SRepository repo, SModule module) {
    myRepo = repo;
    myModule = module;
  }

  public boolean importVersionsUpdateRequired() {
    myRepo.getModelAccess().checkReadAccess();
    return doUpdateImportVersions(true);
  }

  public void updateImportVersions() {
    myRepo.getModelAccess().checkWriteAccess();
    doUpdateImportVersions(false);
  }

  /**
   * 
   * 
   * @param dryRun true means the changes shouldn't be committed to the module
   * @return true if the module differs from updated one
   */
  private boolean doUpdateImportVersions(final boolean dryRun) {
    AbstractModule abstractModule = (AbstractModule) myModule;
    final ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + myModule + " has not module descriptor.");
    }

    // this shows whether we can remove versions. If some dep or lang import is invalid, we do not do this as this  
    // "invalid" import may cause another import to become "odd", which is wrong 
    boolean canRemove = true;

    Map<SModuleReference, Integer> oldDepsFiltered = filterValidDependencyVersions(md.getDependencyVersions());
    canRemove = canRemove && oldDepsFiltered.size() == md.getDependencyVersions().size();

    Map<SLanguage, Integer> langVersions = filterValidLanguageVersions(md.getLanguageVersions());
    canRemove = canRemove && langVersions.size() == md.getLanguageVersions().size();

    final Wrappers._boolean changed = new Wrappers._boolean(false);

    Map<SModuleReference, Integer> newDepVersions = collectActualDependencyVersions(abstractModule, oldDepsFiltered);
    if (!(oldDepsFiltered.equals(newDepVersions))) {
      if (canRemove) {
        Iterable<SModuleReference> keysToRemove = oldDepsFiltered.keySet();
        changed.value = changed.value || Sequence.fromIterable(keysToRemove).isNotEmpty();
        if (!(dryRun)) {
          Sequence.fromIterable(keysToRemove).visitAll(new IVisitor<SModuleReference>() {
            public void visit(SModuleReference it) {
              md.getDependencyVersions().remove(it);
            }
          });
        }
      }
      MapSequence.fromMap(newDepVersions).visitAll(new IVisitor<IMapping<SModuleReference, Integer>>() {
        public void visit(IMapping<SModuleReference, Integer> it) {
          boolean willBeChanged = neq_bfw0l_a0a0a0a0a0a1a71a01(md.getDependencyVersions().get(it.key()), it.value());
          changed.value = changed.value || willBeChanged;
          if (willBeChanged && !(dryRun)) {
            md.getDependencyVersions().put(it.key(), it.value());
          }
        }
      });
    }

    Map<SLanguage, Integer> newLangVersions = collectActualLanguageVersions(abstractModule, langVersions);
    if (!(langVersions.equals(newLangVersions))) {
      if (canRemove) {
        Iterable<SLanguage> keysToRemove = SetSequence.fromSet(((Set<SLanguage>) langVersions.keySet())).where(new IWhereFilter<SLanguage>() {
          public boolean accept(SLanguage it) {
            return it.isValid();
          }
        });
        changed.value = changed.value || Sequence.fromIterable(keysToRemove).isNotEmpty();
        if (!(dryRun)) {
          Sequence.fromIterable(keysToRemove).visitAll(new IVisitor<SLanguage>() {
            public void visit(SLanguage it) {
              md.getLanguageVersions().remove(it);
            }
          });
        }
      }
      MapSequence.fromMap(newLangVersions).visitAll(new IVisitor<IMapping<SLanguage, Integer>>() {
        public void visit(IMapping<SLanguage, Integer> it) {
          boolean willBeChanged = neq_bfw0l_a0a0a0a0a0a1a02a01(md.getLanguageVersions().get(it.key()), it.value());
          changed.value = changed.value || willBeChanged;
          if (willBeChanged && !(dryRun)) {
            md.getLanguageVersions().put(it.key(), it.value());
          }
        }
      });
    }

    // TODO move this check somewhere else 
    checkModelVersionsAreValid(myModule, newLangVersions);

    if (changed.value && !(dryRun)) {
      abstractModule.setChanged();
    }
    return changed.value;
  }

  public void addJustCreatedLanguageVersion(SLanguage language, Integer version) {
    myRepo.getModelAccess().checkWriteAccess();

    AbstractModule abstractModule = (AbstractModule) myModule;
    ModuleDescriptor md = abstractModule.getModuleDescriptor();
    if (md == null) {
      throw new IllegalStateException("Module " + myModule + " has not module descriptor.");
    }

    if (md.getLanguageVersions().containsKey(language)) {
      throw new IllegalArgumentException("Module " + myModule + " already contains version for language " + language);
    }

    md.getLanguageVersions().put(language, version);
  }

  private Map<SLanguage, Integer> filterValidLanguageVersions(Map<SLanguage, Integer> langVersions) {
    final Map<SLanguage, Integer> versions = new HashMap<SLanguage, Integer>(langVersions);
    List<SLanguage> missed = SetSequence.fromSet(MapSequence.fromMap(versions).keySet()).where(new IWhereFilter<SLanguage>() {
      public boolean accept(SLanguage it) {
        return !(it.isValid());
      }
    }).toListSequence();
    ListSequence.fromList(missed).visitAll(new IVisitor<SLanguage>() {
      public void visit(SLanguage it) {
        MapSequence.fromMap(versions).removeKey(it);
      }
    });
    return versions;
  }

  private Map<SLanguage, Integer> collectActualLanguageVersions(SModule module, Map<SLanguage, Integer> oldLangVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    Map<SLanguage, Integer> newLangVersions = new HashMap<SLanguage, Integer>();
    Set<SLanguage> usedLanguages = module.getUsedLanguages();
    SLanguageHierarchy languageHierarchy = new SLanguageHierarchy(LanguageRegistry.getInstance(myRepo), usedLanguages);
    Set<SLanguage> extendingLangsClosure = languageHierarchy.getExtended();
    for (SLanguage lang : extendingLangsClosure) {
      if (!(lang.isValid())) {
        continue;
      }
      if (oldLangVersions.containsKey(lang)) {
        newLangVersions.put(lang, oldLangVersions.get(lang));
      } else {
        newLangVersions.put(lang, lang.getLanguageVersion());
      }
    }
    return newLangVersions;
  }

  private Map<SModuleReference, Integer> filterValidDependencyVersions(Map<SModuleReference, Integer> dependencyVersions) {
    final Map<SModuleReference, Integer> versions = new HashMap<SModuleReference, Integer>(dependencyVersions);
    List<SModuleReference> missed = SetSequence.fromSet(MapSequence.fromMap(versions).keySet()).where(new IWhereFilter<SModuleReference>() {
      public boolean accept(SModuleReference it) {
        return it.resolve(myRepo) == null;
      }
    }).toListSequence();
    ListSequence.fromList(missed).visitAll(new IVisitor<SModuleReference>() {
      public void visit(SModuleReference it) {
        MapSequence.fromMap(versions).removeKey(it);
      }
    });
    return versions;
  }

  private Map<SModuleReference, Integer> collectActualDependencyVersions(SModule module, Map<SModuleReference, Integer> oldDepVersions) {
    module.getRepository().getModelAccess().checkReadAccess();
    Map<SModuleReference, Integer> newDepVersions = new HashMap<SModuleReference, Integer>();
    Set<SModule> visible = new LinkedHashSet<SModule>();
    visible.add(module);
    Collection<SModule> dependentModules = new GlobalModuleDependenciesManager(module).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE);
    visible.addAll(dependentModules);
    for (SModule dep : visible) {
      if (oldDepVersions.containsKey(dep.getModuleReference())) {
        newDepVersions.put(dep.getModuleReference(), oldDepVersions.get(dep.getModuleReference()));
      } else {
        newDepVersions.put(dep.getModuleReference(), ((AbstractModule) dep).getModuleVersion());
      }
    }
    return newDepVersions;
  }

  private void checkModelVersionsAreValid(SModule myModule, Map<SLanguage, Integer> langVersions) {
    // TODO [MM] get rid of this method, check on model load etc.  
    myModule.getRepository().getModelAccess().checkReadAccess();
    for (SModel m : myModule.getModels()) {
      SModelInternal modelInternal = (SModelInternal) m;
      for (SLanguage lang : CollectionSequence.fromCollection(modelInternal.importedLanguageIds())) {
        Integer currentVersion = langVersions.get(lang);
        if (currentVersion == null) {
          continue;
        }
        int modelVer = modelInternal.getLanguageImportVersion(lang);
        if (modelVer != -1 && modelVer != currentVersion) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Migration assistant detected inconsistency in language versions. Module " + myModule + " uses language " + lang + " with version " + currentVersion + " while its model " + m.getName() + " uses this language with version " + modelVer);
          }
        }
      }
    }
  }
  private static boolean neq_bfw0l_a0a0a0a0a0a1a71a01(Object a, Object b) {
    return !(((a != null ? a.equals(b) : a == b)));
  }
  private static boolean neq_bfw0l_a0a0a0a0a0a1a02a01(Object a, Object b) {
    return !(((a != null ? a.equals(b) : a == b)));
  }
}
