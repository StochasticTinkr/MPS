package jetbrains.mps.datatransfer;

/*Generated by MPS */

import jetbrains.mps.components.CoreComponent;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModuleOperations;
import jetbrains.mps.util.ConditionalIterable;
import org.jetbrains.mps.util.Condition;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;

public class CopyPasteManager extends AbstractManager implements CoreComponent {
  private static final Logger LOG = LogManager.getLogger(CopyPasteManager.class);
  private static CopyPasteManager INSTANCE;
  private Map<SNode, AbstractManager.Descriptor<PastePostProcessor>> myPostProcessors = null;
  private Map<SNode, AbstractManager.Descriptor<CopyPreProcessor>> myPreProcessors = null;
  private boolean myLoaded = false;
  public CopyPasteManager(ClassLoaderManager classLoaderManager) {
    super(classLoaderManager);
  }

  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }

    INSTANCE = this;
    super.init();
  }

  @Override
  public void dispose() {
    super.dispose();
    INSTANCE = null;
  }

  public void preProcessNode(SNode copy, final Map<SNode, SNode> newNodesToSourceNodes) {
    SNode sourceNode = newNodesToSourceNodes.get(copy);
    CopyPreProcessor preProcessor = getPreProcessor(SNodeOperations.getConceptDeclaration(copy));
    if (preProcessor != null && sourceNode != null) {
      preProcessor.preProcesNode(copy, sourceNode);
    } else {
      ListSequence.fromList(SNodeOperations.getChildren(copy)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          preProcessNode(it, newNodesToSourceNodes);
        }
      });
    }
  }

  public void postProcessNode(SNode node) {
    PastePostProcessor postProcessor = getPostProcessor(SNodeOperations.getConceptDeclaration(node));
    if (postProcessor != null) {
      postProcessor.postProcesNode(node);
    } else {
      ListSequence.fromList(SNodeOperations.getChildren(node)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          postProcessNode(it);
        }
      });
    }
  }

  public CopyPreProcessor getPreProcessor(SNode concept) {
    load();
    AbstractManager.Descriptor<CopyPreProcessor> descriptor = MapSequence.fromMap(myPreProcessors).get(concept);
    return (descriptor == null ? (CopyPreProcessor) null : descriptor.getInstance());
  }

  private PastePostProcessor getPostProcessor(SNode concept) {
    load();
    AbstractManager.Descriptor<PastePostProcessor> descriptor = MapSequence.fromMap(myPostProcessors).get(concept);
    return (descriptor == null ? (PastePostProcessor) null : descriptor.getInstance());
  }

  private void load() {
    if (myLoaded) {
      return;
    }
    myPostProcessors = MapSequence.fromMap(new HashMap<SNode, AbstractManager.Descriptor<PastePostProcessor>>());
    myPreProcessors = MapSequence.fromMap(new HashMap<SNode, AbstractManager.Descriptor<CopyPreProcessor>>());
    for (Language language : ModuleRepositoryFacade.getInstance().getAllModules(Language.class)) {
      SModel actionsModelDescriptor = SModuleOperations.getAspect(language, "actions");
      if (actionsModelDescriptor == null) {
        continue;
      }
      Iterable<SNode> roots = new ConditionalIterable<SNode>(actionsModelDescriptor.getRootNodes(), new Condition<SNode>() {
        public boolean met(SNode node) {
          return SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xaee9cad2acd44608L, 0xaef20004f6a1cdbdL, 0x528ba37dd3383e1eL, "jetbrains.mps.lang.actions.structure.CopyPasteHandlers"));
        }
      });
      for (SNode root : roots) {
        for (SNode preProcessor : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(root, MetaAdapterFactory.getConcept(0xaee9cad2acd44608L, 0xaef20004f6a1cdbdL, 0x528ba37dd3383e1eL, "jetbrains.mps.lang.actions.structure.CopyPasteHandlers")), MetaAdapterFactory.getContainmentLink(0xaee9cad2acd44608L, 0xaef20004f6a1cdbdL, 0x528ba37dd3383e1eL, 0x528ba37dd3383f1fL, "preProcessor")))) {
          MapSequence.fromMap(myPreProcessors).put(SLinkOperations.getTarget(preProcessor, MetaAdapterFactory.getReferenceLink(0xaee9cad2acd44608L, 0xaef20004f6a1cdbdL, 0x528ba37dd3311946L, 0x528ba37dd3317b8dL, "concept")), new AbstractManager.Descriptor<CopyPreProcessor>(language.getModuleName() + "." + LanguageAspect.ACTIONS.getName() + "." + ((String) BHReflection.invoke(preProcessor, SMethodTrimmedId.create("getClassName", MetaAdapterFactory.getConcept(0xaee9cad2acd44608L, 0xaef20004f6a1cdbdL, 0x528ba37dd3311946L, "jetbrains.mps.lang.actions.structure.CopyPreProcessor"), "5abCRRjcnXl"))), language, LOG));
        }
        for (SNode postProcessor : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(root, MetaAdapterFactory.getConcept(0xaee9cad2acd44608L, 0xaef20004f6a1cdbdL, 0x528ba37dd3383e1eL, "jetbrains.mps.lang.actions.structure.CopyPasteHandlers")), MetaAdapterFactory.getContainmentLink(0xaee9cad2acd44608L, 0xaef20004f6a1cdbdL, 0x528ba37dd3383e1eL, 0x528ba37dd3383f1eL, "postProcessor")))) {
          MapSequence.fromMap(myPostProcessors).put(SLinkOperations.getTarget(postProcessor, MetaAdapterFactory.getReferenceLink(0xaee9cad2acd44608L, 0xaef20004f6a1cdbdL, 0x7d4ebb4f893516cL, 0x53a34ae13c0c947bL, "concept")), new AbstractManager.Descriptor<PastePostProcessor>(language.getModuleName() + "." + LanguageAspect.ACTIONS.getName() + "." + ((String) BHReflection.invoke(postProcessor, SMethodTrimmedId.create("getClassName", MetaAdapterFactory.getConcept(0xaee9cad2acd44608L, 0xaef20004f6a1cdbdL, 0x7d4ebb4f893516cL, "jetbrains.mps.lang.actions.structure.PastePostProcessor"), "4IXs4YUz$e_"))), language, LOG));
        }

      }
    }
    myLoaded = true;
  }

  @Override
  public void clearCaches() {
    myPostProcessors = null;
    myPreProcessors = null;
    myLoaded = false;
  }

  public static CopyPasteManager getInstance() {
    return INSTANCE;
  }
}
