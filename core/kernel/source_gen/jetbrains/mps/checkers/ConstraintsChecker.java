package jetbrains.mps.checkers;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.smodel.runtime.impl.CheckingNodeContextImpl;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.runtime.CheckingNodeContext;
import jetbrains.mps.errors.item.NodeReportItem;
import jetbrains.mps.errors.item.RuleIdFlavouredItem;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.runtime.ConstraintsDescriptor;
import jetbrains.mps.smodel.language.ConceptRegistry;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.project.validation.ConceptFeatureMissingError;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.project.validation.ConceptMissingError;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.PropertySupport;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.smodel.runtime.PropertyConstraintsDescriptor;
import jetbrains.mps.errors.item.ConstraintsReportItem;

public class ConstraintsChecker extends AbstractNodeChecker {
  public ConstraintsChecker() {
  }

  private SNodeReference getBreakingRuleAndClearContext(CheckingNodeContextImpl checkingNodeContext) {
    SNodeReference breakingRulePointer = checkingNodeContext.getBreakingNode();
    checkingNodeContext.setBreakingNode(null);
    return breakingRulePointer;
  }
  private void runCheck(LanguageErrorsCollector errorsCollector, final _FunctionTypes._return_P1_E0<? extends Boolean, ? super CheckingNodeContext> check, _FunctionTypes._return_P1_E0<? extends NodeReportItem, ? super RuleIdFlavouredItem.TypesystemRuleId> reportItem) {
    final CheckingNodeContextImpl context = new CheckingNodeContextImpl();
    boolean success = errorsCollector.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>() {
      public Boolean invoke() {
        return check.invoke(context);
      }
    });
    if (!(success)) {
      errorsCollector.addError(reportItem.invoke(new RuleIdFlavouredItem.TypesystemRuleId(context.getBreakingNode())));
    }
  }
  @Override
  public void checkNode(final SNode node, LanguageErrorsCollector errorsCollector, SRepository repository) {
    final SAbstractConcept nodeConcept = SNodeOperations.getConcept(node);
    SNode parent = SNodeOperations.getParent(node);

    ConstraintsDescriptor constraintsDescriptor = ConceptRegistry.getInstance().getConstraintsDescriptor(nodeConcept);
    final CheckingNodeContextImpl checkingNodeContext = new CheckingNodeContextImpl();

    if (parent != null) {
      errorsCollector.addDependency(parent);
      if (SNodeOperations.getConcept(parent).isValid()) {
        SContainmentLink link = node.getContainmentLink();
        if (!(SNodeOperations.getConcept(parent).getContainmentLinks().contains(link))) {
          errorsCollector.addError(new ConceptFeatureMissingError(node, SNodeOperations.getContainingLink(node), "Incorrect child role used: LinkDeclaration with role \"" + SNodeOperations.getContainingLink(node).getName() + "\" was not found in parent node's concept: " + SNodeOperations.getConcept(parent).getName()));
          return;
        }
        boolean canBeChild = errorsCollector.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>() {
          public Boolean invoke() {
            return ModelConstraints.canBeChild(node, checkingNodeContext);
          }
        });
        if (!(canBeChild)) {
          SNodeReference rule = getBreakingRuleAndClearContext(checkingNodeContext);
          errorsCollector.addErrorWithoutDependencies(node, "Node " + node + " cannot be child of node " + parent, rule);
        }
      }
    }

    if ((SNodeOperations.getParent(node) == null)) {
      final SModel model = SNodeOperations.getModel(node);
      boolean canBeRoot = errorsCollector.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>() {
        public Boolean invoke() {
          return ModelConstraints.canBeRoot(nodeConcept, model);
        }
      });
      if (!(canBeRoot)) {
        SNodeReference rule = getBreakingRuleAndClearContext(checkingNodeContext);
        errorsCollector.addErrorWithoutDependencies(node, "Not rootable concept added as root", rule);
      }
    }
    if (!(SNodeOperations.getConcept(node).isValid())) {
      errorsCollector.addError(new ConceptMissingError(node, node.getConcept()));
    }

    for (final SNode child : SNodeOperations.getChildren(node)) {
      boolean canBeParent = errorsCollector.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>() {
        public Boolean invoke() {
          return ModelConstraints.canBeParent(child, checkingNodeContext);
        }
      });
      if (!(canBeParent)) {
        SNodeReference rule = getBreakingRuleAndClearContext(checkingNodeContext);
        errorsCollector.addErrorWithoutDependencies(node, "Node " + node + " cannot be parent of node " + child, rule);
      }
    }

    for (final Wrappers._T<SNode> ancestor = new Wrappers._T<SNode>(parent); ancestor.value != null; ancestor.value = SNodeOperations.getParent(ancestor.value)) {
      boolean canBeAncestor = errorsCollector.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>() {
        public Boolean invoke() {
          return ModelConstraints.canBeAncestorDirect(ancestor.value, node, checkingNodeContext);
        }
      });
      if (!(canBeAncestor)) {
        SNodeReference rule = getBreakingRuleAndClearContext(checkingNodeContext);
        errorsCollector.addErrorWithoutDependencies(node, "Invalid ancestor: " + ancestor.value, rule);
      }
    }

    // Properties validation 
    Iterable<SProperty> props = nodeConcept.getProperties();
    for (final SProperty property : Sequence.fromIterable(props)) {
      final PropertySupport ps = PropertySupport.getPropertySupport(property);
      final String value = ps.fromInternalValue(SNodeAccessUtil.getProperty(node, property));
      final PropertyConstraintsDescriptor propertyDescriptor = constraintsDescriptor.getProperty(property);
      boolean canSetValue = (propertyDescriptor == null ? false : errorsCollector.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>() {
        public Boolean invoke() {
          return ps.canSetValue(propertyDescriptor, node, property, value);
        }
      }));
      if (!(canSetValue)) {
        // todo find a rule 
        errorsCollector.addError(new ConstraintsReportItem.PropertyConstraintReportItem(node, property));
      }
    }
  }
}
