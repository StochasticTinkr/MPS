package jetbrains.mps.checkers;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.errors.item.NodeReportItem;
import jetbrains.mps.errors.item.IssueKindReportItem;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.runtime.CheckingNodeContext;
import jetbrains.mps.errors.item.RuleIdFlavouredItem;
import jetbrains.mps.smodel.runtime.impl.CheckingNodeContextImpl;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.runtime.ConstraintsDescriptor;
import jetbrains.mps.smodel.language.ConceptRegistry;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.project.validation.ConceptFeatureMissingError;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import jetbrains.mps.errors.item.ConstraintsReportItem;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.project.validation.ConceptMissingError;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.PropertySupport;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.smodel.runtime.PropertyConstraintsDescriptor;

public class ConstraintsChecker extends AbstractNodeCheckerInEditor implements IChecker<SNode, NodeReportItem> {
  public ConstraintsChecker() {
  }

  @Override
  public String getCategory() {
    return IssueKindReportItem.CONSTRAINTS;
  }
  @Override
  public IChecker.AbstractNodeChecker.ErrorSkipCondition skipCondition() {
    return AbstractConstraintsCheckerRootCheckerAdapter.SKIP_CONSTRAINTS_CONDITION;
  }
  private void runCheck(LanguageErrorsCollector errorsCollector, final _FunctionTypes._return_P1_E0<? extends Boolean, ? super CheckingNodeContext> check, _FunctionTypes._return_P1_E0<? extends NodeReportItem, ? super RuleIdFlavouredItem.TypesystemRuleId> reportItem) {
    final CheckingNodeContextImpl context = new CheckingNodeContextImpl();
    boolean success = errorsCollector.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>() {
      public Boolean invoke() {
        return check.invoke(context);
      }
    });
    if (!(success)) {
      errorsCollector.addError(reportItem.invoke(new RuleIdFlavouredItem.TypesystemRuleId(context.getBreakingNode())));
    }
  }
  @Override
  public void checkNodeInEditor(final SNode node, LanguageErrorsCollector errorsCollector, SRepository repository) {
    final SAbstractConcept nodeConcept = SNodeOperations.getConcept(node);
    final SNode parent = SNodeOperations.getParent(node);

    ConstraintsDescriptor constraintsDescriptor = ConceptRegistry.getInstance().getConstraintsDescriptor(nodeConcept);

    if (parent != null) {
      errorsCollector.addDependency(parent);
      if (SNodeOperations.getConcept(parent).isValid()) {
        SContainmentLink link = node.getContainmentLink();
        if (!(SNodeOperations.getConcept(parent).getContainmentLinks().contains(link))) {
          errorsCollector.addError(new ConceptFeatureMissingError(node, SNodeOperations.getContainingLink(node), "Incorrect child role used: LinkDeclaration with role \"" + SNodeOperations.getContainingLink(node).getName() + "\" was not found in parent node's concept: " + SNodeOperations.getConcept(parent).getName()));
          return;
        }
        runCheck(errorsCollector, new _FunctionTypes._return_P1_E0<Boolean, CheckingNodeContext>() {
          public Boolean invoke(CheckingNodeContext context) {
            return ModelConstraints.canBeChild(node, context);
          }
        }, new _FunctionTypes._return_P1_E0<ConstraintsReportItem.CanBeChildFailedReportItem, RuleIdFlavouredItem.TypesystemRuleId>() {
          public ConstraintsReportItem.CanBeChildFailedReportItem invoke(RuleIdFlavouredItem.TypesystemRuleId ruleId) {
            return new ConstraintsReportItem.CanBeChildFailedReportItem(node, parent, ruleId);
          }
        });
      }
    }

    if ((SNodeOperations.getParent(node) == null)) {
      final SModel model = SNodeOperations.getModel(node);
      runCheck(errorsCollector, new _FunctionTypes._return_P1_E0<Boolean, CheckingNodeContext>() {
        public Boolean invoke(CheckingNodeContext context) {
          return ModelConstraints.canBeRoot(nodeConcept, model, context);
        }
      }, new _FunctionTypes._return_P1_E0<ConstraintsReportItem.CanBeRootFailedReportItem, RuleIdFlavouredItem.TypesystemRuleId>() {
        public ConstraintsReportItem.CanBeRootFailedReportItem invoke(RuleIdFlavouredItem.TypesystemRuleId ruleId) {
          return new ConstraintsReportItem.CanBeRootFailedReportItem(node, ruleId);
        }
      });
    }
    if (!(SNodeOperations.getConcept(node).isValid())) {
      errorsCollector.addError(new ConceptMissingError(node, node.getConcept()));
    }

    for (final SNode child : SNodeOperations.getChildren(node)) {
      runCheck(errorsCollector, new _FunctionTypes._return_P1_E0<Boolean, CheckingNodeContext>() {
        public Boolean invoke(CheckingNodeContext context) {
          return ModelConstraints.canBeParent(child, context);
        }
      }, new _FunctionTypes._return_P1_E0<ConstraintsReportItem.CanBeParentFailedReportItem, RuleIdFlavouredItem.TypesystemRuleId>() {
        public ConstraintsReportItem.CanBeParentFailedReportItem invoke(RuleIdFlavouredItem.TypesystemRuleId ruleId) {
          return new ConstraintsReportItem.CanBeParentFailedReportItem(node, child, ruleId);
        }
      });
    }

    for (final Wrappers._T<SNode> ancestor = new Wrappers._T<SNode>(parent); ancestor.value != null; ancestor.value = SNodeOperations.getParent(ancestor.value)) {
      runCheck(errorsCollector, new _FunctionTypes._return_P1_E0<Boolean, CheckingNodeContext>() {
        public Boolean invoke(CheckingNodeContext context) {
          return ModelConstraints.canBeAncestorDirect(ancestor.value, node, context);
        }
      }, new _FunctionTypes._return_P1_E0<ConstraintsReportItem.CanBeAncestorFailedReportItem, RuleIdFlavouredItem.TypesystemRuleId>() {
        public ConstraintsReportItem.CanBeAncestorFailedReportItem invoke(RuleIdFlavouredItem.TypesystemRuleId ruleId) {
          return new ConstraintsReportItem.CanBeAncestorFailedReportItem(node, ancestor.value, ruleId);
        }
      });
    }

    // Properties validation 
    Iterable<SProperty> props = nodeConcept.getProperties();
    for (final SProperty property : Sequence.fromIterable(props)) {
      final PropertySupport ps = PropertySupport.getPropertySupport(property);
      final String value = ps.fromInternalValue(SNodeAccessUtil.getProperty(node, property));
      final PropertyConstraintsDescriptor propertyDescriptor = constraintsDescriptor.getProperty(property);
      boolean canSetValue = (propertyDescriptor == null ? false : errorsCollector.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>() {
        public Boolean invoke() {
          return ps.canSetValue(propertyDescriptor, node, property, value);
        }
      }));
      if (!(canSetValue)) {
        // todo find a rule 
        errorsCollector.addError(new ConstraintsReportItem.PropertyConstraintReportItem(node, property));
      }
    }
  }
}
