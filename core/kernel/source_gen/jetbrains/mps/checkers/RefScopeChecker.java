package jetbrains.mps.checkers;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.resolve.ReferenceResolverUtils;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.constraints.ReferenceDescriptor;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.scope.ErrorScope;
import jetbrains.mps.errors.item.LanguageErrorItem;
import jetbrains.mps.smodel.runtime.ReferenceScopeProvider;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.errors.item.OutOfScopeReferenceReportItem;
import jetbrains.mps.errors.item.EditorQuickFix;
import jetbrains.mps.errors.item.NodeFeatureFlavouredItem;
import jetbrains.mps.resolve.ResolverComponent;
import java.util.Set;
import jetbrains.mps.errors.item.FlavouredItem;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;

import org.jetbrains.mps.openapi.language.SConceptFeature;

public class RefScopeChecker extends AbstractNodeChecker {
  public RefScopeChecker() {
  }
  @Override
  public void checkNode(SNode node, LanguageErrorsCollector errorsCollector, SRepository repository) {
    if (node == null || SNodeOperations.getModel(node) == null) {
      return;
    }
    SModule module = SNodeOperations.getModel(node).getModule();
    if (module == null) {
      return;
    }
    boolean executeImmediately = ReferenceResolverUtils.canExecuteImmediately(SNodeOperations.getModel(node), repository);
    for (SReference ref : SNodeOperations.getReferences(node)) {
      SNode target = SLinkOperations.getTargetNode(ref);
      if (target == null) {
        continue;
      }
      // don't check unresolved and broken references, they should already have an error message 
      // do we need all these additional dependencies? mb. it's better to use .runcheckingAction() instead? 
      errorsCollector.addDependency(target);
      errorsCollector.addDependency(SNodeOperations.getParent(node));
      for (SNode c : SNodeOperations.getChildren(node)) {
        errorsCollector.addDependency(c);
      }
      ReferenceDescriptor refDescriptor = ModelConstraints.getReferenceDescriptor(ref);
      Scope refScope = refDescriptor.getScope();
      if (refScope instanceof ErrorScope) {
        errorsCollector.addError(new LanguageErrorItem.ReferenceItem((ErrorScope) refScope, ref));
      } else if (!(refScope.contains(target))) {
        ReferenceScopeProvider scopeProvider = refDescriptor.getScopeProvider();
        SNodeReference ruleNode = null;
        if (scopeProvider != null) {
          ruleNode = scopeProvider.getSearchScopeValidatorNode();
        }
        errorsCollector.addError(new OutOfScopeReferenceReportItem(ref, ruleNode, createResolveReferenceQuickfix(ref, repository, executeImmediately)));
      }
    }
  }
  protected EditorQuickFix createResolveReferenceQuickfix(SReference reference, SRepository repository, boolean executeImmediately) {
    return new RefScopeChecker.ResolveReferenceQuickFix(reference, executeImmediately);
  }
  protected static class ResolveReferenceQuickFix implements EditorQuickFix, NodeFeatureFlavouredItem {
    protected SReference myReference;
    private boolean myExecuteImmediately;
    public ResolveReferenceQuickFix(SReference reference, boolean executeImmediately) {
      myReference = reference;
      myExecuteImmediately = executeImmediately;
    }
    @Override
    public void execute(SRepository repository) {
      ResolverComponent.getInstance().resolve(myReference, repository);
    }
    @Override
    public String getDescription(SRepository repository) {
      return "Resolve \"" + myReference.getLink().getName() + "\" reference";
    }
    @Override
    public boolean isExecutedImmediately() {
      return myExecuteImmediately;
    }
    @Override
    public Set<FlavouredItem.ReportItemFlavour<?, ?>> getIdFlavours() {
      return SetSequence.fromSetAndArray(new HashSet<FlavouredItem.ReportItemFlavour<?, ?>>(), FlavouredItem.FLAVOUR_CLASS, FLAVOUR_NODE, FLAVOUR_NODE_FEATURE);
    }
    @Override
    public SConceptFeature getConceptFeature() {
      return myReference.getLink();
    }
    @Override
    public SNodeReference getNode() {
      return myReference.getSourceNode().getReference();
    }
    @Override
    public boolean isAlive(SRepository repository) {
      return myReference.getSourceNode().getModel() != null;
    }
  }
}
