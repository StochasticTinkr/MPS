package jetbrains.mps.checkers;

/*Generated by MPS */

import jetbrains.mps.errors.item.ReportItem;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.List;
import java.util.Collections;
import jetbrains.mps.errors.item.IssueKindReportItem;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.errors.item.NodeReportItem;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

/**
 * Base interface for custom checkers.
 * Custom checker should extend one of the following base classes depending on preciseness of the checker
 */
public interface IChecker<O, I extends ReportItem> extends IAbstractChecker<O, I> {
  String getCategory();

  /**
   * represents some contract that checker declares to satisfy
   */
  abstract class CheckerOutputConvention<O, I extends ReportItem> {
    public abstract String check(O checked, I checkerOuput, SRepository repository);
  }

  abstract class AbstractChecker<O, I extends ReportItem> implements IChecker<O, I> {
    public List<IChecker.CheckerOutputConvention<O, I>> getOutputConventions() {
      return Collections.emptyList();
    }
  }

  abstract class AbstractModuleChecker<I extends IssueKindReportItem> extends IChecker.AbstractChecker<SModule, I> {
  }

  abstract class AbstractModelChecker<I extends IssueKindReportItem> extends IChecker.AbstractChecker<SModel, I> {
  }

  abstract class AbstractRootChecker<I extends NodeReportItem> extends IChecker.AbstractChecker<SNode, I> {
    @Override
    public List<IChecker.CheckerOutputConvention<SNode, I>> getOutputConventions() {
      return ListSequence.fromListAndArray(new ArrayList<IChecker.CheckerOutputConvention<SNode, I>>(), new IChecker.CheckerOutputConvention<SNode, I>() {
        @Override
        public String check(SNode root, I checkerOuput, SRepository repository) {
          SNode reportedNode = checkerOuput.getNode().resolve(repository);
          if (reportedNode == null) {
            return "Checker reported error for node that do not exist in repository. node=" + checkerOuput.getNode();
          }
          if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(reportedNode, null, true)).contains(root))) {
            return "Checker returned error for node " + reportedNode.getReference() + " that do not belong to root " + root.getReference();
          }
          return null;
        }
      });
    }
  }

  abstract class AbstractNodeChecker<I extends NodeReportItem> extends IChecker.AbstractChecker<SNode, I> {
    @Override
    public List<IChecker.CheckerOutputConvention<SNode, I>> getOutputConventions() {
      return ListSequence.fromListAndArray(new ArrayList<IChecker.CheckerOutputConvention<SNode, I>>(), new IChecker.CheckerOutputConvention<SNode, I>() {
        @Override
        public String check(SNode checked, I checkerOuput, SRepository repository) {
          if (neq_6h4aza_a0a0a0a1a0a0m(checkerOuput.getNode(), checked.getReference())) {
            return "Checker returned error for node " + checkerOuput.getNode() + " while it was asked for node " + checked.getReference();
          }
          return null;
        }
      });
    }
    public AbstractConstraintsCheckerRootCheckerAdapter.ErrorSkipCondition skipCondition() {
      return AbstractConstraintsCheckerRootCheckerAdapter.SKIP_NOTHING_CONDITION;
    }
    private static boolean neq_6h4aza_a0a0a0a1a0a0m(Object a, Object b) {
      return !(((a != null ? a.equals(b) : a == b)));
    }
  }

}
