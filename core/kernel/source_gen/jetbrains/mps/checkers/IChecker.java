package jetbrains.mps.checkers;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.errors.item.IssueKindReportItem;
import jetbrains.mps.errors.item.IssueKindReportItem.CheckerCategory;
import jetbrains.mps.errors.item.NodeReportItem;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.util.Consumer;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import org.jetbrains.mps.util.DescendantsTreeIterator;

import java.util.ArrayList;
import java.util.List;

/**
 * Base interface for custom checkers.
 * Custom checker should extend one of the following base classes depending on preciseness of the checker
 */
public interface IChecker<O, I extends IssueKindReportItem> extends IAbstractChecker<O, I> {
  CheckerCategory getCategory();


  abstract class AbstractChecker<O, I extends IssueKindReportItem> implements IChecker<O, I> {
  }

  abstract class AbstractModuleChecker<I extends IssueKindReportItem> extends IChecker.AbstractChecker<SModule, I> {
  }

  abstract class AbstractModelChecker<I extends IssueKindReportItem> extends IChecker.AbstractChecker<SModel, I> {
  }

  /**
   * returned errors are expected to belong to nodes under given root
   */
  abstract class AbstractRootChecker<I extends NodeReportItem> extends IChecker.AbstractChecker<SNode, I> {
    public IChecker.AbstractModelChecker<I> asModelChecker() {
      final IAbstractChecker<SModel, I> result = new IteratingChecker<SModel, SNode, I>(this, new _FunctionTypes._return_P1_E0<IteratingChecker.CollectionIteratorWithProgress<SNode>, SModel>() {
        public IteratingChecker.CollectionIteratorWithProgress<SNode> invoke(SModel model) {
          return new IteratingChecker.CollectionIteratorWithProgress<SNode>(SModelOperations.roots(model, null));
        }
      });
      return new IChecker.AbstractModelChecker<I>() {
        public CheckerCategory getCategory() {
          return AbstractRootChecker.this.getCategory();
        }
        @Override
        public String toString() {
          return AbstractRootChecker.this.toString();
        }
        @Override
        public void check(SModel model, SRepository repository, Consumer<? super I> errorCollector, ProgressMonitor monitor) {
          result.check(model, repository, errorCollector, monitor);
        }
      };
    }
  }

  /**
   * returned errors are expected to belong to given node
   */
  abstract class AbstractNodeChecker<I extends NodeReportItem> extends IChecker.AbstractChecker<SNode, I> {
    public IChecker.AbstractRootChecker<I> asRootChecker() {
      final IteratingChecker<SNode, SNode, I> skippingChecker = new IteratingChecker<SNode, SNode, I>(this, new _FunctionTypes._return_P1_E0<IteratingChecker.CollectionIteratorWithProgress<SNode>, SNode>() {
        public IteratingChecker.CollectionIteratorWithProgress<SNode> invoke(SNode root) {
          List<SNode> toCheck = ListSequence.fromList(new ArrayList<SNode>());
          DescendantsTreeIterator fullCheckIterator = new DescendantsTreeIterator(root);
          while (fullCheckIterator.hasNext()) {
            SNode node = fullCheckIterator.next();
            if (AbstractNodeChecker.this.skipCondition().skipSubtree(node)) {
              fullCheckIterator.skipChildren();
              continue;
            }
            if (AbstractNodeChecker.this.skipCondition().skipSingleNode(node)) {
              continue;
            }
            ListSequence.fromList(toCheck).addElement(node);
          }
          return new IteratingChecker.CollectionIteratorWithProgress<SNode>(toCheck);
        }
      });
      return new IChecker.AbstractRootChecker<I>() {
        public CheckerCategory getCategory() {
          return AbstractNodeChecker.this.getCategory();
        }
        @Override
        public String toString() {
          return AbstractNodeChecker.this.toString();
        }
        @Override
        public void check(SNode root, SRepository repository, Consumer<? super I> errorCollector, ProgressMonitor monitor) {
          skippingChecker.check(root, repository, errorCollector, monitor);
        }
      };
    }
    public IChecker.AbstractModelChecker<I> asModelChecker() {
      return this.asRootChecker().asModelChecker();
    }
    public IChecker.AbstractNodeChecker.ErrorSkipCondition skipCondition() {
      return SKIP_NOTHING_CONDITION;
    }
    public interface ErrorSkipCondition {
      boolean skipSingleNode(SNode node);
      boolean skipSubtree(SNode root);
    }
    public static final IChecker.AbstractNodeChecker.ErrorSkipCondition SKIP_NOTHING_CONDITION = new IChecker.AbstractNodeChecker.ErrorSkipCondition() {
      public boolean skipSingleNode(SNode node) {
        return false;
      }
      public boolean skipSubtree(SNode root) {
        return false;
      }
    };
  }

}
