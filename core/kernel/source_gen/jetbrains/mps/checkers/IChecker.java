package jetbrains.mps.checkers;

/*Generated by MPS */

import jetbrains.mps.errors.item.ReportItem;
import jetbrains.mps.errors.item.IssueKindReportItem;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.errors.item.NodeReportItem;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.util.Consumer;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.util.DescendantsTreeIterator;

/**
 * Base interface for custom checkers.
 * Custom checker should extend one of the following base classes depending on preciseness of the checker
 */
public interface IChecker<O, I extends ReportItem> extends IAbstractChecker<O, I> {
  String getCategory();


  abstract class AbstractChecker<O, I extends ReportItem> implements IChecker<O, I> {
  }

  abstract class AbstractModuleChecker<I extends IssueKindReportItem> extends IChecker.AbstractChecker<SModule, I> {
    private static List<SModel> getModels(SModule module, boolean checkStubs) {
      List<SModel> modelDescrpitors = ListSequence.fromList(new ArrayList<SModel>());
      for (SModel modelDescriptor : Sequence.fromIterable(module.getModels())) {
        if (SModelStereotype.isUserModel(modelDescriptor)) {
          ListSequence.fromList(modelDescrpitors).addElement(modelDescriptor);
        }
        if (checkStubs && SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(modelDescriptor))) {
          ListSequence.fromList(modelDescrpitors).addElement(modelDescriptor);
        }
      }
      if (module instanceof Language) {
        Language language = (Language) module;
        for (Generator generator : CollectionSequence.fromCollection(language.getGenerators())) {
          ListSequence.fromList(modelDescrpitors).addSequence(ListSequence.fromList(getModels(generator, checkStubs)));
        }
      }
      return modelDescrpitors;
    }
    public static <I extends NodeReportItem> IChecker.AbstractModuleChecker<I> wrapModelChecker(IChecker.AbstractModelChecker<I> modelChecker, final boolean checkStubs) {
      // todo: handle progress correctly 
      final IChecker<SModule, I> result = new IteratingChecker<SModule, SModel, I>(modelChecker, new _FunctionTypes._return_P1_E0<IteratingChecker.CollectionIteratorWithProgress<SModel>, SModule>() {
        public IteratingChecker.CollectionIteratorWithProgress<SModel> invoke(SModule module) {
          return new IteratingChecker.CollectionIteratorWithProgress<SModel>(getModels(module, checkStubs));
        }
      });
      return new IChecker.AbstractModuleChecker<I>() {
        public String getCategory() {
          return result.getCategory();
        }
        @Override
        public void check(SModule toCheck, SRepository repository, Consumer<? super I> errorCollector, ProgressMonitor monitor) {
          result.check(toCheck, repository, errorCollector, monitor);
        }
      };
    }
  }

  abstract class AbstractModelChecker<I extends IssueKindReportItem> extends IChecker.AbstractChecker<SModel, I> {
    public static <I extends NodeReportItem> IChecker.AbstractModelChecker<I> wrapRootChecker(IChecker.AbstractNodeChecker<I> nodeChecker) {
      final IChecker<SModel, I> result = new IteratingChecker<SModel, SNode, I>(nodeChecker, new _FunctionTypes._return_P1_E0<IteratingChecker.CollectionIteratorWithProgress<SNode>, SModel>() {
        public IteratingChecker.CollectionIteratorWithProgress<SNode> invoke(SModel model) {
          return new IteratingChecker.CollectionIteratorWithProgress<SNode>(SModelOperations.roots(model, null));
        }
      });
      return new IChecker.AbstractModelChecker<I>() {
        public String getCategory() {
          return result.getCategory();
        }
        @Override
        public void check(SModel toCheck, SRepository repository, Consumer<? super I> errorCollector, ProgressMonitor monitor) {
          result.check(toCheck, repository, errorCollector, monitor);
        }
      };
    }
  }

  abstract class AbstractRootChecker<I extends NodeReportItem> extends IChecker.AbstractChecker<SNode, I> {
    public static <I extends NodeReportItem> IChecker.AbstractRootChecker<I> wrapNodeChecker(final IChecker.AbstractNodeChecker<I> nodeChecker) {
      IteratingChecker<SNode, SNode, I> skippingSubtreeChecker = new IteratingChecker<SNode, SNode, I>(nodeChecker, new _FunctionTypes._return_P1_E0<IteratingChecker.CollectionIteratorWithProgress<SNode>, SNode>() {
        public IteratingChecker.CollectionIteratorWithProgress<SNode> invoke(SNode root) {
          List<SNode> toCheck = ListSequence.fromList(new ArrayList<SNode>());
          DescendantsTreeIterator fullCheckIterator = new DescendantsTreeIterator(root);
          while (fullCheckIterator.hasNext()) {
            SNode node = fullCheckIterator.next();
            if (nodeChecker.skipCondition().skipSubtree(node)) {
              fullCheckIterator.skipChildren();
              continue;
            }
            ListSequence.fromList(toCheck).addElement(node);
          }
          return new IteratingChecker.CollectionIteratorWithProgress<SNode>(toCheck);
        }
      });
      final IChecker<SNode, I> filtering = new FilteringChecker<SNode, I>(skippingSubtreeChecker, new _FunctionTypes._return_P2_E0<Boolean, NodeReportItem, SRepository>() {
        public Boolean invoke(NodeReportItem reportItem, SRepository repository) {
          return !(nodeChecker.skipCondition().skipSingleNode(reportItem.getNode().resolve(repository)));
        }
      });
      return new IChecker.AbstractRootChecker<I>() {
        public String getCategory() {
          return filtering.getCategory();
        }
        @Override
        public void check(SNode toCheck, SRepository repository, Consumer<? super I> errorCollector, ProgressMonitor monitor) {
          filtering.check(toCheck, repository, errorCollector, monitor);
        }
      };
    }
  }

  abstract class AbstractNodeChecker<I extends NodeReportItem> extends IChecker.AbstractChecker<SNode, I> {
    public IChecker.AbstractNodeChecker.ErrorSkipCondition skipCondition() {
      return SKIP_NOTHING_CONDITION;
    }
    public interface ErrorSkipCondition {
      boolean skipSingleNode(SNode node);
      boolean skipSubtree(SNode root);
    }
    public static final IChecker.AbstractNodeChecker.ErrorSkipCondition SKIP_NOTHING_CONDITION = new IChecker.AbstractNodeChecker.ErrorSkipCondition() {
      public boolean skipSingleNode(SNode node) {
        return false;
      }
      public boolean skipSubtree(SNode root) {
        return false;
      }
    };
  }

}
