package jetbrains.mps.project.structure;

/*Generated by MPS */

import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.components.CoreComponent;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SModelId;
import java.util.concurrent.ConcurrentHashMap;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import jetbrains.mps.extapi.module.SRepositoryExt;
import org.jetbrains.mps.openapi.module.SModuleListener;
import org.jetbrains.mps.openapi.module.SModuleAdapter;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.util.annotation.Hack;
import org.apache.log4j.Level;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.DefaultModelAccess;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SRepositoryListener;
import org.jetbrains.mps.openapi.module.SRepositoryListenerBase;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.DevKit;
import java.util.List;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.extapi.model.SModelBase;
import org.jetbrains.mps.openapi.module.SModuleId;
import jetbrains.mps.smodel.SModelStereotype;
import java.util.ArrayList;
import jetbrains.mps.smodel.RegularModelDescriptor;
import org.jetbrains.mps.openapi.persistence.NullDataSource;
import jetbrains.mps.smodel.ModelLoadResult;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.project.structure.stub.ProjectStructureBuilder;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.nodeidmap.ForeignNodeIdMap;
import jetbrains.mps.smodel.FastNodeFinder;
import jetbrains.mps.smodel.BaseFastNodeFinder;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class ProjectStructureModule extends AbstractModule implements CoreComponent {
  private static final String MODULE_REF = "642f71f8-327a-425b-84f9-44ad58786d27(jetbrains.mps.lang.project.modules)";
  private Map<SModelId, ProjectStructureModule.ProjectStructureSModelDescriptor> myModels = new ConcurrentHashMap<SModelId, ProjectStructureModule.ProjectStructureSModelDescriptor>();
  private static ProjectStructureModule INSTANCE;
  private final MPSModuleOwner myOwner = new BaseMPSModuleOwner();
  private final SRepositoryExt myRepository;
  private final SModuleListener myModuleListener = new SModuleAdapter() {
    @Override
    public void modelAdded(SModule module, SModel model) {
      runInWrite(module);
    }

    /**
     * bad hack, will go away in 3.4 after we ensure that #modelAdded always has the write lock (as #modelRemoved now)
     */
    @Hack
    private void runInWrite(final SModule module) {
      if (myRepository.getModelAccess().canWrite()) {
        refreshModule(module, false);
      } else {
        if (LOG.isEnabledFor(Level.WARN)) {
          LOG.warn("Running project structure module refresh asynchronously; no write action here", new Throwable());
        }
        if (!(ModelAccess.instance() instanceof DefaultModelAccess)) {
          myRepository.getModelAccess().runWriteInEDT(new Runnable() {
            public void run() {
              refreshModule(module, false);
            }
          });
        } else {
          String message = "We have DefaultModelAccess, asynchronous call is not possible here; the project structure module is not updated";
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error(message, new Throwable());
          }
        }
      }
    }

    @Override
    public void modelRemoved(SModule module, SModelReference reference) {
      refreshModule(module, false);
    }
  };

  private final SRepositoryListener myListener = new SRepositoryListenerBase() {
    @Override
    public void moduleAdded(@NotNull SModule module) {
      refreshModule(module, false);
      module.addModuleListener(myModuleListener);
    }

    @Override
    public void beforeModuleRemoved(@NotNull SModule module) {
      module.removeModuleListener(myModuleListener);
      refreshModule(module, true);
    }
  };

  /**
   * 
   * @deprecated use {@link jetbrains.mps.project.structure.ProjectStructureModule#getInstance(SRepository) } instead
   */
  @Deprecated
  @ToRemove(version = 3.3)
  public static ProjectStructureModule getInstance() {
    return INSTANCE;
  }

  /**
   * There's single ProjectStructureModule per project, thus if you use Project.getRepository(), you are guaranteed to get an instance. 
   */
  @Nullable
  public static ProjectStructureModule getInstance(@NotNull SRepository repo) {
    // FIXME likely, shall do it with myModuleRef.resolve(mpsProject.getRepository) 
    // Generally, I'd prefer plain SModule as return value, however exact instance of the class are needed to access #getModelByModule. 
    // The only reason to have a helper access method here is to hide module reference we use (so that client code shall not keep MODULE_REF). 
    return getInstance();
  }

  public ProjectStructureModule(@NotNull SRepositoryExt repository, @NotNull PersistenceFacade persistenceFacade) {
    myRepository = repository;
    setModuleReference(persistenceFacade.createModuleReference(MODULE_REF));
  }

  private void refreshModule(SModule module, boolean isDeleted) {
    assertCanChange();
    if (!((module instanceof Solution || module instanceof Language || module instanceof DevKit))) {
      return;
    }
    SModelReference ref = getSModelReference(module);
    if (isDeleted) {
      ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
      if (descriptor != null) {
        removeModel(descriptor);
      }
    } else
    if (myModels.containsKey(ref.getModelId())) {
      ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
      descriptor.originalModuleChanged();
    } else {
      createModel(module);
    }
  }

  public SModel getModelByModule(SModule module) {
    myRepository.getModelAccess().checkReadAccess();
    if (module == null) {
      return null;
    }
    SModelReference ref = getSModelReference(module);
    ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
    return (descriptor == null ? null : descriptor);
  }

  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myRepository.addRepositoryListener(myListener);
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        myRepository.registerModule(ProjectStructureModule.this, myOwner);
      }
    });
  }

  @Override
  public void dispose() {
    // it is disposed as CoreComponent 
    if (INSTANCE == null) {
      return;
    }
    INSTANCE = null;
    clearAll();
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        myRepository.unregisterModule(ProjectStructureModule.this, myOwner);
      }
    });
    myRepository.removeRepositoryListener(myListener);
  }

  public void clearAll() {
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        removeAll();
        dependenciesChanged();
        myModels.clear();
      }
    });
  }

  private void removeAll() {
    List<SModel> models = getProjectStructureModels();
    for (SModel model : models) {
      removeModel(model);
    }
  }

  @Override
  public Set<SLanguage> getUsedLanguages() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x86ef829012bb4ca7L, 0x947f093788f263a9L), "jetbrains.mps.lang.project"));
  }

  private void removeModel(SModel md) {
    if (myModels.remove(md.getReference().getModelId()) != null) {
      md.unload();
      unregisterModel((SModelBase) md);
    }
  }

  public ProjectStructureModule.ProjectStructureSModelDescriptor createModel(SModule module) {
    ProjectStructureModule.ProjectStructureSModelDescriptor result = new ProjectStructureModule.ProjectStructureSModelDescriptor(getSModelReference(module), module);
    myModels.put(getSModelReference(module).getModelId(), result);
    registerModel(result);
    return result;
  }

  private SModelReference getSModelReference(SModule module) {
    SModuleId moduleId = module.getModuleReference().getModuleId();
    SModelId id = (moduleId != null ? jetbrains.mps.smodel.SModelId.foreign("project", moduleId.toString()) : null);
    return new jetbrains.mps.smodel.SModelReference(this.getModuleReference(), id, "module." + module.getModuleName() + "@" + SModelStereotype.getStubStereotypeForId("project"));
  }
  public String toString() {
    return getModuleName();
  }
  private List<SModel> getProjectStructureModels() {
    return new ArrayList<SModel>(myModels.values());
  }
  @Override
  protected void collectFacetTypes(Set<String> types) {
    // none 
  }
  @Override
  public SModel resolveInDependencies(SModelId ref) {
    return myModels.get(ref);
  }

  public class ProjectStructureSModelDescriptor extends RegularModelDescriptor {
    private final SModule myModule;
    private ProjectStructureSModelDescriptor(SModelReference ref, SModule module) {
      super(ref, new NullDataSource());
      myModule = module;
    }
    @Override
    @NotNull
    protected ModelLoadResult<jetbrains.mps.smodel.SModel> createModel() {
      final ProjectStructureModule.ProjectStructureSModel model = new ProjectStructureModule.ProjectStructureSModel(getReference());
      final ModuleDescriptor moduleDescriptor = ((AbstractModule) myModule).getModuleDescriptor();
      final IFile file = ((AbstractModule) myModule).getDescriptorFile();
      if (file != null && moduleDescriptor != null) {
        NodeReadAccessCasterInEditor.runReadTransparentAction(new Runnable() {
          @Override
          public void run() {
            new ProjectStructureBuilder(moduleDescriptor, file, model) {
              @Override
              public Iterable<SModelReference> loadReferences(SNode m, ModuleDescriptor descriptor) {
                SModule module = (moduleDescriptor == descriptor ? myModule : ModuleRepositoryFacade.getInstance().getModule(descriptor.getModuleReference()));
                if (module == null) {
                  return Collections.emptyList();
                }
                return Sequence.fromIterable(module.getModels()).where(new IWhereFilter<SModel>() {
                  @Override
                  public boolean accept(SModel o) {
                    return SModelStereotype.isUserModel(o);
                  }
                }).select(new ISelector<SModel, SModelReference>() {
                  @Override
                  public SModelReference select(SModel o) {
                    return o.getReference();
                  }
                });
              }
            }.convert();
          }
        });
      }
      return new ModelLoadResult<jetbrains.mps.smodel.SModel>(model, ModelLoadingState.FULLY_LOADED);
    }
    /*package*/ void originalModuleChanged() {
      jetbrains.mps.smodel.SModel oldModel = getCurrentModelInternal();
      if (oldModel == null) {
        return;
      }
      unload();
      // since we know the module is still there (just has been changed), tell those not caring about unload 
      // that the content of the model is new (instead of a null, could pass getSModelInternal(), but see no reason 
      // to read module file unless needed) 
      replaceModelAndFireEvent(oldModel, null);
    }
  }

  public static class ProjectStructureSModel extends jetbrains.mps.smodel.SModel {
    public ProjectStructureSModel(@NotNull SModelReference modelReference) {
      super(modelReference, new ForeignNodeIdMap());
    }
    @Override
    public boolean canFireEvent() {
      return false;
    }
    @Override
    public FastNodeFinder createFastNodeFinder() {
      return new BaseFastNodeFinder(getModelDescriptor());
    }
  }
  protected static Logger LOG = LogManager.getLogger(ProjectStructureModule.class);
}
