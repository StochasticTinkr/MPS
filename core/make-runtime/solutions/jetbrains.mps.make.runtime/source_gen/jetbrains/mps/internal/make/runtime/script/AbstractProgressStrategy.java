package jetbrains.mps.internal.make.runtime.script;

/*Generated by MPS */

import jetbrains.mps.make.script.IProgress;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

/**
 * 
 * @deprecated Don't use. Will be removed in the next major update.
 */
@Deprecated
public abstract class AbstractProgressStrategy {
  private AbstractProgressStrategy.Work last;
  private IProgress current;
  @Deprecated
  public AbstractProgressStrategy(String total) {
    this.last = new AbstractProgressStrategy.Work(null, total, 1000, 1000);
    this.current = new AbstractProgressStrategy.CurrentProgress();
  }
  protected AbstractProgressStrategy.Work pushProgress(String name, int estimate, int total) {
    return this.last = new AbstractProgressStrategy.Work(last, name, estimate, total);
  }
  protected AbstractProgressStrategy.Work popProgress(AbstractProgressStrategy.Work wrk) {
    return this.last = (wrk.prev != null ? wrk.prev : wrk);
  }
  protected AbstractProgressStrategy.Work lastProgress() {
    return last;
  }
  protected abstract void begunWork(AbstractProgressStrategy.Work wrk);
  protected abstract void advancedWork(AbstractProgressStrategy.Work wrk);
  protected abstract void finishedWork(AbstractProgressStrategy.Work wrk);
  public IProgress currentProgress() {
    return current;
  }
  public class Work implements IProgress {
    private AbstractProgressStrategy.Work prev;
    private String name;
    private String comment;
    private int estimate;
    private int total;
    private int done = 0;
    public Work(AbstractProgressStrategy.Work prev, String name, int estimate, int ofTotal) {
      this.prev = prev;
      this.name = name;
      this.estimate = estimate;
      this.total = ofTotal;
    }
    @Override
    public void beginWork(String name, int estimate, int ofTotal) {
      if (estimate <= 0) {
        throw new IllegalArgumentException("invalid estimate value");
      }
      if (ofTotal < 0) {
        throw new IllegalArgumentException("invalid ofTotal value");
      }
      begunWork(pushProgress(name, estimate, ofTotal));
    }
    @Override
    public void advanceWork(String name, int done) {
      advanceWork(name, done, null);
    }
    @Override
    public void advanceWork(String name, int done, String comment) {
      if (done < 0) {
        throw new IllegalArgumentException("invalid done value");
      }
      matchingOrTotal(name).primDone(done, comment);
    }
    @Override
    public void finishWork(String name) {
      AbstractProgressStrategy.Work wrk = matchingOrTotal(name);
      wrk.primDone(wrk.workLeft(), null);
      finishedWork(wrk);
      popProgress(wrk);
    }
    @Override
    public int workLeft() {
      return Math.max(0, estimate - done);
    }
    public int workDone() {
      return Math.min(estimate, done);
    }
    public int prevWork() {
      return total;
    }
    public double prevWorkRatio() {
      return ((double) prev.estimate) / total;
    }
    public String name() {
      return name;
    }
    public String fullName() {
      List<String> names = this.namePath();
      return IterableUtils.join(ListSequence.fromList(names).reversedList(), "/");
    }
    public String namePrefix() {
      List<String> names = this.namePath();
      return IterableUtils.join(ListSequence.fromList(names).reversedList().cut(1), "/");
    }
    public double doneRatio() {
      return ((double) Math.min(this.estimate, this.done)) / this.estimate;
    }
    public String comment() {
      return comment;
    }
    public AbstractProgressStrategy.Work matchingOrTotal(String name) {
      AbstractProgressStrategy.Work wrk = this;
      while (wrk.prev != null) {
        if (eq_idfyc1_a0a0b0u01(wrk.name, name)) {
          return wrk;
        }
        wrk = wrk.prev;
      }
      return wrk;
    }
    private List<String> namePath() {
      List<String> names = ListSequence.fromList(new ArrayList<String>());
      AbstractProgressStrategy.Work wrk = this;
      while (wrk != null) {
        ListSequence.fromList(names).addElement(wrk.name);
        wrk = wrk.prev;
      }
      return names;
    }
    private void primDone(int primDone, String comment) {
      this.comment = comment;
      if (primDone > 0) {
        this.done += primDone;
        if (prev != null) {
          prev.primDone((int) Math.floor(((double) Math.min(primDone, estimate)) * total / estimate), null);
        }
      }
      advancedWork(this);
    }
  }
  public class CurrentProgress implements IProgress {
    public CurrentProgress() {
    }
    @Override
    public void beginWork(String name, int estimate, int ofTotal) {
      lastProgress().beginWork(name, estimate, ofTotal);
    }
    @Override
    public void finishWork(String name) {
      lastProgress().finishWork(name);
    }
    @Override
    public void advanceWork(String name, int done) {
      lastProgress().advanceWork(name, done);
    }
    @Override
    public void advanceWork(String name, int done, String comment) {
      lastProgress().advanceWork(name, done, comment);
    }
    @Override
    public int workLeft() {
      return lastProgress().workLeft();
    }
  }
  private static boolean eq_idfyc1_a0a0b0u01(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
