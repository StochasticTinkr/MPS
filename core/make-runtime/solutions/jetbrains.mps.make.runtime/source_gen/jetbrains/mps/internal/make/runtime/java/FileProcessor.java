package jetbrains.mps.internal.make.runtime.java;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.util.FileUtil;
import org.jdom.Element;
import org.jdom.Document;
import java.io.ByteArrayOutputStream;
import jetbrains.mps.util.JDOMUtil;
import java.io.IOException;
import java.util.Collection;
import java.io.OutputStream;
import java.io.InputStream;

public class FileProcessor {
  private static final Logger LOG = LogManager.getLogger(FileProcessor.class);
  private final List<FileProcessor.FileContent> myFilesAndContents = new ArrayList<FileProcessor.FileContent>();
  private final List<IFile> myFilesToDelete = new ArrayList<IFile>();

  public FileProcessor() {
    // XXX perhaps, could make use of IMessageHandler supplied by facet to replace LOG handling IO errors? 
  }

  public boolean saveContent(IFile file, String content) {
    return saveContent(new FileProcessor.FileContent(file, content.getBytes(FileUtil.DEFAULT_CHARSET)));
  }

  public boolean saveContent(IFile file, Element content) {
    Document document;
    if (content.getDocument() != null) {
      assert content.isRootElement() : "Need a document to serialize an xml element; could not save if element is already inside a document";
      document = content.getDocument();
    } else {
      document = new Document(content);
    }
    ByteArrayOutputStream bos = new ByteArrayOutputStream(1 << 13);
    try {
      JDOMUtil.writeDocument(document, bos);
    } catch (IOException ex) {
      // FIXME what could we do here? Log into IMessageHandler, once it's here, at least 
    }
    return saveContent(new FileProcessor.FileContent(file, bos.toByteArray()));
  }

  public boolean saveContent(IFile file, byte[] content) {
    return saveContent(new FileProcessor.FileContent(file, content));
  }

  private boolean saveContent(FileProcessor.FileContent fileContent) {
    // XXX though it seems more honest to collect all fileContent 
    //     and make decision whether isChanged right before the write operation 
    //     I need to tell written/touch at this moment, therefore isChanged is here 
    //     and no reason to keep the data we aren't going to write anyway 
    if (fileContent.isChanged()) {
      myFilesAndContents.add(fileContent);
      return true;
    }
    return false;
  }
  public void filesToDelete(Collection<IFile> files) {
    myFilesToDelete.addAll(files);
  }
  public void flushChanges() {
    for (FileProcessor.FileContent fileContent : myFilesAndContents) {
      fileContent.saveToFile();
    }
    for (IFile file : myFilesToDelete) {
      file.delete();
    }
  }

  private static class FileContent {
    private final IFile myFile;
    private final byte[] myContent;

    private FileContent(IFile file, byte[] content) {
      myFile = file;
      myContent = content;
    }

    public void saveToFile() {
      OutputStream stream = null;
      try {
        stream = myFile.openOutputStream();
        stream.write(myContent);
      } catch (IOException e) {
        FileProcessor.LOG.error((e.getMessage() == null ? e.getClass().getName() : e.getMessage()), e);
      } finally {
        if (stream != null) {
          try {
            stream.close();
          } catch (IOException ignored) {
          }
        }
      }
    }

    public boolean isChanged() {
      if (!(myFile.exists())) {
        return true;
      }
      long len = myFile.length();
      if (len != myContent.length) {
        return true;
      }

      byte[] res = new byte[Math.min(1 << 13, myContent.length)];
      InputStream stream = null;
      try {
        stream = myFile.openInputStream();
        int bytesRead = 0;
        int index = 0;
        while ((bytesRead = stream.read(res)) != -1) {
          for (int i = 0; i < bytesRead; i++) {
            if (myContent[index++] != res[i]) {
              return true;
            }
          }
        }
        return false;
      } catch (IOException ex) {
        return true;
      } finally {
        if (stream != null) {
          try {
            stream.close();
          } catch (IOException ex) {
            return true;
          }
        }
      }
    }
  }
}
