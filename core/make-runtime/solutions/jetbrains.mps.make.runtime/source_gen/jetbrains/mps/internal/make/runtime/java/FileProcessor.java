package jetbrains.mps.internal.make.runtime.java;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.vfs.IFile;
import org.jdom.Element;
import java.util.Collection;
import java.io.OutputStreamWriter;
import java.io.BufferedOutputStream;
import jetbrains.mps.util.FileUtil;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.InputStream;
import java.util.Arrays;
import org.jdom.Document;
import jetbrains.mps.util.JDOMUtil;
import java.io.ByteArrayOutputStream;

public class FileProcessor {
  private static final Logger LOG = LogManager.getLogger(FileProcessor.class);
  private final List<FileProcessor.FileContent> myFilesAndContents = new ArrayList<FileProcessor.FileContent>();
  private final List<IFile> myFilesToDelete = new ArrayList<IFile>();

  public FileProcessor() {
    // XXX perhaps, could make use of IMessageHandler supplied by facet to replace LOG handling IO errors? 
  }
  public boolean saveContent(IFile file, String content) {
    return saveContent(new FileProcessor.StringFileContent(file, content));
  }
  public boolean saveContent(IFile file, Element content) {
    return saveContent(new FileProcessor.XMLFileContent(file, content));
  }
  public boolean saveContent(IFile file, byte[] content) {
    return saveContent(new FileProcessor.BinaryFileContent(file, content));
  }
  private boolean saveContent(FileProcessor.FileContent fileContent) {
    if (fileContent.isChanged()) {
      myFilesAndContents.add(fileContent);
      return true;
    }
    return false;
  }
  public void filesToDelete(Collection<IFile> files) {
    myFilesToDelete.addAll(files);
  }
  public void flushChanges() {
    for (FileProcessor.FileContent fileContent : myFilesAndContents) {
      fileContent.saveToFile();
    }
    for (IFile file : myFilesToDelete) {
      file.delete();
    }
  }

  private interface FileContent {
    boolean isChanged();
    void saveToFile();
  }

  private static class StringFileContent implements FileProcessor.FileContent {
    private final IFile myFile;
    private final String myContent;

    private StringFileContent(IFile file, String content) {
      myFile = file;
      myContent = content;
    }
    @Override
    public void saveToFile() {
      OutputStreamWriter writer = null;
      try {
        writer = new OutputStreamWriter(new BufferedOutputStream(myFile.openOutputStream()), FileUtil.DEFAULT_CHARSET);
        writer.write(myContent);
      } catch (IOException e) {
        FileProcessor.LOG.error((e.getMessage() == null ? e.getClass().getName() : e.getMessage()), e);
      } finally {
        if (writer != null) {
          try {
            writer.close();
          } catch (IOException ignored) {
          }
        }
      }
    }
    @Override
    public boolean isChanged() {
      if (!(myFile.exists())) {
        return true;
      }
      BufferedReader reader = null;
      StringBuilder res = new StringBuilder();
      // FIXME doesn't look effective to read whole file, reconstruct strings and newlines, just to do String.equals() 
      try {
        reader = new BufferedReader(new InputStreamReader(myFile.openInputStream(), FileUtil.DEFAULT_CHARSET));
        String line;
        while ((line = reader.readLine()) != null) {
          res.append(line).append('\n');
        }
        return !(res.toString().equals(myContent));
      } catch (IOException ex) {
        return true;
      } finally {
        try {
          if (reader != null) {
            reader.close();
          }
        } catch (IOException ex) {
          return true;
        }
      }
    }
  }
  private static class BinaryFileContent implements FileProcessor.FileContent {
    private final IFile myFile;
    private byte[] myContent;

    private BinaryFileContent(IFile file, byte[] content) {
      myFile = file;
      myContent = content;
    }
    @Override
    public void saveToFile() {
      OutputStream stream = null;
      try {
        stream = myFile.openOutputStream();
        stream.write(myContent);
      } catch (IOException e) {
        FileProcessor.LOG.error((e.getMessage() == null ? e.getClass().getName() : e.getMessage()), e);
      } finally {
        if (stream != null) {
          try {
            stream.close();
          } catch (IOException ignored) {
          }
        }
      }
    }

    @Override
    public boolean isChanged() {
      if (!(myFile.exists())) {
        return true;
      }
      long len = myFile.length();
      if (len != myContent.length) {
        return true;
      }

      byte[] res = new byte[myContent.length];
      InputStream stream = null;
      try {
        stream = myFile.openInputStream();
        if (stream.read(res) != len) {
          return true;
        }
        return !(Arrays.equals(res, myContent));
      } catch (IOException ex) {
        return true;
      } finally {
        if (stream != null) {
          try {
            stream.close();
          } catch (IOException ex) {
            return true;
          }
        }
      }
    }
  }
  private static class XMLFileContent implements FileProcessor.FileContent {
    private final IFile myFile;
    private final Document myDocument;

    private XMLFileContent(IFile file, Element element) {
      myFile = file;
      // if element is right under a document, use this document, otherwise create a new one 
      if (element.getDocument() != null) {
        assert element.isRootElement() : "Need a document to serialize an xml element; could not save if element is already inside a document";
        myDocument = element.getDocument();
      } else {
        myDocument = new Document(element);
      }
    }
    @Override
    public void saveToFile() {
      try {
        JDOMUtil.writeDocument(myDocument, myFile);
      } catch (IOException e) {
        FileProcessor.LOG.error((e.getMessage() == null ? e.getClass().getName() : e.getMessage()), e);
      }
    }

    @Override
    public boolean isChanged() {
      try {
        ByteArrayOutputStream bos = new ByteArrayOutputStream(1 << 13);
        JDOMUtil.writeDocument(myDocument, bos);
        return new FileProcessor.BinaryFileContent(myFile, bos.toByteArray()).isChanged();
      } catch (IOException ex) {
        return true;
      }
    }
  }
}
