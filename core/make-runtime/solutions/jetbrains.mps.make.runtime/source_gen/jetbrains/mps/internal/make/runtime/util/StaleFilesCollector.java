package jetbrains.mps.internal.make.runtime.util;

/*Generated by MPS */

import jetbrains.mps.vfs.IFile;
import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import java.util.LinkedList;
import java.util.Arrays;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.generator.impl.dependencies.GenerationDependenciesCache;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.generator.impl.dependencies.GenerationDependencies;
import java.util.Collections;
import jetbrains.mps.generator.info.GeneratorPathsComponent;

/**
 * IMPORTANT Use of this class is discouraged.
 * 
 * The class is informed about FS changes walks FS to find out existing files and report those unchanged as stale.
 * As a drawback, need an external mechanism to tell non-generated files under generated location.
 * MPS doesn't use it for TextGen as we record names of generated files and don't need to walk FS any more
 */
public class StaleFilesCollector {
  private IFile rootDir;
  private Map<IFile, List<IFile>> generatedChildren = MapSequence.fromMap(new HashMap<IFile, List<IFile>>());
  private final Set<IFile> filesToKeep;

  public StaleFilesCollector(IFile rootDir) {
    this.rootDir = rootDir;
    MapSequence.fromMap(generatedChildren).put(rootDir, ListSequence.fromList(new ArrayList<IFile>()));
    filesToKeep = SetSequence.fromSet(new HashSet<IFile>());
  }

  private List<IFile> collectFilesToDelete() {
    String[] pathsToKeep = SetSequence.fromSet(filesToKeep).select(new ISelector<IFile, String>() {
      public String select(IFile f) {
        return (f.isDirectory() ? DirUtil.normalizeAsDir(f.getPath()) : DirUtil.normalize(f.getPath()));
      }
    }).sort(new ISelector<String, String>() {
      public String select(String p) {
        return p;
      }
    }, true).toListSequence().toGenericArray(String.class);

    List<IFile> filesToDelete = ListSequence.fromList(new ArrayList<IFile>());

    Queue<IFile> dirQueue = QueueSequence.fromQueueAndArray(new LinkedList<IFile>(), rootDir);
    while (QueueSequence.fromQueue(dirQueue).isNotEmpty()) {
      IFile dir = QueueSequence.fromQueue(dirQueue).removeFirstElement();
      String dirpath = DirUtil.normalizeAsDir(dir.getPath());
      int diridx = Arrays.binarySearch(pathsToKeep, dirpath);

      for (Tuples._2<IFile, String> fileAndPath : Sequence.fromIterable(getChildren(dir)).select(new ISelector<IFile, Tuples._2<IFile, String>>() {
        public Tuples._2<IFile, String> select(IFile f) {
          return MultiTuple.<IFile,String>from(f, DirUtil.normalize(f.getPath()));
        }
      }).sort(new ISelector<Tuples._2<IFile, String>, String>() {
        public String select(Tuples._2<IFile, String> t) {
          return t._1();
        }
      }, true)) {
        if (fileAndPath._0().isDirectory()) {
          int fidx = Arrays.binarySearch(pathsToKeep, DirUtil.normalizeAsDir(fileAndPath._1()));
          fidx = (fidx < 0 ? -1 - fidx : fidx);
          if (fidx >= pathsToKeep.length || !(DirUtil.startsWith(pathsToKeep[fidx], fileAndPath._1()))) {
            ListSequence.fromList(filesToDelete).addElement(fileAndPath._0());
            if (fidx >= pathsToKeep.length) {
              break;
            }
          } else if (fidx < pathsToKeep.length) {
            QueueSequence.fromQueue(dirQueue).addLastElement(fileAndPath._0());
          }
        } else {
          int fidx = Arrays.binarySearch(pathsToKeep, fileAndPath._1());
          if (fidx < 0 && diridx < 0) {
            ListSequence.fromList(filesToDelete).addElement(fileAndPath._0());
          }
        }
      }
    }

    return filesToDelete;
  }

  /**
   * Read cached state of generated files, if any, assuming files were generated under rootDir.
   * 
   * The code is intended to handle case when we generate into a root with foreign files we shall keep.
   * Generally, all the files under rootDir might need deletion (except those explicitly written/kept).
   * Files left after excluding those touched are additionally filtered through 'foreign' roots in a way
   * that we consider only generated files under output root (intersect in getChildren).
   */
  public void recordGeneratedChildren(GenerationDependenciesCache genDeps, SModel model) {
    List<IFile> genChildren = knownGeneratedChildren(genDeps.get(model));
    ListSequence.fromList(MapSequence.fromMap(generatedChildren).get(rootDir)).addSequence(ListSequence.fromList(genChildren));
  }

  private List<IFile> knownGeneratedChildren(GenerationDependencies gd) {
    // XXX shall report generated children from GD, but as long as there's no use and the class likely to cease, decided to left unimplemented. 
    return Collections.emptyList();
  }

  /**
   * May be invoked multiple times, updates internal state of what files are considered 'touched' according to delta supplied
   * These files are not reported as 'stale' by {@link jetbrains.mps.internal.make.runtime.util.StaleFilesCollector#reportStaleFilesInto(FilesDelta) }
   */
  public void recordFilesToKeep(FilesDelta delta) {
    delta.acceptVisitor(new FilesDelta.Visitor() {
      @Override
      public boolean acceptWritten(IFile file) {
        SetSequence.fromSet(filesToKeep).addElement(file);
        return true;
      }
      @Override
      public boolean acceptKept(IFile file) {
        SetSequence.fromSet(filesToKeep).addElement(file);
        return true;
      }
    });
  }

  public void reportStaleFilesInto(FilesDelta delta) {
    for (IFile f : collectFilesToDelete()) {
      delta.stale(f);
    }
  }

  /**
   * This method assumes there's no other delta for the root other than passed as an argument, which is wrong for forked generation plans with multiple models that save output into the same location. 
   * Then there are few deltas reported for the same location, some reporting files as stale while other report as added
   * 
   * @deprecated 
   */
  @Deprecated
  public void updateDelta(FilesDelta delta) {
    recordFilesToKeep(delta);
    reportStaleFilesInto(delta);
  }

  private Iterable<IFile> getChildren(IFile dir) {
    Iterable<IFile> realChilren = (Iterable<IFile>) dir.getChildren();
    if (GeneratorPathsComponent.getInstance().isForeign(dir)) {
      List<IFile> genChildren = MapSequence.fromMap(generatedChildren).get(dir);
      return ListSequence.fromList(genChildren).intersect(Sequence.fromIterable(realChilren));
    }
    return realChilren;
  }

}
