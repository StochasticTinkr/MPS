package jetbrains.mps.make.dependencies;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.language.LanguageRegistry;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.Generator;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.generator.impl.plan.ModelContentUtil;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import java.util.LinkedList;
import jetbrains.mps.internal.make.runtime.util.GraphAnalyzer;

public class ModulesCluster {
  private final Map<SModuleReference, ModulesCluster.ModuleDeps> myDepsGraph = MapSequence.fromMap(new HashMap<SModuleReference, ModulesCluster.ModuleDeps>());
  private final Map<SLanguage, ModulesCluster.ModuleDeps> languageModules = MapSequence.fromMap(new HashMap<SLanguage, ModulesCluster.ModuleDeps>());
  private final LanguageRegistry myLanguageRegistry;

  public ModulesCluster(LanguageRegistry languageRegistry) {
    myLanguageRegistry = languageRegistry;
  }

  private void collectRequired(Iterable<SModule> pool) {
    // keep graph with dependencies, with vertexes for modules being clusterized only (i.e. no vertex for a module that is among dependencies but not being built) 
    MapSequence.fromMap(myDepsGraph).clear();
    // keep track of a module that results in a deployed language; these need to be build prior to their uses 
    MapSequence.fromMap(languageModules).clear();
    // ensure we've got all the vertexes of our graph ready 
    for (SModule m : Sequence.fromIterable(pool)) {
      SModuleReference mr = m.getModuleReference();
      ModulesCluster.ModuleDeps md = new ModulesCluster.ModuleDeps(m);
      MapSequence.fromMap(myDepsGraph).put(mr, md);
      if (m instanceof Language) {
        MapSequence.fromMap(languageModules).put(MetaAdapterFactory.getLanguage(mr), md);
      }
    }

    for (ModulesCluster.ModuleDeps md : Sequence.fromIterable(MapSequence.fromMap(myDepsGraph).values())) {
      fillEdges(md);
    }
  }

  public Iterable<? extends Iterable<SModule>> buildOrder(Iterable<SModule> pool) {
    collectRequired(pool);
    List<List<SModuleReference>> order = new ModulesCluster.ModulesGraph().totalOrder();
    Iterable<? extends Iterable<SModuleReference>> compacted = Sequence.fromIterable(this.compact(order)).toListSequence();
    return Sequence.fromIterable(compacted).select(new ISelector<Iterable<SModuleReference>, IListSequence<SModule>>() {
      public IListSequence<SModule> select(Iterable<SModuleReference> cycle) {
        return Sequence.fromIterable(cycle).select(new ISelector<SModuleReference, SModule>() {
          public SModule select(SModuleReference mr) {
            return MapSequence.fromMap(myDepsGraph).get(mr).getModule();
          }
        }).toListSequence();
      }
    }).toListSequence();
  }

  public Iterable<SLanguage> usedLanguage(SModule m) {
    // we need used languages to determine build order (in case language/generator module is among those being built) 
    // and also we need these languages to detect facets to activate in build script. Not to build this set twice, re-use once computed 
    assert MapSequence.fromMap(myDepsGraph).containsKey(m.getModuleReference());
    return MapSequence.fromMap(myDepsGraph).get(m.getModuleReference()).usedLanguages;
  }

  private Iterable<? extends Iterable<SModuleReference>> compact(List<List<SModuleReference>> order) {
    // XXX what's the point of this code, what do we 'compact' here? Do we merge cycles so that they are built together and later has a chance to load ok? 
    final Wrappers._T<Iterable<SModuleReference>> prev = new Wrappers._T<Iterable<SModuleReference>>(null);
    return ListSequence.fromList(order).concat(Sequence.fromIterable(Sequence.<List<SModuleReference>>singleton(null))).translate(new ITranslator2<List<SModuleReference>, Iterable<SModuleReference>>() {
      public Iterable<Iterable<SModuleReference>> translate(final List<SModuleReference> cycle) {
        return new Iterable<Iterable<SModuleReference>>() {
          public Iterator<Iterable<SModuleReference>> iterator() {
            return new YieldingIterator<Iterable<SModuleReference>>() {
              private int __CP__ = 0;
              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 2:
                      if (cycle == null) {
                        this.__CP__ = 3;
                        break;
                      } else if (prev.value == null) {
                        this.__CP__ = 6;
                        break;
                      }
                      this.__CP__ = 8;
                      break;
                    case 9:
                      if (ListSequence.fromList(cycle).translate(new ITranslator2<SModuleReference, SModuleReference>() {
                        public Iterable<SModuleReference> translate(SModuleReference mr) {
                          return MapSequence.fromMap(myDepsGraph).get(mr).required;
                        }
                      }).intersect(Sequence.fromIterable(prev.value).translate(new ITranslator2<SModuleReference, SModuleReference>() {
                        public Iterable<SModuleReference> translate(SModuleReference mr) {
                          return MapSequence.fromMap(myDepsGraph).get(mr).dependent;
                        }
                      })).isEmpty()) {
                        this.__CP__ = 10;
                        break;
                      }
                      this.__CP__ = 12;
                      break;
                    case 4:
                      this.__CP__ = 5;
                      this.yield(prev.value);
                      return true;
                    case 13:
                      this.__CP__ = 14;
                      this.yield(prev.value);
                      return true;
                    case 0:
                      this.__CP__ = 2;
                      break;
                    case 3:
                      this.__CP__ = 4;
                      break;
                    case 5:
                      prev.value = null;
                      this.__CP__ = 1;
                      break;
                    case 6:
                      prev.value = ListSequence.fromList(cycle).toListSequence();
                      this.__CP__ = 1;
                      break;
                    case 8:
                      this.__CP__ = 9;
                      break;
                    case 10:
                      prev.value = Sequence.fromIterable(prev.value).concat(ListSequence.fromList(cycle).toListSequence());
                      this.__CP__ = 1;
                      break;
                    case 12:
                      this.__CP__ = 13;
                      break;
                    case 14:
                      prev.value = ListSequence.fromList(cycle).toListSequence();
                      this.__CP__ = 1;
                      break;
                    default:
                      break __loop__;
                  }
                } while (true);
                return false;
              }
            };
          }
        };
      }
    });
  }

  private void fillEdges(ModulesCluster.ModuleDeps rv) {
    SModule mod = rv.getModule();
    // get a set of modules we are going to build transitive dependencies for 
    ArrayList<SModule> modExt = new ArrayList<SModule>();
    modExt.add(rv.getModule());

    Set<SLanguage> moduleUsedLanguages;
    // inv: reference existing vertexes only 
    Set<SModuleReference> reqs = SetSequence.fromSet(new HashSet<SModuleReference>());
    if (mod instanceof Generator) {
      Generator generator = (Generator) mod;
      // FIXME is it true GMDM doesn't recognize generator's source language as COMPILE or VISIBLE dependency? 
      modExt.add(generator.getSourceLanguage());
      // XXX though it looks suspicious that we require source language module to build a generator, the reason to have it there 
      //     is likely the need to satisfy module load dependency (not the need to have language available the moment generator module is being generated/textgen'ed) 
      moduleUsedLanguages = SetSequence.fromSet(new HashSet<SLanguage>());
      for (SModel m : generator.getModels()) {
        SetSequence.fromSet(moduleUsedLanguages).addSequence(CollectionSequence.fromCollection(ModelContentUtil.getUsedLanguages(m)));
      }
    } else {
      moduleUsedLanguages = mod.getUsedLanguages();
      // XXX ModelContentUtil adds auto-imported and engaged on generation lagnuages as well, shall I use it here, too? 
      //     I didn't add them as previous version relied on SModule.getUsedLanguages() collection, which does not include engaged nor auto-imports, and is working for years 

    }
    Set<SLanguage> allUsedLanguages = new SLanguageHierarchy(myLanguageRegistry, moduleUsedLanguages).getExtended();
    SetSequence.fromSet(rv.usedLanguages).addSequence(SetSequence.fromSet(allUsedLanguages));

    // if a module of any used language happens to be among modules to build, ensure it's build first, as well as their generators... 
    // Note with this approach we ignore workspace dependencies of a deployed language. E.g. if there's a changed RT solution, its language module unchanged, 
    // and we mak RT solution and the one that uses the language, we may miss the dependency that RT needs to be 'Make' first 
    for (Language l : SetSequence.fromSet(allUsedLanguages).where(new IWhereFilter<SLanguage>() {
      public boolean accept(SLanguage it) {
        return MapSequence.fromMap(languageModules).containsKey(it);
      }
    }).select(new ISelector<SLanguage, Language>() {
      public Language select(SLanguage it) {
        return as_7qjyo9_a0a0a0a0a0p0o(MapSequence.fromMap(languageModules).get(it).getModule(), Language.class);
      }
    })) {
      //  there's vertex for this language module, don't care to calculate its dependencies, will get to that anyway at respective fillEdges call 
      SetSequence.fromSet(reqs).addElement(l.getModuleReference());
      for (Generator g : CollectionSequence.fromCollection(l.getGenerators())) {
        if (MapSequence.fromMap(myDepsGraph).containsKey(g.getModuleReference())) {
          SetSequence.fromSet(reqs).addElement(g.getModuleReference());
        } else {
          // we aren't going to cluserize required generator, but perhaps we do some of its dependencies 
          modExt.add(g);
        }
      }
    }
    // XXX in fact, don't need to build complete set of dependencies, more effective is to follow one by one to see if it's vertex in the graph or it's known not to give any new dependency 
    GlobalModuleDependenciesManager depman = new GlobalModuleDependenciesManager(modExt);
    Set<SModule> reqmods = SetSequence.fromSet(new HashSet<SModule>());
    SetSequence.fromSet(reqmods).addSequence(CollectionSequence.fromCollection(depman.getModules(GlobalModuleDependenciesManager.Deptype.COMPILE)));
    SetSequence.fromSet(reqmods).addSequence(CollectionSequence.fromCollection(depman.getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE)));
    // record edges only to existing vertexes 
    SetSequence.fromSet(reqs).addSequence(SetSequence.fromSet(reqmods).select(new ISelector<SModule, SModuleReference>() {
      public SModuleReference select(SModule m) {
        return m.getModuleReference();
      }
    }).where(new IWhereFilter<SModuleReference>() {
      public boolean accept(SModuleReference it) {
        return MapSequence.fromMap(myDepsGraph).containsKey(it);
      }
    }));


    // XXX perhaps, we shall respect target languages of used languages as well, as they may appear while generating this module.  
    //     We need them anyway to build required facets in ModulesClusterizer.allLanguagesToActivateFacets 

    ListSequence.fromList(rv.required).addSequence(SetSequence.fromSet(reqs));
    for (SModuleReference req : rv.required) {
      ListSequence.fromList(MapSequence.fromMap(myDepsGraph).get(req).dependent).addElement(rv.getModule().getModuleReference());
    }
  }

  /*package*/ static class ModuleDeps {
    private final SModule myModule;
    /*package*/ List<SModuleReference> dependent = ListSequence.fromList(new LinkedList<SModuleReference>());
    /*package*/ List<SModuleReference> required = ListSequence.fromList(new LinkedList<SModuleReference>());
    /*package*/ final Set<SLanguage> usedLanguages = SetSequence.fromSet(new HashSet<SLanguage>());

    public ModuleDeps(SModule mod) {
      myModule = mod;
      ListSequence.fromList(dependent).addElement(mod.getModuleReference());
      ListSequence.fromList(required).addElement(mod.getModuleReference());
    }

    /*package*/ SModule getModule() {
      return myModule;
    }
  }

  public class ModulesGraph extends GraphAnalyzer<SModuleReference> {
    public ModulesGraph() {
    }
    @Override
    public Iterable<SModuleReference> forwardEdges(SModuleReference v) {
      return MapSequence.fromMap(myDepsGraph).get(v).dependent;
    }
    @Override
    public Iterable<SModuleReference> backwardEdges(SModuleReference v) {
      return MapSequence.fromMap(myDepsGraph).get(v).required;
    }
    @Override
    public Iterable<SModuleReference> vertices() {
      return MapSequence.fromMap(myDepsGraph).keySet();
    }
  }
  private static <T> T as_7qjyo9_a0a0a0a0a0p0o(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
