package jetbrains.mps.baseLanguage.javastub;

/*Generated by MPS */

import org.jetbrains.mps.annotations.Immutable;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.AbstractModule;
import java.util.Collection;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.extapi.model.SModelData;
import jetbrains.mps.vfs.IFile;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.java.stub.StubReferenceFactory;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ITranslator2;

@Immutable
public final class ASMModelLoader {
  private static final Logger LOG = LogManager.getLogger(ASMModelLoader.class);

  private final AbstractModule myModule;
  private final Collection<String> myPaths;
  private boolean mySkipPrivate;
  private boolean myOnlyPublic;

  public ASMModelLoader(@NotNull AbstractModule module, Collection<String> paths) {
    myModule = module;
    myPaths = paths;
  }

  public ASMModelLoader onlyPublicClasses(boolean onlyPublicClasses) {
    myOnlyPublic = onlyPublicClasses;
    return this;
  }

  public ASMModelLoader skipPrivateMembers(boolean skipPrivateMembers) {
    mySkipPrivate = skipPrivateMembers;
    return this;
  }

  public void populateRoots(SModelData modelData) {
    // XXX may pass openapi.SModel in addition to SModelData so that ClassifierLoader may use model as factory 
    for (IFile classfile : getTopClassFiles()) {
      ClassifierLoader loader = new ClassifierLoader(classfile, myOnlyPublic, mySkipPrivate);
      SNode c = loader.createClassifier();
      if (c != null) {
        modelData.addRootNode(c);
      }
    }
  }

  public Collection<SModelReference> completeModel(SModel partialModel, SModelData completeModelData) {
    try {
      StubReferenceFactory refFactory = new StubReferenceFactory(myModule, partialModel);
      for (IFile classfile : getTopClassFiles()) {
        ClassifierLoader rootLoader = new ClassifierLoader(classfile, myOnlyPublic, mySkipPrivate);
        SNode c = rootLoader.createClassifier();
        if (c != null) {
          rootLoader.updateClassifier(c, refFactory);
          completeModelData.addRootNode(c);
        }
      }
      return refFactory.getImports();
    } catch (Throwable e) {
      LOG.error("Exception for model " + partialModel.getReference(), e);
    }
    return Collections.emptyList();
  }

  public Iterable<IFile> getTopClassFiles() {
    return CollectionSequence.fromCollection(myPaths).select(new ISelector<String, IFile>() {
      public IFile select(String it) {
        return myModule.getFileSystem().getFile(it);
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return it != null;
      }
    }).translate(new ITranslator2<IFile, IFile>() {
      public Iterable<IFile> translate(IFile it) {
        return it.getChildren();
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return !(it.isDirectory()) && it.getName().endsWith(".class") && !(ClassifierLoader.getClassName(it).contains("$"));
      }
    });
  }
}
