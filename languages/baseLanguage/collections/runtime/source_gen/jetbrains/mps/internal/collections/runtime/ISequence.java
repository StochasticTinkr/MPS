package jetbrains.mps.internal.collections.runtime;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.closures.runtime.AdapterClass;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Comparator;

public interface ISequence<T> extends Iterable<T>, IEnumerable<T> {
  ISequence<T> where(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter);
  T findFirst(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter);
  T findLast(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter);
  boolean any(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter);
  boolean all(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter);
  <U> ISequence<U> translate(@AdapterClass(value = "ITranslator2") _FunctionTypes._return_P1_E0<? extends Iterable<U>, ? super T> translator);
  <U> ISequence<U> select(@AdapterClass(value = "ISelector") _FunctionTypes._return_P1_E0<? extends U, ? super T> selector);
  <U> ISequence<U> ofType(Class<U> type);
  ISequence<T> sort(@AdapterClass(value = "ISelector") _FunctionTypes._return_P1_E0<? extends Comparable<?>, ? super T> selector, boolean ascending);
  ISequence<T> alsoSort(@AdapterClass(value = "ISelector") _FunctionTypes._return_P1_E0<? extends Comparable<?>, ? super T> selector, boolean ascending);
  ISequence<T> sort(Comparator<? super T> comparator, boolean ascending);
  ISequence<T> distinct();
  void visitAll(@AdapterClass(value = "IVisitor") _FunctionTypes._void_P1_E0<? super T> visitor);
  ISequence<T> take(int length);
  ISequence<T> skip(int length);
  ISequence<T> cut(int length);
  ISequence<T> tail(int length);
  ISequence<T> page(int skip, int skipplustake);
  ISequence<T> concat(ISequence<? extends T> that);
  ISequence<T> intersect(ISequence<? extends T> that);
  ISequence<T> subtract(ISequence<? extends T> that);
  ISequence<T> union(ISequence<? extends T> that);
  ISequence<T> disjunction(ISequence<? extends T> that);
  ISequence<T> reverse();
  boolean contains(Object o);
  boolean containsSequence(ISequence<? extends T> that);
  int indexOf(T t);
  int lastIndexOf(T t);
  int count();
  boolean isEmpty();
  boolean isNotEmpty();
  T first();
  T last();
  T reduceLeft(@AdapterClass(value = "ILeftCombinator") _FunctionTypes._return_P2_E0<? extends T, ? super T, ? super T> comb);
  T reduceRight(@AdapterClass(value = "IRightCombinator") _FunctionTypes._return_P2_E0<? extends T, ? super T, ? super T> comb);
  <S> S foldLeft(S seed, @AdapterClass(value = "ILeftCombinator") _FunctionTypes._return_P2_E0<? extends S, ? super S, ? super T> comb);
  <S> S foldRight(S seed, @AdapterClass(value = "IRightCombinator") _FunctionTypes._return_P2_E0<? extends S, ? super T, ? super S> comb);
  Iterable<T> toIterable();
  IListSequence<T> toListSequence();
  T[] toGenericArray();
  T[] toGenericArray(Class<T> runtimeClass);
}
