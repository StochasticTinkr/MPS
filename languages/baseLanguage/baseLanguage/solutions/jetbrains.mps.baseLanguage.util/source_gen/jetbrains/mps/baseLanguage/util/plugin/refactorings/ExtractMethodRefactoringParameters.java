package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Iterator;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.pattern.util.MatchingUtil;

public class ExtractMethodRefactoringParameters extends MethodModel {
  private ExtractMethodRefactoringAnalyzer myAnalyzer;
  private List<SNode> myNodesToRefactor;
  private VisibilityLevel myVisibility = VisibilityLevel.PRIVATE;
  private List<MethodParameter> myParameters = ListSequence.fromList(new ArrayList<MethodParameter>());
  public ExtractMethodRefactoringParameters(List<SNode> nodes) {
    this.myNodesToRefactor = nodes;
    this.myAnalyzer = new ExtractMethodRefactoringAnalyzer(nodes);
    for (MethodParameter inputVariable : ListSequence.fromList(this.myAnalyzer.getInputVariables())) {
      ListSequence.fromList(this.myParameters).addElement(inputVariable);
    }
    this.myIsStatic = this.getStatic();
  }
  public List<SNode> getNodesToRefactor() {
    return this.myNodesToRefactor;
  }
  public SNode getContainerMethod() {
    return this.myAnalyzer.getExtractMethodReafactoringProcessor().getContainerMethod();
  }
  public VisibilityLevel getVisibilityLevel() {
    return this.myVisibility;
  }
  public void setVisibilityLevel(VisibilityLevel level) {
    this.myVisibility = level;
    this.fireChange();
  }
  public List<MethodParameter> getParameters() {
    return this.myParameters;
  }
  @Override
  public List<String> getParametersNames() {
    List<String> result = ListSequence.fromList(new ArrayList<String>());
    for (MethodParameter param : ListSequence.fromList(this.myParameters)) {
      ListSequence.fromList(result).addElement(param.getTypeName() + " " + param.getName());
    }
    return result;
  }
  public SNode getOverridingMethodClass() {
    final String name = this.getName();
    final SNode classifier = this.myAnalyzer.getClassifier();
    if (classifier != null) {
      Iterable<SNode> methods = Sequence.fromIterable(SNodeOperations.ofConcept(((Iterable<SNode>) BHReflection.invoke0(((SNode) BHReflection.invoke0(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), SMethodTrimmedId.create("getThisType", null, "2RtWPFZ12w7"))), MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x66c71d82c2eb7f7eL, "jetbrains.mps.baseLanguage.structure.IClassifierType"), SMethodTrimmedId.create("getMembers", MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x66c71d82c2eb7f7eL, "jetbrains.mps.baseLanguage.structure.IClassifierType"), "6r77ob2V1Fr"))), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"))).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return Objects.equals(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), name) && ((boolean) (Boolean) BHReflection.invoke0(it, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), SMethodTrimmedId.create("isVisible", null, "70J2WaK_oVl"), classifier, classifier));
        }
      });
      for (SNode method : methods) {
        boolean good = this.isParametersMatch(method);
        if (good) {
          return SNodeOperations.getNodeAncestor(method, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, false);
        }
      }
    }
    return null;
  }
  public ExtractMethodRefactoringAnalyzer getAnalyzer() {
    return this.myAnalyzer;
  }
  private boolean isParametersMatch(SNode method) {
    Iterator<SNode> parameters = ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, "parameter"))).iterator();
    for (MethodParameter p1 : this.myParameters) {
      if (p1.isSelected()) {
        if (!(parameters.hasNext())) {
          return false;
        }
        SNode p2 = parameters.next();
        if (!(MatchingUtil.matchNodes(p1.getType(), SLinkOperations.getTarget(p2, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type"))))) {
          return false;
        }
      }
    }
    if (parameters.hasNext()) {
      return false;
    }
    return true;
  }
  private boolean getStatic() {
    if (this.myAnalyzer.canBeStatic() && this.myAnalyzer.shouldBeStatic()) {
      return true;
    } else {
      return false;
    }
  }
  @Override
  public String getMethodText() {
    String result = this.myVisibility.getName() + " " + super.getMethodText();
    return result;

  }
}
