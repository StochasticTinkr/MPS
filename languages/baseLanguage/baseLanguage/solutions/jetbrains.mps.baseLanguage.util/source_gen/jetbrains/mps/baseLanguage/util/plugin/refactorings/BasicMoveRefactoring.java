package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class BasicMoveRefactoring {
  protected final SNode myMoving;
  protected final SNode myDestination;
  protected SNode myReplacing = null;
  protected SearchResults<SNode> myUsages = new SearchResults<SNode>();
  private boolean myIsChangingModel = false;
  public BasicMoveRefactoring(SNode moving, SNode destination) {
    this.myMoving = moving;
    this.myDestination = destination;
  }
  public void setUsages(SearchResults<SNode> usages) {
    this.myUsages = usages;
  }
  public SearchResults<SNode> getUsages() {
    return this.myUsages;
  }
  public void doRefactoring() {
    this.setIsChangingModel();
    this.correctMoving();
    this.createCopy();
    MoveRefactoringUtils.fixImportsFromNode(this.myReplacing);
    for (SearchResult<SNode> result : ListSequence.fromList(this.myUsages.getSearchResults())) {
      // accomodate for non-MPS usages (e.g. in plugin) 
      // TODO (not sure if it's a good solution) 
      if (result.getObject() == null) {
        continue;
      }
      this.replaceSingleUsage(result.getObject());
    }
    this.deleteOld();
  }
  public void replaceSingleUsage(SNode usage) {
    if (this.myIsChangingModel) {
      MoveRefactoringUtils.addNodeModelImportIfNeed(usage, this.myDestination);
    }
  }
  protected void createCopy() {
    this.myReplacing = SNodeOperations.copyNode(this.myMoving);
    MoveRefactoringUtils.addNodeAtLink(this.myDestination, this.myReplacing);
  }
  protected void deleteOld() {
    SNodeOperations.deleteNode(this.myMoving);
  }
  protected void correctMoving() {
  }
  private void setIsChangingModel() {
    this.myIsChangingModel = (SNodeOperations.getModel(this.myDestination) != SNodeOperations.getModel(this.myMoving));
  }
}
