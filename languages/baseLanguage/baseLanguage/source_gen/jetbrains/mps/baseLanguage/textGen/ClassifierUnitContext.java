package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import java.util.HashSet;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.util.JavaNameUtil;
import jetbrains.mps.util.InternUtil;
import jetbrains.mps.baseLanguage.behavior.Classifier__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.util.NameUtil;

/**
 * Common context for any Classifier TextUnit (top-level), manages imports for shorter names and tracks dependencies 
 * to facilitate further creation of bl dependencies file
 */
public class ClassifierUnitContext {
  private final ImportsContext myImports;
  private final HashSet<String> myDepends;
  private final HashSet<String> myExtends;

  public ClassifierUnitContext(SNode topClassifierNode) {
    myImports = new ImportsContext(topClassifierNode);
    myDepends = new HashSet<String>();
    myExtends = new HashSet<String>();
  }

  public ImportEntry getClassifierRefText(String packageName, String fqName, SNode contextNode) {
    addDependency(packageName, fqName);
    // FIXME there's likely no reason to pass package name and fqName (except, perhaps, for nested classes) 
    // Could we instead pass node<Classifier> here directly? 
    return myImports.getClassifierRefText(packageName, fqName, contextNode);
  }

  public void addDependency(String packageName, String fqName) {
    // using only root classifiers as dependencies 
    String nestedName = JavaNameUtil.nestedClassName(packageName, fqName);
    int dotIndex = nestedName.indexOf('.');
    String dependencyFqName;
    if (dotIndex == -1) {
      dependencyFqName = fqName;
    } else {
      dependencyFqName = packageName + '.' + nestedName.substring(0, dotIndex);
    }
    myDepends.add(InternUtil.intern(dependencyFqName));
  }

  public void registerDependenciesOf(SNode cls) {
    boolean topClassifier = !((boolean) Classifier__BehaviorDescriptor.isInner_idsWroEc0xXl.invoke(cls));
    if (SNodeOperations.isInstanceOf(cls, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
      registerExtendsRelation(SLinkOperations.getChildren(SNodeOperations.cast(cls, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, 0x101eddadad7L, "extendedInterface")), topClassifier);
    } else if (SNodeOperations.isInstanceOf(cls, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
      registerExtendsRelation(SLinkOperations.getChildren(SNodeOperations.cast(cls, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xff2ac0b419L, "implementedInterface")), topClassifier);
      registerExtendsRelation(Sequence.<SNode>singleton(SLinkOperations.getTarget(SNodeOperations.cast(cls, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass"))), topClassifier);
    }
  }

  /**
   * 
   * @param classifiers collection to report
   * @param isTopClassifier true indicates we generate a top-level class, false for inner class indicates we shall record relaxed dependency
   */
  private void registerExtendsRelation(Iterable<SNode> classifiers, boolean isTopClassifier) {
    // if an inner class extends/implements outer classifier, we shall not record this dependency as 'extends' of a 
    // top-level unit (see sample in MPS-17604). Perhaps, we shall not record this dependency at all? 

    HashSet<String> deps = (isTopClassifier ? myExtends : myDepends);
    for (SNode c : classifiers) {
      // FIXME why not Java-specific naming utility here? JavaNameUtil? 
      deps.add(NameUtil.nodeFQName(SLinkOperations.getTarget(c, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"))));
    }
  }
}
