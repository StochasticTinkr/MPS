package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import jetbrains.mps.textGen.TextGenBuffer;
import java.util.Set;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.HashMap;
import java.util.HashSet;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.util.JavaNameUtil;
import jetbrains.mps.text.TextBuffer;
import jetbrains.mps.text.BasicToken;
import jetbrains.mps.textGen.TextGen;

public class ImportsContext {
  private static final String USER_OBJECT_KEY = "CLASS_IMPORTS_CONTEXT";
  private final TextGenBuffer buffer;
  private final String packageName;
  private final Set<String> packageSimpleNames;
  private final Map<String, String> bindings;
  private ContextClassifiersInRoot contextClassifiers;

  private ImportsContext(TextGenBuffer buffer, SNode rootNode) {
    this.buffer = buffer;
    this.packageName = SModelOperations.getModelName(SNodeOperations.getModel(rootNode));

    contextClassifiers = new ContextClassifiersInRoot(rootNode);

    // init nested class bindings 
    bindings = new HashMap<String, String>();

    // init package simple names 
    packageSimpleNames = new HashSet<String>();
    for (SNode classifier : SModelOperations.roots(SNodeOperations.getModel(rootNode), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      packageSimpleNames.add(SPropertyOperations.getString(classifier, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
    }
  }
  public String getClassifierRefText(String packageName, String fqName, SNode contextNode) {
    // main invariant: use always nested names, import only root classifiers 
    String nestedName = JavaNameUtil.nestedClassName(packageName, fqName);

    int dotIndex = nestedName.indexOf(".");
    String rootClassifierName = (dotIndex == -1 ? nestedName : nestedName.substring(0, dotIndex));
    String nestedPart = nestedName.substring(rootClassifierName.length());

    return getRootClassifierRefText(packageName, rootClassifierName, contextNode) + nestedPart;
  }
  private String getRootClassifierRefText(String packageName, String className, SNode contextNode) {
    assert !(className.contains("."));

    String fqName = packageName + "." + className;
    Map<String, String> nestedClassifiersBinding = contextClassifiers.getContextClassifiers(contextNode);

    // 1) check nested classes context 
    if (nestedClassifiersBinding.containsKey(className)) {
      if (fqName.equals(nestedClassifiersBinding.get(className))) {
        return className;
      } else {
        return fqName;
      }
    }

    // 2) check current binding 
    if (bindings.containsKey(className)) {
      if (fqName.equals(bindings.get(className))) {
        return className;
      } else {
        return fqName;
      }
    }

    // 3) add binding, question is: add explicit import or not? 
    bindings.put(className, fqName);
    boolean shouldBeImported;

    if (packageName.equals(this.packageName)) {
      shouldBeImported = false;
    } else if (packageName.equals("java.lang")) {
      // java.lang model: generate without explicit import if context package doesn't contains same simple name 
      shouldBeImported = packageSimpleNames.contains(className);
    } else {
      // in other cases: generate explicit import 
      shouldBeImported = true;
    }
    if (shouldBeImported) {
      addImport(fqName);
    }

    return className;
  }
  private void addImport(String fqName) {
    // FIXME shall be simple append statement, once we manage to pass TextGenContext here instead of legacy TextGenBuffer: 
    TextBuffer tb = buffer.getRealBuffer();
    // For the time being, this hack (with explicit knowledge how to identify layout areas), ensures imports are directed into proper area 
    // In fact, instead of append done here (and passing of TextGenContext), this class shall be refactored to answer both name and import stmt, 
    // and external code (caller) shall perform the append operation 
    tb.pushTextArea(new BasicToken("IMPORTS"));
    tb.area().append("import ").append(fqName).append(";").newLine();
    tb.popTextArea();
  }
  public static ImportsContext getInstance(TextGenBuffer buffer) {
    ImportsContext instance = (ImportsContext) buffer.getUserObject(USER_OBJECT_KEY);
    if (instance == null) {
      SNode rootNode = (SNode) buffer.getUserObject(TextGen.ROOT_NODE);
      if ((rootNode == null) || !(SNodeOperations.isInstanceOf(rootNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")))) {
        throw new IllegalStateException();
      }
      instance = new ImportsContext(buffer, SNodeOperations.cast(rootNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
      buffer.putUserObject(USER_OBJECT_KEY, instance);
    }
    return instance;
  }
}
