package jetbrains.mps.lang.typesystem.structure;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.LanguageConceptIndex;
import jetbrains.mps.lang.smodel.LanguageConceptIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public final class LanguageConceptSwitch {
  private final LanguageConceptIndex myIndex;
  public static final int AbstractCheckingRule = 0;
  public static final int AbstractComparableStatement = 1;
  public static final int AbstractEquationStatement = 2;
  public static final int AbstractInequationStatement = 3;
  public static final int AbstractOverloadedOpsTypeRule = 4;
  public static final int AbstractRule = 5;
  public static final int AbstractSubtypingRule = 6;
  public static final int AddDependencyStatement = 7;
  public static final int ApplicableNodeCondition = 8;
  public static final int ApplicableNodeReference = 9;
  public static final int AssertStatement = 10;
  public static final int AttributedNodeExpression = 11;
  public static final int CoerceExpression = 12;
  public static final int CoerceStatement = 13;
  public static final int CoerceStrongExpression = 14;
  public static final int ComparisonRule = 15;
  public static final int ConceptFunctionParameter_ContextNode = 16;
  public static final int ConceptFunctionParameter_EditorContext = 17;
  public static final int ConceptFunctionParameter_Role = 18;
  public static final int ConceptFunctionParameter_Selection = 19;
  public static final int ConceptFunctionParameter_isAggregation = 20;
  public static final int ConceptFunctionParameter_node = 21;
  public static final int ConceptFunctionParameter_var = 22;
  public static final int ConceptReference = 23;
  public static final int CreateComparableEquationStatement = 24;
  public static final int CreateComparableEquationStatementStrong = 25;
  public static final int CreateEquationStatement = 26;
  public static final int CreateGreaterThanInequationStatement = 27;
  public static final int CreateLessThanInequationStatement = 28;
  public static final int CreateStrongGreaterThanInequationStatement = 29;
  public static final int CreateStrongLessThanInequationStatement = 30;
  public static final int DefaultGroupReference = 31;
  public static final int ErrorInfoExpression = 32;
  public static final int GetOperationType = 33;
  public static final int IRuleWithOneNode = 34;
  public static final int IRuleWithTwoNodes = 35;
  public static final int ImmediateSupertypesExpression = 36;
  public static final int InequationReference = 37;
  public static final int InequationReplacementRule = 38;
  public static final int InferenceRule = 39;
  public static final int InfoStatement = 40;
  public static final int InfoStatementAnnotation = 41;
  public static final int IsApplicableConceptFunction = 42;
  public static final int IsReplacementRuleApplicable_ConceptFunction = 43;
  public static final int IsStrongSubtypeExpression = 44;
  public static final int IsSubtypeExpression = 45;
  public static final int JoinContainer = 46;
  public static final int JoinType = 47;
  public static final int LeftOperandType_parameter = 48;
  public static final int LinkPatternVariableReference = 49;
  public static final int MatchStatement = 50;
  public static final int MatchStatementItem = 51;
  public static final int MeetContainer = 52;
  public static final int MeetType = 53;
  public static final int MessageStatement = 54;
  public static final int MessageStatementAnnotation = 55;
  public static final int MessageTarget = 56;
  public static final int Node_InferTypeOperation = 57;
  public static final int Node_TypeOperation = 58;
  public static final int NonTypesystemRule = 59;
  public static final int NormalTypeClause = 60;
  public static final int Operation_parameter = 61;
  public static final int OrStatement = 62;
  public static final int OriginalNodeId = 63;
  public static final int OverloadedOpIsApplicableFunction = 64;
  public static final int OverloadedOpRulesContainer = 65;
  public static final int OverloadedOpTypeRule_OneTypeSpecified = 66;
  public static final int OverloadedOperatorTypeFunction = 67;
  public static final int OverloadedOperatorTypeRule = 68;
  public static final int OverridesConceptFunction = 69;
  public static final int PatternCondition = 70;
  public static final int PatternVariableReference = 71;
  public static final int PrintToTrace = 72;
  public static final int Processed = 73;
  public static final int PropertyMessageTarget = 74;
  public static final int PropertyNameTarget = 75;
  public static final int PropertyPatternVariableReference = 76;
  public static final int QuickFixArgument = 77;
  public static final int QuickFixArgumentReference = 78;
  public static final int QuickFixDescriptionBlock = 79;
  public static final int QuickFixExecuteBlock = 80;
  public static final int QuickFixField = 81;
  public static final int QuickFixFieldReference = 82;
  public static final int QuickFixSetSelectionBlock = 83;
  public static final int ReferenceMessageTarget = 84;
  public static final int ReferenceRoleTarget = 85;
  public static final int ReportErrorStatement = 86;
  public static final int ReportErrorStatementAnnotation = 87;
  public static final int RightOperandType_parameter = 88;
  public static final int RuntimeErrorType = 89;
  public static final int RuntimeHoleType = 90;
  public static final int RuntimeListVariable = 91;
  public static final int RuntimeTypeVariable = 92;
  public static final int SelectionType = 93;
  public static final int SubstituteTypeRule = 94;
  public static final int SubtypingRule = 95;
  public static final int SupersedeConceptFunction = 96;
  public static final int TypeCheckerAccessExpression = 97;
  public static final int TypeClause = 98;
  public static final int TypeOfExpression = 99;
  public static final int TypeVarDeclaration = 100;
  public static final int TypeVarReference = 101;
  public static final int TypesystemIntention = 102;
  public static final int TypesystemIntentionArgument = 103;
  public static final int TypesystemQuickFix = 104;
  public static final int VariableConverterItem = 105;
  public static final int VariableConverterItem_ApplicableBlock = 106;
  public static final int VariableConverterItem_ConvertBlock = 107;
  public static final int VariableConvertersContainer = 108;
  public static final int WarningStatement = 109;
  public static final int WarningStatementAnnotation = 110;
  public static final int WhenConcreteStatement = 111;
  public static final int WhenConcreteVariableDeclaration = 112;
  public static final int WhenConcreteVariableReference = 113;

  public LanguageConceptSwitch() {
    LanguageConceptIndexBuilder builder = new LanguageConceptIndexBuilder(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L);
    builder.put(0x1164847e929L, AbstractCheckingRule);
    builder.put(0x3be2294807013eb7L, AbstractComparableStatement);
    builder.put(0x1117f3c1ffaL, AbstractEquationStatement);
    builder.put(0x11a342c1412L, AbstractInequationStatement);
    builder.put(0x70bfdafbb2c9449bL, AbstractOverloadedOpsTypeRule);
    builder.put(0x1117e7b5c73L, AbstractRule);
    builder.put(0x1119c40dfb0L, AbstractSubtypingRule);
    builder.put(0x11c22f6c964L, AddDependencyStatement);
    builder.put(0x1117e29d976L, ApplicableNodeCondition);
    builder.put(0x1117e9ef5dcL, ApplicableNodeReference);
    builder.put(0x111b24c0cd8L, AssertStatement);
    builder.put(0x2152354b0d500086L, AttributedNodeExpression);
    builder.put(0x1127a2a14aeL, CoerceExpression);
    builder.put(0x111f05e2451L, CoerceStatement);
    builder.put(0x1127a376a3dL, CoerceStrongExpression);
    builder.put(0x114caade477L, ComparisonRule);
    builder.put(0x11e078ffb82L, ConceptFunctionParameter_ContextNode);
    builder.put(0x335fe1d0b7494cfcL, ConceptFunctionParameter_EditorContext);
    builder.put(0x11e078e410eL, ConceptFunctionParameter_Role);
    builder.put(0x611e7dc14a69a014L, ConceptFunctionParameter_Selection);
    builder.put(0x11e078ecdbdL, ConceptFunctionParameter_isAggregation);
    builder.put(0x11b3618c300L, ConceptFunctionParameter_node);
    builder.put(0x11e07431ba7L, ConceptFunctionParameter_var);
    builder.put(0x1117e2a88b3L, ConceptReference);
    builder.put(0x1117f63bc23L, CreateComparableEquationStatement);
    builder.put(0x112c36bc7ecL, CreateComparableEquationStatementStrong);
    builder.put(0x1117f179e8dL, CreateEquationStatement);
    builder.put(0x1117f62956cL, CreateGreaterThanInequationStatement);
    builder.put(0x1117f60bfd5L, CreateLessThanInequationStatement);
    builder.put(0x31c3185c17a0f767L, CreateStrongGreaterThanInequationStatement);
    builder.put(0x112b37f1b6eL, CreateStrongLessThanInequationStatement);
    builder.put(0x12541e5f229acee2L, DefaultGroupReference);
    builder.put(0x117c6082b85L, ErrorInfoExpression);
    builder.put(0x11fd11186b7L, GetOperationType);
    builder.put(0x3e3c1137fe6cb778L, IRuleWithOneNode);
    builder.put(0x3e3c1137fe6cb779L, IRuleWithTwoNodes);
    builder.put(0x1120ebd8531L, ImmediateSupertypesExpression);
    builder.put(0x42501924d0bd1913L, InequationReference);
    builder.put(0x117c5668bf2L, InequationReplacementRule);
    builder.put(0x1117e2f5efaL, InferenceRule);
    builder.put(0x11d2965916bL, InfoStatement);
    builder.put(0x6ee9803e48223f31L, InfoStatementAnnotation);
    builder.put(0x669222c8f1941d7fL, IsApplicableConceptFunction);
    builder.put(0x31d99a115038e5e8L, IsReplacementRuleApplicable_ConceptFunction);
    builder.put(0x11222e251f1L, IsStrongSubtypeExpression);
    builder.put(0x111ef7b9fb7L, IsSubtypeExpression);
    builder.put(0x1206cda22fcL, JoinContainer);
    builder.put(0x1129e737f02L, JoinType);
    builder.put(0x11fcc4cf5b0L, LeftOperandType_parameter);
    builder.put(0x11192d92ad3L, LinkPatternVariableReference);
    builder.put(0x1122952fb1dL, MatchStatement);
    builder.put(0x112295a8fecL, MatchStatementItem);
    builder.put(0x1206cd802f8L, MeetContainer);
    builder.put(0x114b68ad132L, MeetType);
    builder.put(0x11db4aad802L, MessageStatement);
    builder.put(0x2bb0fe622a9eb078L, MessageStatementAnnotation);
    builder.put(0x11db4a65783L, MessageTarget);
    builder.put(0x584039bf75272c67L, Node_InferTypeOperation);
    builder.put(0x111ef7d5e03L, Node_TypeOperation);
    builder.put(0x1164853e0faL, NonTypesystemRule);
    builder.put(0x1141682561cL, NormalTypeClause);
    builder.put(0x11fcc4d8298L, Operation_parameter);
    builder.put(0xba3b706cf9561ecL, OrStatement);
    builder.put(0x2980b78b2f03a40bL, OriginalNodeId);
    builder.put(0x5529dae3231347deL, OverloadedOpIsApplicableFunction);
    builder.put(0x11fd137d047L, OverloadedOpRulesContainer);
    builder.put(0x70bfdafbb2c80edcL, OverloadedOpTypeRule_OneTypeSpecified);
    builder.put(0x11fcc4bffaeL, OverloadedOperatorTypeFunction);
    builder.put(0x11fcc4a641fL, OverloadedOperatorTypeRule);
    builder.put(0x1885777d1370d97bL, OverridesConceptFunction);
    builder.put(0x1117e2c3e68L, PatternCondition);
    builder.put(0x11192d10036L, PatternVariableReference);
    builder.put(0x76b48f1c91e9de8L, PrintToTrace);
    builder.put(0x11cd732687dL, Processed);
    builder.put(0x11db4a6a000L, PropertyMessageTarget);
    builder.put(0x11db54b106bL, PropertyNameTarget);
    builder.put(0x11192d97ff9L, PropertyPatternVariableReference);
    builder.put(0x11b361afb76L, QuickFixArgument);
    builder.put(0x11b3683c009L, QuickFixArgumentReference);
    builder.put(0x11b368d7f20L, QuickFixDescriptionBlock);
    builder.put(0x11b3617feddL, QuickFixExecuteBlock);
    builder.put(0x70489eee8478e93eL, QuickFixField);
    builder.put(0x70489eee8479b55dL, QuickFixFieldReference);
    builder.put(0x335fe1d0b7494a6dL, QuickFixSetSelectionBlock);
    builder.put(0x11db4a87c94L, ReferenceMessageTarget);
    builder.put(0x11db54de8fdL, ReferenceRoleTarget);
    builder.put(0x111b251a62aL, ReportErrorStatement);
    builder.put(0x6ee9803e48223f2eL, ReportErrorStatementAnnotation);
    builder.put(0x11fcc4d8edaL, RightOperandType_parameter);
    builder.put(0x113f84956f9L, RuntimeErrorType);
    builder.put(0x11e68800741L, RuntimeHoleType);
    builder.put(0x11831ae86e3L, RuntimeListVariable);
    builder.put(0x113f84956fbL, RuntimeTypeVariable);
    builder.put(0x611e7dc14a6926c8L, SelectionType);
    builder.put(0x58e32a0782bca52aL, SubstituteTypeRule);
    builder.put(0x1119c426ccaL, SubtypingRule);
    builder.put(0x65684a1aee252403L, SupersedeConceptFunction);
    builder.put(0x111b6ea6b9bL, TypeCheckerAccessExpression);
    builder.put(0x114168188c7L, TypeClause);
    builder.put(0x1117f0ad10aL, TypeOfExpression);
    builder.put(0x1117f85df7bL, TypeVarDeclaration);
    builder.put(0x1117f90b04cL, TypeVarReference);
    builder.put(0x119e85e030eL, TypesystemIntention);
    builder.put(0x119e85f8628L, TypesystemIntentionArgument);
    builder.put(0x11b36163865L, TypesystemQuickFix);
    builder.put(0x11e073a595aL, VariableConverterItem);
    builder.put(0x11e0740f5fbL, VariableConverterItem_ApplicableBlock);
    builder.put(0x11e074487bbL, VariableConverterItem_ConvertBlock);
    builder.put(0x11e07487edcL, VariableConvertersContainer);
    builder.put(0x1190a1db131L, WarningStatement);
    builder.put(0x6ee9803e48223f34L, WarningStatementAnnotation);
    builder.put(0x114177ce6cdL, WhenConcreteStatement);
    builder.put(0x118bd05a27aL, WhenConcreteVariableDeclaration);
    builder.put(0x118bd0e07f1L, WhenConcreteVariableReference);
    myIndex = builder.seal();
  }

  /*package*/ int index(SConceptId cid) {
    return myIndex.index(cid);
  }

  public int index(SAbstractConcept concept) {
    return myIndex.index(concept);
  }
}
