package jetbrains.mps.lang.generator.generator.baseLanguage.template.util;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class GenUtil {
  private static final String KEY = "VarName";
  public GenUtil() {
  }
  public static String getVar(TemplateQueryContext context, SNode node, int skipMacro) {
    List<SNode> macros = ListSequence.fromList(SNodeOperations.getChildren(node)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0xfd47ed6742L, "jetbrains.mps.lang.generator.structure.NodeMacro"));
      }
    }).toListSequence();
    SNode real = (ListSequence.fromList(macros).count() <= skipMacro ? node : ListSequence.fromList(macros).getElement(skipMacro));
    return (String) context.getTransientObject(MultiTuple.<String,SNode>from(KEY, real));
  }
  public static String saveVar(TemplateQueryContext context, SNode node, String var) {
    SNode original = (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0xfd47ed6742L, "jetbrains.mps.lang.generator.structure.NodeMacro")) ? SNodeOperations.getParent(node) : node);
    if (context.getTransientObject(original) == null) {
      context.putTransientObject(original, var);
    }
    context.putTransientObject(MultiTuple.<String,SNode>from(KEY, node), var);
    return var;
  }

  /**
   * Record the fact template for given node has been extracted into distinct method
   */
  public static void markExtractedMethodForTemplate(TemplateQueryContext context, SNode node, String methodName) {
    context.putTransientObject(MultiTuple.<String,SNode>from("meth", node), methodName);
  }

  /**
   * Tell previously recorded name of the method extracted for the given template node.
   */
  public static String getExtractedMethodName(TemplateQueryContext context, SNode node) {
    return (String) context.getTransientObject(MultiTuple.<String,SNode>from("meth", node));
  }

  public static boolean isGeneratable(SModel model) {
    SNode node = SModelOperations.getModuleStub(model);
    if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0x86ef829012bb4ca7L, 0x947f093788f263a9L, 0x5869770da61dfe21L, "jetbrains.mps.lang.project.structure.Generator"))) {
      return SPropertyOperations.getBoolean(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0x86ef829012bb4ca7L, 0x947f093788f263a9L, 0x5869770da61dfe21L, "jetbrains.mps.lang.project.structure.Generator")), MetaAdapterFactory.getProperty(0x86ef829012bb4ca7L, 0x947f093788f263a9L, 0x5869770da61dfe21L, 0x29a5716c5dfed280L, "generateTemplates"));
    }
    return false;
  }
  public static String asIdentifier(String s) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      if (Character.isDigit(c) && sb.length() > 0) {
        sb.append(c);
      } else if (Character.isJavaIdentifierStart(c) && c != '$') {
        sb.append(c);
      } else {
        // replace all non-identifier characters with underscore 
        //  I realize that may lead to name clashes, but odds are too low and do not justify e.g. _x0020 in the name with spaces 
        sb.append('_');
      }
    }

    return sb.toString();
  }
}
