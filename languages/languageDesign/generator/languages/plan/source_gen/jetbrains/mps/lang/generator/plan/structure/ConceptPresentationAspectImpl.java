package jetbrains.mps.lang.generator.plan.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;

public class ConceptPresentationAspectImpl extends ConceptPresentationAspectBase {
  private ConceptPresentation props_ApplyGenerators;
  private ConceptPresentation props_Checkpoint;
  private ConceptPresentation props_CheckpointDeclaration;
  private ConceptPresentation props_CheckpointSpecification;
  private ConceptPresentation props_CheckpointSynchronization;
  private ConceptPresentation props_DeclaredCheckpointSpec;
  private ConceptPresentation props_InPlaceCheckpointRefSpec;
  private ConceptPresentation props_InPlaceCheckpointSpec;
  private ConceptPresentation props_IncludePlan;
  private ConceptPresentation props_Plan;
  private ConceptPresentation props_Step;
  private ConceptPresentation props_Transform;

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) myLanguageRuntime.getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);
    switch (structureDescriptor.internalIndex(c)) {
      case LanguageConceptSwitch.ApplyGenerators:
        if (props_ApplyGenerators == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Collection of generators to apply directly");
          cpb.rawPresentation("ApplyGenerators");
          props_ApplyGenerators = cpb.create();
        }
        return props_ApplyGenerators;
      case LanguageConceptSwitch.Checkpoint:
        if (props_Checkpoint == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Synchronization point of a generation plan");
          cpb.presentationByName();
          props_Checkpoint = cpb.create();
        }
        return props_Checkpoint;
      case LanguageConceptSwitch.CheckpointDeclaration:
        if (props_CheckpointDeclaration == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Declaration of a checkpoint suitable for reuse, with no persistence/synchronization semantics attached.");
          cpb.presentationByName();
          props_CheckpointDeclaration = cpb.create();
        }
        return props_CheckpointDeclaration;
      case LanguageConceptSwitch.CheckpointSpecification:
        if (props_CheckpointSpecification == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_CheckpointSpecification = cpb.create();
        }
        return props_CheckpointSpecification;
      case LanguageConceptSwitch.CheckpointSynchronization:
        if (props_CheckpointSynchronization == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Take external references associated with the given checkpoint");
          cpb.rawPresentation("synchronize with checkpoint");
          props_CheckpointSynchronization = cpb.create();
        }
        return props_CheckpointSynchronization;
      case LanguageConceptSwitch.DeclaredCheckpointSpec:
        if (props_DeclaredCheckpointSpec == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("use a pure checkpoint declared elsewhere");
          cpb.rawPresentation("DeclaredCheckpointSpec");
          props_DeclaredCheckpointSpec = cpb.create();
        }
        return props_DeclaredCheckpointSpec;
      case LanguageConceptSwitch.InPlaceCheckpointRefSpec:
        if (props_InPlaceCheckpointRefSpec == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("reference another checkpoint step with in-place declaration");
          cpb.rawPresentation("InPlaceCheckpointRefSpec");
          props_InPlaceCheckpointRefSpec = cpb.create();
        }
        return props_InPlaceCheckpointRefSpec;
      case LanguageConceptSwitch.InPlaceCheckpointSpec:
        if (props_InPlaceCheckpointSpec == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("define checkpoint right here");
          cpb.presentationByName();
          props_InPlaceCheckpointSpec = cpb.create();
        }
        return props_InPlaceCheckpointSpec;
      case LanguageConceptSwitch.IncludePlan:
        if (props_IncludePlan == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("aggregate existing plan");
          cpb.rawPresentation("include plan");
          props_IncludePlan = cpb.create();
        }
        return props_IncludePlan;
      case LanguageConceptSwitch.Plan:
        if (props_Plan == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Sequence of transformation steps");
          cpb.presentationByName();
          props_Plan = cpb.create();
        }
        return props_Plan;
      case LanguageConceptSwitch.Step:
        if (props_Step == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_Step = cpb.create();
        }
        return props_Step;
      case LanguageConceptSwitch.Transform:
        if (props_Transform == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Collection of languages to reduce (iow, generators to apply)");
          cpb.rawPresentation("Transform");
          props_Transform = cpb.create();
        }
        return props_Transform;
    }
    return null;
  }
}
