package jetbrains.mps.lang.core.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vfs.IFile;
import java.util.List;
import jetbrains.mps.make.delta.IDelta;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.make.runtime.java.FileDeltaCollector;
import java.util.HashMap;
import jetbrains.mps.internal.make.runtime.java.FileProcessor;
import jetbrains.mps.generator.impl.dependencies.GenerationDependenciesCache;
import jetbrains.mps.messages.IMessageHandler;
import jetbrains.mps.project.facets.GenerationTargetFacet;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.project.facets.JavaModuleFacet;
import jetbrains.mps.internal.make.runtime.util.FilesDelta;
import jetbrains.mps.internal.make.runtime.util.DeltaKey;
import java.util.function.Consumer;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.generator.impl.dependencies.GenerationDependencies;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;

/*package*/ class ModuleStaleFileManager {
  private final SModule myModule;
  private final _FunctionTypes._return_P1_E0<? extends IFile, ? super String> myPath2File;
  private final List<IDelta> myRetainedFilesDelta = ListSequence.fromList(new ArrayList<IDelta>());
  private final List<IDelta> myStaleFilesDelta = ListSequence.fromList(new ArrayList<IDelta>());
  private final Map<IFile, FileDeltaCollector> myModelLocationStreams = new HashMap<IFile, FileDeltaCollector>();
  private final FileProcessor myFileStorage;
  private final GenerationDependenciesCache myGenDeps;

  public ModuleStaleFileManager(SModule module, _FunctionTypes._return_P1_E0<? extends IFile, ? super String> getFile, GenerationDependenciesCache genDeps, IMessageHandler msgHandler) {
    myModule = module;
    myFileStorage = new FileProcessor(msgHandler);
    myPath2File = getFile;
    myGenDeps = genDeps;
  }

  private GenerationTargetFacet getGenerationTargetFacet(SModel model) {
    // For a model, we need to find source_gen, test_gen location and relative model/qualified/name under respective output root 
    // FIXME module facets and their output location management story is not complete, here is a hack to ensure test models are kept where they used to be 
    if (SModelStereotype.isTestModel(model)) {
      TestsFacet testsFacet = myModule.getFacet(TestsFacet.class);
      if (testsFacet != null) {
        return testsFacet;
      }
    }
    //  SModuleOperations.getOutputRoots respected TestsFacet and JavaModuleFacet, therefore keep JMF with higher priority than any other GTF 
    JavaModuleFacet jmf = myModule.getFacet(JavaModuleFacet.class);
    if (jmf != null) {
      return jmf;
    }
    // resort to any other 
    return myModule.getFacet(GenerationTargetFacet.class);
  }

  /*package*/ void collectRetainedFiles(Iterable<SModel> retainedModels) {
    // each file we know as generated from a retained model reported as kept 
    final FilesDelta fd = new FilesDelta(new DeltaKey(myModule));
    Consumer<IFile> f = new Consumer<IFile>() {
      public void accept(IFile f) {
        fd.kept(f);
      }
    };
    for (SModel m : Sequence.fromIterable(retainedModels)) {
      // I'm fine with retained delta as module-wide, known clients that utilize TResource care about fresh files 
      visitGeneratedFiles(m, f);
    }
    ListSequence.fromList(myRetainedFilesDelta).addElement(fd);
    // It's important to keep user files, and I'd rather say extra keep rather than deal with user files gone 
    // FIXME remove this code after 2018.3 
    Iterable<IDelta> retainedFilesDelta = RetainedUtil.retainedDeltas(myModule, retainedModels, myPath2File);
    ListSequence.fromList(myRetainedFilesDelta).addSequence(Sequence.fromIterable(retainedFilesDelta));
  }

  private void visitGeneratedFiles(SModel m, Consumer<IFile> visitor) {
    GenerationDependencies gdc = myGenDeps.get(m);
    if (gdc == null) {
      return;
    }
    // COMPATIBILITY: for 'generated' without file name information (we could detect here by GD's version), no file would be reported 
    // both for retained and changed models. As long as no files would be marked as stale, I don't expect any unchaned file to be deleted then. 
    final GenerationTargetFacet gtf = getGenerationTargetFacet(m);
    if (gtf == null) {
      return;
    }
    final IFile outputRoot = gtf.getOutputRoot(m);
    final IFile outputDir = gtf.getOutputLocation(m);
    if (outputDir == null || outputRoot == null) {
      return;
    }
    IFile actualOutputRoot = myPath2File.invoke(outputRoot.getPath());
    IFile actualModelOutputLoc = myPath2File.invoke(outputDir.getPath());
    gdc.reportGeneratedFiles(actualOutputRoot, actualModelOutputLoc, visitor);
    IFile outputCacheLocation = gtf.getOutputCacheLocation(m);
    IFile actualCacheLocation = (outputCacheLocation == null ? null : myPath2File.invoke(outputCacheLocation.getPath()));
    if (actualCacheLocation != null) {
      visitor.accept(actualCacheLocation);
    }
  }

  /*package*/ void collectGeneratedFiles(SModel generatedInputModel) {
    // each file of generated model reported as stale 
    // or collect files of generatedModels, then update with delta of generated, and those that left report as 'stale' (not to merge stale delta with written/touched) 
    final FilesDelta fd = new FilesDelta(new DeltaKey(myModule, generatedInputModel));
    visitGeneratedFiles(generatedInputModel, new Consumer<IFile>() {
      public void accept(IFile f) {
        fd.stale(f);
      }
    });
    ListSequence.fromList(myStaleFilesDelta).addElement(fd);
  }

  /**
   * For now, as we report delta for a (module, model) pair, FDC instances recorded here are not in use (#completeDelta is not invoked).
   * However, once there's no need for per resource delta, external code shall cease using getModuleWideDelta directly.
   */
  /*package*/ FileDeltaCollector getPrimaryStreamHandler(SModel generatedInputModel) {
    // stream handler to write files inside a standard model location by default 
    // it seems that StreamHandler API needs are redesign - its use of IFile is just to produce descendant from filename. In fact, it may keep 
    // arbitrary file. 
    GenerationTargetFacet gtf = getGenerationTargetFacet(generatedInputModel);
    if (gtf == null) {
      throw new IllegalStateException();
    }
    IFile outputDir = gtf.getOutputLocation(generatedInputModel);
    // In fact, we are not obliged to cache FDC per output dir, it' just handy to keep them here to perform batched delta update later. 
    // Could be new FDC() right in the facet code and then feed this manager with fdc.getDelta() result 
    FileDeltaCollector rv = myModelLocationStreams.get(outputDir);
    if (rv == null) {
      rv = newStreamHandler(generatedInputModel, outputDir);
      myModelLocationStreams.put(outputDir, rv);
    }
    return rv;
  }

  /**
   * PROVISIONAL, intended to investigate TU with own path spec.
   * 'new' in the name means we don't track FDC instance here
   */
  /*package*/ FileDeltaCollector newPrimaryStreamHandler(SModel generatedInputModel, String path) {
    GenerationTargetFacet gtf = getGenerationTargetFacet(generatedInputModel);
    if (gtf == null) {
      throw new IllegalStateException();
    }
    IFile outputRoot = gtf.getOutputRoot(generatedInputModel);
    IFile nested = outputRoot.getDescendant(path);
    return newStreamHandler(generatedInputModel, nested);
  }

  /*package*/ FileDeltaCollector getCacheStreamHandler(SModel generatedInputModel) {
    // almost identical to getPrimaryStreamHandler(), above, uses getOutputCacheLocation() 
    GenerationTargetFacet gtf = getGenerationTargetFacet(generatedInputModel);
    if (gtf == null) {
      throw new IllegalStateException();
    }
    IFile outputDir = gtf.getOutputCacheLocation(generatedInputModel);
    FileDeltaCollector rv = myModelLocationStreams.get(outputDir);
    if (rv == null) {
      rv = newStreamHandler(generatedInputModel, outputDir);
      myModelLocationStreams.put(outputDir, rv);
    }
    return rv;
  }

  /*package*/ List<IDelta> completeDelta() {
    // pretty much the same code is in getModuleWideStaleFiles, the difference is that this method is to work in conjunction 
    // with getStreamHandler(), so that updateWith(newStreamHandler()) is not necessary (it's what foreach below does). 
    List<IDelta> rv = ListSequence.fromList(new ArrayList<IDelta>());
    for (FileDeltaCollector fdc : CollectionSequence.fromCollection(myModelLocationStreams.values())) {
      ListSequence.fromList(rv).addElement(fdc.getDelta());
    }
    ListSequence.fromList(rv).addSequence(ListSequence.fromList(getModuleWideDelta()));
    return rv;
  }


  private FileDeltaCollector newStreamHandler(SModel model, IFile outputDir) {
    DeltaKey dk = new DeltaKey(model.getModule(), model);
    // FDC needs actual path as it creates IFile from filename string at that location 
    return new FileDeltaCollector(new FilesDelta(dk), myPath2File.invoke(outputDir.getPath()), myFileStorage);
  }

  /*package*/ List<IDelta> getModuleWideDelta() {
    List<IDelta> rv = ListSequence.fromListWithValues(new ArrayList<IDelta>(), myStaleFilesDelta);
    ListSequence.fromList(rv).addSequence(ListSequence.fromList(myRetainedFilesDelta));
    return rv;
  }

  /*package*/ void flushChanges() {
    myFileStorage.flushChanges();
  }
}
