package jetbrains.mps.lang.core.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vfs.IFile;
import java.util.List;
import jetbrains.mps.make.delta.IDelta;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.make.runtime.java.FileDeltaCollector;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.internal.make.runtime.java.FileProcessor;
import jetbrains.mps.internal.make.runtime.util.StaleFilesCollector;
import jetbrains.mps.messages.IMessageHandler;
import jetbrains.mps.project.SModuleOperations;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.generator.impl.dependencies.GenerationDependenciesCache;
import jetbrains.mps.internal.make.runtime.util.FilesDelta;
import jetbrains.mps.internal.make.runtime.util.DeltaKey;
import jetbrains.mps.generator.impl.dependencies.GenerationDependencies;
import jetbrains.mps.generator.impl.DefaultStreamManager;
import java.util.function.Consumer;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.make.runtime.util.DirUtil;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;

/*package*/ class ModuleStaleFileManager {
  private final SModule myModule;
  private final _FunctionTypes._return_P1_E0<? extends IFile, ? super String> myPath2File;
  private final List<IDelta> myRetainedFilesDelta = ListSequence.fromList(new ArrayList<IDelta>());
  private final List<IDelta> myNonRootedDelta = ListSequence.fromList(new ArrayList<IDelta>());
  private final FileDeltaCollector mySourceGenStreams;
  private final Map<IFile, FileDeltaCollector> myModelLocationStreams = new HashMap<IFile, FileDeltaCollector>();
  private final FileProcessor myFileStorage;
  private final Map<IFile, StaleFilesCollector> myStaleFileCollectors = new HashMap<IFile, StaleFilesCollector>();

  public ModuleStaleFileManager(SModule module, _FunctionTypes._return_P1_E0<? extends IFile, ? super String> getFile, IMessageHandler msgHandler) {
    myModule = module;
    myFileStorage = new FileProcessor(msgHandler);
    // XXX it seems I need StaleFilesCollector and hence module's output roots only if I'd like to walk FS and collect files. 
    // If I can tell generated files by other means (e.g. read from 'generated'), I don't need to bother with output roots 
    for (IFile outputRoot : SModuleOperations.getOutputRoots(module)) {
      // quite likely I don't need dedicated StaleFilesCollector class as I could do the same here. OTOH, may want to encapsulate 
      // different approaches to stale files (e.g. explicitly listed in 'generated' vs collected by root walking) there 
      myStaleFileCollectors.put(outputRoot, new StaleFilesCollector(getFile.invoke(outputRoot.getPath())));
    }
    // FIXME initialize mySourceGenStreams once we start using paths from textgen 
    mySourceGenStreams = null;
    myPath2File = getFile;
  }

  /*package*/ void collectRetainedFiles(Iterable<SModel> retainedModels) {
    // each file of retained model reported as kept 
    Iterable<IDelta> retainedFilesDelta = RetainedUtil.retainedDeltas(myModule, retainedModels, myPath2File);
    ListSequence.fromList(myRetainedFilesDelta).addSequence(Sequence.fromIterable(retainedFilesDelta));
  }

  /*package*/ void collectRetainedFiles2(GenerationDependenciesCache genDeps, Iterable<SModel> retainedModels) {
    // each file of retained model reported as kept 
    final IFile outputRoot = null;
    IFile actualOutputRoot = myPath2File.invoke(outputRoot.getPath());
    final FilesDelta fd = new FilesDelta(new DeltaKey(myModule));
    for (SModel m : Sequence.fromIterable(retainedModels)) {
      GenerationDependencies gdc = genDeps.get(m);
      if (gdc == null) {
        continue;
      }
      final IFile outputDir = DefaultStreamManager.Provider.getOutputDir(m);
      IFile actualModelOutputLoc = myPath2File.invoke(outputDir.getPath());
      gdc.reportGeneratedFiles(actualOutputRoot, actualModelOutputLoc, new Consumer<IFile>() {
        public void accept(IFile f) {
          fd.kept(f);
        }
      });
    }
    ListSequence.fromList(myRetainedFilesDelta).addElement(fd);
  }

  /*package*/ void collectGeneratedFiles(GenerationDependenciesCache genDeps, SModel generatedInputModel) {
    // each file of generated model reported as stale 
    // or collect files of generatedModels, then update with delta of generated, and those that left report as 'stale' (not to merge stale delta with written/touched) 
    // 
    // intentionally no myStaleFileCollector.recordGeneratedChildren() call, GenerationDependenciesCache doesn't list any file these days 
    // TextGen used to do StaleFileCollector(javaOutputDir).recordGeneratedChildren(genDeps, inputModel) 
    // however, with genDeps that don't keep files information, it's merely a no-op, hence no reason to bother calling it. 
    // Besides, myStateFileCollector is not rooted at javaOutputDir, and I don't want to figure out whether it matters or not 
  }

  /*package*/ FileDeltaCollector getModuleWideStreamHandler() {
    // per source_gen, for output into files with path, not just file name 
    return mySourceGenStreams;
  }

  /**
   * This method is not in use now and is merely to suggest a future API, once we don't need to report delta for a (module, model) pair and can collect delta 
   * for the whole module at once
   */
  /*package*/ FileDeltaCollector getStreamHandler(IFile outputDir) {
    // transition stream handler to write files inside a standard model location 
    // it seems that StreamHandler API needs are redesign. 
    // 
    // In fact, we are not obliged to cache FDC per output dir, it' just handy to keep them here to perform batched delta update later. 
    // Could ne new FDC() right in the facet code and then feed this manager with fdc.getDelta() result 
    FileDeltaCollector rv = myModelLocationStreams.get(outputDir);
    if (rv == null) {
      // FIXME model arg for newStreamHandler could not be null 
      rv = newStreamHandler(null, outputDir);
      myModelLocationStreams.put(outputDir, rv);
    }
    return rv;
  }

  /*package*/ List<IDelta> completeDelta() {
    // pretty much the same code is in getModuleWideStaleFiles, the difference is that this method is to work in conjunction 
    // with getStreamHandler(), so that updateWith(newStreamHandler()) is not necessary (it's what foreach below does). 
    List<IDelta> rv = ListSequence.fromList(new ArrayList<IDelta>());
    for (IFile f : SetSequence.fromSet(myModelLocationStreams.keySet())) {
      FileDeltaCollector fdc = myModelLocationStreams.get(f);
      updateWith(f, fdc);
      ListSequence.fromList(rv).addElement(fdc.getDelta());
    }
    ListSequence.fromList(rv).addSequence(ListSequence.fromList(getModuleWideDelta()));
    return rv;
  }




  /*package*/ FileDeltaCollector newStreamHandler(SModel model, IFile outputDir) {
    DeltaKey dk = new DeltaKey(model.getModule(), model);
    // FDC needs actual path as it creates IFile from filename string at that location 
    return new FileDeltaCollector(new FilesDelta(dk), myPath2File.invoke(outputDir.getPath()), myFileStorage);
  }

  /*package*/ void updateWith(IFile outputDir, FileDeltaCollector fdc) {
    // this method to be used in conjunction with getModuleWideDelta 
    // fdc is result of earlier newStreamHandler call. Here, we find collector of stale files for output root that is ancestor of supplied delta (fdc) 
    // and update it with written/kept files so that some of the stale files are not anymore. 
    for (IFile f : SetSequence.fromSet(myStaleFileCollectors.keySet())) {
      // didn't find a mechanism to figure out f.isAncestor(outputDir), resort to DirUtil. Beware x/source_gen.caches starts with x/source_gen; DirUtil cares to ensure there's slash 
      if (DirUtil.startsWith(outputDir.getPath(), f.getPath())) {
        // record a delta in a tracker for a first root that contains the output directory 
        myStaleFileCollectors.get(f).recordFilesToKeep(fdc.getDelta());
        return;
      }
    }
    // generally shall not happen, although there are models that override location (see GeneratableSModel.isGenerateIntoModelFolder) and therefore we won't find entry 
    // in myStaleFileCollectors (which is populated from module output roots) 
    // Note, at the moment, I don't use this value (getModuleWideDelta doesn't need this as fdc's delta would be reported through ResourceDeltaCollector for (module, model) 
    ListSequence.fromList(myNonRootedDelta).addElement(fdc.getDelta());
  }

  /*package*/ List<IDelta> getModuleWideDelta() {
    // walk delta of each MyModelLocationStreams.values() + mySourceGenStreams and record files were modified and therefore we shall not delete 
    // then for each file we treat as generated (either we've walked source_gen or we've read cached information with generated files paths) 
    // check if it's in the first list, and for those missing report 'stale'. 
    if (mySourceGenStreams != null) {
      for (StaleFilesCollector fc : CollectionSequence.fromCollection(myStaleFileCollectors.values())) {
        fc.recordFilesToKeep(mySourceGenStreams.getDelta());
      }
    }
    FilesDelta d = new FilesDelta(new DeltaKey(myModule));
    for (StaleFilesCollector fc : CollectionSequence.fromCollection(myStaleFileCollectors.values())) {
      fc.reportStaleFilesInto(d);
    }
    List<IDelta> rv = ListSequence.fromListWithValues(new ArrayList<IDelta>(), myRetainedFilesDelta);
    ListSequence.fromList(rv).addElement(d);
    return rv;
  }

  /*package*/ void flushChanges() {
    myFileStorage.flushChanges();
  }
}
