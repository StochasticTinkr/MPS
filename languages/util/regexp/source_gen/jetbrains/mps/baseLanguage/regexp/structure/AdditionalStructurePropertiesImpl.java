package jetbrains.mps.baseLanguage.regexp.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.BaseAdditionalStructureProperties;
import jetbrains.mps.smodel.runtime.AdditionalConceptProperties;
import jetbrains.mps.smodel.runtime.ConceptPropsBuilder;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class AdditionalStructurePropertiesImpl extends BaseAdditionalStructureProperties {
  private final AdditionalConceptProperties props_AtLeastNTimesRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_BinaryRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_CharacterSymbolClassPart = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_DotRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_FindMatchExpression = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_FindMatchStatement = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_ForEachMatchStatement = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_FromNToMTimesRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_InlineRegexpExpression = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_IntersectionSymbolClassPart = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_IntervalSymbolClassPart = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_LazyPlusRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_LazyQuestionRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_LazyStarRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_LineEndRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_LineStartRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_LiteralReplacement = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_LookRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_MatchParensRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_MatchRegexpExpression = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_MatchRegexpOperation = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_MatchRegexpStatement = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_MatchVariableReference = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_MatchVariableReferenceRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_MatchVariableReferenceReplacement = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_NTimesRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_NegativeLookAheadRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_NegativeLookBehindRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_NegativeSymbolClassRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_OrRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_ParensRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_PlusRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_PositiveLookAheadRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_PositiveLookBehindRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_PositiveSymbolClassRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_PredefinedSymbolClassDeclaration = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_PredefinedSymbolClassRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_PredefinedSymbolClassSymbolClassPart = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_PredefinedSymbolClasses = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_QuestionRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_Regexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_RegexpDeclaration = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_RegexpDeclarationReferenceRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_RegexpExpression = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_RegexpUsingConstruction = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_Regexps = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_ReplaceBlock = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_ReplaceRegexpOperation = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_ReplaceWithRegexpExpression = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_ReplaceWithRegexpOperation = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_Replacement = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_SeqRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_SplitExpression = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_SplitOperation = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_StarRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_StringLiteralRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_SymbolClassPart = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_SymbolClassRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_SymbolClassRegexpAndPart = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_UnaryRegexp = new ConceptPropsBuilder().create();
  private final AdditionalConceptProperties props_UnicodeCharacterRegexp = new ConceptPropsBuilder().create();

  @Override
  @Nullable
  public AdditionalConceptProperties getDescriptor(SAbstractConcept c) {
    {
      SAbstractConcept cncpt = c;
      Integer preIndex = indices_4qogsf_a0kc.get(cncpt);
      int switchIndex = (preIndex == null ? -1 : preIndex);
      switch (switchIndex) {
        case 0:
          if (true) {
            return props_AtLeastNTimesRegexp;
          }
          break;
        case 1:
          if (true) {
            return props_BinaryRegexp;
          }
          break;
        case 2:
          if (true) {
            return props_CharacterSymbolClassPart;
          }
          break;
        case 3:
          if (true) {
            return props_DotRegexp;
          }
          break;
        case 4:
          if (true) {
            return props_FindMatchExpression;
          }
          break;
        case 5:
          if (true) {
            return props_FindMatchStatement;
          }
          break;
        case 6:
          if (true) {
            return props_ForEachMatchStatement;
          }
          break;
        case 7:
          if (true) {
            return props_FromNToMTimesRegexp;
          }
          break;
        case 8:
          if (true) {
            return props_InlineRegexpExpression;
          }
          break;
        case 9:
          if (true) {
            return props_IntersectionSymbolClassPart;
          }
          break;
        case 10:
          if (true) {
            return props_IntervalSymbolClassPart;
          }
          break;
        case 11:
          if (true) {
            return props_LazyPlusRegexp;
          }
          break;
        case 12:
          if (true) {
            return props_LazyQuestionRegexp;
          }
          break;
        case 13:
          if (true) {
            return props_LazyStarRegexp;
          }
          break;
        case 14:
          if (true) {
            return props_LineEndRegexp;
          }
          break;
        case 15:
          if (true) {
            return props_LineStartRegexp;
          }
          break;
        case 16:
          if (true) {
            return props_LiteralReplacement;
          }
          break;
        case 17:
          if (true) {
            return props_LookRegexp;
          }
          break;
        case 18:
          if (true) {
            return props_MatchParensRegexp;
          }
          break;
        case 19:
          if (true) {
            return props_MatchRegexpExpression;
          }
          break;
        case 20:
          if (true) {
            return props_MatchRegexpOperation;
          }
          break;
        case 21:
          if (true) {
            return props_MatchRegexpStatement;
          }
          break;
        case 22:
          if (true) {
            return props_MatchVariableReference;
          }
          break;
        case 23:
          if (true) {
            return props_MatchVariableReferenceRegexp;
          }
          break;
        case 24:
          if (true) {
            return props_MatchVariableReferenceReplacement;
          }
          break;
        case 25:
          if (true) {
            return props_NTimesRegexp;
          }
          break;
        case 26:
          if (true) {
            return props_NegativeLookAheadRegexp;
          }
          break;
        case 27:
          if (true) {
            return props_NegativeLookBehindRegexp;
          }
          break;
        case 28:
          if (true) {
            return props_NegativeSymbolClassRegexp;
          }
          break;
        case 29:
          if (true) {
            return props_OrRegexp;
          }
          break;
        case 30:
          if (true) {
            return props_ParensRegexp;
          }
          break;
        case 31:
          if (true) {
            return props_PlusRegexp;
          }
          break;
        case 32:
          if (true) {
            return props_PositiveLookAheadRegexp;
          }
          break;
        case 33:
          if (true) {
            return props_PositiveLookBehindRegexp;
          }
          break;
        case 34:
          if (true) {
            return props_PositiveSymbolClassRegexp;
          }
          break;
        case 35:
          if (true) {
            return props_PredefinedSymbolClassDeclaration;
          }
          break;
        case 36:
          if (true) {
            return props_PredefinedSymbolClassRegexp;
          }
          break;
        case 37:
          if (true) {
            return props_PredefinedSymbolClassSymbolClassPart;
          }
          break;
        case 38:
          if (true) {
            return props_PredefinedSymbolClasses;
          }
          break;
        case 39:
          if (true) {
            return props_QuestionRegexp;
          }
          break;
        case 40:
          if (true) {
            return props_Regexp;
          }
          break;
        case 41:
          if (true) {
            return props_RegexpDeclaration;
          }
          break;
        case 42:
          if (true) {
            return props_RegexpDeclarationReferenceRegexp;
          }
          break;
        case 43:
          if (true) {
            return props_RegexpExpression;
          }
          break;
        case 44:
          if (true) {
            return props_RegexpUsingConstruction;
          }
          break;
        case 45:
          if (true) {
            return props_Regexps;
          }
          break;
        case 46:
          if (true) {
            return props_ReplaceBlock;
          }
          break;
        case 47:
          if (true) {
            return props_ReplaceRegexpOperation;
          }
          break;
        case 48:
          if (true) {
            return props_ReplaceWithRegexpExpression;
          }
          break;
        case 49:
          if (true) {
            return props_ReplaceWithRegexpOperation;
          }
          break;
        case 50:
          if (true) {
            return props_Replacement;
          }
          break;
        case 51:
          if (true) {
            return props_SeqRegexp;
          }
          break;
        case 52:
          if (true) {
            return props_SplitExpression;
          }
          break;
        case 53:
          if (true) {
            return props_SplitOperation;
          }
          break;
        case 54:
          if (true) {
            return props_StarRegexp;
          }
          break;
        case 55:
          if (true) {
            return props_StringLiteralRegexp;
          }
          break;
        case 56:
          if (true) {
            return props_SymbolClassPart;
          }
          break;
        case 57:
          if (true) {
            return props_SymbolClassRegexp;
          }
          break;
        case 58:
          if (true) {
            return props_SymbolClassRegexpAndPart;
          }
          break;
        case 59:
          if (true) {
            return props_UnaryRegexp;
          }
          break;
        case 60:
          if (true) {
            return props_UnicodeCharacterRegexp;
          }
          break;
        default:
      }
    }
    throw new IllegalStateException();
  }
  private static Map<SAbstractConcept, Integer> buildConceptIndices(SAbstractConcept... concepts) {
    HashMap<SAbstractConcept, Integer> res = new HashMap<SAbstractConcept, Integer>();
    int counter = 0;
    for (SAbstractConcept c : concepts) {
      res.put(c, counter++);
    }
    return res;
  }
  private static final Map<SAbstractConcept, Integer> indices_4qogsf_a0kc = buildConceptIndices(MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118dc30ee2L, "AtLeastNTimesRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174c56bf9L, "BinaryRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x111791ae82fL, "CharacterSymbolClassPart"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x111790aa926L, "DotRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x550fbf4ebc5de3f5L, "FindMatchExpression"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1119d8807a3L, "FindMatchStatement"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1119caff72eL, "ForEachMatchStatement"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118dc58c6eL, "FromNToMTimesRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117648961dL, "InlineRegexpExpression"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11c0ef7f429L, "IntersectionSymbolClassPart"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11179215e8bL, "IntervalSymbolClassPart"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117f38e076L, "LazyPlusRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117f394b67L, "LazyQuestionRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117f383367L, "LazyStarRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1119d126564L, "LineEndRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1119d11da7eL, "LineStartRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x34ae970c192ab94cL, "LiteralReplacement"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118de32185L, "LookRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x111797946c7L, "MatchParensRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x112972a0c32L, "MatchRegexpExpression"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11c9466ae95L, "MatchRegexpOperation"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11176652f14L, "MatchRegexpStatement"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117987ff5eL, "MatchVariableReference"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118e0a1c55L, "MatchVariableReferenceRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x34ae970c192ab94eL, "MatchVariableReferenceReplacement"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118dbeda57L, "NTimesRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118de1f935L, "NegativeLookAheadRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118de6e3f6L, "NegativeLookBehindRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11178e35c63L, "NegativeSymbolClassRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174a0d780L, "OrRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x111752101b0L, "ParensRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174a15de8L, "PlusRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118ddfb973L, "PositiveLookAheadRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118de6742fL, "PositiveLookBehindRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11178e2f48cL, "PositiveSymbolClassRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11178e59fd0L, "PredefinedSymbolClassDeclaration"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11178fa2a18L, "PredefinedSymbolClassRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117928d9f2L, "PredefinedSymbolClassSymbolClassPart"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11178e5efc7L, "PredefinedSymbolClasses"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11178c4e1e0L, "QuestionRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174a06efdL, "Regexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174a6454dL, "RegexpDeclaration"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117f58ea2aL, "RegexpDeclarationReferenceRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1118ea37105L, "RegexpExpression"), MetaAdapterFactory.getInterfaceConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117ecbc07aL, "RegexpUsingConstruction"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117f550b6dL, "Regexps"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117ef80054L, "ReplaceBlock"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x34ae970c1923d18aL, "ReplaceRegexpOperation"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1117ef3f72dL, "ReplaceWithRegexpExpression"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11c94680172L, "ReplaceWithRegexpOperation"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x34ae970c192ab952L, "Replacement"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174bc30e7L, "SeqRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x1119d41c734L, "SplitExpression"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11c942ab86bL, "SplitOperation"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174a16ffaL, "StarRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174a0992dL, "StringLiteralRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x111791aa602L, "SymbolClassPart"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11178e2916aL, "SymbolClassRegexp"), MetaAdapterFactory.getInterfaceConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11c22ec8f79L, "SymbolClassRegexpAndPart"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174c678adL, "UnaryRegexp"), MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11831260718L, "UnicodeCharacterRegexp"));
}
