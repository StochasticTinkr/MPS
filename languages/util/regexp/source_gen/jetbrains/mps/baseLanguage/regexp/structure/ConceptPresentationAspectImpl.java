package jetbrains.mps.baseLanguage.regexp.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;

public class ConceptPresentationAspectImpl extends ConceptPresentationAspectBase {
  private ConceptPresentation props_AtLeastNTimesRegexp;
  private ConceptPresentation props_BinaryRegexp;
  private ConceptPresentation props_CharacterSymbolClassPart;
  private ConceptPresentation props_DotRegexp;
  private ConceptPresentation props_FindMatchExpression;
  private ConceptPresentation props_FindMatchStatement;
  private ConceptPresentation props_ForEachMatchStatement;
  private ConceptPresentation props_FromNToMTimesRegexp;
  private ConceptPresentation props_InlineRegexpExpression;
  private ConceptPresentation props_IntersectionSymbolClassPart;
  private ConceptPresentation props_IntervalSymbolClassPart;
  private ConceptPresentation props_LazyPlusRegexp;
  private ConceptPresentation props_LazyQuestionRegexp;
  private ConceptPresentation props_LazyStarRegexp;
  private ConceptPresentation props_LineEndRegexp;
  private ConceptPresentation props_LineStartRegexp;
  private ConceptPresentation props_LiteralReplacement;
  private ConceptPresentation props_LookRegexp;
  private ConceptPresentation props_MatchParensRegexp;
  private ConceptPresentation props_MatchRegexpExpression;
  private ConceptPresentation props_MatchRegexpOperation;
  private ConceptPresentation props_MatchRegexpStatement;
  private ConceptPresentation props_MatchVariableReference;
  private ConceptPresentation props_MatchVariableReferenceRegexp;
  private ConceptPresentation props_MatchVariableReferenceReplacement;
  private ConceptPresentation props_NTimesRegexp;
  private ConceptPresentation props_NegativeLookAheadRegexp;
  private ConceptPresentation props_NegativeLookBehindRegexp;
  private ConceptPresentation props_NegativeSymbolClassRegexp;
  private ConceptPresentation props_OrRegexp;
  private ConceptPresentation props_ParensRegexp;
  private ConceptPresentation props_PlusRegexp;
  private ConceptPresentation props_PositiveLookAheadRegexp;
  private ConceptPresentation props_PositiveLookBehindRegexp;
  private ConceptPresentation props_PositiveSymbolClassRegexp;
  private ConceptPresentation props_PredefinedSymbolClassDeclaration;
  private ConceptPresentation props_PredefinedSymbolClassRegexp;
  private ConceptPresentation props_PredefinedSymbolClassSymbolClassPart;
  private ConceptPresentation props_PredefinedSymbolClasses;
  private ConceptPresentation props_QuestionRegexp;
  private ConceptPresentation props_Regexp;
  private ConceptPresentation props_RegexpDeclaration;
  private ConceptPresentation props_RegexpDeclarationReferenceRegexp;
  private ConceptPresentation props_RegexpExpression;
  private ConceptPresentation props_RegexpUsingConstruction;
  private ConceptPresentation props_Regexps;
  private ConceptPresentation props_ReplaceBlock;
  private ConceptPresentation props_ReplaceRegexpOperation;
  private ConceptPresentation props_ReplaceWithRegexpExpression;
  private ConceptPresentation props_ReplaceWithRegexpOperation;
  private ConceptPresentation props_Replacement;
  private ConceptPresentation props_SeqRegexp;
  private ConceptPresentation props_SplitExpression;
  private ConceptPresentation props_SplitOperation;
  private ConceptPresentation props_StarRegexp;
  private ConceptPresentation props_StringLiteralRegexp;
  private ConceptPresentation props_SymbolClassPart;
  private ConceptPresentation props_SymbolClassRegexp;
  private ConceptPresentation props_SymbolClassRegexpAndPart;
  private ConceptPresentation props_UnaryRegexp;
  private ConceptPresentation props_UnicodeCharacterRegexp;

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) myLanguageRuntime.getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);
    switch (structureDescriptor.internalIndex(c)) {
      case LanguageConceptSwitch.AtLeastNTimesRegexp:
        if (props_AtLeastNTimesRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("at least n times");
          props_AtLeastNTimesRegexp = cpb.create();
        }
        return props_AtLeastNTimesRegexp;
      case LanguageConceptSwitch.BinaryRegexp:
        if (props_BinaryRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_BinaryRegexp = cpb.create();
        }
        return props_BinaryRegexp;
      case LanguageConceptSwitch.CharacterSymbolClassPart:
        if (props_CharacterSymbolClassPart == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("character");
          props_CharacterSymbolClassPart = cpb.create();
        }
        return props_CharacterSymbolClassPart;
      case LanguageConceptSwitch.DotRegexp:
        if (props_DotRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("dot regexp (any character)");
          props_DotRegexp = cpb.create();
        }
        return props_DotRegexp;
      case LanguageConceptSwitch.FindMatchExpression:
        if (props_FindMatchExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_FindMatchExpression = cpb.create();
        }
        return props_FindMatchExpression;
      case LanguageConceptSwitch.FindMatchStatement:
        if (props_FindMatchStatement == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_FindMatchStatement = cpb.create();
        }
        return props_FindMatchStatement;
      case LanguageConceptSwitch.ForEachMatchStatement:
        if (props_ForEachMatchStatement == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ForEachMatchStatement = cpb.create();
        }
        return props_ForEachMatchStatement;
      case LanguageConceptSwitch.FromNToMTimesRegexp:
        if (props_FromNToMTimesRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("at least n but not more than m times");
          props_FromNToMTimesRegexp = cpb.create();
        }
        return props_FromNToMTimesRegexp;
      case LanguageConceptSwitch.InlineRegexpExpression:
        if (props_InlineRegexpExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_InlineRegexpExpression = cpb.create();
        }
        return props_InlineRegexpExpression;
      case LanguageConceptSwitch.IntersectionSymbolClassPart:
        if (props_IntersectionSymbolClassPart == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("intersection of classes");
          props_IntersectionSymbolClassPart = cpb.create();
        }
        return props_IntersectionSymbolClassPart;
      case LanguageConceptSwitch.IntervalSymbolClassPart:
        if (props_IntervalSymbolClassPart == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("character range");
          props_IntervalSymbolClassPart = cpb.create();
        }
        return props_IntervalSymbolClassPart;
      case LanguageConceptSwitch.LazyPlusRegexp:
        if (props_LazyPlusRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("one or more times, reluctant");
          props_LazyPlusRegexp = cpb.create();
        }
        return props_LazyPlusRegexp;
      case LanguageConceptSwitch.LazyQuestionRegexp:
        if (props_LazyQuestionRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("once or not at all, reluctant");
          props_LazyQuestionRegexp = cpb.create();
        }
        return props_LazyQuestionRegexp;
      case LanguageConceptSwitch.LazyStarRegexp:
        if (props_LazyStarRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("zero or more times, reluctant");
          props_LazyStarRegexp = cpb.create();
        }
        return props_LazyStarRegexp;
      case LanguageConceptSwitch.LineEndRegexp:
        if (props_LineEndRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("line end");
          props_LineEndRegexp = cpb.create();
        }
        return props_LineEndRegexp;
      case LanguageConceptSwitch.LineStartRegexp:
        if (props_LineStartRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("line start");
          props_LineStartRegexp = cpb.create();
        }
        return props_LineStartRegexp;
      case LanguageConceptSwitch.LiteralReplacement:
        if (props_LiteralReplacement == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_LiteralReplacement = cpb.create();
        }
        return props_LiteralReplacement;
      case LanguageConceptSwitch.LookRegexp:
        if (props_LookRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_LookRegexp = cpb.create();
        }
        return props_LookRegexp;
      case LanguageConceptSwitch.MatchParensRegexp:
        if (props_MatchParensRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("matching parens");
          props_MatchParensRegexp = cpb.create();
        }
        return props_MatchParensRegexp;
      case LanguageConceptSwitch.MatchRegexpExpression:
        if (props_MatchRegexpExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatchRegexpExpression = cpb.create();
        }
        return props_MatchRegexpExpression;
      case LanguageConceptSwitch.MatchRegexpOperation:
        if (props_MatchRegexpOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatchRegexpOperation = cpb.create();
        }
        return props_MatchRegexpOperation;
      case LanguageConceptSwitch.MatchRegexpStatement:
        if (props_MatchRegexpStatement == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("match with regexp");
          props_MatchRegexpStatement = cpb.create();
        }
        return props_MatchRegexpStatement;
      case LanguageConceptSwitch.MatchVariableReference:
        if (props_MatchVariableReference == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatchVariableReference = cpb.create();
        }
        return props_MatchVariableReference;
      case LanguageConceptSwitch.MatchVariableReferenceRegexp:
        if (props_MatchVariableReferenceRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatchVariableReferenceRegexp = cpb.create();
        }
        return props_MatchVariableReferenceRegexp;
      case LanguageConceptSwitch.MatchVariableReferenceReplacement:
        if (props_MatchVariableReferenceReplacement == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_MatchVariableReferenceReplacement = cpb.create();
        }
        return props_MatchVariableReferenceReplacement;
      case LanguageConceptSwitch.NTimesRegexp:
        if (props_NTimesRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("exactly n times");
          props_NTimesRegexp = cpb.create();
        }
        return props_NTimesRegexp;
      case LanguageConceptSwitch.NegativeLookAheadRegexp:
        if (props_NegativeLookAheadRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("negative look ahead");
          props_NegativeLookAheadRegexp = cpb.create();
        }
        return props_NegativeLookAheadRegexp;
      case LanguageConceptSwitch.NegativeLookBehindRegexp:
        if (props_NegativeLookBehindRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("negative look behind");
          props_NegativeLookBehindRegexp = cpb.create();
        }
        return props_NegativeLookBehindRegexp;
      case LanguageConceptSwitch.NegativeSymbolClassRegexp:
        if (props_NegativeSymbolClassRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("negative symbol class");
          props_NegativeSymbolClassRegexp = cpb.create();
        }
        return props_NegativeSymbolClassRegexp;
      case LanguageConceptSwitch.OrRegexp:
        if (props_OrRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_OrRegexp = cpb.create();
        }
        return props_OrRegexp;
      case LanguageConceptSwitch.ParensRegexp:
        if (props_ParensRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("parens");
          props_ParensRegexp = cpb.create();
        }
        return props_ParensRegexp;
      case LanguageConceptSwitch.PlusRegexp:
        if (props_PlusRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("one or more times");
          props_PlusRegexp = cpb.create();
        }
        return props_PlusRegexp;
      case LanguageConceptSwitch.PositiveLookAheadRegexp:
        if (props_PositiveLookAheadRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_PositiveLookAheadRegexp = cpb.create();
        }
        return props_PositiveLookAheadRegexp;
      case LanguageConceptSwitch.PositiveLookBehindRegexp:
        if (props_PositiveLookBehindRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("positive look behind");
          props_PositiveLookBehindRegexp = cpb.create();
        }
        return props_PositiveLookBehindRegexp;
      case LanguageConceptSwitch.PositiveSymbolClassRegexp:
        if (props_PositiveSymbolClassRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("positive symbol class");
          props_PositiveSymbolClassRegexp = cpb.create();
        }
        return props_PositiveSymbolClassRegexp;
      case LanguageConceptSwitch.PredefinedSymbolClassDeclaration:
        if (props_PredefinedSymbolClassDeclaration == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_PredefinedSymbolClassDeclaration = cpb.create();
        }
        return props_PredefinedSymbolClassDeclaration;
      case LanguageConceptSwitch.PredefinedSymbolClassRegexp:
        if (props_PredefinedSymbolClassRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_PredefinedSymbolClassRegexp = cpb.create();
        }
        return props_PredefinedSymbolClassRegexp;
      case LanguageConceptSwitch.PredefinedSymbolClassSymbolClassPart:
        if (props_PredefinedSymbolClassSymbolClassPart == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_PredefinedSymbolClassSymbolClassPart = cpb.create();
        }
        return props_PredefinedSymbolClassSymbolClassPart;
      case LanguageConceptSwitch.PredefinedSymbolClasses:
        if (props_PredefinedSymbolClasses == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_PredefinedSymbolClasses = cpb.create();
        }
        return props_PredefinedSymbolClasses;
      case LanguageConceptSwitch.QuestionRegexp:
        if (props_QuestionRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("once or not at all");
          props_QuestionRegexp = cpb.create();
        }
        return props_QuestionRegexp;
      case LanguageConceptSwitch.Regexp:
        if (props_Regexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_Regexp = cpb.create();
        }
        return props_Regexp;
      case LanguageConceptSwitch.RegexpDeclaration:
        if (props_RegexpDeclaration == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_RegexpDeclaration = cpb.create();
        }
        return props_RegexpDeclaration;
      case LanguageConceptSwitch.RegexpDeclarationReferenceRegexp:
        if (props_RegexpDeclarationReferenceRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_RegexpDeclarationReferenceRegexp = cpb.create();
        }
        return props_RegexpDeclarationReferenceRegexp;
      case LanguageConceptSwitch.RegexpExpression:
        if (props_RegexpExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_RegexpExpression = cpb.create();
        }
        return props_RegexpExpression;
      case LanguageConceptSwitch.RegexpUsingConstruction:
        if (props_RegexpUsingConstruction == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_RegexpUsingConstruction = cpb.create();
        }
        return props_RegexpUsingConstruction;
      case LanguageConceptSwitch.Regexps:
        if (props_Regexps == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_Regexps = cpb.create();
        }
        return props_Regexps;
      case LanguageConceptSwitch.ReplaceBlock:
        if (props_ReplaceBlock == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ReplaceBlock = cpb.create();
        }
        return props_ReplaceBlock;
      case LanguageConceptSwitch.ReplaceRegexpOperation:
        if (props_ReplaceRegexpOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ReplaceRegexpOperation = cpb.create();
        }
        return props_ReplaceRegexpOperation;
      case LanguageConceptSwitch.ReplaceWithRegexpExpression:
        if (props_ReplaceWithRegexpExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ReplaceWithRegexpExpression = cpb.create();
        }
        return props_ReplaceWithRegexpExpression;
      case LanguageConceptSwitch.ReplaceWithRegexpOperation:
        if (props_ReplaceWithRegexpOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("replace with regexp");
          props_ReplaceWithRegexpOperation = cpb.create();
        }
        return props_ReplaceWithRegexpOperation;
      case LanguageConceptSwitch.Replacement:
        if (props_Replacement == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_Replacement = cpb.create();
        }
        return props_Replacement;
      case LanguageConceptSwitch.SeqRegexp:
        if (props_SeqRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_SeqRegexp = cpb.create();
        }
        return props_SeqRegexp;
      case LanguageConceptSwitch.SplitExpression:
        if (props_SplitExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("split with regexp");
          props_SplitExpression = cpb.create();
        }
        return props_SplitExpression;
      case LanguageConceptSwitch.SplitOperation:
        if (props_SplitOperation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("split with regexp");
          props_SplitOperation = cpb.create();
        }
        return props_SplitOperation;
      case LanguageConceptSwitch.StarRegexp:
        if (props_StarRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("zero or more times");
          props_StarRegexp = cpb.create();
        }
        return props_StarRegexp;
      case LanguageConceptSwitch.StringLiteralRegexp:
        if (props_StringLiteralRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_StringLiteralRegexp = cpb.create();
        }
        return props_StringLiteralRegexp;
      case LanguageConceptSwitch.SymbolClassPart:
        if (props_SymbolClassPart == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_SymbolClassPart = cpb.create();
        }
        return props_SymbolClassPart;
      case LanguageConceptSwitch.SymbolClassRegexp:
        if (props_SymbolClassRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_SymbolClassRegexp = cpb.create();
        }
        return props_SymbolClassRegexp;
      case LanguageConceptSwitch.SymbolClassRegexpAndPart:
        if (props_SymbolClassRegexpAndPart == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_SymbolClassRegexpAndPart = cpb.create();
        }
        return props_SymbolClassRegexpAndPart;
      case LanguageConceptSwitch.UnaryRegexp:
        if (props_UnaryRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_UnaryRegexp = cpb.create();
        }
        return props_UnaryRegexp;
      case LanguageConceptSwitch.UnicodeCharacterRegexp:
        if (props_UnicodeCharacterRegexp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_UnicodeCharacterRegexp = cpb.create();
        }
        return props_UnicodeCharacterRegexp;
    }
    return null;
  }
}
