package jetbrains.mps.baseLanguage.regexp.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public class ConceptPresentationAspectImpl extends ConceptPresentationAspectBase {
  private final ConceptPresentation props_AtLeastNTimesRegexp = new ConceptPresentationBuilder().shortDesc("at least n times").create();
  private final ConceptPresentation props_BinaryRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_CharacterSymbolClassPart = new ConceptPresentationBuilder().shortDesc("character").create();
  private final ConceptPresentation props_DotRegexp = new ConceptPresentationBuilder().shortDesc("dot regexp (any character)").create();
  private final ConceptPresentation props_FindMatchExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_FindMatchStatement = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ForEachMatchStatement = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_FromNToMTimesRegexp = new ConceptPresentationBuilder().shortDesc("at least n but not more than m times").create();
  private final ConceptPresentation props_InlineRegexpExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_IntersectionSymbolClassPart = new ConceptPresentationBuilder().shortDesc("intersection of classes").create();
  private final ConceptPresentation props_IntervalSymbolClassPart = new ConceptPresentationBuilder().shortDesc("character range").create();
  private final ConceptPresentation props_LazyPlusRegexp = new ConceptPresentationBuilder().shortDesc("one or more times, reluctant").create();
  private final ConceptPresentation props_LazyQuestionRegexp = new ConceptPresentationBuilder().shortDesc("once or not at all, reluctant").create();
  private final ConceptPresentation props_LazyStarRegexp = new ConceptPresentationBuilder().shortDesc("zero or more times, reluctant").create();
  private final ConceptPresentation props_LineEndRegexp = new ConceptPresentationBuilder().shortDesc("line end").create();
  private final ConceptPresentation props_LineStartRegexp = new ConceptPresentationBuilder().shortDesc("line start").create();
  private final ConceptPresentation props_LiteralReplacement = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_LookRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatchParensRegexp = new ConceptPresentationBuilder().shortDesc("matching parens").create();
  private final ConceptPresentation props_MatchRegexpExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatchRegexpOperation = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatchRegexpStatement = new ConceptPresentationBuilder().shortDesc("match with regexp").create();
  private final ConceptPresentation props_MatchVariableReference = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatchVariableReferenceRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_MatchVariableReferenceReplacement = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_NTimesRegexp = new ConceptPresentationBuilder().shortDesc("exactly n times").create();
  private final ConceptPresentation props_NegativeLookAheadRegexp = new ConceptPresentationBuilder().shortDesc("negative look ahead").create();
  private final ConceptPresentation props_NegativeLookBehindRegexp = new ConceptPresentationBuilder().shortDesc("negative look behind").create();
  private final ConceptPresentation props_NegativeSymbolClassRegexp = new ConceptPresentationBuilder().shortDesc("negative symbol class").create();
  private final ConceptPresentation props_OrRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ParensRegexp = new ConceptPresentationBuilder().shortDesc("parens").create();
  private final ConceptPresentation props_PlusRegexp = new ConceptPresentationBuilder().shortDesc("one or more times").create();
  private final ConceptPresentation props_PositiveLookAheadRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_PositiveLookBehindRegexp = new ConceptPresentationBuilder().shortDesc("positive look behind").create();
  private final ConceptPresentation props_PositiveSymbolClassRegexp = new ConceptPresentationBuilder().shortDesc("positive symbol class").create();
  private final ConceptPresentation props_PredefinedSymbolClassDeclaration = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_PredefinedSymbolClassRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_PredefinedSymbolClassSymbolClassPart = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_PredefinedSymbolClasses = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_QuestionRegexp = new ConceptPresentationBuilder().shortDesc("once or not at all").create();
  private final ConceptPresentation props_Regexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_RegexpDeclaration = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_RegexpDeclarationReferenceRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_RegexpExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_RegexpUsingConstruction = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_Regexps = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ReplaceBlock = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ReplaceRegexpOperation = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ReplaceWithRegexpExpression = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_ReplaceWithRegexpOperation = new ConceptPresentationBuilder().shortDesc("replace with regexp").create();
  private final ConceptPresentation props_Replacement = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_SeqRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_SplitExpression = new ConceptPresentationBuilder().shortDesc("split with regexp").create();
  private final ConceptPresentation props_SplitOperation = new ConceptPresentationBuilder().shortDesc("split with regexp").create();
  private final ConceptPresentation props_StarRegexp = new ConceptPresentationBuilder().shortDesc("zero or more times").create();
  private final ConceptPresentation props_StringLiteralRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_SymbolClassPart = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_SymbolClassRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_SymbolClassRegexpAndPart = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_UnaryRegexp = new ConceptPresentationBuilder().create();
  private final ConceptPresentation props_UnicodeCharacterRegexp = new ConceptPresentationBuilder().create();

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) myLanguageRuntime.getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);
    switch (structureDescriptor.internalIndex(c)) {
      case LanguageConceptSwitch.AtLeastNTimesRegexp:
        return props_AtLeastNTimesRegexp;
      case LanguageConceptSwitch.BinaryRegexp:
        return props_BinaryRegexp;
      case LanguageConceptSwitch.CharacterSymbolClassPart:
        return props_CharacterSymbolClassPart;
      case LanguageConceptSwitch.DotRegexp:
        return props_DotRegexp;
      case LanguageConceptSwitch.FindMatchExpression:
        return props_FindMatchExpression;
      case LanguageConceptSwitch.FindMatchStatement:
        return props_FindMatchStatement;
      case LanguageConceptSwitch.ForEachMatchStatement:
        return props_ForEachMatchStatement;
      case LanguageConceptSwitch.FromNToMTimesRegexp:
        return props_FromNToMTimesRegexp;
      case LanguageConceptSwitch.InlineRegexpExpression:
        return props_InlineRegexpExpression;
      case LanguageConceptSwitch.IntersectionSymbolClassPart:
        return props_IntersectionSymbolClassPart;
      case LanguageConceptSwitch.IntervalSymbolClassPart:
        return props_IntervalSymbolClassPart;
      case LanguageConceptSwitch.LazyPlusRegexp:
        return props_LazyPlusRegexp;
      case LanguageConceptSwitch.LazyQuestionRegexp:
        return props_LazyQuestionRegexp;
      case LanguageConceptSwitch.LazyStarRegexp:
        return props_LazyStarRegexp;
      case LanguageConceptSwitch.LineEndRegexp:
        return props_LineEndRegexp;
      case LanguageConceptSwitch.LineStartRegexp:
        return props_LineStartRegexp;
      case LanguageConceptSwitch.LiteralReplacement:
        return props_LiteralReplacement;
      case LanguageConceptSwitch.LookRegexp:
        return props_LookRegexp;
      case LanguageConceptSwitch.MatchParensRegexp:
        return props_MatchParensRegexp;
      case LanguageConceptSwitch.MatchRegexpExpression:
        return props_MatchRegexpExpression;
      case LanguageConceptSwitch.MatchRegexpOperation:
        return props_MatchRegexpOperation;
      case LanguageConceptSwitch.MatchRegexpStatement:
        return props_MatchRegexpStatement;
      case LanguageConceptSwitch.MatchVariableReference:
        return props_MatchVariableReference;
      case LanguageConceptSwitch.MatchVariableReferenceRegexp:
        return props_MatchVariableReferenceRegexp;
      case LanguageConceptSwitch.MatchVariableReferenceReplacement:
        return props_MatchVariableReferenceReplacement;
      case LanguageConceptSwitch.NTimesRegexp:
        return props_NTimesRegexp;
      case LanguageConceptSwitch.NegativeLookAheadRegexp:
        return props_NegativeLookAheadRegexp;
      case LanguageConceptSwitch.NegativeLookBehindRegexp:
        return props_NegativeLookBehindRegexp;
      case LanguageConceptSwitch.NegativeSymbolClassRegexp:
        return props_NegativeSymbolClassRegexp;
      case LanguageConceptSwitch.OrRegexp:
        return props_OrRegexp;
      case LanguageConceptSwitch.ParensRegexp:
        return props_ParensRegexp;
      case LanguageConceptSwitch.PlusRegexp:
        return props_PlusRegexp;
      case LanguageConceptSwitch.PositiveLookAheadRegexp:
        return props_PositiveLookAheadRegexp;
      case LanguageConceptSwitch.PositiveLookBehindRegexp:
        return props_PositiveLookBehindRegexp;
      case LanguageConceptSwitch.PositiveSymbolClassRegexp:
        return props_PositiveSymbolClassRegexp;
      case LanguageConceptSwitch.PredefinedSymbolClassDeclaration:
        return props_PredefinedSymbolClassDeclaration;
      case LanguageConceptSwitch.PredefinedSymbolClassRegexp:
        return props_PredefinedSymbolClassRegexp;
      case LanguageConceptSwitch.PredefinedSymbolClassSymbolClassPart:
        return props_PredefinedSymbolClassSymbolClassPart;
      case LanguageConceptSwitch.PredefinedSymbolClasses:
        return props_PredefinedSymbolClasses;
      case LanguageConceptSwitch.QuestionRegexp:
        return props_QuestionRegexp;
      case LanguageConceptSwitch.Regexp:
        return props_Regexp;
      case LanguageConceptSwitch.RegexpDeclaration:
        return props_RegexpDeclaration;
      case LanguageConceptSwitch.RegexpDeclarationReferenceRegexp:
        return props_RegexpDeclarationReferenceRegexp;
      case LanguageConceptSwitch.RegexpExpression:
        return props_RegexpExpression;
      case LanguageConceptSwitch.RegexpUsingConstruction:
        return props_RegexpUsingConstruction;
      case LanguageConceptSwitch.Regexps:
        return props_Regexps;
      case LanguageConceptSwitch.ReplaceBlock:
        return props_ReplaceBlock;
      case LanguageConceptSwitch.ReplaceRegexpOperation:
        return props_ReplaceRegexpOperation;
      case LanguageConceptSwitch.ReplaceWithRegexpExpression:
        return props_ReplaceWithRegexpExpression;
      case LanguageConceptSwitch.ReplaceWithRegexpOperation:
        return props_ReplaceWithRegexpOperation;
      case LanguageConceptSwitch.Replacement:
        return props_Replacement;
      case LanguageConceptSwitch.SeqRegexp:
        return props_SeqRegexp;
      case LanguageConceptSwitch.SplitExpression:
        return props_SplitExpression;
      case LanguageConceptSwitch.SplitOperation:
        return props_SplitOperation;
      case LanguageConceptSwitch.StarRegexp:
        return props_StarRegexp;
      case LanguageConceptSwitch.StringLiteralRegexp:
        return props_StringLiteralRegexp;
      case LanguageConceptSwitch.SymbolClassPart:
        return props_SymbolClassPart;
      case LanguageConceptSwitch.SymbolClassRegexp:
        return props_SymbolClassRegexp;
      case LanguageConceptSwitch.SymbolClassRegexpAndPart:
        return props_SymbolClassRegexpAndPart;
      case LanguageConceptSwitch.UnaryRegexp:
        return props_UnaryRegexp;
      case LanguageConceptSwitch.UnicodeCharacterRegexp:
        return props_UnicodeCharacterRegexp;
    }
    return null;
  }
}
