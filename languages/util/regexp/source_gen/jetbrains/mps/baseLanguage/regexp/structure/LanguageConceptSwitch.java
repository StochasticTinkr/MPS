package jetbrains.mps.baseLanguage.regexp.structure;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.LanguageConceptIndex;
import jetbrains.mps.lang.smodel.LanguageConceptIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public final class LanguageConceptSwitch {
  private final LanguageConceptIndex myIndex;
  public static final int AtLeastNTimesRegexp = 0;
  public static final int BinaryRegexp = 1;
  public static final int CharacterSymbolClassPart = 2;
  public static final int DotRegexp = 3;
  public static final int FindMatchExpression = 4;
  public static final int FindMatchStatement = 5;
  public static final int ForEachMatchStatement = 6;
  public static final int FromNToMTimesRegexp = 7;
  public static final int InlineRegexpExpression = 8;
  public static final int IntersectionSymbolClassPart = 9;
  public static final int IntervalSymbolClassPart = 10;
  public static final int LazyPlusRegexp = 11;
  public static final int LazyQuestionRegexp = 12;
  public static final int LazyStarRegexp = 13;
  public static final int LineEndRegexp = 14;
  public static final int LineStartRegexp = 15;
  public static final int LiteralReplacement = 16;
  public static final int LookRegexp = 17;
  public static final int MatchParensRegexp = 18;
  public static final int MatchRegexpExpression = 19;
  public static final int MatchRegexpOperation = 20;
  public static final int MatchRegexpStatement = 21;
  public static final int MatchVariableReference = 22;
  public static final int MatchVariableReferenceRegexp = 23;
  public static final int MatchVariableReferenceReplacement = 24;
  public static final int NTimesRegexp = 25;
  public static final int NegativeLookAheadRegexp = 26;
  public static final int NegativeLookBehindRegexp = 27;
  public static final int NegativeSymbolClassRegexp = 28;
  public static final int OrRegexp = 29;
  public static final int ParensRegexp = 30;
  public static final int PlusRegexp = 31;
  public static final int PositiveLookAheadRegexp = 32;
  public static final int PositiveLookBehindRegexp = 33;
  public static final int PositiveSymbolClassRegexp = 34;
  public static final int PredefinedSymbolClassDeclaration = 35;
  public static final int PredefinedSymbolClassRegexp = 36;
  public static final int PredefinedSymbolClassSymbolClassPart = 37;
  public static final int PredefinedSymbolClasses = 38;
  public static final int QuestionRegexp = 39;
  public static final int Regexp = 40;
  public static final int RegexpDeclaration = 41;
  public static final int RegexpDeclarationReferenceRegexp = 42;
  public static final int RegexpExpression = 43;
  public static final int RegexpUsingConstruction = 44;
  public static final int Regexps = 45;
  public static final int ReplaceBlock = 46;
  public static final int ReplaceRegexpOperation = 47;
  public static final int ReplaceWithRegexpExpression = 48;
  public static final int ReplaceWithRegexpOperation = 49;
  public static final int Replacement = 50;
  public static final int SeqRegexp = 51;
  public static final int SplitExpression = 52;
  public static final int SplitOperation = 53;
  public static final int StarRegexp = 54;
  public static final int StringLiteralRegexp = 55;
  public static final int SymbolClassPart = 56;
  public static final int SymbolClassRegexp = 57;
  public static final int SymbolClassRegexpAndPart = 58;
  public static final int UnaryRegexp = 59;
  public static final int UnicodeCharacterRegexp = 60;

  public LanguageConceptSwitch() {
    LanguageConceptIndexBuilder builder = new LanguageConceptIndexBuilder(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L);
    builder.put(0x1118dc30ee2L, AtLeastNTimesRegexp);
    builder.put(0x11174c56bf9L, BinaryRegexp);
    builder.put(0x111791ae82fL, CharacterSymbolClassPart);
    builder.put(0x111790aa926L, DotRegexp);
    builder.put(0x550fbf4ebc5de3f5L, FindMatchExpression);
    builder.put(0x1119d8807a3L, FindMatchStatement);
    builder.put(0x1119caff72eL, ForEachMatchStatement);
    builder.put(0x1118dc58c6eL, FromNToMTimesRegexp);
    builder.put(0x1117648961dL, InlineRegexpExpression);
    builder.put(0x11c0ef7f429L, IntersectionSymbolClassPart);
    builder.put(0x11179215e8bL, IntervalSymbolClassPart);
    builder.put(0x1117f38e076L, LazyPlusRegexp);
    builder.put(0x1117f394b67L, LazyQuestionRegexp);
    builder.put(0x1117f383367L, LazyStarRegexp);
    builder.put(0x1119d126564L, LineEndRegexp);
    builder.put(0x1119d11da7eL, LineStartRegexp);
    builder.put(0x34ae970c192ab94cL, LiteralReplacement);
    builder.put(0x1118de32185L, LookRegexp);
    builder.put(0x111797946c7L, MatchParensRegexp);
    builder.put(0x112972a0c32L, MatchRegexpExpression);
    builder.put(0x11c9466ae95L, MatchRegexpOperation);
    builder.put(0x11176652f14L, MatchRegexpStatement);
    builder.put(0x1117987ff5eL, MatchVariableReference);
    builder.put(0x1118e0a1c55L, MatchVariableReferenceRegexp);
    builder.put(0x34ae970c192ab94eL, MatchVariableReferenceReplacement);
    builder.put(0x1118dbeda57L, NTimesRegexp);
    builder.put(0x1118de1f935L, NegativeLookAheadRegexp);
    builder.put(0x1118de6e3f6L, NegativeLookBehindRegexp);
    builder.put(0x11178e35c63L, NegativeSymbolClassRegexp);
    builder.put(0x11174a0d780L, OrRegexp);
    builder.put(0x111752101b0L, ParensRegexp);
    builder.put(0x11174a15de8L, PlusRegexp);
    builder.put(0x1118ddfb973L, PositiveLookAheadRegexp);
    builder.put(0x1118de6742fL, PositiveLookBehindRegexp);
    builder.put(0x11178e2f48cL, PositiveSymbolClassRegexp);
    builder.put(0x11178e59fd0L, PredefinedSymbolClassDeclaration);
    builder.put(0x11178fa2a18L, PredefinedSymbolClassRegexp);
    builder.put(0x1117928d9f2L, PredefinedSymbolClassSymbolClassPart);
    builder.put(0x11178e5efc7L, PredefinedSymbolClasses);
    builder.put(0x11178c4e1e0L, QuestionRegexp);
    builder.put(0x11174a06efdL, Regexp);
    builder.put(0x11174a6454dL, RegexpDeclaration);
    builder.put(0x1117f58ea2aL, RegexpDeclarationReferenceRegexp);
    builder.put(0x1118ea37105L, RegexpExpression);
    builder.put(0x1117ecbc07aL, RegexpUsingConstruction);
    builder.put(0x1117f550b6dL, Regexps);
    builder.put(0x1117ef80054L, ReplaceBlock);
    builder.put(0x34ae970c1923d18aL, ReplaceRegexpOperation);
    builder.put(0x1117ef3f72dL, ReplaceWithRegexpExpression);
    builder.put(0x11c94680172L, ReplaceWithRegexpOperation);
    builder.put(0x34ae970c192ab952L, Replacement);
    builder.put(0x11174bc30e7L, SeqRegexp);
    builder.put(0x1119d41c734L, SplitExpression);
    builder.put(0x11c942ab86bL, SplitOperation);
    builder.put(0x11174a16ffaL, StarRegexp);
    builder.put(0x11174a0992dL, StringLiteralRegexp);
    builder.put(0x111791aa602L, SymbolClassPart);
    builder.put(0x11178e2916aL, SymbolClassRegexp);
    builder.put(0x11c22ec8f79L, SymbolClassRegexpAndPart);
    builder.put(0x11174c678adL, UnaryRegexp);
    builder.put(0x11831260718L, UnicodeCharacterRegexp);
    myIndex = builder.seal();
  }

  /*package*/ int index(SConceptId cid) {
    return myIndex.index(cid);
  }

  public int index(SAbstractConcept concept) {
    return myIndex.index(concept);
  }
}
