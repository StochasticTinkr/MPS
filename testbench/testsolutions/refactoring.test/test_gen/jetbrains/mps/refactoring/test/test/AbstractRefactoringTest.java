package jetbrains.mps.refactoring.test.test;

/*Generated by MPS */

import jetbrains.mps.testbench.EnvironmentAwareTestCase;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.Project;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.util.NameUtil;
import java.io.File;
import java.nio.file.Files;
import jetbrains.mps.util.FileUtil;
import java.util.List;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.ide.make.DefaultMakeMessageHandler;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.make.actions.MakeActionParameters;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.tool.builder.make.BuildMakeService;
import junit.framework.Assert;
import java.util.concurrent.ExecutionException;

public abstract class AbstractRefactoringTest extends EnvironmentAwareTestCase {
  private static final Logger LOG = LogManager.getLogger(AbstractRefactoringTest.class);
  protected Project project;
  private String projectTempDir;
  private String projectSourcePath;
  private boolean wasUsingInterpreted;
  public AbstractRefactoringTest(String path) {
    projectSourcePath = path;
  }

  @Override
  protected void setUp() throws Exception {
    super.setUp();
    try {
      wasUsingInterpreted = RuntimeFlags.isUseInterpretedLanguages();
      RuntimeFlags.setUseInterpretedLanguages(false);
      String dirPrefix = NameUtil.toConstantName(NameUtil.toValidIdentifier(this.getName()));
      File tempDir = Files.createTempDirectory(dirPrefix).toFile();
      projectTempDir = tempDir.getCanonicalPath();
      FileUtil.copyDir(new File(projectSourcePath), tempDir);
      project = myEnvironment.openProject(tempDir);
    } catch (Exception e) {
      RuntimeFlags.setUseInterpretedLanguages(wasUsingInterpreted);
      throw e;
    }
  }

  @Override
  protected void tearDown() throws Exception {
    try {
      super.tearDown();
      myEnvironment.closeProject(project);
      com.intellij.openapi.util.io.FileUtil.delete(new File(projectTempDir));
    } finally {
      RuntimeFlags.setUseInterpretedLanguages(wasUsingInterpreted);
    }
  }

  public void doMake(final List<SModule> modules, final boolean cleanMake) {
    if (LOG.isInfoEnabled()) {
      LOG.info("Making modules: " + ListSequence.fromList(modules).toListSequence());
    }
    MakeSession session = new MakeSession(project, new DefaultMakeMessageHandler(project), true);
    final Wrappers._T<List<? extends IResource>> inputRes = new Wrappers._T<List<? extends IResource>>(null);
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        inputRes.value = Sequence.fromIterable(new MakeActionParameters(project).cleanMake(cleanMake).modules(modules).collectInput()).toListSequence();
      }
    });
    Future<IResult> res = new BuildMakeService().makeAndReload(session, inputRes.value);
    try {
      Assert.assertTrue("Make was not successful", res.get().isSucessful());
    } catch (InterruptedException e) {
      Assert.fail(e.toString());
    } catch (ExecutionException e) {
      Assert.fail(e.toString());
    }
    if (LOG.isInfoEnabled()) {
      LOG.info("Make finished");
    }
  }

}
