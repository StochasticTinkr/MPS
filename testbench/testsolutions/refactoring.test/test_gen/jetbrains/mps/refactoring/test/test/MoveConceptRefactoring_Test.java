package jetbrains.mps.refactoring.test.test;

/*Generated by MPS */

import jetbrains.mps.testbench.EnvironmentAwareTestCase;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import junit.framework.Assert;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModuleOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.core.pluginSolution.plugin.UpdateModelImports;
import jetbrains.mps.lang.core.pluginSolution.plugin.UpdateReferencesParticipantBase;
import jetbrains.mps.lang.structure.pluginSolution.plugin.MoveAspectsParticipant;
import jetbrains.mps.lang.structure.pluginSolution.plugin.LanguageStructureMigrationParticipant;
import jetbrains.mps.lang.migration.pluginSolution.plugin.MoveNodeRefactoringLogParticipant;
import jetbrains.mps.ide.platform.actions.core.MoveNodesUtil;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import java.util.Collection;
import jetbrains.mps.errors.item.ReportItem;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.ide.make.DefaultMakeMessageHandler;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.make.actions.MakeActionParameters;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.tool.builder.make.BuildMakeService;
import java.util.concurrent.ExecutionException;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.ide.migration.AntTaskExecutionUtil;
import com.intellij.openapi.application.ModalityState;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.io.File;
import jetbrains.mps.project.validation.ValidationUtil;
import org.jetbrains.mps.openapi.util.Processor;
import jetbrains.mps.util.Reference;
import jetbrains.mps.ide.ThreadUtils;

public class MoveConceptRefactoring_Test extends EnvironmentAwareTestCase {
  private static final Logger LOG = LogManager.getLogger(MoveConceptRefactoring_Test.class);
  private static final String PROJECT_PATH = "testbench/modules/testRefactoringWithMigration/MoveConcept_MPS_27372/";
  private Project project;
  public void test_moveConcept_MPS_27372() throws Exception {
    // this is not formally correct to store SModule, but ok for testing purposes 
    final Wrappers._T<SModule> sourceModule = new Wrappers._T<SModule>();
    final Wrappers._T<SModule> targetModule = new Wrappers._T<SModule>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        sourceModule.value = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("3e00419d-4801-4bad-bf2a-50479218fb53(jetbrains.mps.refactoring.testmaterial.moveConcept.SourceLanguage)"));
        Assert.assertNotNull(sourceModule.value);
        targetModule.value = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("2f6eb168-4811-48ad-becb-56fd47d21d59(jetbrains.mps.refactoring.testmaterial.moveConcept.TargetLanguage)"));
        Assert.assertNotNull(targetModule.value);
      }
    });

    runCommand(new Runnable() {
      public void run() {
        SModel targetModel = SModuleOperations.getAspect(targetModule.value, "structure");
        Assert.assertNotNull(targetModel);
        SNode nodeToMove = SNodeOperations.getNode("r:469ff9d9-5a2e-4029-9891-ce478377a661(jetbrains.mps.refactoring.testmaterial.moveConcept.SourceLanguage.structure)", "6006982468244407213");
        Assert.assertNotNull(nodeToMove);

        List<RefactoringParticipant.Option> options = ListSequence.fromList(new ArrayList<RefactoringParticipant.Option>());

        ListSequence.fromList(options).addElement(UpdateModelImports.OPTION);
        ListSequence.fromList(options).addElement(UpdateReferencesParticipantBase.UpdateReferencesParticipant.OPTION);

        ListSequence.fromList(options).addElement(MoveAspectsParticipant.OPTION);

        ListSequence.fromList(options).addElement(LanguageStructureMigrationParticipant.OPTION);
        ListSequence.fromList(options).addElement(MoveNodeRefactoringLogParticipant.OPTION);

        if (LOG.isInfoEnabled()) {
          LOG.info("Refactoring starting...");
        }
        MoveNodesUtil.moveTo(project, "", MapSequence.<MoveNodesUtil.NodeProcessor, List<SNode>>fromMapAndKeysArray(new HashMap<MoveNodesUtil.NodeProcessor, List<SNode>>(), new MoveNodesUtil.NodeCreatingProcessor(new NodeLocation.NodeLocationRoot(targetModel), project)).withValues(ListSequence.fromListAndArray(new ArrayList<SNode>(), nodeToMove)), new HeadlessRefactoringUI(options));
        if (LOG.isInfoEnabled()) {
          LOG.info("Refactoring finished");
        }
      }
    });
    // not really needed, but still let's end the transaction before checking 

    if (LOG.isInfoEnabled()) {
      LOG.info("Checking for errors after refactoring...");
    }
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Collection<ReportItem> sourceErrors = getErrors(SModelOperations.roots(SModuleOperations.getAspect(sourceModule.value, "constraints"), null));
        Assert.assertTrue("" + sourceErrors, CollectionSequence.fromCollection(sourceErrors).isEmpty());
        Collection<ReportItem> targetErrors = getErrors(SModelOperations.roots(SModuleOperations.getAspect(targetModule.value, "constraints"), null));
        Assert.assertTrue("" + targetErrors, CollectionSequence.fromCollection(targetErrors).isEmpty());
      }
    });
    if (LOG.isInfoEnabled()) {
      LOG.info("Checking finished");
    }

    if (LOG.isInfoEnabled()) {
      LOG.info("Making newly created migrations...");
    }
    MakeSession session = new MakeSession(project, new DefaultMakeMessageHandler(project), true);
    final Wrappers._T<List<IResource>> inputRes = new Wrappers._T<List<IResource>>(null);
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        inputRes.value = Sequence.fromIterable(new MakeActionParameters(project).modules(ListSequence.fromListAndArray(new ArrayList<SModule>(), sourceModule.value, targetModule.value)).collectInput()).toListSequence();
      }
    });
    Future<IResult> res = new BuildMakeService().makeAndReload(session, inputRes.value);
    try {
      Assert.assertTrue("Make was not successful", res.get().isSucessful());
    } catch (InterruptedException e) {
      Assert.fail(e.toString());
    } catch (ExecutionException e) {
      Assert.fail(e.toString());
    }
    if (LOG.isInfoEnabled()) {
      LOG.info("Make finished");
    }

    if (LOG.isInfoEnabled()) {
      LOG.info("Migrating...");
    }
    ApplicationManager.getApplication().invokeAndWait(new Runnable() {
      public void run() {
        try {
          AntTaskExecutionUtil.migrate(project);
        } catch (Exception e) {
          throw new RuntimeException("Exception during migration", e);
        }
      }
    }, ModalityState.defaultModalityState());
    if (LOG.isInfoEnabled()) {
      LOG.info("Migration finished");
    }

    if (LOG.isInfoEnabled()) {
      LOG.info("Checking migration results...");
    }
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        String val = SNodeOperations.getNode("r:ac08359f-193b-493f-92ef-48848aecee7b(jetbrains.mps.refactoring.testmaterial.moveConcept.InstanceSolution.main)", "6006982468244420385").getProperty(MetaAdapterFactory.getProperty(0x3e00419d48014badL, 0xbf2a50479218fb53L, 0x535d16ba7fb503adL, 0x535d16ba7fbdf83fL, "prop"));
        Assert.assertNull("Old property value is: " + val, val);
        Assert.assertTrue(SNodeOperations.getNode("r:ac08359f-193b-493f-92ef-48848aecee7b(jetbrains.mps.refactoring.testmaterial.moveConcept.InstanceSolution.main)", "6006982468244420385").getProperties().iterator().hasNext());
      }
    });
    if (LOG.isInfoEnabled()) {
      LOG.info("Check finished");
    }
  }
  public void setUp() {
    project = myEnvironment.openProject(new File(PROJECT_PATH));
  }
  public void tearDown() {
    myEnvironment.closeProject(project);
  }


  public static Collection<ReportItem> getErrors(Iterable<SNode> roots) {
    final List<ReportItem> result = ListSequence.fromList(new ArrayList<ReportItem>());
    ValidationUtil.validateModelContent(roots, new Processor<ReportItem>() {
      public boolean process(ReportItem problem) {
        ListSequence.fromList(result).addElement(problem);
        return true;
      }
    });
    return result;
  }

  public void runCommand(final Runnable runnable) {
    final Reference<Throwable> ref = new Reference();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        project.getModelAccess().executeCommand(new Runnable() {
          public void run() {
            try {
              runnable.run();
            } catch (Throwable t) {
              ref.set(t);
            }

          }
        });
      }
    });
    if (!(ref.isNull())) {
      throw new RuntimeException(ref.get());
    }
  }
}
