package refactoring.test.test;

/*Generated by MPS */

import junit.framework.TestCase;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.project.Project;
import junit.framework.Assert;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModuleOperations;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.ide.platform.actions.core.MoveNodesUtil;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import jetbrains.mps.ide.platform.actions.core.RefactoringUI;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import jetbrains.mps.lang.core.plugin.UpdateModelImports;
import jetbrains.mps.lang.core.plugin.UpdateReferencesParticipantBase;
import jetbrains.mps.lang.structure.pluginSolution.plugin.WriteSubconceptMigrationParticipant;
import jetbrains.mps.lang.structure.pluginSolution.plugin.MoveAspectsParticipant;
import jetbrains.mps.lang.structure.pluginSolution.plugin.UpdateLocalInstancesParticipant;
import jetbrains.mps.lang.structure.pluginSolution.plugin.LanguageStructureMigrationParticipant;
import jetbrains.mps.lang.migration.pluginSolution.plugin.MoveNodeRefactoringLogParticipant;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchTask;
import jetbrains.mps.refactoring.participant.RefactoringSession;
import jetbrains.mps.tool.environment.MpsEnvironment;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import java.io.File;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.validation.MessageCollectProcessor;
import jetbrains.mps.project.validation.ValidationUtil;
import org.apache.log4j.Level;
import jetbrains.mps.util.Reference;
import jetbrains.mps.ide.ThreadUtils;

public class Refactoring_Test extends TestCase {
  private static final String PROJECT_PATH = "testbench/modules/testRefactoring/";
  private Environment env;
  private Project project;
  public void test_checkConsistency() throws Exception {
    runCommand(new Runnable() {
      public void run() {
        Assert.assertNotNull(getConceptA());
      }
    });
  }
  public void test_moveConcept() throws Exception {
    runCommand(new Runnable() {
      public void run() {
        SModel targetModel = SModuleOperations.getAspect(getTargetLanguage(), "structure");
        List<SNode> nodesToMove = ListSequence.fromListAndArray(new ArrayList<SNode>(), getConceptA());

        MoveNodesUtil.moveTo(project, "testMoveConcept", MapSequence.<MoveNodesUtil.NodeProcessor, List<SNode>>fromMapAndKeysArray(new HashMap<MoveNodesUtil.NodeProcessor, List<SNode>>(), new MoveNodesUtil.NodeCreatingProcessor(new NodeLocation.NodeLocationRoot(targetModel), project)).withValues(nodesToMove), new RefactoringUI() {
          public void prepare(Runnable task) {
            task.run();
          }
          public void runSearch(final _FunctionTypes._void_P1_E0<? super ProgressMonitor> task) {
            task.invoke(new EmptyProgressMonitor());
          }
          public List<RefactoringParticipant.Option> selectParticipants(List<RefactoringParticipant.Option> options) {

            Assert.assertTrue(ListSequence.fromList(options).contains(UpdateModelImports.OPTION));
            Assert.assertTrue(ListSequence.fromList(options).contains(UpdateReferencesParticipantBase.UpdateReferencesParticipant.OPTION));

            Assert.assertTrue(ListSequence.fromList(options).contains(WriteSubconceptMigrationParticipant.OPTION));
            Assert.assertTrue(ListSequence.fromList(options).contains(MoveAspectsParticipant.OPTION));
            Assert.assertTrue(ListSequence.fromList(options).contains(UpdateLocalInstancesParticipant.OPTION));

            Assert.assertTrue(ListSequence.fromList(options).contains(LanguageStructureMigrationParticipant.OPTION));
            Assert.assertTrue(ListSequence.fromList(options).contains(MoveNodeRefactoringLogParticipant.OPTION));

            Assert.assertTrue(false);

            return ListSequence.fromListWithValues(new ArrayList<RefactoringParticipant.Option>(), options);
          }
          public void showRefactoringView(final Runnable task, String refactoringName, SearchResults searchResults, SearchTask searchTask, RefactoringSession session) {
            task.run();
          }
        });
      }
    });
  }
  public void setUp() {
    env = MpsEnvironment.getOrCreate(EnvironmentConfig.defaultConfig().withDevkitPlugin());
    project = (env.openProject(new File(PROJECT_PATH)));
  }
  public void tearDown() {
    env.release();
  }

  public SModule getSourceLanguage() {
    return PersistenceFacade.getInstance().createModuleReference("0e4cf406-fc7e-4ee7-a6f3-93f8c8dbdc64(SourceLanguage)").resolve(project.getRepository());
  }

  public SModule getTargetLanguage() {
    return PersistenceFacade.getInstance().createModuleReference("bf13acef-3fb7-4e3b-882a-bc94b7e487b3(TargetLanguage)").resolve(project.getRepository());
  }

  public SNode getConceptA() {
    return ListSequence.fromList(SModelOperations.roots(SModuleOperations.getAspect(getSourceLanguage(), "structure"), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return eq_hy6ey0_a0a0a0a0a0a0a21(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), "A");
      }
    }).first();
  }

  protected static Logger LOG = LogManager.getLogger(Refactoring_Test.class);
  public static void checkModule(AbstractModule module) {
    MessageCollectProcessor processor = new MessageCollectProcessor();
    ValidationUtil.validateModule(module, processor);
    if (!(processor.getErrors().isEmpty())) {
      for (String error : processor.getErrors()) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error found while checking '" + module + "': " + error);
        }
      }
      org.junit.Assert.fail();
    }
  }

  public void runCommand(final Runnable runnable) {
    final Reference<Throwable> ref = new Reference();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        project.getModelAccess().executeCommand(new Runnable() {
          public void run() {
            try {
              runnable.run();
            } catch (Throwable t) {
              ref.set(t);
            }

          }
        });
      }
    });
    if (!(ref.isNull())) {
      throw new RuntimeException(ref.get());
    }
  }
  private static boolean eq_hy6ey0_a0a0a0a0a0a0a21(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
