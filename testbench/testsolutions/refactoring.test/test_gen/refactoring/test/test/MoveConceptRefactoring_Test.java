package refactoring.test.test;

/*Generated by MPS */

import jetbrains.mps.testbench.EnvironmentAwareTestCase;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import junit.framework.Assert;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModuleOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.core.pluginSolution.plugin.UpdateModelImports;
import jetbrains.mps.lang.core.pluginSolution.plugin.UpdateReferencesParticipantBase;
import jetbrains.mps.lang.structure.pluginSolution.plugin.MoveAspectsParticipant;
import jetbrains.mps.lang.structure.pluginSolution.plugin.UpdateLocalInstancesParticipant;
import jetbrains.mps.lang.structure.pluginSolution.plugin.LanguageStructureMigrationParticipant;
import jetbrains.mps.lang.migration.pluginSolution.plugin.MoveNodeRefactoringLogParticipant;
import jetbrains.mps.ide.platform.actions.core.MoveNodesUtil;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import java.util.Collection;
import jetbrains.mps.errors.item.ReportItem;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.ide.save.SaveRepositoryCommand;
import jetbrains.mps.ide.make.actions.MakeActionParameters;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.ide.make.DefaultMakeMessageHandler;
import jetbrains.mps.make.IMakeService;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.resources.MResource;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.ide.migration.AntTaskExecutionUtil;
import com.intellij.openapi.project.ProjectManager;
import com.intellij.ide.impl.ProjectUtil;
import com.intellij.openapi.application.ModalityState;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.io.File;
import jetbrains.mps.project.validation.ValidationUtil;
import org.jetbrains.mps.openapi.util.Processor;
import jetbrains.mps.util.Reference;
import jetbrains.mps.ide.ThreadUtils;

public class MoveConceptRefactoring_Test extends EnvironmentAwareTestCase {
  private static final String PROJECT_PATH = "testbench/modules/testRefactoring/";
  private Project project;
  public void test_moveConcept_MPS_27372() throws Exception {
    // this is not formally correct to store SModule, but ok for testing purposes 
    final Wrappers._T<SModule> sourceModule = new Wrappers._T<SModule>();
    final Wrappers._T<SModule> targetModule = new Wrappers._T<SModule>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        sourceModule.value = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("3e00419d-4801-4bad-bf2a-50479218fb53(jetbrains.mps.refactoring.testmaterial.moveConcept.SourceLanguage)"));
        Assert.assertNotNull(sourceModule.value);
        targetModule.value = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("2f6eb168-4811-48ad-becb-56fd47d21d59(jetbrains.mps.refactoring.testmaterial.moveConcept.TargetLanguage)"));
        Assert.assertNotNull(targetModule.value);
      }
    });

    runCommand(new Runnable() {
      public void run() {
        SModel targetModel = SModuleOperations.getAspect(targetModule.value, "structure");
        Assert.assertNotNull(targetModel);
        SNode nodeToMove = SNodeOperations.getNode("r:469ff9d9-5a2e-4029-9891-ce478377a661(jetbrains.mps.refactoring.testmaterial.moveConcept.SourceLanguage.structure)", "6006982468244407213");
        Assert.assertNotNull(nodeToMove);

        List<RefactoringParticipant.Option> options = ListSequence.fromList(new ArrayList<RefactoringParticipant.Option>());

        ListSequence.fromList(options).addElement(UpdateModelImports.OPTION);
        ListSequence.fromList(options).addElement(UpdateReferencesParticipantBase.UpdateReferencesParticipant.OPTION);

        ListSequence.fromList(options).addElement(MoveAspectsParticipant.OPTION);
        ListSequence.fromList(options).addElement(UpdateLocalInstancesParticipant.OPTION);

        ListSequence.fromList(options).addElement(LanguageStructureMigrationParticipant.OPTION);
        ListSequence.fromList(options).addElement(MoveNodeRefactoringLogParticipant.OPTION);

        MoveNodesUtil.moveTo(project, "", MapSequence.<MoveNodesUtil.NodeProcessor, List<SNode>>fromMapAndKeysArray(new HashMap<MoveNodesUtil.NodeProcessor, List<SNode>>(), new MoveNodesUtil.NodeCreatingProcessor(new NodeLocation.NodeLocationRoot(targetModel), project)).withValues(ListSequence.fromListAndArray(new ArrayList<SNode>(), nodeToMove)), new HeadlessRefactoringUI(options));
      }
    });

    // not really needed, but still let's end the transaction before checking 
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Collection<ReportItem> sourceErrors = getErrors(SModelOperations.roots(SModuleOperations.getAspect(sourceModule.value, "constraints"), null));
        Assert.assertTrue("" + sourceErrors, CollectionSequence.fromCollection(sourceErrors).isEmpty());
        Collection<ReportItem> targetErrors = getErrors(SModelOperations.roots(SModuleOperations.getAspect(targetModule.value, "constraints"), null));
        Assert.assertTrue("" + targetErrors, CollectionSequence.fromCollection(targetErrors).isEmpty());
      }
    });

    // make 
    new SaveRepositoryCommand(project.getRepository()).execute();
    final MakeActionParameters myParams = new MakeActionParameters(project).modules(ListSequence.fromListAndArray(new ArrayList<SModule>(), sourceModule.value, targetModule.value));
    final MakeSession session = new MakeSession(project, new DefaultMakeMessageHandler(project), myParams.isCleanMake());
    if (IMakeService.INSTANCE.get().openNewSession(session)) {
      final Wrappers._T<List<IResource>> inputRes = new Wrappers._T<List<IResource>>(null);
      final ArrayList<SModel> models = new ArrayList<SModel>();
      try {
        project.getRepository().getModelAccess().runReadAction(new Runnable() {
          public void run() {
            inputRes.value = Sequence.fromIterable(myParams.collectInput()).toListSequence();
            models.addAll(ListSequence.fromList(inputRes.value).translate(new ITranslator2<IResource, SModel>() {
              public Iterable<SModel> translate(IResource it) {
                return ((MResource) it).models();
              }
            }).toListSequence());
            IMakeService.INSTANCE.get().make(session, inputRes.value);
          }
        });
      } catch (RuntimeException e) {
        IMakeService.INSTANCE.get().closeSession(session);
        throw e;
      }
    }
    while (IMakeService.INSTANCE.isSessionActive()) {
      // do nothing, just wait 
    }

    ApplicationManager.getApplication().invokeAndWait(new Runnable() {
      public void run() {
        try {
          AntTaskExecutionUtil.migrate(project);
          com.intellij.openapi.project.Project[] projects = ProjectManager.getInstance().getOpenProjects();
          assert projects.length == 1 : "more than one project opened: " + projects.length;
          ProjectUtil.closeAndDispose(projects[0]);
        } catch (Exception e) {
          throw new RuntimeException("Exception during migration", e);
        }
      }
    }, ModalityState.defaultModalityState());

    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        String val = SNodeOperations.getNode("r:ac08359f-193b-493f-92ef-48848aecee7b(jetbrains.mps.refactoring.testmaterial.moveConcept.InstanceSolution.main)", "6006982468244420385").getProperty(MetaAdapterFactory.getProperty(0x3e00419d48014badL, 0xbf2a50479218fb53L, 0x535d16ba7fb503adL, 0x535d16ba7fbdf83fL, "prop"));
        Assert.assertNull("Old property value is: " + val, val);
      }
    });
  }
  public void setUp() {
    project = myEnvironment.openProject(new File(PROJECT_PATH));
  }
  public void tearDown() {
    myEnvironment.closeProject(project);
  }


  public static Collection<ReportItem> getErrors(Iterable<SNode> roots) {
    final List<ReportItem> result = ListSequence.fromList(new ArrayList<ReportItem>());
    ValidationUtil.validateModelContent(roots, new Processor<ReportItem>() {
      public boolean process(ReportItem problem) {
        ListSequence.fromList(result).addElement(problem);
        return true;
      }
    });
    return result;
  }

  public void runCommand(final Runnable runnable) {
    final Reference<Throwable> ref = new Reference();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        project.getModelAccess().executeCommand(new Runnable() {
          public void run() {
            try {
              runnable.run();
            } catch (Throwable t) {
              ref.set(t);
            }

          }
        });
      }
    });
    if (!(ref.isNull())) {
      throw new RuntimeException(ref.get());
    }
  }
}
