package jetbrains.mps.execution.impl.configurations.tests.inprocess;

/*Generated by MPS */

import jetbrains.mps.MPSLaunch;
import jetbrains.mps.lang.test.runtime.BaseTransformationTest;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.junit.ClassRule;
import jetbrains.mps.lang.test.runtime.TestParametersCache;
import org.junit.Test;
import jetbrains.mps.lang.test.runtime.BaseTestBody;
import jetbrains.mps.execution.impl.configurations.util.TestNodeWrapHelper;
import jetbrains.mps.smodel.SNodePointer;
import java.util.List;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunState;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.Executor;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.JUnitInProcessExecutor;
import jetbrains.mps.lang.test.util.TestInProcessRunState;
import com.intellij.execution.process.ProcessHandler;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.execution.impl.configurations.tests.commands.CheckTestStateListener;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.unitTest.execution.client.UnitTestProcessListener;
import java.util.concurrent.CountDownLatch;
import com.intellij.execution.process.ProcessAdapter;
import com.intellij.execution.process.ProcessEvent;
import junit.framework.Assert;
import java.util.concurrent.TimeUnit;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.FakeProcess;
import com.intellij.execution.ExecutionException;
import com.intellij.util.WaitFor;

@MPSLaunch
public class JUnitInProcessTermination_Test extends BaseTransformationTest {
  private static final Logger LOG = LogManager.getLogger(JUnitInProcessTermination_Test.class);
  @ClassRule
  public static final TestParametersCache ourParamCache = new TestParametersCache(JUnitInProcessTermination_Test.class, "${mps_home}", "r:ff98d12f-bc65-4639-94c3-dee022b33791(jetbrains.mps.execution.impl.configurations.tests.inprocess@tests)", false);


  public JUnitInProcessTermination_Test() {
    super(ourParamCache);
  }

  @Test
  public void test_terminate() throws Throwable {
    runTest("jetbrains.mps.execution.impl.configurations.tests.inprocess.JUnitInProcessTermination_Test$TestBody", "test_terminate", false);
  }

  @MPSLaunch
  public static class TestBody extends BaseTestBody {
    public void test_terminate() throws Exception {
      this.startAndTerminate(new TestNodeWrapHelper(myProject.getRepository()).discover(new SNodePointer("r:bbc844ac-dcda-4460-9717-8eb5d64b4778(jetbrains.mps.execution.impl.configurations.tests.commands.sandbox2@tests)", "6339244025082972090")));
    }


    public void startAndTerminate(final List<ITestNodeWrapper> testNodes) {
      try {
        final TestRunState runState = new TestRunState(testNodes);

        Executor processExecutor = new JUnitInProcessExecutor(myProject, "testtest", testNodes);
        final TestInProcessRunState lightState = TestInProcessRunState.getInstance();
        if (LOG.isInfoEnabled()) {
          LOG.info("Starting in-process-execution");
        }
        ProcessHandler process = processExecutor.execute();
        final Wrappers._T<CheckTestStateListener> checkListener = new Wrappers._T<CheckTestStateListener>();
        myProject.getModelAccess().runReadAction(new Runnable() {
          public void run() {
            checkListener.value = new CheckTestStateListener(testNodes, ListSequence.fromList(new ArrayList<ITestNodeWrapper>()));
            runState.addListener(checkListener.value);
          }
        });
        process.addProcessListener(new UnitTestProcessListener(runState));

        final int[] exitCode = {-1};
        final CountDownLatch latch = new CountDownLatch(1);
        process.addProcessListener(new ProcessAdapter() {
          @Override
          public void processTerminated(ProcessEvent event) {
            exitCode[0] = event.getExitCode();
            latch.countDown();
          }
        });
        process.startNotify();
        this.waitForRunToStart(lightState);
        Assert.assertTrue(lightState.isRunning());
        process.destroyProcess();
        latch.await(10, TimeUnit.SECONDS);
        int exitcode = exitCode[0];
        if (exitcode != FakeProcess.TERMINATION_CODE) {
          Assert.fail("Exit code must be equal to " + FakeProcess.TERMINATION_CODE + ", not to " + exitcode);
        }
        if (!(checkListener.value.getMessages().equals(""))) {
          Assert.fail(checkListener.value.getMessages());
        }
      } catch (ExecutionException e) {
        Assert.fail(e.getMessage());
      } catch (InterruptedException e) {
        Assert.fail(e.getMessage());
      }
    }
    public void waitForRunToStart(final TestInProcessRunState lightState) {
      new WaitFor(1000) {
        protected boolean condition() {
          return false;
        }
      };

      new WaitFor(5 * 1000) {
        protected boolean condition() {
          return lightState.isRunning();
        }
      };
    }
  }
}
