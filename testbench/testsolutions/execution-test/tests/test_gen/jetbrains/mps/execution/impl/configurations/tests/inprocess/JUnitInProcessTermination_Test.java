package jetbrains.mps.execution.impl.configurations.tests.inprocess;

/*Generated by MPS */

import jetbrains.mps.MPSLaunch;
import jetbrains.mps.lang.test.runtime.BaseTransformationTest;
import org.junit.Test;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.lang.test.runtime.BaseTestBody;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import java.util.List;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.execution.impl.configurations.util.JUnitWrapHelper;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunState;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestEventsDispatcher;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.Executor;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.JUnitLightExecutor;
import jetbrains.mps.lang.test.util.TestLightRunState;
import com.intellij.execution.process.ProcessHandler;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.execution.impl.configurations.tests.commands.CheckTestStateListener;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.execution.api.commands.OutputRedirector;
import jetbrains.mps.baseLanguage.unitTest.execution.client.UnitTestProcessListener;
import java.util.concurrent.CountDownLatch;
import com.intellij.execution.process.ProcessAdapter;
import com.intellij.execution.process.ProcessEvent;
import junit.framework.Assert;
import java.util.concurrent.TimeUnit;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.FakeProcess;
import com.intellij.execution.ExecutionException;
import com.intellij.util.WaitFor;

@MPSLaunch
public class JUnitInProcessTermination_Test extends BaseTransformationTest {
  @Test
  public void test_terminate() throws Throwable {
    initTest("${mps_home}", "r:ff98d12f-bc65-4639-94c3-dee022b33791(jetbrains.mps.execution.impl.configurations.tests.inprocess@tests)", false);
    runTest("jetbrains.mps.execution.impl.configurations.tests.inprocess.JUnitInProcessTermination_Test$TestBody", "test_terminate", false);
  }

  protected static Logger LOG = LogManager.getLogger(JUnitInProcessTermination_Test.class);
  @MPSLaunch
  public static class TestBody extends BaseTestBody {
    public void test_terminate() throws Exception {
      SModel model = new ModuleRepositoryFacade(myProject.getRepository()).getModelByName("jetbrains.mps.execution.impl.configurations.tests.commands.sandbox2@tests");
      List<ITestNodeWrapper> wrappedTests = new JUnitWrapHelper(myProject.getModelAccess()).wrapTests(model, Sequence.<SNodeReference>singleton(new SNodePointer("r:bbc844ac-dcda-4460-9717-8eb5d64b4778(jetbrains.mps.execution.impl.configurations.tests.commands.sandbox2@tests)", "6339244025082972090")));
      this.startAndTerminate(wrappedTests);
    }


    public void startAndTerminate(final List<ITestNodeWrapper> testNodes) {
      try {
        final TestRunState runState = new TestRunState(testNodes, myProject);
        TestEventsDispatcher eventsDispatcher = new TestEventsDispatcher(runState);

        Executor processExecutor = new JUnitLightExecutor(testNodes, eventsDispatcher);
        final TestLightRunState lightState = JUnitLightExecutor.getRunState();
        if (LOG.isInfoEnabled()) {
          LOG.info("Starting in-process-execution");
        }
        ProcessHandler process = processExecutor.execute();
        final Wrappers._T<CheckTestStateListener> checkListener = new Wrappers._T<CheckTestStateListener>();
        myProject.getModelAccess().runReadAction(new Runnable() {
          public void run() {
            checkListener.value = new CheckTestStateListener(testNodes, ListSequence.fromList(new ArrayList<ITestNodeWrapper>()));
            runState.addListener(checkListener.value);
          }
        });
        OutputRedirector.redirect(process, new UnitTestProcessListener(eventsDispatcher));

        final int[] exitCode = {-1};
        final CountDownLatch latch = new CountDownLatch(1);
        process.addProcessListener(new ProcessAdapter() {
          @Override
          public void processTerminated(ProcessEvent event) {
            exitCode[0] = event.getExitCode();
            latch.countDown();
          }
        });
        process.startNotify();
        this.waitForRunToStart(lightState);
        Assert.assertTrue(lightState.isRunning());
        process.destroyProcess();
        latch.await(30 * 1000, TimeUnit.MILLISECONDS);
        int exitcode = exitCode[0];
        if (exitcode != FakeProcess.TERMINATION_CODE) {
          Assert.fail("Exit code must be equal to " + FakeProcess.TERMINATION_CODE + ", but " + exitcode);
        } else if (exitcode < 0) {
          Assert.fail("Process is running for too long");
        }
        if (!(checkListener.value.getMessages().equals(""))) {
          Assert.fail(checkListener.value.getMessages());
        }
      } catch (ExecutionException e) {
        Assert.fail(e.getMessage());
      } catch (InterruptedException e) {
        Assert.fail(e.getMessage());
      }
    }
    public void waitForRunToStart(final TestLightRunState lightState) {
      new WaitFor(5 * 1000) {
        protected boolean condition() {
          return lightState.isRunning();
        }
      };
    }
  }
}
