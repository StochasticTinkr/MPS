package jetbrains.mps.traceInfo.testWeaving.test;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.ArrayList;
import junit.framework.Assert;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.textgen.trace.DebugInfo;
import jetbrains.mps.textgen.trace.DefaultTraceInfoProvider;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

/*package*/ class TestUtil {
  private final Project myProject;

  public TestUtil(Project mpsProject) {
    myProject = mpsProject;
  }

  public void testWeave(final SNode root, List<SNode> nodes, int startLine) {
    final Wrappers._int line = new Wrappers._int(startLine);
    final int delta = 3;
    ListSequence.fromList(nodes).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        {
          List<SNode> nodesBefore = ListSequence.fromListAndArray(new ArrayList<SNode>(), it);
          List<SNode> nodesAfter = ListSequence.fromListAndArray(new ArrayList<SNode>(), getTracedNode(root, line.value));
          Assert.assertNull("The nodes '" + nodesBefore + "' and '" + nodesAfter + "' do not match!", new NodesMatcher().match(nodesBefore, nodesAfter));
        }
        line.value += delta;
      }
    });
  }

  public void testWeaveMany(final SNode root, List<SNode> nodes, int startLine) {
    final Wrappers._int line = new Wrappers._int(startLine);
    final int delta = 3;
    final int howMany = 3;
    ListSequence.fromList(nodes).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        for (int i = 0; i < howMany; i++) {
          {
            List<SNode> nodesBefore = ListSequence.fromListAndArray(new ArrayList<SNode>(), it);
            List<SNode> nodesAfter = ListSequence.fromListAndArray(new ArrayList<SNode>(), getTracedNode(root, line.value));
            Assert.assertNull("The nodes '" + nodesBefore + "' and '" + nodesAfter + "' do not match!", new NodesMatcher().match(nodesBefore, nodesAfter));
          }
          line.value += delta;
        }
      }
    });
  }

  private SNode getTracedNode(SNode root, int line) {
    DebugInfo di = new DefaultTraceInfoProvider(myProject.getRepository()).debugInfo(SModelOperations.getModelName(SNodeOperations.getModel(root))).findFirst().get();
    if (di == null) {
      return null;
    }
    List<SNodeReference> tracedNodes = di.getTracedNodesForPosition(SPropertyOperations.getString(root, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")) + ".java", line);
    return (tracedNodes.isEmpty() ? null : tracedNodes.get(0).resolve(myProject.getRepository()));
  }
}
