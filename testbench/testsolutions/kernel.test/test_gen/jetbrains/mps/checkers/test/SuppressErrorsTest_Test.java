package jetbrains.mps.checkers.test;

/*Generated by MPS */

import jetbrains.mps.MPSLaunch;
import jetbrains.mps.lang.test.runtime.BaseTransformationTest;
import org.junit.ClassRule;
import jetbrains.mps.lang.test.runtime.TestParametersCache;
import org.junit.Rule;
import jetbrains.mps.lang.test.runtime.RunWithCommand;
import org.junit.Test;
import jetbrains.mps.lang.test.runtime.BaseTestBody;
import jetbrains.mps.lang.test.runtime.TransformationTest;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.List;
import jetbrains.mps.errors.item.IssueKindReportItem;
import jetbrains.mps.typesystemEngine.checker.TypesystemChecker;
import junit.framework.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.checkers.IChecker;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.ArrayList;
import jetbrains.mps.checkers.ModelCheckerBuilder;
import org.jetbrains.mps.openapi.util.Consumer;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.errors.item.NodeFlavouredItem;
import java.util.Collection;
import jetbrains.mps.errors.item.RuleIdFlavouredItem;
import java.util.Objects;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;

@MPSLaunch
public class SuppressErrorsTest_Test extends BaseTransformationTest {
  @ClassRule
  public static final TestParametersCache ourParamCache = new TestParametersCache(SuppressErrorsTest_Test.class, "${mps_home}", "r:4544cb8b-6ea6-46c1-829b-9d57f2ed0e45(jetbrains.mps.checkers.test@tests)", false);
  @Rule
  public final RunWithCommand myWithCommandRule = new RunWithCommand(this);

  public SuppressErrorsTest_Test() {
    super(ourParamCache);
  }

  @Test
  public void test_noQuotationNoSuppress() throws Throwable {
    new SuppressErrorsTest_Test.TestBody(this).test_noQuotationNoSuppress();
  }
  @Test
  public void test_quotationSuppress() throws Throwable {
    new SuppressErrorsTest_Test.TestBody(this).test_quotationSuppress();
  }
  @Test
  public void test_antiquotationNoSuppress() throws Throwable {
    new SuppressErrorsTest_Test.TestBody(this).test_antiquotationNoSuppress();
  }

  /*package*/ static class TestBody extends BaseTestBody {

    /*package*/ TestBody(TransformationTest owner) {
      super(owner);
    }

    public void test_noQuotationNoSuppress() throws Exception {
      addNodeById("6807933448480843367");
      addNodeById("6807933448480841930");
      addNodeById("6807933448482335857");
      SNode nodeToCheck = SLinkOperations.getTarget(SNodeOperations.cast(getNodeById("6807933448480843367"), SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, "jetbrains.mps.lang.test"), 0x11b5a38fc01L, "TestNode"))), MetaAdapterFactory.getContainmentLink(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11b5a38fc01L, 0x11b5a397b92L, "nodeToCheck"));
      List<IssueKindReportItem> errors = this.runChecker(new TypesystemChecker(), nodeToCheck);
      Assert.assertTrue(ListSequence.fromList(errors).count() == 1 && this.isOurError(ListSequence.fromList(errors).first()));
    }
    public void test_quotationSuppress() throws Exception {
      addNodeById("6807933448480843367");
      addNodeById("6807933448480841930");
      addNodeById("6807933448482335857");
      SNode nodeToCheck = SLinkOperations.getTarget(SNodeOperations.cast(getNodeById("6807933448480841930"), SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, "jetbrains.mps.lang.test"), 0x11b5a38fc01L, "TestNode"))), MetaAdapterFactory.getContainmentLink(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11b5a38fc01L, 0x11b5a397b92L, "nodeToCheck"));
      List<IssueKindReportItem> errors = this.runChecker(new TypesystemChecker(), nodeToCheck);
      Assert.assertTrue(ListSequence.fromList(errors).isEmpty());
    }
    public void test_antiquotationNoSuppress() throws Exception {
      addNodeById("6807933448480843367");
      addNodeById("6807933448480841930");
      addNodeById("6807933448482335857");
      SNode nodeToCheck = SLinkOperations.getTarget(SNodeOperations.cast(getNodeById("6807933448482335857"), SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, "jetbrains.mps.lang.test"), 0x11b5a38fc01L, "TestNode"))), MetaAdapterFactory.getContainmentLink(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11b5a38fc01L, 0x11b5a397b92L, "nodeToCheck"));
      List<IssueKindReportItem> errors = this.runChecker(new TypesystemChecker(), nodeToCheck);
      Assert.assertTrue(ListSequence.fromList(errors).count() == 1 && this.isOurError(ListSequence.fromList(errors).first()));
    }


    public List<IssueKindReportItem> runChecker(IChecker<?, ? extends IssueKindReportItem> checker, final SNode root) {
      SModule module = SNodeOperations.getModel(root).getModule();
      final SRepository repository = module.getRepository();
      final List<IssueKindReportItem> result = ListSequence.fromList(new ArrayList<IssueKindReportItem>());
      new ModelCheckerBuilder(false).createChecker(ListSequence.fromListAndArray(new ArrayList<IChecker<?, ? extends IssueKindReportItem>>(), checker)).check(ModelCheckerBuilder.ItemsToCheck.forSingleModule(module), repository, new Consumer<IssueKindReportItem>() {
        public void consume(IssueKindReportItem reportItem) {
          ListSequence.fromList(result).addElement(reportItem);
        }
      }, new EmptyProgressMonitor());
      return ListSequence.fromList(result).where(new IWhereFilter<IssueKindReportItem>() {
        public boolean accept(IssueKindReportItem it) {
          SNode node = check_nwqyf3_a0a0a0a0e0i9(NodeFlavouredItem.FLAVOUR_NODE.tryToGet(it), repository);
          return node != null && ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, true)).contains(root);
        }
      }).toListSequence();
    }
    public boolean isOurError(IssueKindReportItem reportItem) {
      Collection<RuleIdFlavouredItem.TypesystemRuleId> errorRules = RuleIdFlavouredItem.FLAVOUR_RULE_ID.getCollection(reportItem);
      return Objects.equals(ListSequence.fromListWithValues(new ArrayList<SNodeReference>(), CollectionSequence.fromCollection(errorRules).select(new ISelector<RuleIdFlavouredItem.TypesystemRuleId, SNodeReference>() {
        public SNodeReference select(RuleIdFlavouredItem.TypesystemRuleId it) {
          return it.getSourceNode();
        }
      })), ListSequence.fromListAndArray(new ArrayList<SNodeReference>(), SNodeOperations.getParent(SNodeOperations.getNode("r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)", "8292998349249062282")).getReference()));
    }
    private static SNode check_nwqyf3_a0a0a0a0e0i9(SNodeReference checkedDotOperand, SRepository repository) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.resolve(repository);
      }
      return null;
    }
  }
}
