package tests.testPersistence.test;

/*Generated by MPS */

import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import java.io.IOException;
import junit.framework.Assert;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.persistence.PersistenceRegistry;
import java.util.List;
import java.util.Comparator;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * This is test class for _supported_ persistences. 
 * Note the difference between supported persistence and vcs persistence.
 * For info, read doc comments in ModelPersistence/VCSPersistenceSupport classes
 */
public class TestPersistenceHelper {
  /**
   * should be changed to ModelPersistence.firstSupportedVersion
   */
  public static final int START_PERSISTENCE_TEST_VERSION = 9;

  public TestOutputFilter filter = new TestOutputFilter() {
    @Override
    protected boolean isLineOK(String line) {
      return line != null && !((line.contains("attribute") && line.contains("undeclared child role:")));
    }
  };

  public void saveModelInPersistence(final SModelBase model, final PersistenceUtil.InMemoryStreamDataSource dataSource, final int persistence) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        try {
          filter.start();
          ModelPersistence.saveModel(model.getSModel(), dataSource, persistence);
        } catch (IOException e) {
          Assert.fail("Exception during test. See log for details");
          e.printStackTrace();
        } finally {
          filter.stop();
        }
      }
    });
  }

  public DefaultSModelDescriptor getTestModel() {
    return ((DefaultSModelDescriptor) SModelRepository.getInstance().getModelDescriptor("tests.testPersistence.testModel"));
  }

  public String getDefaultExt() {
    return PersistenceRegistry.getInstance().getDefaultModelFactory().getFileExtension();
  }

  public static <C> String assertListsEqual(List<C> expectedList, List<C> actualList, String name) {
    return assertListsEqual(expectedList, actualList, new Comparator<C>() {
      @Override
      public int compare(C o1, C o2) {
        return (o1.equals(o2) ? 0 : 1);
      }
    }, name);
  }
  public static <C> String assertListsEqual(List<C> expectedList, List<C> actualList, Comparator<C> comparator, String name) {
    List<C> notFoundExpected = new ArrayList<C>();
    List<C> notFoundActual = new ArrayList<C>();
    for (C expected : expectedList) {
      boolean found = false;
      for (C actual : actualList) {
        if (comparator.compare(actual, expected) == 0) {
          found = true;
          break;
        }
      }
      if (!(found)) {
        notFoundExpected.add(expected);
      }
    }
    for (C actual : actualList) {
      boolean found = false;
      for (C expected : expectedList) {
        if (comparator.compare(actual, expected) == 0) {
          found = true;
          break;
        }
      }
      if (!(found)) {
        notFoundActual.add(actual);
      }
    }
    if (!(notFoundExpected.isEmpty())) {
      return "Not found expected " + name + " " + Arrays.toString(notFoundExpected.toArray());
    }
    if (!(notFoundActual.isEmpty())) {
      return "Not expected " + name + " " + Arrays.toString(notFoundActual.toArray());
    }
    return null;
  }

}
