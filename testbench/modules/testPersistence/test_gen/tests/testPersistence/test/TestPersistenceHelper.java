package tests.testPersistence.test;

/*Generated by MPS */

import jetbrains.mps.extapi.model.SModelBase;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import jetbrains.mps.smodel.TrivialModelDescriptor;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.SnapshotModelData;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.smodel.ModelImports;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import java.io.IOException;
import junit.framework.Assert;
import jetbrains.mps.extapi.persistence.datasource.PreinstalledDataSourceTypes;
import java.util.List;
import java.util.Comparator;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * This is test class for _supported_ persistences. 
 * Note the difference between supported persistence and vcs persistence.
 * For info, read doc comments in ModelPersistence/VCSPersistenceSupport classes
 */
public class TestPersistenceHelper {
  /**
   * should be changed to ModelPersistence.firstSupportedVersion
   */
  public static final int START_PERSISTENCE_TEST_VERSION = 9;

  public TestOutputFilter filter = new TestOutputFilter() {
    @Override
    protected boolean isLineOK(String line) {
      return line != null && !((line.contains("attribute") && line.contains("undeclared child role:")));
    }
  };

  private final SModelBase myTestModel;

  /*package*/ TestPersistenceHelper(final SRepository repo) {
    // myTestModel is a copy of a sample model, detached to avoid model read access. 
    myTestModel = new ModelAccessHelper(repo).runReadAction(new Computable<TrivialModelDescriptor>() {
      public TrivialModelDescriptor compute() {
        SModel testModel = PersistenceFacade.getInstance().createModelReference("r:b44bed60-e0f0-4d48-bb29-e0fdb2041a66(tests.testPersistence.testModel)").resolve(repo);
        SnapshotModelData mdClone = new SnapshotModelData(SModelOperations.getPointer(testModel));
        // XXX in fact, duplicates CloneUtil.cloneModelWithImports. Don't want dependency from generator, though. 
        // Perhaps, need a high-level mechanism to clone a model? 
        for (SNode r : SModelOperations.roots(testModel, null)) {
          // TrivialModelDescriptor doesn't support addRootNode(), that's why update SModelData directly 
          mdClone.addRootNode(CopyUtil.copyAndPreserveId(r, true));
        }
        TrivialModelDescriptor rv = new TrivialModelDescriptor(mdClone);
        ModelImports mi = new ModelImports(rv);
        mi.copyImportedModelsFrom(testModel);
        mi.copyUsedLanguagesFrom(testModel);
        mi.copyEmployedDevKitsFrom(testModel);
        return rv;
      }
    });
  }

  /*package*/ void saveTestModelInPersistence(PersistenceUtil.InMemoryStreamDataSource dataSource, int persistence) {
    try {
      filter.start();
      ModelPersistence.saveModel(myTestModel.getSModel(), dataSource, persistence);
    } catch (IOException e) {
      Assert.fail("Exception during test. See log for details");
      e.printStackTrace();
    } finally {
      filter.stop();
    }
  }

  /*package*/ SModelBase getTestModel() {
    return myTestModel;
  }

  /*package*/ String getDefaultExt() {
    return PreinstalledDataSourceTypes.MPS.getFileExtension();
  }

  /*package*/ static <C> String assertListsEqual(List<C> expectedList, List<C> actualList, String name) {
    return assertListsEqual(expectedList, actualList, new Comparator<C>() {
      @Override
      public int compare(C o1, C o2) {
        return (o1.equals(o2) ? 0 : 1);
      }
    }, name);
  }
  /*package*/ static <C> String assertListsEqual(List<C> expectedList, List<C> actualList, Comparator<C> comparator, String name) {
    List<C> notFoundExpected = new ArrayList<C>();
    List<C> notFoundActual = new ArrayList<C>();
    for (C expected : expectedList) {
      boolean found = false;
      for (C actual : actualList) {
        if (comparator.compare(actual, expected) == 0) {
          found = true;
          break;
        }
      }
      if (!(found)) {
        notFoundExpected.add(expected);
      }
    }
    for (C actual : actualList) {
      boolean found = false;
      for (C expected : expectedList) {
        if (comparator.compare(actual, expected) == 0) {
          found = true;
          break;
        }
      }
      if (!(found)) {
        notFoundActual.add(actual);
      }
    }
    if (!(notFoundExpected.isEmpty())) {
      return "Not found expected " + name + " " + Arrays.toString(notFoundExpected.toArray());
    }
    if (!(notFoundActual.isEmpty())) {
      return "Not expected " + name + " " + Arrays.toString(notFoundActual.toArray());
    }
    return null;
  }

}
