package jetbrains.mps.testbench.junit.runners;

/*Generated by MPS */

import org.junit.runners.model.RunnerBuilder;
import jetbrains.mps.tool.environment.Environment;
import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
import org.junit.runner.Runner;
import jetbrains.mps.tool.environment.EnvironmentAware;
import junit.framework.TestCase;
import org.junit.internal.runners.JUnit38ClassRunner;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;
import org.junit.runners.model.FrameworkMethod;
import junit.framework.TestSuite;
import junit.framework.Test;
import junit.framework.TestResult;

public final class PushEnvironmentRunnerBuilder extends RunnerBuilder {
  private final RunnerBuilder myDelegateBuilder;
  /*package*/ final Environment myEnvironmentToPush;

  public PushEnvironmentRunnerBuilder(Environment environmentToPush) {
    this(environmentToPush, new AllDefaultPossibilitiesBuilder(true));
    // true for suite just because I see no reason why to forbid it, though not sure there's none. 
  }

  public PushEnvironmentRunnerBuilder(Environment environmentToPush, RunnerBuilder delegate) {
    myDelegateBuilder = delegate;
    myEnvironmentToPush = environmentToPush;
  }

  @Override
  public Runner runnerForClass(Class<?> aClass) throws Throwable {
    if (EnvironmentAware.class.isAssignableFrom(aClass)) {
      // Here, we assume it's generated (i.e. those we've full control over) tests that bear EnvironmentAware, therefore 
      // we don't support neither @Ignored not @RunWith here. 
      if (TestCase.class.isAssignableFrom(aClass)) {
        return new JUnit38ClassRunner(new PushEnvironmentRunnerBuilder.JUnit38SuiteAdapter(aClass));
      }
      return new PushEnvironmentRunnerBuilder.PushEnvJUnit4Runner(aClass);
    } else {
      return myDelegateBuilder.runnerForClass(aClass);
    }
  }

  /*package*/ class PushEnvJUnit4Runner extends BlockJUnit4ClassRunner {

    /*package*/ PushEnvJUnit4Runner(Class<?> klass) throws InitializationError {
      super(klass);
    }

    @Override
    protected Statement withAfters(FrameworkMethod method, final Object target, Statement statement) {
      // there's no specific reason to use withAfters, withBefores is the same 
      // FIXME override createTest() and invoke cons(Environment), if present, to instantiate test object 

      final Statement withAfters = super.withAfters(method, target, statement);
      if (target instanceof EnvironmentAware) {
        return new Statement() {
          public void evaluate() throws Throwable {
            ((EnvironmentAware) target).setEnvironment(myEnvironmentToPush);
            withAfters.evaluate();
          }
        };
      }
      return withAfters;
    }
  }

  /*package*/ class JUnit38SuiteAdapter extends TestSuite {
    /*package*/ JUnit38SuiteAdapter(Class<?> klass) {
      super(klass);
    }

    @Override
    public void runTest(Test test, TestResult result) {
      if (test instanceof EnvironmentAware) {
        //  well, could be assert as it's the first think we check in runnerForClass, above. Nevertheless, why not to check gracefully? 
        ((EnvironmentAware) test).setEnvironment(myEnvironmentToPush);
      }
      super.runTest(test, result);
    }
  }
}
