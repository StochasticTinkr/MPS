package jetbrains.mps.testbench.junit.runners;

/*Generated by MPS */

import org.junit.runners.model.RunnerBuilder;
import jetbrains.mps.tool.environment.Environment;
import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
import org.junit.runner.Runner;
import jetbrains.mps.tool.environment.EnvironmentAware;
import junit.framework.TestCase;
import org.junit.internal.runners.JUnit38ClassRunner;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.InitializationError;
import junit.framework.TestSuite;
import junit.framework.Test;
import junit.framework.TestResult;

public final class PushEnvironmentRunnerBuilder extends RunnerBuilder {
  private final RunnerBuilder myDelegateBuilder;
  /*package*/ final Environment myEnvironmentToPush;

  public PushEnvironmentRunnerBuilder(Environment environmentToPush) {
    this(environmentToPush, new AllDefaultPossibilitiesBuilder(true));
    // true for suite just because I see no reason why to forbid it, though not sure there's none. 
  }

  public PushEnvironmentRunnerBuilder(Environment environmentToPush, RunnerBuilder delegate) {
    myDelegateBuilder = delegate;
    myEnvironmentToPush = environmentToPush;
  }

  @Override
  public Runner runnerForClass(Class<?> aClass) throws Throwable {
    if (EnvironmentAware.class.isAssignableFrom(aClass)) {
      // Here, we assume it's generated (i.e. those we've full control over) tests that bear EnvironmentAware, therefore 
      // we don't support neither @Ignored not @RunWith here. 
      if (TestCase.class.isAssignableFrom(aClass)) {
        return new JUnit38ClassRunner(new PushEnvironmentRunnerBuilder.JUnit38SuiteAdapter(aClass));
      }
      return new PushEnvironmentRunnerBuilder.PushEnvJUnit4Runner(aClass);
    } else {
      return myDelegateBuilder.runnerForClass(aClass);
    }
  }

  /*package*/ class PushEnvJUnit4Runner extends BlockJUnit4ClassRunner {

    /*package*/ PushEnvJUnit4Runner(Class<?> klass) throws InitializationError {
      super(klass);
    }

    @Override
    protected Object createTest() throws Exception {
      // FIXME Seems better to invoke cons(Environment), if present, to instantiate test object, rather than use setter.  
      // Need another (marker) interface then (not to force empty EA.setEnvironment) 
      Object target = super.createTest();
      if (target instanceof EnvironmentAware) {
        ((EnvironmentAware) target).setEnvironment(myEnvironmentToPush);
      }
      return target;
    }
  }

  /*package*/ class JUnit38SuiteAdapter extends TestSuite {
    /*package*/ JUnit38SuiteAdapter(Class<?> klass) {
      super(klass);
    }

    @Override
    public void runTest(Test test, TestResult result) {
      if (test instanceof EnvironmentAware) {
        //  well, could be assert as it's the first think we check in runnerForClass, above. Nevertheless, why not to check gracefully? 
        ((EnvironmentAware) test).setEnvironment(myEnvironmentToPush);
      }
      super.runTest(test, result);
    }
  }
}
