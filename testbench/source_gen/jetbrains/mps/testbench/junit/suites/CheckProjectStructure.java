package jetbrains.mps.testbench.junit.suites;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import org.junit.Test;
import jetbrains.mps.testbench.junit.Order;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.project.validation.MessageCollectProcessor;
import jetbrains.mps.project.validation.ValidationProblem;
import jetbrains.mps.project.validation.ValidationUtil;
import org.junit.Assert;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.project.validation.NodeValidationProblem;
import jetbrains.mps.project.validation.SuppressingAwareProcessorDecorator;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.util.SNodeOperations;
import org.junit.Assume;
import jetbrains.mps.generator.ModelGenerationStatusManager;
import jetbrains.mps.extapi.model.GeneratableSModel;
import java.util.Collection;

public class CheckProjectStructure extends BaseCheckModulesTest {
  public CheckProjectStructure(SModule module) {
    super(module);
  }

  @Test
  @Order(value = 1)
  public void checkModuleProperties() {
    final List<String> errors = new ArrayList<String>();
    BaseCheckModulesTest.getContextProject().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        List<SModule> modules = ListSequence.fromListAndArray(new ArrayList<SModule>(), myModule);
        if (myModule instanceof Language) {
          ListSequence.fromList(modules).addSequence(CollectionSequence.fromCollection(((Language) myModule).getGenerators()));
        }

        for (SModule sm : modules) {
          MessageCollectProcessor<ValidationProblem> processor = new MessageCollectProcessor<ValidationProblem>(false);
          ValidationUtil.validateModule(sm, processor);
          if (processor.getErrors().isEmpty()) {
            continue;
          }

          StringBuilder errorMessages = new StringBuilder();
          for (String item : processor.getErrors()) {
            errorMessages.append("\t").append(item).append("\n");
          }
          errors.add("Error in module " + sm.getModuleName() + ": " + errorMessages.toString());
        }
      }
    });
    Assert.assertTrue("Module property or dependency errors:\n" + CheckingTestsUtil.formatErrors(errors), errors.isEmpty());
  }

  @Test
  @Order(value = 2)
  public void checkModels() {
    final List<String> errors = new ArrayList<String>();
    BaseCheckModulesTest.getContextProject().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (SModel sm : extractModels(true)) {
          MessageCollectProcessor<ValidationProblem> collector = new MessageCollectProcessor<ValidationProblem>(false);
          ValidationUtil.validateModel(sm, collector);
          if (collector.getErrors().isEmpty()) {
            continue;
          }

          final StringBuilder errorMessages = new StringBuilder();
          errorMessages.append("errors in model: ").append(sm.getReference().toString()).append("\n");
          ListSequence.fromList(((List<String>) collector.getErrors())).visitAll(new IVisitor<String>() {
            public void visit(String it) {
              errorMessages.append("\t").append(it).append("\n");
            }
          });
          errors.add(errorMessages.toString());
        }
      }
    });
    Assert.assertTrue("Model errors:\n" + CheckingTestsUtil.formatErrors(errors), errors.isEmpty());
  }

  @Test
  @Order(value = 3)
  public void checkStructure() {
    final List<String> errors = new ArrayList<String>();
    BaseCheckModulesTest.getContextProject().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (SModel sm : extractModels(true)) {
          MessageCollectProcessor<NodeValidationProblem> collector = new MessageCollectProcessor<NodeValidationProblem>(false) {
            @Override
            protected String formatMessage(NodeValidationProblem problem) {
              String err = super.formatMessage(problem);
              return err + " in node " + problem.getNode().getNodeId();
            }
          };
          ValidationUtil.validateModelContent(sm.getRootNodes(), new SuppressingAwareProcessorDecorator(collector));
          if (collector.getErrors().isEmpty()) {
            continue;
          }

          final StringBuilder errorMessages = new StringBuilder();
          errorMessages.append("errors in model: ").append(sm.getReference().toString()).append("\n");
          ListSequence.fromList(((List<String>) collector.getErrors())).visitAll(new IVisitor<String>() {
            public void visit(String it) {
              errorMessages.append("\t").append(it).append("\n");
            }
          });
          errors.add(errorMessages.toString());
        }
      }
    });
    Assert.assertTrue("Structure errors:\n" + CheckingTestsUtil.formatErrors(errors), errors.isEmpty());
  }

  @Test
  @Order(value = 4)
  public void checkReferences() {
    final List<String> errors = new ArrayList<String>();
    BaseCheckModulesTest.getContextProject().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (SModel sm : extractModels(true)) {
          StringBuilder errorMessages = new StringBuilder();
          errorMessages.append("errors in model: ").append(sm.getReference().toString()).append("\n");
          boolean withErrors = false;

          for (SNode node : SNodeUtil.getDescendants(sm)) {
            for (SReference ref : node.getReferences()) {
              if (jetbrains.mps.smodel.SNodeUtil.hasReferenceMacro(node, ref.getLink())) {
                continue;
              }
              if (SNodeOperations.getTargetNodeSilently(ref) != null) {
                continue;
              }

              withErrors = true;
              errorMessages.append("Broken reference in model {").append(node.getModel().getName().getLongName()).append("}").append(" node ").append(node.getNodeId().toString()).append("(").append(node).append(")\n");
            }
          }

          if (withErrors) {
            errors.add("Broken References: " + errorMessages.toString());
          }
        }
      }
    });
    Assert.assertTrue("Reference errors:\n" + CheckingTestsUtil.formatErrors(errors), errors.isEmpty());
  }

  @Test
  @Order(value = 5)
  public void checkGenerationStatus() {
    Assume.assumeFalse("Generation status is meaningless for packaged modules", myModule.isPackaged());
    final List<String> errors = new ArrayList<String>();
    BaseCheckModulesTest.getContextProject().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (SModel sm : extractModels(false)) {
          SModule module = sm.getModule();
          if (module == null) {
            errors.add("Model without a module: " + sm.getReference().toString());
            continue;
          }
          String genHash = ModelGenerationStatusManager.getLastGenerationHash(((GeneratableSModel) sm));
          if (genHash == null) {
            errors.add("No generated hash for " + sm.getReference().toString());
            continue;
          }
          String realHash = ((GeneratableSModel) sm).getModelHash();
          if (realHash == null) {
            errors.add("cannot gen cache for " + sm.getReference().toString());
            continue;
          }
          if (!(realHash.equals(genHash))) {
            errors.add("model requires generation: " + sm.getReference().toString() + " last genHash:" + genHash + " modelHash:" + realHash);
          }
        }
      }
    });
    Assert.assertTrue("Try to regenerate models:\n" + CheckingTestsUtil.formatErrors(errors), errors.isEmpty());
  }

  private Collection<SModel> extractModels(boolean includeDontGenerate) {
    return new ModelsExtractor(myModule, includeDontGenerate).includingGenerators().getModels();
  }
}
