package jetbrains.mps.ide.vcs.test.merge;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import jetbrains.mps.ide.platform.watching.ReloadManager;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vcs.FileStatus;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import com.intellij.openapi.vcs.FileStatusListener;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.vcs.changes.VcsDirtyScopeManager;
import com.intellij.openapi.vcs.changes.ChangeListManagerImpl;
import jetbrains.mps.vcs.changesmanager.SimpleCommandQueue;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import jetbrains.mps.ide.platform.watching.ReloadListener;

public class ChangesManagerTestWaitHelper {
  private boolean myWaitCompleted = true;
  private final Object myWaitLock = new Object();

  private Project myProject;

  private Runnable myAfterReloadTask;
  private ChangesManagerTestWaitHelper.MyReloadListener myReloadListener = new ChangesManagerTestWaitHelper.MyReloadListener();
  private final ReloadManager myReloadManager;

  public ChangesManagerTestWaitHelper(Project p, ReloadManager reloadManager) {
    myProject = p;
    myReloadManager = reloadManager;
    myReloadManager.addReloadListener(this.myReloadListener);
  }

  public void dispose() {
    myReloadManager.removeReloadListener(myReloadListener);
  }

  public void waitForFileStatusChange(@NotNull final VirtualFile file, @NotNull final FileStatus expectedFileStatus) {
    final FileStatusManager fsm = FileStatusManager.getInstance(myProject);
    // In case fs is not updated, we need to stop waiting, so set timeout to 5 seconds 
    int fsUpdateTimeout = 5000;
    waitForSomething(new Runnable() {
      public void run() {
        final Wrappers._T<FileStatusListener> listener = new Wrappers._T<FileStatusListener>();
        final _FunctionTypes._void_P0_E0 stopIfNeeded = new _FunctionTypes._void_P0_E0() {
          public void invoke() {
            if (expectedFileStatus == fsm.getStatus(file)) {
              fsm.removeFileStatusListener(listener.value);
              // Wait until changes manager is notified about changed file status 
              try {
                Thread.sleep(100);
              } catch (InterruptedException e) {
                e.printStackTrace();
              }
              waitCompleted();
            }
          }
        };
        listener.value = new FileStatusListener() {
          @Override
          public void fileStatusesChanged() {
            stopIfNeeded.invoke();
          }
          @Override
          public void fileStatusChanged(@NotNull VirtualFile f) {
            stopIfNeeded.invoke();
          }
        };
        fsm.addFileStatusListener(listener.value);
        VcsDirtyScopeManager.getInstance(myProject).fileDirty(file);
        ChangeListManagerImpl.getInstanceImpl(myProject).scheduleUpdate();
        stopIfNeeded.invoke();
      }
    }, fsUpdateTimeout);
  }

  private class WaitForChangesManagerTask implements Runnable {
    @Override
    public void run() {
      SimpleCommandQueue commandQueue = CurrentDifferenceRegistry.getInstance(myProject).getCommandQueue();
      if (commandQueue.isEmpty()) {
        waitCompleted();
      } else {
        commandQueue.addTask(this);
      }
    }
  }
  public void waitForChangesManager() {
    waitForSomething(new Runnable() {
      public void run() {
        CurrentDifferenceRegistry.getInstance(myProject).getCommandQueue().addTask(new ChangesManagerTestWaitHelper.WaitForChangesManagerTask());
      }
    }, -1);
  }

  public void waitForReloadFinished() {
    waitForSomething(new Runnable() {
      public void run() {
        synchronized (ChangesManagerTestWaitHelper.this) {
          myAfterReloadTask = new Runnable() {
            public void run() {
              synchronized (ChangesManagerTestWaitHelper.this) {
                myAfterReloadTask = null;
              }
              waitCompleted();
            }
          };
        }
      }
    }, -1);
  }

  /**
   * 
   * @param waitScheduling is runnable with work wait to finish, must call {@link ChangesManagerTestWaitHelper#waitCompleted()}
   * @param timeout time to wait for runnable to be finished in milliseconds, -1 for wait until myWaitCompleted
   */
  private void waitForSomething(Runnable waitScheduling, int timeout) {
    synchronized (myWaitLock) {
      assert myWaitCompleted;
      myWaitCompleted = false;
      waitScheduling.run();
      if (timeout > 0) {
        while (!(myWaitCompleted)) {
          try {
            myWaitLock.wait(timeout);
          } catch (InterruptedException e) {
            e.printStackTrace();
          } finally {
            if (!(myWaitCompleted)) {
              // Reset flag for next calls 
              myWaitCompleted = true;
              System.err.print("Runnable did not call waitCompleted. Ended by timeout");
            }
          }
        }
      } else {
        while (!(myWaitCompleted)) {
          try {
            myWaitLock.wait();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }

  private void waitCompleted() {
    synchronized (myWaitLock) {
      assert !(myWaitCompleted);
      myWaitCompleted = true;
      myWaitLock.notify();
    }
  }

  private class MyReloadListener implements ReloadListener {
    public MyReloadListener() {
    }
    @Override
    public void reloadStarted() {
    }
    @Override
    public void reloadFinished() {
      synchronized (this) {
        check_6valm7_a0a0a2y(myAfterReloadTask);
      }
    }
  }
  private static void check_6valm7_a0a0a2y(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }
}
