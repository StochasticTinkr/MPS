package jetbrains.mps.ide.vcs.test.merge;

/*Generated by MPS */

import jetbrains.mps.project.MPSProject;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vcs.changes.ChangeListManagerImpl;
import jetbrains.mps.vcs.changesmanager.CurrentDifference;
import com.intellij.openapi.vcs.AbstractVcs;
import jetbrains.mps.tool.environment.Environment;
import org.junit.BeforeClass;
import jetbrains.mps.tool.environment.IdeaEnvironment;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import jetbrains.mps.smodel.SReference;
import com.intellij.openapi.util.registry.Registry;
import java.io.File;
import org.junit.AfterClass;
import org.junit.Before;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import com.intellij.openapi.vcs.impl.projectlevelman.AllVcses;
import org.junit.Assume;
import com.intellij.openapi.vcs.VcsShowConfirmationOption;
import javax.swing.SwingUtilities;
import com.intellij.openapi.vcs.FileStatusManager;
import java.lang.reflect.InvocationTargetException;
import org.junit.After;
import jetbrains.mps.nodeEditor.InspectorTool;
import org.junit.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.vcs.VcsConfiguration;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.vcs.diff.ChangeSet;
import jetbrains.mps.vcs.diff.ChangeSetBuilder;
import jetbrains.mps.vcs.changesmanager.roots.NodeFileStatusMappingExt;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vcs.changes.Change;
import java.util.List;
import com.intellij.openapi.vcs.VcsException;
import java.util.ArrayList;
import java.util.Arrays;
import com.intellij.openapi.vcs.rollback.RollbackProgressListener;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.extapi.persistence.FileDataSource;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.persistence.PersistenceRegistry;

public abstract class ChangesTestBase {
  protected static MPSProject ourProject;
  protected static boolean ourEnabled;

  protected Project myIdeaProject;
  protected ChangesManagerTestWaitHelper myWaitHelper;

  protected ChangeListManagerImpl myChangeListManager;
  protected CurrentDifference myDiff;
  protected AbstractVcs myGitVcs;
  protected static Environment ourEnvironment;

  public ChangesTestBase() {
    // todo add group changes tests 
  }

  @BeforeClass
  public static void setUp() {
    ourEnvironment = IdeaEnvironment.getOrCreate(EnvironmentConfig.defaultConfig().withVcsPlugin());
    SReference.disableLogging();
    Registry.get("vcs.showConsole").setValue(false);

    // Point to current directory with MPS project 
    File mpsProject = new File("").getAbsoluteFile();
    ourProject = ((MPSProject) ourEnvironment.openProject(mpsProject));
  }

  @AfterClass
  public static void tearDown() {
    ourEnabled = false;
    ourEnvironment.flushAllEvents();
    ourProject.dispose();
  }

  @Before
  public void init() {
    myIdeaProject = ourProject.getProject();
    CurrentDifferenceRegistry.getInstance(myIdeaProject).getCommandQueue().setHadExceptions(false);
    myWaitHelper = new ChangesManagerTestWaitHelper(myIdeaProject);
    myWaitHelper.waitForChangesManager();

    myGitVcs = AllVcses.getInstance(myIdeaProject).getByName("Git");
    Assume.assumeNotNull(myGitVcs);
    Assume.assumeNotNull(getTestModel());
    myDiff = CurrentDifferenceRegistry.getInstance(myIdeaProject).getCurrentDifference((getTestModel()));
    myChangeListManager = ChangeListManagerImpl.getInstanceImpl(myIdeaProject);
    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_NOTHING_SILENTLY);

    if (!(ChangesTestBase.ourEnabled)) {
      myChangeListManager.ensureUpToDate(false);
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            FileStatusManager.getInstance(myIdeaProject).fileStatusesChanged();
          }
        });
      } catch (InterruptedException e) {
        throw new AssertionError(e);
      } catch (InvocationTargetException e) {
        throw new AssertionError(e);
      }

      checkAndEnable();
      ChangesTestBase.ourEnabled = true;
    }
  }
  @After
  public void after() throws InvocationTargetException, InterruptedException {
    revertMemChangesAndWait();
    SwingUtilities.invokeAndWait(new Runnable() {
      public void run() {
        myIdeaProject.getComponent(InspectorTool.class).getInspector().editNode(null);
      }
    });
    Assert.assertFalse(CurrentDifferenceRegistry.getInstance(myIdeaProject).getCommandQueue().hadExceptions());
    myWaitHelper.dispose();
  }

  protected void checkAndEnable() {
    Assert.assertNull(myDiff.getChangeSet());

    myDiff.setEnabled(true);
    myWaitHelper.waitForChangesManager();

    Assert.assertTrue(ListSequence.fromList(myDiff.getChangeSet().getModelChanges()).isEmpty());
  }

  protected void setAutoaddPolicy(VcsShowConfirmationOption.Value value) {
    ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(myIdeaProject);
    vcsManager.getStandardConfirmation(VcsConfiguration.StandardConfirmation.ADD, myGitVcs).setValue(value);
  }

  protected void testChanges(Runnable change) {
    makeChangeAndWait(change);

    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ChangeSet cs = myDiff.getChangeSet();
        ChangeSet rebuiltChangeSet = ChangeSetBuilder.buildChangeSet(cs.getOldModel(), cs.getNewModel());
        Assert.assertEquals(getChangeSetString(rebuiltChangeSet), getChangeSetString(cs));
      }
    });
  }

  protected void makeChangeAndWait(Runnable change) {
    ourProject.getModelAccess().executeCommandInEDT(change);

    ourEnvironment.flushAllEvents();
    myWaitHelper.waitForChangesManager();
  }

  protected void checkRootStatuses(final RootStatusItem... statuses) {
    final NodeFileStatusMappingExt fsm = myIdeaProject.getComponent(NodeFileStatusMappingExt.class);
    final SModel model = myDiff.getModelDescriptor();
    // query for first time 
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ListSequence.fromList(SModelOperations.roots(model, null)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode r) {
            fsm.getStatus(r);
          }
        });
      }
    });
    // wait while statuses update 
    myWaitHelper.waitForChangesManager();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ListSequence.fromList(SModelOperations.roots(model, null)).visitAll(new IVisitor<SNode>() {
          public void visit(final SNode r) {
            FileStatus actual = fsm.getStatus(r);
            FileStatus expected = check_l1nwgz_a0b0a0a0a0g0cb(Sequence.fromIterable(Sequence.fromArray(statuses)).findFirst(new IWhereFilter<RootStatusItem>() {
              public boolean accept(RootStatusItem it) {
                return it.rootName().equals(r.getName());
              }
            }));
            Assert.assertSame(expected, actual);
          }
        });
      }
    });
  }

  protected void revertMemChangesAndWait() {
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        getTestModel().reloadFromSource();
      }
    });
    ourEnvironment.flushAllEvents();
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_l1nwgz_a0a3a03(myDiff.getChangeSet())).isEmpty());
  }

  protected void revertDiskChangesAndWait(VirtualFile modelFile) {
    myChangeListManager.ensureUpToDate(false);
    Change modelFileChange = myChangeListManager.getChange(modelFile);
    List<VcsException> exceptions = ListSequence.fromList(new ArrayList<VcsException>());
    myGitVcs.getRollbackEnvironment().rollbackChanges(Arrays.asList(modelFileChange), exceptions, RollbackProgressListener.EMPTY);
    Assert.assertTrue(ListSequence.fromList(exceptions).isEmpty());

    myWaitHelper.waitForFileStatusChange(modelFile, FileStatus.NOT_CHANGED);
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_l1nwgz_a0a8a23(myDiff.getChangeSet())).isEmpty());
  }

  protected EditableSModel getTestModel() {
    return (EditableSModel) PersistenceFacade.getInstance().createModelReference("r:296ba97d-4b26-4d06-be61-297d86180cce(jetbrains.mps.ide.vcs.test.testModel)").resolve(ourProject.getRepository());
  }

  protected VirtualFile getTestModelFile() {
    return VirtualFileUtils.getProjectVirtualFile(((FileDataSource) getTestModel().getSource()).getFile());
  }

  protected String getChangeSetString(ChangeSet changeSet) {
    return getChangeSetString(changeSet.getModelChanges());
  }

  protected String getChangeSetString(List<ModelChange> modelChanges) {
    return IterableUtils.join(ListSequence.fromList(modelChanges).select(new ISelector<ModelChange, String>() {
      public String select(ModelChange c) {
        return c.toString();
      }
    }).sort(new ISelector<String, String>() {
      public String select(String s) {
        return s;
      }
    }, true), "|");
  }

  public String getDefaultExt() {
    return PersistenceRegistry.getInstance().getDefaultModelFactory().getFileExtension();
  }
  private static FileStatus check_l1nwgz_a0b0a0a0a0g0cb(RootStatusItem checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.status();
    }
    return null;
  }
  private static List<ModelChange> check_l1nwgz_a0a3a03(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static List<ModelChange> check_l1nwgz_a0a8a23(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
}
