package jetbrains.mps.ide.vcs.test.merge;

/*Generated by MPS */

import jetbrains.mps.tool.environment.EnvironmentAware;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.project.MPSProject;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vcs.changes.ChangeListManagerImpl;
import jetbrains.mps.vcs.changesmanager.CurrentDifference;
import com.intellij.openapi.vcs.AbstractVcs;
import org.jetbrains.annotations.NotNull;
import org.junit.BeforeClass;
import jetbrains.mps.smodel.SReference;
import com.intellij.openapi.util.registry.Registry;
import org.junit.AfterClass;
import org.junit.Before;
import java.io.File;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import com.intellij.openapi.vcs.impl.projectlevelman.AllVcses;
import org.junit.Assume;
import com.intellij.openapi.vcs.VcsShowConfirmationOption;
import javax.swing.SwingUtilities;
import com.intellij.openapi.vcs.FileStatusManager;
import java.lang.reflect.InvocationTargetException;
import org.junit.After;
import jetbrains.mps.nodeEditor.InspectorTool;
import org.junit.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.vcs.VcsConfiguration;
import jetbrains.mps.vcs.diff.ChangeSet;
import jetbrains.mps.vcs.diff.ChangeSetBuilder;
import jetbrains.mps.vcs.changesmanager.roots.NodeFileStatusMappingExt;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vcs.changes.Change;
import java.util.List;
import com.intellij.openapi.vcs.VcsException;
import java.util.ArrayList;
import java.util.Arrays;
import com.intellij.openapi.vcs.rollback.RollbackProgressListener;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.extapi.persistence.FileDataSource;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.persistence.PersistenceRegistry;

public abstract class ChangesTestBase implements EnvironmentAware {
  protected static boolean ourEnabled;
  protected Environment myEnv;
  protected static MPSProject ourProject;

  protected Project myIdeaProject;
  protected ChangesManagerTestWaitHelper myWaitHelper;

  protected ChangeListManagerImpl myChangeListManager;
  protected CurrentDifference myDiff;
  protected AbstractVcs myGitVcs;

  public ChangesTestBase() {
    // todo add group changes tests 
  }


  @Override
  public void setEnvironment(@NotNull Environment env) {
    myEnv = env;
  }

  @BeforeClass
  public static void setUp() {
    SReference.disableLogging();
    Registry.get("vcs.showConsole").setValue(false);
  }

  @AfterClass
  public static void tearDown() {
    ourEnabled = false;
    // the right way to close project is Environment.closeProject(myProject), but at the momen PushEnvironmentRunnerBuilder does it with instance method only 
    ourProject.dispose();
    ourProject = null;
  }

  @Before
  public void init() {
    if (ourProject == null) {
      // Point to current directory with MPS project 
      File mpsProject = new File("").getAbsoluteFile();
      ourProject = ((MPSProject) myEnv.openProject(mpsProject));
      // For whatever reason, tests with this superclass work only if there's 1 project dispose per class (open/close of the project in Before/After doesn't work) 
      // Given there's odd magic with ourEnabled and the fact it's VCS, I don't want to dive into this sh!t now. 
    }

    myIdeaProject = ourProject.getProject();
    CurrentDifferenceRegistry.getInstance(myIdeaProject).getCommandQueue().setHadExceptions(false);
    myWaitHelper = new ChangesManagerTestWaitHelper(myIdeaProject);
    myWaitHelper.waitForChangesManager();

    myGitVcs = AllVcses.getInstance(myIdeaProject).getByName("Git");
    Assume.assumeNotNull(myGitVcs);
    Assume.assumeNotNull(getTestModel());
    myDiff = CurrentDifferenceRegistry.getInstance(myIdeaProject).getCurrentDifference((getTestModel()));
    myChangeListManager = ChangeListManagerImpl.getInstanceImpl(myIdeaProject);
    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_NOTHING_SILENTLY);

    if (!(ChangesTestBase.ourEnabled)) {
      myChangeListManager.ensureUpToDate(false);
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            FileStatusManager.getInstance(myIdeaProject).fileStatusesChanged();
          }
        });
      } catch (InterruptedException e) {
        throw new AssertionError(e);
      } catch (InvocationTargetException e) {
        throw new AssertionError(e);
      }

      checkAndEnable();
      ChangesTestBase.ourEnabled = true;
    }
  }

  @After
  public void after() throws InvocationTargetException, InterruptedException {
    revertMemChangesAndWait();
    SwingUtilities.invokeAndWait(new Runnable() {
      public void run() {
        myIdeaProject.getComponent(InspectorTool.class).getInspector().editNode(null);
      }
    });
    Assert.assertFalse(CurrentDifferenceRegistry.getInstance(myIdeaProject).getCommandQueue().hadExceptions());
    myWaitHelper.dispose();
  }

  protected MPSProject getProject() {
    return ourProject;
  }

  protected void checkAndEnable() {
    Assert.assertNull(myDiff.getChangeSet());

    myDiff.setEnabled(true);
    myWaitHelper.waitForChangesManager();

    Assert.assertTrue(ListSequence.fromList(myDiff.getChangeSet().getModelChanges()).isEmpty());
  }

  protected void setAutoaddPolicy(VcsShowConfirmationOption.Value value) {
    ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(myIdeaProject);
    vcsManager.getStandardConfirmation(VcsConfiguration.StandardConfirmation.ADD, myGitVcs).setValue(value);
  }

  protected void testChanges(Runnable change) {
    makeChangeAndWait(change);

    ourProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        ChangeSet cs = myDiff.getChangeSet();
        ChangeSet rebuiltChangeSet = ChangeSetBuilder.buildChangeSet(cs.getOldModel(), cs.getNewModel());
        Assert.assertEquals(getChangeSetString(rebuiltChangeSet), getChangeSetString(cs));
      }
    });
  }

  protected void makeChangeAndWait(Runnable change) {
    ourProject.getModelAccess().executeCommandInEDT(change);

    myEnv.flushAllEvents();
    myWaitHelper.waitForChangesManager();
  }

  protected void checkRootStatuses(final RootStatusItem... statuses) {
    final NodeFileStatusMappingExt fsm = myIdeaProject.getComponent(NodeFileStatusMappingExt.class);
    final SModel model = myDiff.getModelDescriptor();
    // query for first time 
    ourProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        ListSequence.fromList(SModelOperations.roots(model, null)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode r) {
            fsm.getStatus(r);
          }
        });
      }
    });
    // wait while statuses update 
    myWaitHelper.waitForChangesManager();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ListSequence.fromList(SModelOperations.roots(model, null)).visitAll(new IVisitor<SNode>() {
          public void visit(final SNode r) {
            FileStatus actual = fsm.getStatus(r);
            FileStatus expected = check_l1nwgz_a0b0a0a0a0g0ib(Sequence.fromIterable(Sequence.fromArray(statuses)).findFirst(new IWhereFilter<RootStatusItem>() {
              public boolean accept(RootStatusItem it) {
                return it.rootName().equals(r.getName());
              }
            }));
            Assert.assertSame(expected, actual);
          }
        });
      }
    });
  }

  protected void revertMemChangesAndWait() {
    ourProject.getRepository().getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        getTestModel().reloadFromSource();
      }
    });
    myEnv.flushAllEvents();
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_l1nwgz_a0a3a63(myDiff.getChangeSet())).isEmpty());
  }

  protected void revertDiskChangesAndWait(VirtualFile modelFile) {
    myChangeListManager.ensureUpToDate(false);
    Change modelFileChange = myChangeListManager.getChange(modelFile);
    List<VcsException> exceptions = ListSequence.fromList(new ArrayList<VcsException>());
    myGitVcs.getRollbackEnvironment().rollbackChanges(Arrays.asList(modelFileChange), exceptions, RollbackProgressListener.EMPTY);
    Assert.assertTrue(ListSequence.fromList(exceptions).isEmpty());

    myWaitHelper.waitForFileStatusChange(modelFile, FileStatus.NOT_CHANGED);
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_l1nwgz_a0a8a83(myDiff.getChangeSet())).isEmpty());
  }

  protected EditableSModel getTestModel() {
    return (EditableSModel) PersistenceFacade.getInstance().createModelReference("r:296ba97d-4b26-4d06-be61-297d86180cce(jetbrains.mps.ide.vcs.test.testModel)").resolve(ourProject.getRepository());
  }

  protected VirtualFile getTestModelFile() {
    return VirtualFileUtils.getProjectVirtualFile(((FileDataSource) getTestModel().getSource()).getFile());
  }

  protected String getChangeSetString(ChangeSet changeSet) {
    return getChangeSetString(changeSet.getModelChanges());
  }

  protected String getChangeSetString(List<ModelChange> modelChanges) {
    return IterableUtils.join(ListSequence.fromList(modelChanges).select(new ISelector<ModelChange, String>() {
      public String select(ModelChange c) {
        return c.toString();
      }
    }).sort(new ISelector<String, String>() {
      public String select(String s) {
        return s;
      }
    }, true), "|");
  }

  public String getDefaultExt() {
    return PersistenceRegistry.getInstance().getDefaultModelFactory().getFileExtension();
  }
  private static FileStatus check_l1nwgz_a0b0a0a0a0g0ib(RootStatusItem checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.status();
    }
    return null;
  }
  private static List<ModelChange> check_l1nwgz_a0a3a63(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static List<ModelChange> check_l1nwgz_a0a8a83(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
}
