package jetbrains.mps.ide.vcs.test.merge;

/*Generated by MPS */

import org.junit.Test;
import com.intellij.openapi.vcs.VcsException;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vcs.FileStatus;
import com.intellij.openapi.vcs.changes.Change;
import org.junit.Assert;
import java.util.Arrays;
import git4idea.commands.GitSimpleHandler;
import git4idea.commands.GitCommand;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.vcs.VcsShowConfirmationOption;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.workbench.actions.model.DeleteModelHelper;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.project.SModuleOperations;
import jetbrains.mps.vcs.changesmanager.CurrentDifference;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.extapi.persistence.FileDataSource;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import java.io.IOException;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.persistence.PersistenceUtil;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.util.FileUtil;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.vcs.diff.ChangeSet;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

/**
 * These tests check that incremental changes building works well with VCS (commit, reset, rollback) 
 * and model operations (create, delete)
 */
public class IncrementalChangeUpdateTest_Model extends ChangesTestBase {
  @Test
  public void testChangesOnCommitAndReset() throws VcsException {
    // change 
    makeChangeAndWait(new Runnable() {
      public void run() {
        SNodeOperations.deleteNode(SNodeOperations.getNode("r:296ba97d-4b26-4d06-be61-297d86180cce(jetbrains.mps.ide.vcs.test.testModel)", "5876208808348821705"));
        getTestModel().save();
      }
    });

    // check change list 
    VirtualFile modelFile = getTestModelFile();
    myWaitHelper.waitForFileStatusChange(modelFile, FileStatus.MODIFIED);
    myChangeListManager.ensureUpToDate(false);
    Change change = myChangeListManager.getChange(modelFile);
    Assert.assertTrue(change != null);

    // commit 
    myGitVcs.getCheckinEnvironment().commit(Arrays.asList(change), "dumb commit");
    myWaitHelper.waitForFileStatusChange(modelFile, FileStatus.NOT_CHANGED);
    myWaitHelper.waitForChangesManager();
    Assert.assertNull(myDiff.getChangeSet());

    // revert 
    try {
      GitSimpleHandler h = new GitSimpleHandler(myIdeaProject, myIdeaProject.getBaseDir(), GitCommand.RESET);
      h.addParameters("--mixed", "HEAD^");
      h.run();
    } catch (VcsException e) {
      throw new AssertionError(e);
    }
    myWaitHelper.waitForFileStatusChange(modelFile, FileStatus.MODIFIED);
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_2jv4hj_a0a02a0(myDiff.getChangeSet())).isNotEmpty());
    revertDiskChangesAndWait(getTestModelFile());
  }

  @Test
  public void testChangesOnDeleteAndRollback() {
    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_ACTION_SILENTLY);
    VirtualFile modelFile = getTestModelFile();
    final EditableSModel md = getTestModel();

    makeChangeAndWait(new Runnable() {
      public void run() {
        DeleteModelHelper.deleteModel(ProjectHelper.toMPSProject(myIdeaProject), md.getModule(), md, false, true);
      }
    });
    revertDiskChangesAndWait(modelFile);

    myDiff = CurrentDifferenceRegistry.getInstance(myIdeaProject).getCurrentDifference(getTestModel());
    myDiff.setEnabled(true);
    myWaitHelper.waitForChangesManager();

    Assert.assertTrue(ListSequence.fromList(check_2jv4hj_a0a11a2(myDiff.getChangeSet())).isEmpty());
    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_NOTHING_SILENTLY);
  }

  @Test
  public void testNoCreatedChangesForNewModel() {
    final Wrappers._T<EditableSModel> newModel = new Wrappers._T<EditableSModel>();
    ourProject.getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        SModule module = myDiff.getModelDescriptor().getModule();
        ModelRoot modelRoot = module.getModelRoots().iterator().next();
        newModel.value = SModuleOperations.createModelWithAdjustments("jetbrains.mps.ide.vcs.test.newTestModel", modelRoot);
        newModel.value.load();
        newModel.value.save();
      }
    });
    ourEnvironment.flushAllEvents();

    CurrentDifference newModelDiff = CurrentDifferenceRegistry.getInstance(myIdeaProject).getCurrentDifference(newModel.value);
    newModelDiff.setEnabled(true);

    VirtualFile vf = VirtualFileUtils.getProjectVirtualFile(((FileDataSource) newModel.value.getSource()).getFile());
    myWaitHelper.waitForFileStatusChange(vf, FileStatus.UNKNOWN);
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_2jv4hj_a0a01a4(newModelDiff.getChangeSet())).isEmpty());

    ourProject.getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        DeleteModelHelper.deleteModel(ProjectHelper.toMPSProject(myIdeaProject), newModel.value.getModule(), newModel.value, false, true);
      }
    });
  }

  @Test
  public void modifyExternallyRollback() throws ModelReadException, IOException, VcsException {
    final Wrappers._T<String> model = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        model.value = PersistenceUtil.saveModel(getTestModel(), getDefaultExt());
      }
    });
    final SModel changedCopy = PersistenceUtil.loadModel(model.value, getDefaultExt());
    SModelOperations.addRootNode(changedCopy, createClassConcept_2jv4hj_a0a3a6());
    final Wrappers._T<String> changedContent = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        // todo that's just because of the Object ref, and Persistence9.genResolveInfo which goes by ref 
        changedContent.value = PersistenceUtil.saveModel(changedCopy, getDefaultExt());
      }
    });

    ourProject.getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        try {
          getTestModelFile().setBinaryContent(changedContent.value.getBytes(FileUtil.DEFAULT_CHARSET));
        } catch (IOException e) {
          throw new AssertionError(e);
        }
      }
    });
    ourEnvironment.flushAllEvents();
    myWaitHelper.waitForFileStatusChange(getTestModelFile(), FileStatus.MODIFIED);
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_2jv4hj_a0a11a6(myDiff.getChangeSet())).isNotEmpty());

    revertDiskChangesAndWait(getTestModelFile());
    revertMemChangesAndWait();
    myWaitHelper.waitForFileStatusChange(getTestModelFile(), FileStatus.NOT_CHANGED);
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_2jv4hj_a0a71a6(myDiff.getChangeSet())).isEmpty());
  }
  private static List<ModelChange> check_2jv4hj_a0a02a0(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static List<ModelChange> check_2jv4hj_a0a11a2(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static List<ModelChange> check_2jv4hj_a0a01a4(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static SNode createClassConcept_2jv4hj_a0a3a6() {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode n1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"), null, null, false);
    n1.setProperty(MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "NewRoot");
    return n1;
  }
  private static List<ModelChange> check_2jv4hj_a0a11a6(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static List<ModelChange> check_2jv4hj_a0a71a6(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
}
