package jetbrains.mps.ide.vcs.test.merge;

/*Generated by MPS */

import org.junit.Test;
import com.intellij.openapi.vcs.VcsShowConfirmationOption;
import com.intellij.openapi.vfs.VirtualFile;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.workbench.actions.model.DeleteModelHelper;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import org.junit.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.project.SModuleOperations;
import jetbrains.mps.vcs.changesmanager.CurrentDifference;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.extapi.persistence.FileDataSource;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import java.io.IOException;
import com.intellij.openapi.vcs.VcsException;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import jetbrains.mps.vcs.diff.merge.MergeTemporaryModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.util.FileUtil;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.vcs.diff.ChangeSet;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

/**
 * These tests check that incremental changes building works well with VCS (commit, reset, rollback) 
 * and model operations (create, delete)
 */
public class IncrementalChangeUpdateTest_Model extends ChangesTestBase {

  @Test
  public void testChangesOnDeleteAndRollback() {
    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_ACTION_SILENTLY);
    VirtualFile modelFile = getTestModelFile();
    final EditableSModel md = getTestModel();

    makeChangeAndWait(new Runnable() {
      public void run() {
        DeleteModelHelper.deleteModel(getProject(), md.getModule(), md, false, true);
      }
    });
    revertDiskChangesAndWait(modelFile);

    myDiff = CurrentDifferenceRegistry.getInstance(myIdeaProject).getCurrentDifference(getTestModel());
    myDiff.setEnabled(true);
    myWaitHelper.waitForChangesManager();

    Assert.assertTrue(ListSequence.fromList(check_2jv4hj_a0a11a1(myDiff.getChangeSet())).isEmpty());
    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_NOTHING_SILENTLY);
  }

  @Test
  public void testNoCreatedChangesForNewModel() {
    final Wrappers._T<EditableSModel> newModel = new Wrappers._T<EditableSModel>();
    getProject().getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        SModule module = myDiff.getModelDescriptor().getModule();
        ModelRoot modelRoot = module.getModelRoots().iterator().next();
        newModel.value = SModuleOperations.createModelWithAdjustments("jetbrains.mps.ide.vcs.test.newTestModel", modelRoot);
        newModel.value.load();
        newModel.value.save();
      }
    });
    myEnv.flushAllEvents();

    CurrentDifference newModelDiff = CurrentDifferenceRegistry.getInstance(myIdeaProject).getCurrentDifference(newModel.value);

    VirtualFile vf = VirtualFileUtils.getProjectVirtualFile(((FileDataSource) newModel.value.getSource()).getFile());
    myWaitHelper.waitForFileStatusChange(vf, FileStatus.UNKNOWN);

    newModelDiff.setEnabled(true);

    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_2jv4hj_a0a21a3(newModelDiff.getChangeSet())).isEmpty());

    getProject().getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        DeleteModelHelper.deleteModel(getProject(), newModel.value.getModule(), newModel.value, false, true);
      }
    });
  }

  @Test
  public void modifyExternallyRollback() throws ModelReadException, IOException, VcsException {
    SModel modelCopy2Change = new ModelAccessHelper(getProject().getModelAccess()).runReadAction(new Computable<MergeTemporaryModel>() {
      public MergeTemporaryModel compute() {
        return MergeTemporaryModel.writableCloneOf(getTestModel());
      }
    });
    SModelOperations.addRootNode(modelCopy2Change, createClassConcept_2jv4hj_a0a1a5());
    final String changedContent = PersistenceUtil.saveModel(modelCopy2Change, getDefaultExt());

    // FIXME It's odd to use *model* write to ensure proper FileSystem access (there's no model access in here). 
    getProject().getModelAccess().runWriteInEDT(new Runnable() {
      public void run() {
        try {
          getTestModelFile().setBinaryContent(changedContent.getBytes(FileUtil.DEFAULT_CHARSET));
        } catch (IOException e) {
          throw new AssertionError(e);
        }
      }
    });
    myEnv.flushAllEvents();
    myWaitHelper.waitForFileStatusChange(getTestModelFile(), FileStatus.MODIFIED);
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_2jv4hj_a0a9a5(myDiff.getChangeSet())).isNotEmpty());

    revertDiskChangesAndWait(getTestModelFile());
    revertMemChangesAndWait();
    myWaitHelper.waitForFileStatusChange(getTestModelFile(), FileStatus.NOT_CHANGED);
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_2jv4hj_a0a51a5(myDiff.getChangeSet())).isEmpty());
  }
  private static List<ModelChange> check_2jv4hj_a0a11a1(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static List<ModelChange> check_2jv4hj_a0a21a3(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static SNode createClassConcept_2jv4hj_a0a1a5() {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode n1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"), null, null, false);
    n1.setProperty(MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "NewRoot");
    return n1;
  }
  private static List<ModelChange> check_2jv4hj_a0a9a5(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static List<ModelChange> check_2jv4hj_a0a51a5(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
}
